<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2019-11-30.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000015"><span class="nick" style="color:#389600"><a href="#000015" label="[00:00:15]">&lt;xentrac&gt;</a></span><span class="message">sadly David A. Wheeler's &quot;SLOCCount&quot; doesn't recognize Verilog as a programming language</span></div><div class="line" id="000101"><span class="nick" style="color:#389600"><a href="#000101" label="[00:01:01]">&lt;xentrac&gt;</a></span><span class="message">I think light8080 is closer to 1300 lines of Verilog but I also think its microcode is not included in that</span></div><div class="line" id="000144"><span class="nick" style="color:#8dd3c7"><a href="#000144" label="[00:01:44]">&lt;oriansj&gt;</a></span><span class="message">z80s had alot more microcode than 8080s</span></div><div class="line" id="000235"><span class="nick" style="color:#389600"><a href="#000235" label="[00:02:35]">&lt;xentrac&gt;</a></span><span class="message">you could probably build an 8080 clone with any arbitrary amount of microcode including zero</span></div><div class="line" id="000304"><span class="nick" style="color:#389600"><a href="#000304" label="[00:03:04]">&lt;xentrac&gt;</a></span><span class="message">light8080 is very microcode-heavy in order to fit into fewer LUTs, at the cost of speed</span></div><div class="line" id="000325"><span class="nick" style="color:#8dd3c7"><a href="#000325" label="[00:03:25]">&lt;oriansj&gt;</a></span><span class="message">what is interesting: <a rel="nofollow" href="https://en.wikipedia.org/wiki/Transistor_count">https://en.wikipedia.org/wiki/Transistor_count</a>  is that an 8051 uses more transistors than a ARMv1</span></div><div class="line" id="000328"><span class="nick" style="color:#389600"><a href="#000328" label="[00:03:28]">&lt;xentrac&gt;</a></span><span class="message">and, more important for us I think, at the cost of intellectual complexity</span></div><div class="line" id="000354"><span class="nick" style="color:#389600"><a href="#000354" label="[00:03:54]">&lt;xentrac&gt;</a></span><span class="message">yeah, in RISC processors the machine code is the microcode</span></div><div class="line" id="000410"><span class="nick" style="color:#389600"><a href="#000410" label="[00:04:10]">&lt;xentrac&gt;</a></span><span class="message">so its transistors get charged to your RAM and not the CU :)</span></div><div class="line" id="000416"><span class="nick" style="color:#389600"><a href="#000416" label="[00:04:16]">&lt;xentrac&gt;</a></span><span class="message">the CPU :)</span></div><div class="line" id="000441"><span class="nick" style="color:#8dd3c7"><a href="#000441" label="[00:04:41]">&lt;oriansj&gt;</a></span><span class="message">xentrac: no, early risc processors had hard-wired instruction decode</span></div><div class="line" id="000450"><span class="nick" style="color:#389600"><a href="#000450" label="[00:04:50]">&lt;xentrac&gt;</a></span><span class="message">that's exactly what i mean</span></div><div class="line" id="000516"><span class="nick" style="color:#389600"><a href="#000516" label="[00:05:16]">&lt;xentrac&gt;</a></span><span class="message">just like contemporary non-risc processors had hard-wired decoding of microcode</span></div><div class="line" id="000600"><span class="nick" style="color:#389600"><a href="#000600" label="[00:06:00]">&lt;xentrac&gt;</a></span><span class="message">this is not an observation original to me; the Symbolics guys made that remark about porting Genera to the Alpha</span></div><div class="line" id="000602"><span class="nick" style="color:#8dd3c7"><a href="#000602" label="[00:06:02]">&lt;oriansj&gt;</a></span><span class="message">well RISC II did support compressed instructions</span></div><div class="line" id="000654"><span class="nick" style="color:#8dd3c7"><a href="#000654" label="[00:06:54]">&lt;oriansj&gt;</a></span><span class="message">which did produce a 30% improvement in code density</span></div><div class="line" id="000718"><span class="nick" style="color:#389600"><a href="#000718" label="[00:07:18]">&lt;xentrac&gt;</a></span><span class="message">ARM Thumb-2 has amazing code density, better even than i386</span></div><div class="line" id="000737"><span class="nick" style="color:#389600"><a href="#000737" label="[00:07:37]">&lt;xentrac&gt;</a></span><span class="message">but AARch64 has apparently abandoned the Thumb-* approach entirely</span></div><div class="line" id="000821"><span class="nick" style="color:#389600"><a href="#000821" label="[00:08:21]">&lt;xentrac&gt;</a></span><span class="message">I guess they figure that if you want to compress your instructions in RAM then your OS can page to Snappy-compressed RAM</span></div><div class="line" id="000915"><span class="nick" style="color:#2e2a4a"><a href="#000915" label="[00:09:15]">&lt;theruran&gt;</a></span><span class="message">stikonas: is anyone else working on reduced binary seed bootstrap of Gentoo? when I asked in #gentoo-prefix they didn't understand the problem or need</span></div><div class="line" id="000917"><span class="nick" style="color:#8dd3c7"><a href="#000917" label="[00:09:17]">&lt;oriansj&gt;</a></span><span class="message">ARM Thumb-2 also has insanely complex encoding/decode rules that eat transistors like crazy</span></div><div class="line" id="001019"><span class="nick" style="color:#389600"><a href="#001019" label="[00:10:19]">&lt;xentrac&gt;</a></span><span class="message">yet implementations of it still take way less silicon area than amd64 frontends ;)</span></div><div class="line" id="001112"><span class="nick" style="color:#8dd3c7"><a href="#001112" label="[00:11:12]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well we can't know that for certain because no one has implemented AMD64 without OoO and that is a bigger eater of transistors than anything</span></div><div class="line" id="001129"><span class="nick" style="color:#389600"><a href="#001129" label="[00:11:29]">&lt;xentrac&gt;</a></span><span class="message">hmm, that's an excellent opint</span></div><div class="line" id="001130"><span class="nick" style="color:#389600"><a href="#001130" label="[00:11:30]">&lt;xentrac&gt;</a></span><span class="message">point</span></div><div class="line" id="001204"><span class="nick" style="color:#389600"><a href="#001204" label="[00:12:04]">&lt;xentrac&gt;</a></span><span class="message">and I guess the ARM CPUs that are graduating into the OoO age are AArch64</span></div><div class="line" id="001227"><span class="nick" style="color:#8dd3c7"><a href="#001227" label="[00:12:27]">&lt;oriansj&gt;</a></span><span class="message">yep</span></div><div class="line" id="001322"><span class="nick" style="color:#389600"><a href="#001322" label="[00:13:22]">&lt;xentrac&gt;</a></span><span class="message">an interesting thing is that the GPU cores that contribute most of the computrons in modern PCs aren't OoO either</span></div><div class="line" id="001335"><span class="nick" style="color:#389600"><a href="#001335" label="[00:13:35]">&lt;xentrac&gt;</a></span><span class="message">they're more like the Tera MTA</span></div><div class="line" id="001340"><span class="nick" style="color:#8dd3c7"><a href="#001340" label="[00:13:40]">&lt;oriansj&gt;</a></span><span class="message">nope VLIW like most OoO cores these days</span></div><div class="line" id="001404"><span class="nick" style="color:#389600"><a href="#001404" label="[00:14:04]">&lt;xentrac&gt;</a></span><span class="message">well, semi-VLIW, especially the intel ones</span></div><div class="line" id="001445"><span class="nick" style="color:#389600"><a href="#001445" label="[00:14:45]">&lt;xentrac&gt;</a></span><span class="message">if RISC was &quot;why don't you just compile your program to vertical microcode&quot; then VLIW is &quot;why don't you just compile your program to horizontal microcode&quot;</span></div><div class="line" id="001502"><span class="nick" style="color:#389600"><a href="#001502" label="[00:15:02]">&lt;xentrac&gt;</a></span><span class="message">an approach which has produced some EPIC fails</span></div><div class="line" id="001603"><span class="nick" style="color:#8dd3c7"><a href="#001603" label="[00:16:03]">&lt;oriansj&gt;</a></span><span class="message">xentrac: and some amazing results (R700 series)</span></div><div class="line" id="001623"><span class="nick" style="color:#8dd3c7"><a href="#001623" label="[00:16:23]">&lt;oriansj&gt;</a></span><span class="message">it is almost like no single design ideal is universally a good idea</span></div><div class="line" id="001653"><span class="nick" style="color:#389600"><a href="#001653" label="[00:16:53]">&lt;xentrac&gt;</a></span><span class="message">i'm starting to think you're right about that :)</span></div><div class="line" id="001727"><span class="nick" style="color:#389600"><a href="#001727" label="[00:17:27]">&lt;xentrac&gt;</a></span><span class="message">i still haven't written anything in the assembly code of any GPU, i've barely written GLSL</span></div><div class="line" id="001803"><span class="nick" style="color:#389600"><a href="#001803" label="[00:18:03]">&lt;xentrac&gt;</a></span><span class="message">have you tried it?</span></div><div class="line" id="001804"><span class="nick" style="color:#8dd3c7"><a href="#001804" label="[00:18:04]">&lt;oriansj&gt;</a></span><span class="message">xentrac: you really don't want to try to write VLIW in assembly, you'll do it wrong (in fact everyone does)</span></div><div class="line" id="001826"><span class="nick" style="color:#389600"><a href="#001826" label="[00:18:26]">&lt;xentrac&gt;</a></span><span class="message">maybe a better assembler would help</span></div><div class="line" id="001834"><span class="nick" style="color:#8dd3c7"><a href="#001834" label="[00:18:34]">&lt;oriansj&gt;</a></span><span class="message">nope</span></div><div class="line" id="001852"><span class="nick" style="color:#8dd3c7"><a href="#001852" label="[00:18:52]">&lt;oriansj&gt;</a></span><span class="message">you need to track the latency of all bundles and their sub-instructions</span></div><div class="line" id="001913"><span class="nick" style="color:#389600"><a href="#001913" label="[00:19:13]">&lt;xentrac&gt;</a></span><span class="message">that sounds like the kind of thing a better assembler would be good at</span></div><div class="line" id="001934"><span class="nick" style="color:#389600"><a href="#001934" label="[00:19:34]">&lt;xentrac&gt;</a></span><span class="message">to figure out which bundle to schedule each sub-instruction into</span></div><div class="line" id="001959"><span class="nick" style="color:#8dd3c7"><a href="#001959" label="[00:19:59]">&lt;oriansj&gt;</a></span><span class="message">xentrac: in the end most compute in every VLIW is wasted</span></div><div class="line" id="002024"><span class="nick" style="color:#389600"><a href="#002024" label="[00:20:24]">&lt;xentrac&gt;</a></span><span class="message">unfortunately I only have Intel and NVIDIA GPUs handy here</span></div><div class="line" id="002035"><span class="nick" style="color:#8dd3c7"><a href="#002035" label="[00:20:35]">&lt;oriansj&gt;</a></span><span class="message">it costs an insane amount of development time and money to extract major chunks of that performance</span></div><div class="line" id="002144"><span class="nick" style="color:#389600"><a href="#002144" label="[00:21:44]">&lt;xentrac&gt;</a></span><span class="message">yeah, but you and I both know that things that sound infeasibly difficult to most people sometimes aren't ;)</span></div><div class="line" id="002407"><span class="nick" style="color:#8dd3c7"><a href="#002407" label="[00:24:07]">&lt;oriansj&gt;</a></span><span class="message">xentrac: true, but billions of dollars and decades of funded research were needed to get VLIW Optimizers competitive for non-embaressingly parallel work loads</span></div><div class="line" id="002506"><span class="nick" style="color:#389600"><a href="#002506" label="[00:25:06]">&lt;xentrac&gt;</a></span><span class="message">right, but now we have the results of that research to build off of</span></div><div class="line" id="002536"><span class="nick" style="color:#389600"><a href="#002536" label="[00:25:36]">&lt;xentrac&gt;</a></span><span class="message">plus lots of other advancements in search and optimization</span></div><div class="line" id="002545"><span class="nick" style="color:#389600"><a href="#002545" label="[00:25:45]">&lt;xentrac&gt;</a></span><span class="message">and maybe the expectations for the input of those optimizers were unrealistically demanding</span></div><div class="line" id="002942"><span class="nick" style="color:#8dd3c7"><a href="#002942" label="[00:29:42]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well Intel needed to make a VLIW outperform an OoO and we now know that is entirely impossible for single threaded applications</span></div><div class="line" id="003846"><span class="nick" style="color:#389600"><a href="#003846" label="[00:38:46]">&lt;xentrac&gt;</a></span><span class="message">yeah.  but for applications written in some future cleaned-up version of J or K or GLSL, maybe...</span></div><div class="line" id="004109"><span class="nick" style="color:#8dd3c7"><a href="#004109" label="[00:41:09]">&lt;oriansj&gt;</a></span><span class="message">xentrac: skip future; K applications fly on GPUs today</span></div><div class="line" id="004207"><span class="nick" style="color:#389600"><a href="#004207" label="[00:42:07]">&lt;xentrac&gt;</a></span><span class="message">okay but I really don't want to program in K :D</span></div><div class="line" id="004248"><span class="nick" style="color:#389600"><a href="#004248" label="[00:42:48]">&lt;xentrac&gt;</a></span><span class="message">GLSL is a little more bearable in some ways but it's way too limited, unless that's just the limitations of my knowledge</span></div><div class="line" id="004325"><span class="nick" style="color:#389600"><a href="#004325" label="[00:43:25]">&lt;xentrac&gt;</a></span><span class="message">I mean I'd much rather program in assembly than in K</span></div><div class="line" id="004326"><span class="nick" style="color:#8dd3c7"><a href="#004326" label="[00:43:26]">&lt;oriansj&gt;</a></span><span class="message">fair, but you can't beat it on wallstreet</span></div><div class="line" id="004410"><span class="nick" style="color:#389600"><a href="#004410" label="[00:44:10]">&lt;xentrac&gt;</a></span><span class="message">I've heard people say that, but all the HFT quants I've talked to were using C++ and Java and Python, not K</span></div><div class="line" id="004442"><span class="nick" style="color:#8dd3c7"><a href="#004442" label="[00:44:42]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://paste.debian.net/1118588/">https://paste.debian.net/1118588/</a> </span></div><div class="line" id="004446"><span class="nick" style="color:#389600"><a href="#004446" label="[00:44:46]">&lt;xentrac&gt;</a></span><span class="message">it's been a few years since I wrote any trading code though so maybe K has gotten more popular</span></div><div class="line" id="004522"><span class="nick" style="color:#389600"><a href="#004522" label="[00:45:22]">&lt;xentrac&gt;</a></span><span class="message">one guy was working at Morgan Stanley and mentioned that they had not only some K code but even some A+</span></div><div class="line" id="004532"><span class="nick" style="color:#389600"><a href="#004532" label="[00:45:32]">&lt;xentrac&gt;</a></span><span class="message">but he was writing C++</span></div><div class="line" id="004752"><span class="nick" style="color:#8dd3c7"><a href="#004752" label="[00:47:52]">&lt;oriansj&gt;</a></span><span class="message">and patches are up for mes-m2 (slow_lisp branch)</span></div><div class="line" id="004808"><span class="nick" style="color:#389600"><a href="#004808" label="[00:48:08]">&lt;xentrac&gt;</a></span><span class="message">hooray!</span></div><div class="line" id="004830"><span class="nick" style="color:#8dd3c7"><a href="#004830" label="[00:48:30]">&lt;oriansj&gt;</a></span><span class="message">now just to figure out record-constructor to finish off support for records</span></div><div class="line" id="004934"><span class="nick" style="color:#8dd3c7"><a href="#004934" label="[00:49:34]">&lt;oriansj&gt;</a></span><span class="message">could probably do it entirely in scheme since all the other record primitives are implemented</span></div><div class="line" id="005110"><span class="nick" style="color:#389600"><a href="#005110" label="[00:51:10]">&lt;xentrac&gt;</a></span><span class="message">+1 :)</span></div><div class="line" id="005155"><span class="nick" style="color:#8dd3c7"><a href="#005155" label="[00:51:55]">&lt;oriansj&gt;</a></span><span class="message">hint: (core:make-record a #(#f #f #f #f))</span></div><div class="line" id="005226"><span class="nick" style="color:#8dd3c7"><a href="#005226" label="[00:52:26]">&lt;oriansj&gt;</a></span><span class="message">^a^(make-record-type &quot;foo&quot; '(a b c d)))^</span></div><div class="line" id="005432"><span class="nick" style="color:#8dd3c7"><a href="#005432" label="[00:54:32]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well k and A+ are generally considered write only languages for most programmers</span></div><div class="line" id="005514"><span class="nick" style="color:#8dd3c7"><a href="#005514" label="[00:55:14]">&lt;oriansj&gt;</a></span><span class="message">or more commonly anything is just a one-liner in k if you hate yourself enough</span></div><div class="line" id="005545"><span class="nick" style="color:#80b1d3"><a href="#005545" label="[00:55:45]">&lt;stikonas&gt;</a></span><span class="message">theruran: no, I don't think anybody is working...</span></div><div class="line" id="005606"><span class="nick" style="color:#80b1d3"><a href="#005606" label="[00:56:06]">&lt;stikonas&gt;</a></span><span class="message">theruran: in fact java people were not really helpful here, although they pointed out that path that I used earlier had blobs</span></div><div class="line" id="005621"><span class="nick" style="color:#80b1d3"><a href="#005621" label="[00:56:21]">&lt;stikonas&gt;</a></span><span class="message">(I tried to use gcj, but that used precompiled ecj)\</span></div><div class="line" id="005703"><span class="nick" style="color:#389600"><a href="#005703" label="[00:57:03]">&lt;xentrac&gt;</a></span><span class="message">yeah, the write-only aspect is what I most want to avoid</span></div><div class="line" id="005707"><span class="nick" style="color:#2e2a4a"><a href="#005707" label="[00:57:07]">&lt;theruran&gt;</a></span><span class="message">stikonas: I see, and #gentoo-toolchain confirms. Could bootstrap Gentoo from a bootstrapped Guix system and toolchain though.</span></div><div class="line" id="005724"><span class="nick" style="color:#80b1d3"><a href="#005724" label="[00:57:24]">&lt;stikonas&gt;</a></span><span class="message">theruran: in principle yes</span></div><div class="line" id="005734"><span class="nick" style="color:#80b1d3"><a href="#005734" label="[00:57:34]">&lt;stikonas&gt;</a></span><span class="message">but that's work TBD</span></div><div class="line" id="005739"><span class="nick" style="color:#80b1d3"><a href="#005739" label="[00:57:39]">&lt;stikonas&gt;</a></span><span class="message">theruran: do you use gentoo?</span></div><div class="line" id="005752"><span class="nick" style="color:#2e2a4a"><a href="#005752" label="[00:57:52]">&lt;theruran&gt;</a></span><span class="message">stikonas: right. :D and yes, I do</span></div><div class="line" id="005801"><span class="nick" style="color:#80b1d3"><a href="#005801" label="[00:58:01]">&lt;stikonas&gt;</a></span><span class="message">well, this is my current java work:<a rel="nofollow" href="https://git.stikonas.eu/andrius/openjdk-overlay">https://git.stikonas.eu/andrius/openjdk-overlay</a> </span></div><div class="line" id="005815"><span class="nick" style="color:#2e2a4a"><a href="#005815" label="[00:58:15]">&lt;theruran&gt;</a></span><span class="message">though not having fun with this dependency hell that portage is having rn</span></div><div class="line" id="005852"><span class="nick" style="color:#80b1d3"><a href="#005852" label="[00:58:52]">&lt;stikonas&gt;</a></span><span class="message">at the moment I am able to bootstrap jamvm/classpath-devel/ecj, which should be enough to compile icedtea:6 (need some patches though, this is now WIP)</span></div><div class="line" id="005924"><span class="nick" style="color:#2e2a4a"><a href="#005924" label="[00:59:24]">&lt;theruran&gt;</a></span><span class="message">stikonas: keep up the good work!</span></div><div class="line" id="005925"><span class="nick" style="color:#389600"><a href="#005925" label="[00:59:25]">&lt;xentrac&gt;</a></span><span class="message">awesome!</span></div><div class="line" id="005929"><span class="nick" style="color:#389600"><a href="#005929" label="[00:59:29]">&lt;xentrac&gt;</a></span><span class="message">that's fantastic</span></div><div class="line" id="005953"><span class="nick" style="color:#80b1d3"><a href="#005953" label="[00:59:53]">&lt;stikonas&gt;</a></span><span class="message">at the moment, when icedtae:6 ebuild fails, build tree is about 2GB, so I guess I'm getting close</span></div><div class="line" id="010106"><span class="nick" style="color:#8dd3c7"><a href="#010106" label="[01:01:06]">&lt;oriansj&gt;</a></span><span class="message">stikonas: good</span></div><div class="line" id="010108"><span class="nick" style="color:#80b1d3"><a href="#010108" label="[01:01:08]">&lt;stikonas&gt;</a></span><span class="message">after icedtea:6 compiles, it should be very easy to just build icedtea:7</span></div><div class="line" id="010128"><span class="nick" style="color:#80b1d3"><a href="#010128" label="[01:01:28]">&lt;stikonas&gt;</a></span><span class="message">maybe it would be possible to also make some overlay for rust...</span></div><div class="line" id="010156"><span class="nick" style="color:#80b1d3"><a href="#010156" label="[01:01:56]">&lt;stikonas&gt;</a></span><span class="message">theruran: feel free to test my java bootstrap stuff :D</span></div><div class="line" id="010216"><span class="nick" style="color:#8dd3c7"><a href="#010216" label="[01:02:16]">&lt;oriansj&gt;</a></span><span class="message">stikonas: entirely possible, just depends on the time you are willing to burn on it</span></div><div class="line" id="010240"><span class="nick" style="color:#2e2a4a"><a href="#010240" label="[01:02:40]">&lt;theruran&gt;</a></span><span class="message">stikonas: ah well, I think I have a hardened-musl Gentoo VM available :)</span></div><div class="line" id="010432"><span class="nick" style="color:#80b1d3"><a href="#010432" label="[01:04:32]">&lt;stikonas&gt;</a></span><span class="message">theruran: do you have openjdk already installed there?</span></div><div class="line" id="010448"><span class="nick" style="color:#80b1d3"><a href="#010448" label="[01:04:48]">&lt;stikonas&gt;</a></span><span class="message">musl might be especially interesting, I only tried on libc</span></div><div class="line" id="010536"><span class="nick" style="color:#2e2a4a"><a href="#010536" label="[01:05:36]">&lt;theruran&gt;</a></span><span class="message">stikonas: no, I don't think so</span></div><div class="line" id="010548"><span class="nick" style="color:#2e2a4a"><a href="#010548" label="[01:05:48]">&lt;theruran&gt;</a></span><span class="message">only just now getting around to installing a Guix SD VM</span></div><div class="line" id="010719"><span class="nick" style="color:#80b1d3"><a href="#010719" label="[01:07:19]">&lt;stikonas&gt;</a></span><span class="message">theruran: well, no java is easier, otherwise you probably need to uninstall it to be sure that it doesn't accidentally build what is supposed to be bootstrapped</span></div><div class="line" id="014737"><span class="nick" style="color:#8dd3c7"><a href="#014737" label="[01:47:37]">&lt;oriansj&gt;</a></span><span class="message">and core:record-constructor is implemented and record-constructor is implemented via a trivial define in test/test019/core.scm</span></div><div class="line" id="014808"><span class="nick" style="color:#8dd3c7"><a href="#014808" label="[01:48:08]">&lt;oriansj&gt;</a></span><span class="message">and test019 passes; mes-m2 slow_lisp now supports all the record primitives requried by guile</span></div><div class="line" id="014906"><span class="nick" style="color:#8dd3c7"><a href="#014906" label="[01:49:06]">&lt;oriansj&gt;</a></span><span class="message">((record-constructor a '(d b c a)) 1 2 3 4) does the right thing, as does ((record-constructor a '(d b a)) 1 2 3 4) and ((record-constructor a '(d c a)) 1 2 3)</span></div><div class="line" id="014938"><span class="nick" style="color:#8dd3c7"><a href="#014938" label="[01:49:38]">&lt;oriansj&gt;</a></span><span class="message">up next is modules, right janneke?</span></div><div class="line" id="061622"><span class="nick" style="color:#2e2a4a"><a href="#061622" label="[06:16:22]">&lt;theruran&gt;</a></span><span class="message">oriansj: eh what happens when MAX_STRING is much larger so mes-m2 doesn't segfault on larger programs?</span></div><div class="line" id="062143"><span class="nick" style="color:#2e2a4a"><a href="#062143" label="[06:21:43]">&lt;theruran&gt;</a></span><span class="message">should it produce an error when too large of a program is inputted?</span></div><div class="line" id="165916"><span class="nick" style="color:#8dd3c7"><a href="#165916" label="[16:59:16]">&lt;oriansj&gt;</a></span><span class="message">theruran: well I can easily make MAX_STRING 10MB, but it is just the max size for a single S-expression</span></div><div class="line" id="170323"><span class="nick" style="color:#8dd3c7"><a href="#170323" label="[17:03:23]">&lt;oriansj&gt;</a></span><span class="message">and since the slow_lisp branch is just a grand total of 83,694 characters (including white space), I find it hard to justify a single S-expression bigger than 1/8 the size of the lisp interpreter running it</span></div><div class="line" id="170633"><span class="nick" style="color:#8dd3c7"><a href="#170633" label="[17:06:33]">&lt;oriansj&gt;</a></span><span class="message">as for running out of cells when evaluating, one can set MES_ARENA to any value they desire, the default is 1,000,000 cells (consuming 32MB of memory)</span></div><div class="line" id="175515"><span class="nick" style="color:#2e2a4a"><a href="#175515" label="[17:55:15]">&lt;theruran&gt;</a></span><span class="message">oriansj: got it. well, last night I did manage to statically compile Jitawa LISP with CompCert and musl. What I was trying to do before was host the Milawa proof assistant on top of mes-m2, but it seems that the (define) semantics are different (Milawa used to run on Common Lisp)</span></div><div class="line" id="175723"><span class="nick" style="color:#2e2a4a"><a href="#175723" label="[17:57:23]">&lt;theruran&gt;</a></span><span class="message">not that that makes much of a difference. I just had my doubts about wrapper.c :)</span></div><div class="line" id="180408"><span class="nick" style="color:#8dd3c7"><a href="#180408" label="[18:04:08]">&lt;oriansj&gt;</a></span><span class="message">well mes-m2 supports (define a (thing)) and (define (a b c) (thing))</span></div><div class="line" id="180513"><span class="nick" style="color:#8dd3c7"><a href="#180513" label="[18:05:13]">&lt;oriansj&gt;</a></span><span class="message">wrapper.c?</span></div><div class="line" id="180544"><span class="nick" style="color:#2e2a4a"><a href="#180544" label="[18:05:44]">&lt;theruran&gt;</a></span><span class="message">Milawa is written like (define 'lookup-safe '(a x) '(+ a x))</span></div><div class="line" id="180639"><span class="nick" style="color:#2e2a4a"><a href="#180639" label="[18:06:39]">&lt;theruran&gt;</a></span><span class="message">wrapper.c is used to provide an entry-point to Jitawa's verified x86_64 assembly *shrugs*</span></div><div class="line" id="180858"><span class="nick" style="color:#2e2a4a"><a href="#180858" label="[18:08:58]">&lt;theruran&gt;</a></span><span class="message">it also allocates all the memory necessary to run the JIT compiler</span></div><div class="line" id="182906"><span class="nick" style="color:#8dd3c7"><a href="#182906" label="[18:29:06]">&lt;oriansj&gt;</a></span><span class="message">so, 19 assembly instructions? (setup stack, brk and jump to entry point)</span></div><div class="line" id="221035"><span class="nick" style="color:#2e2a4a"><a href="#221035" label="[22:10:35]">&lt;theruran&gt;</a></span><span class="message">oriansj: that's what I was thinking :D and it also does some basic I/O</span></div><div class="line" id="221250"><span class="nick" style="color:#2e2a4a"><a href="#221250" label="[22:12:50]">&lt;theruran&gt;</a></span><span class="message">the assembly would be easier to get correct than the C, and smaller TCB</span></div><div class="line" id="224826"><span class="nick" style="color:#8dd3c7"><a href="#224826" label="[22:48:26]">&lt;oriansj&gt;</a></span><span class="message">theruran: On Posix systems there is no way to do I/O directly; one requires syscalls for read and write, which involves a rather large TCB</span></div><br /></div></body></html>