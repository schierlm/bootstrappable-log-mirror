<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2020-12-04.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="003838"><span class="nick" style="color:#8dd3c7"><a href="#003838" label="[00:38:38]">&lt;OriansJ&gt;</a></span><span class="message">pder: it should also build correctly with M2-Planet as well</span></div><div class="line" id="004626"><span class="nick" style="color:#8dd3c7"><a href="#004626" label="[00:46:26]">&lt;OriansJ&gt;</a></span><span class="message">now I'm going to try to figure out how to break the generation of raw into smaller steps.</span></div><div class="line" id="004724"><span class="nick" style="color:#2e2a4a"><a href="#004724" label="[00:47:24]">&lt;yt&gt;</a></span><span class="message">OriansJ: AArch64 hex0 is up <a rel="nofollow" href="https://github.com/oriansj/mescc-tools-seed/pull/12">https://github.com/oriansj/mescc-tools-seed/pull/12</a> </span></div><div class="line" id="004824"><span class="nick" style="color:#2e2a4a"><a href="#004824" label="[00:48:24]">&lt;yt&gt;</a></span><span class="message">thought we best start small and see if there are any big changes that need to be applied across the board</span></div><div class="line" id="004957"><span class="nick" style="color:#8dd3c7"><a href="#004957" label="[00:49:57]">&lt;OriansJ&gt;</a></span><span class="message">hex0_AArcd64.M1 ? did you mean hex0_AArch64.M1 ?</span></div><div class="line" id="005014"><span class="nick" style="color:#2e2a4a"><a href="#005014" label="[00:50:14]">&lt;yt&gt;</a></span><span class="message">ahhh I'd forgotten about that typo</span></div><div class="line" id="005135"><span class="nick" style="color:#2e2a4a"><a href="#005135" label="[00:51:35]">&lt;yt&gt;</a></span><span class="message">that's the problem with thinking &quot;I'll fix that later&quot; XD</span></div><div class="line" id="005207"><span class="nick" style="color:#2e2a4a"><a href="#005207" label="[00:52:07]">&lt;yt&gt;</a></span><span class="message">should be fixed now</span></div><div class="line" id="005333"><span class="nick" style="color:#8dd3c7"><a href="#005333" label="[00:53:33]">&lt;OriansJ&gt;</a></span><span class="message">It'll take me a bit to validate the DEFINEs but I'll get to that shortly</span></div><div class="line" id="005416"><span class="nick" style="color:#2e2a4a"><a href="#005416" label="[00:54:16]">&lt;yt&gt;</a></span><span class="message">do you trust objdump when verifying the opcodes? :)</span></div><div class="line" id="005605"><span class="nick" style="color:#2e2a4a"><a href="#005605" label="[00:56:05]">&lt;yt&gt;</a></span><span class="message">I think when I was doing hex0 I even hand-encoded them all, but I gave up on that with the bigger tools</span></div><div class="line" id="005649"><span class="nick" style="color:#2e2a4a"><a href="#005649" label="[00:56:49]">&lt;yt&gt;</a></span><span class="message">I didn't really try to minimise the number of opcodes, aiming for something that's more or less readable in M1</span></div><div class="line" id="005651"><span class="nick" style="color:#8dd3c7"><a href="#005651" label="[00:56:51]">&lt;OriansJ&gt;</a></span><span class="message">yt: DATA_OFFSET ? couldn't $output DATA_OFFSET be better written as &amp;output?</span></div><div class="line" id="005744"><span class="nick" style="color:#8dd3c7"><a href="#005744" label="[00:57:44]">&lt;OriansJ&gt;</a></span><span class="message">or is &amp;label not behaving correctly in hex2 for AArch64?</span></div><div class="line" id="005757"><span class="nick" style="color:#2e2a4a"><a href="#005757" label="[00:57:57]">&lt;yt&gt;</a></span><span class="message">ah I'm sure it can, I'm sure I used &amp;label in the later tools</span></div><div class="line" id="005850"><span class="nick" style="color:#2e2a4a"><a href="#005850" label="[00:58:50]">&lt;yt&gt;</a></span><span class="message">hex0 lived at 0x00000000 originally when I started in qemu, but a real linux kernel didn't like that whatsoever</span></div><div class="line" id="005856"><span class="nick" style="color:#2e2a4a"><a href="#005856" label="[00:58:56]">&lt;yt&gt;</a></span><span class="message">hence the botched in DATA_OFFSET</span></div><div class="line" id="010112"><span class="nick" style="color:#8dd3c7"><a href="#010112" label="[01:01:12]">&lt;OriansJ&gt;</a></span><span class="message">well hex0 doesn't actually have support for labels as all but hex2 will accept any arbitrary base address</span></div><div class="line" id="010231"><span class="nick" style="color:#2e2a4a"><a href="#010231" label="[01:02:31]">&lt;yt&gt;</a></span><span class="message">yeah, I'd missed that option to hex2 initially; maybe the default for the base address shouldn't be 0x0 as that's unlikely to generate a working executable</span></div><div class="line" id="010344"><span class="nick" style="color:#8dd3c7"><a href="#010344" label="[01:03:44]">&lt;OriansJ&gt;</a></span><span class="message">yt: well hex2 by default generates KNIGHT binaries which are loaded at address 0x0 by default</span></div><div class="line" id="010433"><span class="nick" style="color:#8dd3c7"><a href="#010433" label="[01:04:33]">&lt;OriansJ&gt;</a></span><span class="message">perhaps I could make hex2 show a warning for all other architectures if --base-address isn't set to something other than zero</span></div><div class="line" id="010511"><span class="nick" style="color:#8dd3c7"><a href="#010511" label="[01:05:11]">&lt;OriansJ&gt;</a></span><span class="message">that would help people avoid hitting similiar problems in the future.</span></div><div class="line" id="010558"><span class="nick" style="color:#8dd3c7"><a href="#010558" label="[01:05:58]">&lt;OriansJ&gt;</a></span><span class="message">or would an error be better yt ?</span></div><div class="line" id="010628"><span class="nick" style="color:#2e2a4a"><a href="#010628" label="[01:06:28]">&lt;yt&gt;</a></span><span class="message">I'm all for an error if it doesn't make sense to ignore it</span></div><div class="line" id="010820"><span class="nick" style="color:#8dd3c7"><a href="#010820" label="[01:08:20]">&lt;OriansJ&gt;</a></span><span class="message">well one could use hex2 to build rom images and then using address 0x0 would be entirely reasonable.</span></div><div class="line" id="010903"><span class="nick" style="color:#2e2a4a"><a href="#010903" label="[01:09:03]">&lt;yt&gt;</a></span><span class="message">ah fair enough, warning seems fine then!</span></div><div class="line" id="011103"><span class="nick" style="color:#2e2a4a"><a href="#011103" label="[01:11:03]">&lt;yt&gt;</a></span><span class="message">a very useful error message: &quot;A displacement of 1073742988 does not fit in 2 bytes&quot;</span></div><div class="line" id="011115"><span class="nick" style="color:#2e2a4a"><a href="#011115" label="[01:11:15]">&lt;yt&gt;</a></span><span class="message">would probably help if the displacement was in hex though :D</span></div><div class="line" id="011400"><span class="nick" style="color:#8dd3c7"><a href="#011400" label="[01:14:00]">&lt;OriansJ&gt;</a></span><span class="message">yt: true and I certainly will add that to the backlog of nice-to-have features</span></div><div class="line" id="011520"><span class="nick" style="color:#8dd3c7"><a href="#011520" label="[01:15:20]">&lt;OriansJ&gt;</a></span><span class="message">yt: warning message for hex2 is up; hopefully you find that obvious enough.</span></div><div class="line" id="012116"><span class="nick" style="color:#2e2a4a"><a href="#012116" label="[01:21:16]">&lt;yt&gt;</a></span><span class="message">is that in <a rel="nofollow" href="https://github.com/oriansj/mescc-tools/commits/master">https://github.com/oriansj/mescc-tools/commits/master</a>  ? don't see it yet</span></div><div class="line" id="012150"><span class="nick" style="color:#2e2a4a"><a href="#012150" label="[01:21:50]">&lt;yt&gt;</a></span><span class="message">ah I see hex2_linker.c can't print hex in error messages yet? sounds like something for on the backlog :)</span></div><div class="line" id="012252"><span class="nick" style="color:#8dd3c7"><a href="#012252" label="[01:22:52]">&lt;OriansJ&gt;</a></span><span class="message">7f7039e6e59a1d35e1fe9bbaa92c7806a4836cf1 is up on github</span></div><div class="line" id="012412"><span class="nick" style="color:#2e2a4a"><a href="#012412" label="[01:24:12]">&lt;yt&gt;</a></span><span class="message">OriansJ: just ran into another little niggle trying to test hex0_AArch64.M1 with the change you suggested: aarch64 is little endian only (I think) but hex2 defaults to big endian even when architecture is set to aarch64</span></div><div class="line" id="012448"><span class="nick" style="color:#2e2a4a"><a href="#012448" label="[01:24:48]">&lt;yt&gt;</a></span><span class="message">most tools (readelf, objdump, file) will fall over hard with a big-endian aarch64 ELF file</span></div><div class="line" id="012609"><span class="nick" style="color:#8dd3c7"><a href="#012609" label="[01:26:09]">&lt;OriansJ&gt;</a></span><span class="message">yt: bot M1 and hex2 support --little-endian</span></div><div class="line" id="012721"><span class="nick" style="color:#8dd3c7"><a href="#012721" label="[01:27:21]">&lt;OriansJ&gt;</a></span><span class="message">^bot^both^</span></div><div class="line" id="012756"><span class="nick" style="color:#2e2a4a"><a href="#012756" label="[01:27:56]">&lt;yt&gt;</a></span><span class="message">support yes, default to with --architecture aarch64, no :)</span></div><div class="line" id="013321"><span class="nick" style="color:#8dd3c7"><a href="#013321" label="[01:33:21]">&lt;OriansJ&gt;</a></span><span class="message">certainly a nice to have but unsure if setting Endianness is something that should be implicit when dealing with such low level files.</span></div><div class="line" id="013442"><span class="nick" style="color:#2e2a4a"><a href="#013442" label="[01:34:42]">&lt;yt&gt;</a></span><span class="message">hmm, then maybe a warning (or error) for big-endian aarch64 might be more appropriate</span></div><div class="line" id="013508"><span class="nick" style="color:#8dd3c7"><a href="#013508" label="[01:35:08]">&lt;OriansJ&gt;</a></span><span class="message">pder: sizeof(prog) wouldn't work in M2-Planet as prog isn't a type.</span></div><div class="line" id="013541"><span class="nick" style="color:#8dd3c7"><a href="#013541" label="[01:35:41]">&lt;OriansJ&gt;</a></span><span class="message">well a warning for armv7l, x86 and AMD64 too</span></div><div class="line" id="013629"><span class="nick" style="color:#2e2a4a"><a href="#013629" label="[01:36:29]">&lt;yt&gt;</a></span><span class="message">doesn't armv7l allow both big and little endian?</span></div><div class="line" id="013904"><span class="nick" style="color:#8dd3c7"><a href="#013904" label="[01:39:04]">&lt;OriansJ&gt;</a></span><span class="message">yt: yes it does; hence just a warning</span></div><div class="line" id="013929"><span class="nick" style="color:#8dd3c7"><a href="#013929" label="[01:39:29]">&lt;OriansJ&gt;</a></span><span class="message">as big endian armv7 is more rare as I understand it.</span></div><div class="line" id="013953"><span class="nick" style="color:#2e2a4a"><a href="#013953" label="[01:39:53]">&lt;yt&gt;</a></span><span class="message">sounds good, yeah, TIL that armv7 is mostly little-endian anyway</span></div><div class="line" id="014012"><span class="nick" style="color:#8dd3c7"><a href="#014012" label="[01:40:12]">&lt;OriansJ&gt;</a></span><span class="message">well I can't say that for certain</span></div><div class="line" id="014023"><span class="nick" style="color:#2e2a4a"><a href="#014023" label="[01:40:23]">&lt;yt&gt;</a></span><span class="message">I've had more exposure to the theoretical bounds of the architecture than what's out there in the wild</span></div><div class="line" id="014031"><span class="nick" style="color:#8dd3c7"><a href="#014031" label="[01:40:31]">&lt;OriansJ&gt;</a></span><span class="message">as I have yet to find an armv7 setup that is in big-endian mode</span></div><div class="line" id="014101"><span class="nick" style="color:#8dd3c7"><a href="#014101" label="[01:41:01]">&lt;OriansJ&gt;</a></span><span class="message">but perhaps I just haven't looked in the right places or it is OS image dependent or etc</span></div><div class="line" id="014150"><span class="nick" style="color:#8dd3c7"><a href="#014150" label="[01:41:50]">&lt;OriansJ&gt;</a></span><span class="message">if I could find a armv7 in big endian mode, it'll probably have MUCH nicer M1 definition files.</span></div><div class="line" id="014240"><span class="nick" style="color:#2e2a4a"><a href="#014240" label="[01:42:40]">&lt;yt&gt;</a></span><span class="message">yeah, why did we ever settle on little-endian, it's so annoying when hand-editing hex files /s</span></div><div class="line" id="014356"><span class="nick" style="color:#6b8072"><a href="#014356" label="[01:43:56]">&lt;xentrac&gt;</a></span><span class="message">yt: heh</span></div><div class="line" id="014402"><span class="nick" style="color:#8dd3c7"><a href="#014402" label="[01:44:02]">&lt;OriansJ&gt;</a></span><span class="message">yt: it is cheaper in TTL circuits</span></div><div class="line" id="014420"><span class="nick" style="color:#6b8072"><a href="#014420" label="[01:44:20]">&lt;xentrac&gt;</a></span><span class="message">why TTL?  I don't think the logic family is a relevant distinction here</span></div><div class="line" id="014444"><span class="nick" style="color:#6b8072"><a href="#014444" label="[01:44:44]">&lt;xentrac&gt;</a></span><span class="message">and the chips that established little-endian as the standard (8080, 6502) were NMOS or CMOS, not TTL</span></div><div class="line" id="014452"><span class="nick" style="color:#6b8072"><a href="#014452" label="[01:44:52]">&lt;xentrac&gt;</a></span><span class="message">I've seen big-endian ARMs but not very often</span></div><div class="line" id="014511"><span class="nick" style="color:#8dd3c7"><a href="#014511" label="[01:45:11]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: fair; it generally required less chips when working with individually packaged gates when making a processor out of them</span></div><div class="line" id="014543"><span class="nick" style="color:#6b8072"><a href="#014543" label="[01:45:43]">&lt;xentrac&gt;</a></span><span class="message">really?  how come?</span></div><div class="line" id="014642"><span class="nick" style="color:#8dd3c7"><a href="#014642" label="[01:46:42]">&lt;OriansJ&gt;</a></span><span class="message">8080 was based on a ?Datapoint? calculator design if I remember corerctly which was little endian to reduce costs</span></div><div class="line" id="014720"><span class="nick" style="color:#8dd3c7"><a href="#014720" label="[01:47:20]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: simpler circuit if I remember correctly; saves about 8 gates</span></div><div class="line" id="014746"><span class="nick" style="color:#6b8072"><a href="#014746" label="[01:47:46]">&lt;xentrac&gt;</a></span><span class="message">yeah, the 8080 was sort of a less crippled version of the 8008, which was a clone of the Datapoint intelligent terminal, which was TTL for speed</span></div><div class="line" id="014832"><span class="nick" style="color:#6b8072"><a href="#014832" label="[01:48:32]">&lt;xentrac&gt;</a></span><span class="message">Datapoint ended up not using the 8008 because it was too slow: not as slow as CD4000-family discrete CMOS gates, but slower than the Datapoint 2200 design made out of discrete TTL gates</span></div><div class="line" id="014926"><span class="nick" style="color:#6b8072"><a href="#014926" label="[01:49:26]">&lt;xentrac&gt;</a></span><span class="message">most of my notes on the 8008 are in an extended digression in <a rel="nofollow" href="https://dercuano.github.io/notes/computer-algebras-ii.html">https://dercuano.github.io/notes/computer-algebras-ii.html</a> </span></div><div class="line" id="015029"><span class="nick" style="color:#8dd3c7"><a href="#015029" label="[01:50:29]">&lt;OriansJ&gt;</a></span><span class="message">anyway; once enough software was written changing form little endian to big endian became an impossible task (or close enough people missed obvious solutions)</span></div><div class="line" id="015102"><span class="nick" style="color:#6b8072"><a href="#015102" label="[01:51:02]">&lt;xentrac&gt;</a></span><span class="message">(I was investigating the history of the DAA instruction to give you BCD addition by fixing up the results of binary addition, which survived until the i386 and was dropped in amd64)</span></div><div class="line" id="015139"><span class="nick" style="color:#6b8072"><a href="#015139" label="[01:51:39]">&lt;xentrac&gt;</a></span><span class="message">I'm interested to see what the simplification in the 2200 was</span></div><div class="line" id="015141"><span class="nick" style="color:#8dd3c7"><a href="#015141" label="[01:51:41]">&lt;OriansJ&gt;</a></span><span class="message">for example when DEC went from pdp-11 to VAX or VAX to Alpha; they never fixed endianess. Despite it would have been easier with the Alpha change to go Big Endian by simply adding little endian LOAD and STORE instructions</span></div><div class="line" id="015237"><span class="nick" style="color:#6b8072"><a href="#015237" label="[01:52:37]">&lt;xentrac&gt;</a></span><span class="message">the Alpha isn't really binary-compatible with the VAX, so I'm not sure the compatibility argument applies</span></div><div class="line" id="015303"><span class="nick" style="color:#6b8072"><a href="#015303" label="[01:53:03]">&lt;xentrac&gt;</a></span><span class="message">if you're going to run PDP-11 software on your AXP you'd better have source or you're going to be running a PDP-11 emulator like SIMH or something :)</span></div><div class="line" id="015321"><span class="nick" style="color:#8dd3c7"><a href="#015321" label="[01:53:21]">&lt;OriansJ&gt;</a></span><span class="message">yt: I should have the hex0 fully checked by tomorrow evening.</span></div><div class="line" id="015442"><span class="nick" style="color:#8dd3c7"><a href="#015442" label="[01:54:42]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: yes but then why did they opt for little endian if not to skimp on having to update code that depended upon little endian data.</span></div><div class="line" id="015523"><span class="nick" style="color:#2e2a4a"><a href="#015523" label="[01:55:23]">&lt;yt&gt;</a></span><span class="message">OriansJ: that's awesome!  I'm about to push the change to remove DATA_OFFSET; had to debug hex0_AArch64.M1 first, had one branch instruction going the wrong direction</span></div><div class="line" id="015609"><span class="nick" style="color:#2e2a4a"><a href="#015609" label="[01:56:09]">&lt;yt&gt;</a></span><span class="message">I don't think I tested the M1 / hex2 versions very well</span></div><div class="line" id="015610"><span class="nick" style="color:#6b8072"><a href="#015610" label="[01:56:10]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: maybe they liked little-endian better after using it for 25 years</span></div><div class="line" id="015621"><span class="nick" style="color:#8dd3c7"><a href="#015621" label="[01:56:21]">&lt;OriansJ&gt;</a></span><span class="message">yt: sounds fair; assuming the DEFINEs don't change, it will not slow me down too much</span></div><div class="line" id="015638"><span class="nick" style="color:#6b8072"><a href="#015638" label="[01:56:38]">&lt;xentrac&gt;</a></span><span class="message">the PDP-8 and PDP-10 families were non-endian</span></div><div class="line" id="015843"><span class="nick" style="color:#2e2a4a"><a href="#015843" label="[01:58:43]">&lt;yt&gt;</a></span><span class="message">OriansJ: hopefully not! I'll keep it as separate commits in the pull requests, so you should be able to easily see what's changed</span></div><div class="line" id="020037"><span class="nick" style="color:#2e2a4a"><a href="#020037" label="[02:00:37]">&lt;yt&gt;</a></span><span class="message">hah! I *had* fixed that bug in the hex2 version, but forgotten to do so in hex0_AArch64.M1</span></div><div class="line" id="020118"><span class="nick" style="color:#8dd3c7"><a href="#020118" label="[02:01:18]">&lt;OriansJ&gt;</a></span><span class="message">yt: I am going to check M1 version first; then hex2 and finally hex0</span></div><div class="line" id="020152"><span class="nick" style="color:#8dd3c7"><a href="#020152" label="[02:01:52]">&lt;OriansJ&gt;</a></span><span class="message">M1, hex2 and hex0 versions should all have the exact same checksum when built</span></div><div class="line" id="020216"><span class="nick" style="color:#2e2a4a"><a href="#020216" label="[02:02:16]">&lt;yt&gt;</a></span><span class="message">as long as your ELF headers match :)</span></div><div class="line" id="020248"><span class="nick" style="color:#2e2a4a"><a href="#020248" label="[02:02:48]">&lt;yt&gt;</a></span><span class="message">which I don't think they do... at least the hex2 version has a debug header for objdump purposes</span></div><div class="line" id="020353"><span class="nick" style="color:#2e2a4a"><a href="#020353" label="[02:03:53]">&lt;yt&gt;</a></span><span class="message">but that's something I can fix</span></div><div class="line" id="020502"><span class="nick" style="color:#8dd3c7"><a href="#020502" label="[02:05:02]">&lt;OriansJ&gt;</a></span><span class="message">yt: if you notice ELF-i386.hex2 has the same ELF header as is embedded in x86's hex0, hex1 and hex2</span></div><div class="line" id="020620"><span class="nick" style="color:#8dd3c7"><a href="#020620" label="[02:06:20]">&lt;OriansJ&gt;</a></span><span class="message">the only difference is hard coded values for the stages that don't support proper &amp; or %label&gt;label displacement</span></div><div class="line" id="020720"><span class="nick" style="color:#8dd3c7"><a href="#020720" label="[02:07:20]">&lt;OriansJ&gt;</a></span><span class="message">one trick you might find handy is gdb does a better job of disassembling than objdump</span></div><div class="line" id="020836"><span class="nick" style="color:#8dd3c7"><a href="#020836" label="[02:08:36]">&lt;OriansJ&gt;</a></span><span class="message">do readelf -h $file and b* 0x600078 (using the value for Entry point address)</span></div><div class="line" id="020855"><span class="nick" style="color:#2e2a4a"><a href="#020855" label="[02:08:55]">&lt;yt&gt;</a></span><span class="message">gotcha. I'll fix that up tomorrow, it's only slighly past my bedtime :)</span></div><div class="line" id="020911"><span class="nick" style="color:#2e2a4a"><a href="#020911" label="[02:09:11]">&lt;yt&gt;</a></span><span class="message">OriansJ: yeah, I figured out that trick, thanks though ;)</span></div><div class="line" id="020937"><span class="nick" style="color:#8dd3c7"><a href="#020937" label="[02:09:37]">&lt;OriansJ&gt;</a></span><span class="message">yt: fair; besides it time for me to put my son to bed now anyway ^_^</span></div><div class="line" id="021011"><span class="nick" style="color:#2e2a4a"><a href="#021011" label="[02:10:11]">&lt;yt&gt;</a></span><span class="message">the other changes we talked about are up now; looks like the pull request has updated itself :)</span></div><div class="line" id="021143"><span class="nick" style="color:#2e2a4a"><a href="#021143" label="[02:11:43]">&lt;yt&gt;</a></span><span class="message">see you around; and thanks for the immmediate review, much appreciated!</span></div><div class="line" id="024336"><span class="nick" style="color:#8dd3c7"><a href="#024336" label="[02:43:36]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: now that I think more about it; I am gonna blame IBM's 360 project for little endian lock-in</span></div><div class="line" id="031026"><span class="nick" style="color:#6b8072"><a href="#031026" label="[03:10:26]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: oh, was the 360 little-endian?</span></div><div class="line" id="031148"><span class="nick" style="color:#6b8072"><a href="#031148" label="[03:11:48]">&lt;xentrac&gt;</a></span><span class="message">no, it was big-endian</span></div><div class="line" id="031209"><span class="nick" style="color:#6b8072"><a href="#031209" label="[03:12:09]">&lt;xentrac&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/IBM_System/360#Architectural_overview">https://en.wikipedia.org/wiki/IBM_System/360#Architectural_overview</a> </span></div><div class="line" id="031246"><span class="nick" style="color:#6b8072"><a href="#031246" label="[03:12:46]">&lt;xentrac&gt;</a></span><span class="message">are you suggesting that Intel, DEC, and MOSTek picked little-endian byte ordering as a way of thumbing their nose at IBM? :)</span></div><div class="line" id="034416"><span class="nick" style="color:#80b1d3"><a href="#034416" label="[03:44:16]">&lt;Darius&gt;</a></span><span class="message">what's wrong with little-endian, anyway?</span></div><div class="line" id="040008"><span class="nick" style="color:#6b8072"><a href="#040008" label="[04:00:08]">&lt;xentrac&gt;</a></span><span class="message">it's confusing.  but hey, so is binary</span></div><div class="line" id="040317"><span class="nick" style="color:#8dd3c7"><a href="#040317" label="[04:03:17]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: more they changed the financial dynamics about software; eg binaries without source code became more standard and the lock-in to endianess resulted.</span></div><div class="line" id="040411"><span class="nick" style="color:#8dd3c7"><a href="#040411" label="[04:04:11]">&lt;OriansJ&gt;</a></span><span class="message">Darius: short version 0x12345678 looks like this 78 56 34 12 in memory</span></div><div class="line" id="040435"><span class="nick" style="color:#6b8072"><a href="#040435" label="[04:04:35]">&lt;xentrac&gt;</a></span><span class="message">that was the DoJ consent decree in the 1970s IIRC, not the 360</span></div><div class="line" id="040524"><span class="nick" style="color:#6b8072"><a href="#040524" label="[04:05:24]">&lt;xentrac&gt;</a></span><span class="message">but it was standard pre-360 for people to write nonportable programs, which had lock-in to not just endianness (if you had byte addressing anyway) but lots of other details about your hardware</span></div><div class="line" id="040536"><span class="nick" style="color:#6b8072"><a href="#040536" label="[04:05:36]">&lt;xentrac&gt;</a></span><span class="message">I suspect the 1401 was &quot;little-endian&quot; but can't remember</span></div><div class="line" id="041020"><span class="nick" style="color:#8dd3c7"><a href="#041020" label="[04:10:20]">&lt;OriansJ&gt;</a></span><span class="message">the big problem in computer history; we delete too much</span></div><div class="line" id="042324"><span class="nick" style="color:#6b8072"><a href="#042324" label="[04:23:24]">&lt;xentrac&gt;</a></span><span class="message">well, you'll be pleased to learn that the Utah Data Center is now in operation...</span></div><div class="line" id="042626"><span class="nick" style="color:#8dd3c7"><a href="#042626" label="[04:26:26]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: wrong sort of computer history</span></div><div class="line" id="045947"><span class="nick" style="color:#8dd3c7"><a href="#045947" label="[04:59:47]">&lt;OriansJ&gt;</a></span><span class="message">I think I got it</span></div><div class="line" id="050002"><span class="nick" style="color:#8dd3c7"><a href="#050002" label="[05:00:02]">&lt;OriansJ&gt;</a></span><span class="message">it is mostly wrong but close enough</span></div><div class="line" id="050453"><span class="nick" style="color:#80b1d3"><a href="#050453" label="[05:04:53]">&lt;Darius&gt;</a></span><span class="message">big-endian decimals in everyday writing may have been a mistake too</span></div><div class="line" id="050521"><span class="nick" style="color:#80b1d3"><a href="#050521" label="[05:05:21]">&lt;Darius&gt;</a></span><span class="message">they were little-endian in the arabic source, at least, so i gather</span></div><div class="line" id="050718"><span class="nick" style="color:#8dd3c7"><a href="#050718" label="[05:07:18]">&lt;OriansJ&gt;</a></span><span class="message">Darius: then why is virtually every instruction set big bit endian?</span></div><div class="line" id="051003"><span class="nick" style="color:#80b1d3"><a href="#051003" label="[05:10:03]">&lt;Darius&gt;</a></span><span class="message">i don't follow</span></div><div class="line" id="051041"><span class="nick" style="color:#80b1d3"><a href="#051041" label="[05:10:41]">&lt;Darius&gt;</a></span><span class="message">if you mean the most-significant bits of an instruction tend to be function selectors, that's a different thing</span></div><div class="line" id="051104"><span class="nick" style="color:#8dd3c7"><a href="#051104" label="[05:11:04]">&lt;OriansJ&gt;</a></span><span class="message">for example little bit endian with little byte endian would make 0x12345678 into 87 65 43 21</span></div><div class="line" id="051127"><span class="nick" style="color:#80b1d3"><a href="#051127" label="[05:11:27]">&lt;Darius&gt;</a></span><span class="message">who's advocating for that?</span></div><div class="line" id="051200"><span class="nick" style="color:#8dd3c7"><a href="#051200" label="[05:12:00]">&lt;OriansJ&gt;</a></span><span class="message">where as big bit endian with little byte endian would look like 78 56 34 12</span></div><div class="line" id="051231"><span class="nick" style="color:#8dd3c7"><a href="#051231" label="[05:12:31]">&lt;OriansJ&gt;</a></span><span class="message">but big bit endian with big byte endian would look like 12 34 56 78</span></div><div class="line" id="051242"><span class="nick" style="color:#80b1d3"><a href="#051242" label="[05:12:42]">&lt;Darius&gt;</a></span><span class="message">in my world little-endian means bit k has significance 1&lt;&lt;k, byte b has significance 256**b</span></div><div class="line" id="051319"><span class="nick" style="color:#8dd3c7"><a href="#051319" label="[05:13:19]">&lt;OriansJ&gt;</a></span><span class="message">Darius: so you are for big bit endianess but little byte endianess?</span></div><div class="line" id="051401"><span class="nick" style="color:#8dd3c7"><a href="#051401" label="[05:14:01]">&lt;OriansJ&gt;</a></span><span class="message">because bit endianess doesn't extend past the byte boundary</span></div><div class="line" id="051440"><span class="nick" style="color:#80b1d3"><a href="#051440" label="[05:14:40]">&lt;Darius&gt;</a></span><span class="message">i don't see how you're getting that from what i said</span></div><div class="line" id="051634"><span class="nick" style="color:#8dd3c7"><a href="#051634" label="[05:16:34]">&lt;OriansJ&gt;</a></span><span class="message">ok which of these four do you like best to encode in memory the number 0x12345678: 87 65 43 21 or 78 56 34 12 or 21 43 65 87 or 12 34 56 78</span></div><div class="line" id="051725"><span class="nick" style="color:#80b1d3"><a href="#051725" label="[05:17:25]">&lt;Darius&gt;</a></span><span class="message">you're talking about displaying numbers as text; i'm talking about addressing</span></div><div class="line" id="051816"><span class="nick" style="color:#8dd3c7"><a href="#051816" label="[05:18:16]">&lt;OriansJ&gt;</a></span><span class="message">Darius: no that is how the bits are arranged on consecutive memory cells</span></div><div class="line" id="051903"><span class="nick" style="color:#8dd3c7"><a href="#051903" label="[05:19:03]">&lt;OriansJ&gt;</a></span><span class="message">pder: nearly got vm.c to be behavior match for rts.c; it isn't quite right but if we could figure that out we can eliminate rts.c and the need for compiling repeatedly.</span></div><div class="line" id="051956"><span class="nick" style="color:#8dd3c7"><a href="#051956" label="[05:19:56]">&lt;OriansJ&gt;</a></span><span class="message">Darius: as 0-F are only the order of the nybbles in each byte</span></div><div class="line" id="052006"><span class="nick" style="color:#80b1d3"><a href="#052006" label="[05:20:06]">&lt;Darius&gt;</a></span><span class="message">i already said: bit k has significance 1&lt;&lt;k, byte b has significance 256**b. if you divide a word into bytes, then e.g. the 8th bit of the word would be the 0th bit of byte 1, in that addressing.</span></div><div class="line" id="052029"><span class="nick" style="color:#6d2462"><a href="#052029" label="[05:20:29]">&lt;pder&gt;</a></span><span class="message">OriansJ: very cool.  there seems to be lots of opportunities to remove duplication</span></div><div class="line" id="052210"><span class="nick" style="color:#8dd3c7"><a href="#052210" label="[05:22:10]">&lt;OriansJ&gt;</a></span><span class="message">pder: I just don't have it quite right and I have to get some sleep; hopefully you'll see what stupid thing that I am missing.</span></div><div class="line" id="052617"><span class="nick" style="color:#80b1d3"><a href="#052617" label="[05:26:17]">&lt;Darius&gt;</a></span><span class="message">i'm confused why you would call that scheme big-bit-endian; maybe it has something to do with the big-endian display of the individual bytes in the way you're writing them out, but i don't know and don't feel like arguing about it</span></div><div class="line" id="072844"><span class="nick" style="color:#6b8072"><a href="#072844" label="[07:28:44]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: typically the bits in a physical word of memory (a byte, if the memory is 8-bit) are arranged along a different dimension than successive words in the memory system.  for example, typically each bit in a word is in a separate DRAM chip</span></div><div class="line" id="072931"><span class="nick" style="color:#6b8072"><a href="#072931" label="[07:29:31]">&lt;xentrac&gt;</a></span><span class="message">on an EPROM, each bit in a word comes out (or goes in, when you're programming it) on a separate pin</span></div><div class="line" id="073415"><span class="nick" style="color:#6b8072"><a href="#073415" label="[07:34:15]">&lt;xentrac&gt;</a></span><span class="message">so in a bit-parallel CPU (like very nearly all CPUs since 1960) bits don't have an endianness; bits don't come in a sequence</span></div><div class="line" id="073438"><span class="nick" style="color:#6b8072"><a href="#073438" label="[07:34:38]">&lt;xentrac&gt;</a></span><span class="message">(bit-serial CPUs are invariably bit-little-endian because that way carry propagation is feasible)</span></div><div class="line" id="114944"><span class="nick" style="color:#234e69"><a href="#114944" label="[11:49:44]">&lt;bauen1&gt;</a></span><span class="message">nice to see some progress on aarch64, i recently got some sbcs that i plan into making into a sort of root-of-trust, and bootstrapping from scratch on those would be kind of fun</span></div><div class="line" id="122808"><span class="nick" style="color:#6c3d55"><a href="#122808" label="[12:28:08]">&lt;rain1&gt;</a></span><span class="message"> <a rel="nofollow" href="https://softwarediversity.eu/hardening-the-software-supply-chain-with-multi-compilers/">https://softwarediversity.eu/hardening-the-software-supply-chain-with-multi-compilers/</a> </span></div><div class="line" id="133906"><span class="nick" style="color:#8dd3c7"><a href="#133906" label="[13:39:06]">&lt;OriansJ&gt;</a></span><span class="message">Darius: fair, I guess we don't need this then: <a rel="nofollow" href="https://paste.debian.net/1175568/">https://paste.debian.net/1175568/</a> </span></div><div class="line" id="134042"><span class="nick" style="color:#8dd3c7"><a href="#134042" label="[13:40:42]">&lt;OriansJ&gt;</a></span><span class="message">ironically only 6 and 9 are the only encodings that match</span></div><div class="line" id="164551"><span class="nick" style="color:#2e2a4a"><a href="#164551" label="[16:45:51]">&lt;yt&gt;</a></span><span class="message">OriansJ: a little M2-planet fix <a rel="nofollow" href="https://github.com/oriansj/M2-Planet/pull/6">https://github.com/oriansj/M2-Planet/pull/6</a> </span></div><div class="line" id="164613"><span class="nick" style="color:#2e2a4a"><a href="#164613" label="[16:46:13]">&lt;yt&gt;</a></span><span class="message">M2-planet test suite passes with that on AArch64</span></div><div class="line" id="170723"><span class="nick" style="color:#80b1d3"><a href="#170723" label="[17:07:23]">&lt;Darius&gt;</a></span><span class="message">OriansJ, if i came across as combative last night i'm sorry; i was actually curious about what problems you had in mind, and then in answer you seemed to be attributing things to me i hadn't said.</span></div><div class="line" id="170914"><span class="nick" style="color:#80b1d3"><a href="#170914" label="[17:09:14]">&lt;Darius&gt;</a></span><span class="message">of course there's a mismatch between big-endian writing systems and little-endian addressing, but i think that's boring.</span></div><div class="line" id="181421"><span class="nick" style="color:#d9d9d9"><a href="#181421" label="[18:14:21]">&lt;Hagfish&gt;</a></span><span class="message">(for what it's worth, i don't see anything egregious from a skim through what you wrote, but i really respect that pre-emptive apology.  it's great for this community to see professionalism like that)</span></div><div class="line" id="181841"><span class="nick" style="color:#bc80bd"><a href="#181841" label="[18:18:41]">&lt;QuickBootstrapQu&gt;</a></span><span class="message">The 60MB bootstrap binary seed, Is there anything they require to run that isn't provided by, say, a Linux 2.6.8 kernel?</span></div><div class="line" id="183300"><span class="nick" style="color:#d9d9d9"><a href="#183300" label="[18:33:00]">&lt;Hagfish&gt;</a></span><span class="message">QuickBootstrapQu: good question</span></div><div class="line" id="183333"><span class="nick" style="color:#d9d9d9"><a href="#183333" label="[18:33:33]">&lt;Hagfish&gt;</a></span><span class="message">i think a 2.6 kernel (and a shell?) should be all that's needed, but OriansJ knows much more than me</span></div><div class="line" id="210148"><span class="nick">***</span><span class="message notice">ChanServ sets mode: +o rekado_</span></div><div class="line" id="210150"><span class="nick">***</span><span class="message notice">rekado_ is now known as rekado</span></div><br /></div></body></html>