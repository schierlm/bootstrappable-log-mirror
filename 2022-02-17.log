<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-02-17.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="012350"><span class="nick" style="color:#8dd3c7"><a href="#012350" label="[01:23:50]">&lt;oriansj&gt;</a></span><span class="message">stikonas: well mes-m2 really should work with GCC as well; as there is nothing in M2-Planet that isn't also supported by GCC. It is just a matter of figuring out the gap.</span></div><div class="line" id="012628"><span class="nick" style="color:#2e2a4a"><a href="#012628" label="[01:26:28]">&lt;stikonas&gt;</a></span><span class="message">yes, although it's probably a low priority task</span></div><div class="line" id="012646"><span class="nick" style="color:#2e2a4a"><a href="#012646" label="[01:26:46]">&lt;stikonas&gt;</a></span><span class="message">I guess having it build with M2-Mesoplanet would be more important</span></div><div class="line" id="022644"><span class="nick" style="color:#8dd3c7"><a href="#022644" label="[02:26:44]">&lt;oriansj&gt;</a></span><span class="message">stikonas: a bit below getting Mes-M2 using M2libc</span></div><div class="line" id="051005"><span class="nick">***</span><span class="message notice">genr8eofl__ is now known as genr8eofl</span></div><div class="line" id="085154"><span class="nick" style="color:#6b8072"><a href="#085154" label="[08:51:54]">&lt;fossy&gt;</a></span><span class="message">sigh</span></div><div class="line" id="085158"><span class="nick" style="color:#6b8072"><a href="#085158" label="[08:51:58]">&lt;fossy&gt;</a></span><span class="message">replied to the flex thing</span></div><div class="line" id="085256"><span class="nick" style="color:#6b8072"><a href="#085256" label="[08:52:56]">&lt;fossy&gt;</a></span><span class="message">cannot figure out why exactly tagging is support</span></div><div class="line" id="123620"><span class="nick" style="color:#80b1d3"><a href="#123620" label="[12:36:20]">&lt;stikonas[m]&gt;</a></span><span class="message">the autogenerated tarball would not have files needed to build flex from source. Being able to build without autogenerated files is exactly the reason  why we picked that version... But I guess I can see that tagging new tarball would add a bit of workload to flex maintainer</span></div><div class="line" id="130136"><span class="nick" style="color:#8dd3c7"><a href="#130136" label="[13:01:36]">&lt;oriansj&gt;</a></span><span class="message">fossy: what if I offered to pay them for the support of tagging a commit for a new tarball?</span></div><div class="line" id="130337"><span class="nick" style="color:#2e2a4a"><a href="#130337" label="[13:03:37]">&lt;stikonas&gt;</a></span><span class="message">we can probably survive with the old tarball. Or if necessary we can fork a repo and make a release ourselves</span></div><div class="line" id="130348"><span class="nick" style="color:#2e2a4a"><a href="#130348" label="[13:03:48]">&lt;stikonas&gt;</a></span><span class="message">including patches that we apply on top</span></div><div class="line" id="131225"><span class="nick" style="color:#8dd3c7"><a href="#131225" label="[13:12:25]">&lt;oriansj&gt;</a></span><span class="message">stikonas: it is a question of worth. if it costs $10 and saves us 2 hours of headaches, it would be worth it to me.</span></div><div class="line" id="131317"><span class="nick" style="color:#8dd3c7"><a href="#131317" label="[13:13:17]">&lt;oriansj&gt;</a></span><span class="message">if it costs $10K but only saves a few minutes, not worth it to me</span></div><div class="line" id="131354"><span class="nick" style="color:#2e2a4a"><a href="#131354" label="[13:13:54]">&lt;stikonas&gt;</a></span><span class="message">well, old tarball is working now. If it disappears from that ftp server, maybe then we can think...</span></div><div class="line" id="131420"><span class="nick" style="color:#2e2a4a"><a href="#131420" label="[13:14:20]">&lt;stikonas&gt;</a></span><span class="message">(we do have a few local copies, so even if it disappears we'll not lose it)</span></div><div class="line" id="131457"><span class="nick" style="color:#8dd3c7"><a href="#131457" label="[13:14:57]">&lt;oriansj&gt;</a></span><span class="message">stikonas: let us nip it in the bud and address it before it becomes a bigger problem</span></div><div class="line" id="131519"><span class="nick" style="color:#6d2462"><a href="#131519" label="[13:15:19]">*</a></span><span class="message">pabs3 suggests to web.archive.org/save it at minimum</span></div><div class="line" id="132513"><span class="nick" style="color:#8dd3c7"><a href="#132513" label="[13:25:13]">&lt;oriansj&gt;</a></span><span class="message">fork+tag?</span></div><div class="line" id="133325"><span class="nick" style="color:#2e2a4a"><a href="#133325" label="[13:33:25]">&lt;stikonas&gt;</a></span><span class="message">possibly fork+patch+tag...</span></div><div class="line" id="133332"><span class="nick" style="color:#2e2a4a"><a href="#133332" label="[13:33:32]">&lt;stikonas&gt;</a></span><span class="message">there is fork+patch here <a rel="nofollow" href="https://gitlab.com/giomasce/flex/-/tree/506e9605baf4638ba47d37133c348df1385ef06c">https://gitlab.com/giomasce/flex/-/tree/506e9605baf4638ba47d37133c348df1385ef06c</a> </span></div><div class="line" id="155332"><span class="nick" style="color:#234e69"><a href="#155332" label="[15:53:32]">&lt;siraben&gt;</a></span><span class="message">Can brainfuck be used as a bootstrapping language? The interpreter is very simple <a rel="nofollow" href="https://github.com/siraben/bf/blob/master/bf.c">https://github.com/siraben/bf/blob/master/bf.c</a> </span></div><div class="line" id="155806"><span class="nick" style="color:#6c3d55"><a href="#155806" label="[15:58:06]">&lt;nimaje&gt;</a></span><span class="message">yes, but do you have something where you want to use brainfuck in bootstrapping?</span></div><div class="line" id="155955"><span class="nick" style="color:#d9d9d9"><a href="#155955" label="[15:59:55]">&lt;bauen1&gt;</a></span><span class="message">siraben: an interpreter written in your average assembly language is also quite easy to do</span></div><div class="line" id="160056"><span class="nick" style="color:#d9d9d9"><a href="#160056" label="[16:00:56]">&lt;bauen1&gt;</a></span><span class="message">siraben: however brainfuck i/o is rather limited in practice, and you probably don't want to write anything &gt; 1024 characters by hand, it's a nighmare, i tried, managed to write a simple echo irc bot before i managed to convince myself that it's a very very bad idea</span></div><div class="line" id="162738"><span class="nick" style="color:#bc80bd"><a href="#162738" label="[16:27:38]">&lt;muurkha&gt;</a></span><span class="message">I feel like the main problems with brainfuck for bootstrapping are factoring and performance transparency</span></div><div class="line" id="162755"><span class="nick" style="color:#bc80bd"><a href="#162755" label="[16:27:55]">&lt;muurkha&gt;</a></span><span class="message">I mean there are others but those are the worst ones</span></div><div class="line" id="162943"><span class="nick" style="color:#bc80bd"><a href="#162943" label="[16:29:43]">&lt;muurkha&gt;</a></span><span class="message">it lacks performance transparency because you don't have operations like add, xor, or compare for equality; you have to synthesize them out of more primitive operations like increment</span></div><div class="line" id="163037"><span class="nick" style="color:#bc80bd"><a href="#163037" label="[16:30:37]">&lt;muurkha&gt;</a></span><span class="message">an optimizing BF implementation may be able to recognize your synthetic add and use a native add, but it's hard to predict when</span></div><div class="line" id="163148"><span class="nick" style="color:#bc80bd"><a href="#163148" label="[16:31:48]">&lt;muurkha&gt;</a></span><span class="message">as for factoring, well, you don't have subroutines and I haven't figured out a way to get data pointers either</span></div><div class="line" id="163356"><span class="nick" style="color:#bc80bd"><a href="#163356" label="[16:33:56]">&lt;muurkha&gt;</a></span><span class="message">the great thing about brainfuck is that you can write an interpreter for it in half an hour on any reasonable platform.  (maybe oriansj can do it in five minutes, but it took me half an hour)</span></div><div class="line" id="163749"><span class="nick" style="color:#bc80bd"><a href="#163749" label="[16:37:49]">&lt;muurkha&gt;</a></span><span class="message">it would be nice to have something that is within an order of magnitude in complexity of implementation but that doesn't share brainfuck's flaws</span></div><div class="line" id="163808"><span class="nick" style="color:#bc80bd"><a href="#163808" label="[16:38:08]">&lt;muurkha&gt;</a></span><span class="message">then we could use it to write CPU simulators and things like a bootstrapping kernel</span></div><div class="line" id="164228"><span class="nick" style="color:#d9d9d9"><a href="#164228" label="[16:42:28]">&lt;bauen1&gt;</a></span><span class="message">i'd argue that rv32g is probably a decent candidate, it's a very clean isa that is designed to be easy to implement in hardware, granted writing assembly for it is a bit annoying</span></div><div class="line" id="164246"><span class="nick" style="color:#d9d9d9"><a href="#164246" label="[16:42:46]">&lt;bauen1&gt;</a></span><span class="message">but i have yet to take a closer look into the privileged rv32g specifications</span></div><div class="line" id="164320"><span class="nick" style="color:#bc80bd"><a href="#164320" label="[16:43:20]">&lt;muurkha&gt;</a></span><span class="message">privileged rv32g is definitely not within an order of magnitude of half an hour of implementation effort</span></div><div class="line" id="164332"><span class="nick" style="color:#bc80bd"><a href="#164332" label="[16:43:32]">&lt;muurkha&gt;</a></span><span class="message">even unprivileged rv32i probably isn't</span></div><div class="line" id="164406"><span class="nick" style="color:#d9d9d9"><a href="#164406" label="[16:44:06]">&lt;bauen1&gt;</a></span><span class="message">muurkha: unprivileged rv32i most certainly isn't, it's a few days tops if you have some light background in vhdl and cpu design</span></div><div class="line" id="164441"><span class="nick" style="color:#d9d9d9"><a href="#164441" label="[16:44:41]">&lt;bauen1&gt;</a></span><span class="message">muurkha: but it's arguably something that you can eventually run linux on, so you won't have to &quot;throw away&quot; your effort at some point in the bootstrap (you might need a faster cpu however)</span></div><div class="line" id="164442"><span class="nick" style="color:#bc80bd"><a href="#164442" label="[16:44:42]">&lt;muurkha&gt;</a></span><span class="message">how does vhdl help you write a software simulator?</span></div><div class="line" id="164508"><span class="nick" style="color:#d9d9d9"><a href="#164508" label="[16:45:08]">&lt;bauen1&gt;</a></span><span class="message">muurkha: writing a software simulator should be even easier</span></div><div class="line" id="164510"><span class="nick" style="color:#bc80bd"><a href="#164510" label="[16:45:10]">&lt;muurkha&gt;</a></span><span class="message">that's true!  and you don't have to write your own compiler</span></div><div class="line" id="164537"><span class="nick" style="color:#bc80bd"><a href="#164537" label="[16:45:37]">&lt;muurkha&gt;</a></span><span class="message">yes, but I predict it would still take me longer than 5 hours</span></div><div class="line" id="164552"><span class="nick" style="color:#d9d9d9"><a href="#164552" label="[16:45:52]">&lt;bauen1&gt;</a></span><span class="message">muurkha: the rv32i alu is incredibly simple</span></div><div class="line" id="164621"><span class="nick" style="color:#bc80bd"><a href="#164621" label="[16:46:21]">&lt;muurkha&gt;</a></span><span class="message">it is, but the complexity of a software simulator never comes from the alu</span></div><div class="line" id="164718"><span class="nick" style="color:#d9d9d9"><a href="#164718" label="[16:47:18]">&lt;bauen1&gt;</a></span><span class="message">muurkha: you really don't have that many components, you have the alu, a few very simple branch instructions, a register file, some load and store instructions (which are very easy to implement if you're not doing hardware) and some immediate decoding</span></div><div class="line" id="164737"><span class="nick" style="color:#d9d9d9"><a href="#164737" label="[16:47:37]">&lt;bauen1&gt;</a></span><span class="message">granted i haven't tried to implement anything but rv32i</span></div><div class="line" id="164813"><span class="nick" style="color:#bc80bd"><a href="#164813" label="[16:48:13]">&lt;muurkha&gt;</a></span><span class="message">yeah, and the funky hardware-optimized bit orders, and calculating branch destinations, plus whatever I/O you need to get started</span></div><div class="line" id="164816"><span class="nick" style="color:#d9d9d9"><a href="#164816" label="[16:48:16]">&lt;bauen1&gt;</a></span><span class="message">and by all means it's much easier than designing your own ISA, because you're gonna make some terrible decisions in that part alone if it's your first time ...</span></div><div class="line" id="164852"><span class="nick" style="color:#bc80bd"><a href="#164852" label="[16:48:52]">&lt;muurkha&gt;</a></span><span class="message">but even M and C are pretty simple to implement, and for a uniprocessor software sim A is basically a no-op</span></div><div class="line" id="164915"><span class="nick" style="color:#d9d9d9"><a href="#164915" label="[16:49:15]">&lt;bauen1&gt;</a></span><span class="message">muurkha: the immediate decoder is very simple to implement, there's basically 6 different ways to do it, i.e. 6 C one liner functions, and then you just have to use the right function depending on what opcode you're looking at</span></div><div class="line" id="164933"><span class="nick" style="color:#bc80bd"><a href="#164933" label="[16:49:33]">&lt;muurkha&gt;</a></span><span class="message">yup</span></div><div class="line" id="164950"><span class="nick" style="color:#d9d9d9"><a href="#164950" label="[16:49:50]">&lt;bauen1&gt;</a></span><span class="message">muurkha: i implemented an rv32i vhdl cpu, and it only took me 4 days, 2 of which where debugging memory timings, so i'm very positive you can do a lot better when writing a software simulator</span></div><div class="line" id="165020"><span class="nick" style="color:#d9d9d9"><a href="#165020" label="[16:50:20]">&lt;bauen1&gt;</a></span><span class="message">this reminds me that i still want to polish that thing a bit and see if i can get it running on an fpga</span></div><div class="line" id="165041"><span class="nick" style="color:#bc80bd"><a href="#165041" label="[16:50:41]">&lt;muurkha&gt;</a></span><span class="message">I'm not saying risc-v is bad compared to other CPUs; i love it! I'm just saying that, say, the immediate decoder is roughly the same implementation complexity as all of brainfuck</span></div><div class="line" id="165133"><span class="nick" style="color:#d9d9d9"><a href="#165133" label="[16:51:33]">&lt;bauen1&gt;</a></span><span class="message">muurkha: maybe a bit complexer than brainfuck without loops, but not as complex as brainfuck with loops, they're very easy to get wrong, for the immediate decoder you just follow the 2 tables in the manual</span></div><div class="line" id="165217"><span class="nick" style="color:#bc80bd"><a href="#165217" label="[16:52:17]">&lt;muurkha&gt;</a></span><span class="message">the RISC-V privileged spec is also not that bad.  it's a real breath of fresh air after the nightmare bullshit that is basically any other MMU</span></div><div class="line" id="165415"><span class="nick" style="color:#bc80bd"><a href="#165415" label="[16:54:15]">&lt;muurkha&gt;</a></span><span class="message">have you gotten your design running in an FPGA yet?</span></div><div class="line" id="165428"><span class="nick" style="color:#d9d9d9"><a href="#165428" label="[16:54:28]">&lt;bauen1&gt;</a></span><span class="message">muurkha: no, exams kind of dereailed that plan a bit</span></div><div class="line" id="165440"><span class="nick" style="color:#bc80bd"><a href="#165440" label="[16:54:40]">&lt;muurkha&gt;</a></span><span class="message">I thought that might be why you were debugging memory timings</span></div><div class="line" id="165520"><span class="nick" style="color:#bc80bd"><a href="#165520" label="[16:55:20]">&lt;muurkha&gt;</a></span><span class="message">for me the great thing about RISC-V (especially RV32G) is how boring it is</span></div><div class="line" id="165539"><span class="nick" style="color:#bc80bd"><a href="#165539" label="[16:55:39]">&lt;muurkha&gt;</a></span><span class="message">it's like C that way</span></div><div class="line" id="165559"><span class="nick" style="color:#bc80bd"><a href="#165559" label="[16:55:59]">&lt;muurkha&gt;</a></span><span class="message">&quot;no actually this doesn't have to be clever and confusing&quot;</span></div><div class="line" id="165653"><span class="nick" style="color:#bc80bd"><a href="#165653" label="[16:56:53]">&lt;muurkha&gt;</a></span><span class="message">the exception being the funky bit order</span></div><div class="line" id="183606"><span class="nick" style="color:#2e2a4a"><a href="#183606" label="[18:36:06]">&lt;stikonas&gt;</a></span><span class="message">siraben: brainfuck implementation in C might be simple, but one would have to write it in .hex0 or something similar, basically machine code. This part is doable. But the question is what's next? Presumably you wouldn't want to go back to assembly, so you would have to write a compiler or interpreter for a proper language</span></div><div class="line" id="183619"><span class="nick" style="color:#2e2a4a"><a href="#183619" label="[18:36:19]">&lt;stikonas&gt;</a></span><span class="message">and I wouldn't want to write a C compiler in brainfuck</span></div><div class="line" id="185146"><span class="nick" style="color:#d9d9d9"><a href="#185146" label="[18:51:46]">&lt;bauen1&gt;</a></span><span class="message">and every bigger brainfuck program i know of wasn't written in brainfuck, it was compiled to brainfuck in some way or another</span></div><div class="line" id="191342"><span class="nick" style="color:#234e69"><a href="#191342" label="[19:13:42]">&lt;siraben&gt;</a></span><span class="message">yeah, so it's a poor choice of bootstrapping language unfortunately</span></div><div class="line" id="222736"><span class="nick" style="color:#2e2a4a"><a href="#222736" label="[22:27:36]">&lt;stikonas&gt;</a></span><span class="message">in principle if somebody could write a small interpreter that is more readable than brainfuck it might be useful</span></div><div class="line" id="222749"><span class="nick" style="color:#2e2a4a"><a href="#222749" label="[22:27:49]">&lt;stikonas&gt;</a></span><span class="message">but so far nobody wrote anything like that</span></div><div class="line" id="222810"><span class="nick" style="color:#2e2a4a"><a href="#222810" label="[22:28:10]">&lt;stikonas&gt;</a></span><span class="message">then we could go to arch-independent code much earlier than M2-Planet</span></div><div class="line" id="222945"><span class="nick" style="color:#2e2a4a"><a href="#222945" label="[22:29:45]">&lt;stikonas&gt;</a></span><span class="message">but it's probably hard to write an interpreter that is smaller than M0</span></div><br /></div></body></html>