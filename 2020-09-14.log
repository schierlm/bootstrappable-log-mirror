<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2020-09-14.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="013257"><span class="nick">***</span><span class="message notice">stikonas_ is now known as stikonas</span></div><div class="line" id="014100"><span class="nick" style="color:#8dd3c7"><a href="#014100" label="[01:41:00]">&lt;OriansJ`&gt;</a></span><span class="message">No comments on the armv7l cc_x86.S? no recommendations? no suggestions for improvement? instructions which the assembler will quietly change to something entirely different?</span></div><div class="line" id="014416"><span class="nick" style="color:#2e2a4a"><a href="#014416" label="[01:44:16]">&lt;fossy&gt;</a></span><span class="message">i read over it, it looks fine but i am not really an assembly person</span></div><div class="line" id="014829"><span class="nick" style="color:#8dd3c7"><a href="#014829" label="[01:48:29]">&lt;OriansJ`&gt;</a></span><span class="message">mostly I am finding that it is not actually possible to encode the loading of 577 directly as it can not be expressed in 8bits, nor with 8bit value shifted; thus the assembler quietly replaced it with a thumb2 instruction that isn't valid on all armv7l systems.</span></div><div class="line" id="014850"><span class="nick" style="color:#6b8072"><a href="#014850" label="[01:48:50]">&lt;xentrac&gt;</a></span><span class="message">heh!  naughty assembler1</span></div><div class="line" id="014855"><span class="nick" style="color:#6b8072"><a href="#014855" label="[01:48:55]">&lt;xentrac&gt;</a></span><span class="message">oneone!</span></div><div class="line" id="015011"><span class="nick" style="color:#8dd3c7"><a href="#015011" label="[01:50:11]">&lt;OriansJ`&gt;</a></span><span class="message">now 576 can be encoded in 8bits with a 4bit shift and the thumb instruction loads it and then incrememts</span></div><div class="line" id="015455"><span class="nick" style="color:#8dd3c7"><a href="#015455" label="[01:54:55]">&lt;OriansJ`&gt;</a></span><span class="message">tstmi r2, r3, ror 1 but objdump -d shows: movw    r1, #577</span></div><div class="line" id="020142"><span class="nick" style="color:#8dd3c7"><a href="#020142" label="[02:01:42]">&lt;OriansJ`&gt;</a></span><span class="message">So I am stuck with either the documentation is right or the assembler is right or the disassembler is right. because all three disagree with each other.</span></div><div class="line" id="020333"><span class="nick" style="color:#8dd3c7"><a href="#020333" label="[02:03:33]">&lt;OriansJ`&gt;</a></span><span class="message">and this is only 10 instructions into converting into M1</span></div><div class="line" id="020833"><span class="nick" style="color:#8dd3c7"><a href="#020833" label="[02:08:33]">&lt;OriansJ`&gt;</a></span><span class="message">as RASM2 is spot on with the documentation; objdump is interpreting as movw and gnu assembler states it is a thumb2 optimization. So someone is right and everyone else is wrong</span></div><div class="line" id="021055"><span class="nick" style="color:#6b8072"><a href="#021055" label="[02:10:55]">&lt;xentrac&gt;</a></span><span class="message">what if it varies depending on the hardware?</span></div><div class="line" id="021220"><span class="nick" style="color:#8dd3c7"><a href="#021220" label="[02:12:20]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: then I have to do something insanely ugly to load 577 into a register on all armv7l systems</span></div><div class="line" id="021308"><span class="nick" style="color:#8dd3c7"><a href="#021308" label="[02:13:08]">&lt;OriansJ`&gt;</a></span><span class="message">because M1 has a 1:1 correspondence with binary output regardless of hardware or operating system.</span></div><div class="line" id="021323"><span class="nick" style="color:#6b8072"><a href="#021323" label="[02:13:23]">&lt;xentrac&gt;</a></span><span class="message">right</span></div><div class="line" id="021340"><span class="nick" style="color:#8dd3c7"><a href="#021340" label="[02:13:40]">&lt;OriansJ`&gt;</a></span><span class="message">and it has to have the EXACT same behavior on ALL armv7l systems</span></div><div class="line" id="021410"><span class="nick" style="color:#8dd3c7"><a href="#021410" label="[02:14:10]">&lt;OriansJ`&gt;</a></span><span class="message">if even one armv7l system doesn't work right with a given encoding, I can't use it.</span></div><div class="line" id="021650"><span class="nick" style="color:#8dd3c7"><a href="#021650" label="[02:16:50]">&lt;OriansJ`&gt;</a></span><span class="message">So all of the armv7l ugly special cases need to be avoided so that cc_armv7l.S runs on all armv7l hosts (assuming the malloc, fgetc and fputc functions are adjusted according to the operating system or lack there of used)</span></div><div class="line" id="021909"><span class="nick" style="color:#8dd3c7"><a href="#021909" label="[02:19:09]">&lt;OriansJ`&gt;</a></span><span class="message">it is why I didn't use the floating point division route because I needed to work on systems without SIMD or FPUs</span></div><div class="line" id="022122"><span class="nick" style="color:#8dd3c7"><a href="#022122" label="[02:21:22]">&lt;OriansJ`&gt;</a></span><span class="message">minus a handful of logical operators, it is just: load immediates, load memory, store memory, add, compare, push, pop and a handful of branching instructions.</span></div><div class="line" id="024635"><span class="nick" style="color:#8dd3c7"><a href="#024635" label="[02:46:35]">&lt;OriansJ`&gt;</a></span><span class="message">now in theory even though I am calling it armv7l, it should also work on 90ish of all armv6 processors as well</span></div><div class="line" id="024941"><span class="nick" style="color:#8dd3c7"><a href="#024941" label="[02:49:41]">&lt;OriansJ`&gt;</a></span><span class="message">because it turns out some of them don't support blx or multiply; which is crazy.</span></div><div class="line" id="025007"><span class="nick" style="color:#8dd3c7"><a href="#025007" label="[02:50:07]">&lt;OriansJ`&gt;</a></span><span class="message">Not as bad as the armv5 vs armv6 crazy but pretty bad</span></div><div class="line" id="025705"><span class="nick" style="color:#8dd3c7"><a href="#025705" label="[02:57:05]">&lt;OriansJ`&gt;</a></span><span class="message">what is even weirder is Cortex</span></div><div class="line" id="025711"><span class="nick" style="color:#8dd3c7"><a href="#025711" label="[02:57:11]">&lt;OriansJ`&gt;</a></span><span class="message">M23</span></div><div class="line" id="025736"><span class="nick" style="color:#8dd3c7"><a href="#025736" label="[02:57:36]">&lt;OriansJ`&gt;</a></span><span class="message">is ARMv8 but it also doesn't support multiply</span></div><div class="line" id="030121"><span class="nick" style="color:#8dd3c7"><a href="#030121" label="[03:01:21]">&lt;OriansJ`&gt;</a></span><span class="message">Armv7-M and Armv7E-M architectures always include divide instructions but Armv7-R might in thumb instructions and Armv7-A optionally in virtualization extensions???? (Hence the rolling of a division function)</span></div><div class="line" id="030442"><span class="nick" style="color:#8dd3c7"><a href="#030442" label="[03:04:42]">&lt;OriansJ`&gt;</a></span><span class="message">I guess, I got spoiled by x86 where turing core instructions are always there in every single processor; even the weird third party chips like via or cyrix or even FPGA cores.</span></div><div class="line" id="032342"><span class="nick" style="color:#8dd3c7"><a href="#032342" label="[03:23:42]">&lt;OriansJ`&gt;</a></span><span class="message">and heaven help you if you set condition bit 9. As you will crash the kernel.</span></div><div class="line" id="032601"><span class="nick" style="color:#8dd3c7"><a href="#032601" label="[03:26:01]">&lt;OriansJ`&gt;</a></span><span class="message">as you have just set all data to big endian and the kernel has you preserve your condition codes in memory prior to reseting the register to something sane; otherwise it will not be preserved across syscalls.</span></div><div class="line" id="032845"><span class="nick" style="color:#8dd3c7"><a href="#032845" label="[03:28:45]">&lt;OriansJ`&gt;</a></span><span class="message">and on some optimized kernel trees, they skip that step and get damn near instant kernel panics as all of the bytes in the words the CPU was reading are now flipped into big endian format on load or bit 24; then the cpu will assume kernel instructions are java bytecodes and take a hard dump.</span></div><div class="line" id="033131"><span class="nick" style="color:#8dd3c7"><a href="#033131" label="[03:31:31]">&lt;OriansJ`&gt;</a></span><span class="message">Registers R0 through R7 and the condition register are the same across all CPU modes; they are never banked.</span></div><div class="line" id="033145"><span class="nick" style="color:#8dd3c7"><a href="#033145" label="[03:31:45]">&lt;OriansJ`&gt;</a></span><span class="message">Registers R8 through R12 are the same across all CPU modes except FIQ mode. FIQ mode has its own distinct R8 through R12 registers.</span></div><div class="line" id="033218"><span class="nick" style="color:#8dd3c7"><a href="#033218" label="[03:32:18]">&lt;OriansJ`&gt;</a></span><span class="message">R13 and R14 are banked across all privileged CPU modes except system mode</span></div><div class="line" id="033651"><span class="nick" style="color:#8dd3c7"><a href="#033651" label="[03:36:51]">&lt;OriansJ`&gt;</a></span><span class="message">plus it isn't possible to directly push or pop the condition register on the stack and the condition register and the &quot;do not modify bits&quot; are an absolute mess across implementations</span></div><div class="line" id="033831"><span class="nick" style="color:#6b8072"><a href="#033831" label="[03:38:31]">&lt;xentrac&gt;</a></span><span class="message">&quot;turing core&quot;?</span></div><div class="line" id="034016"><span class="nick" style="color:#6b8072"><a href="#034016" label="[03:40:16]">&lt;xentrac&gt;</a></span><span class="message">division isn't as big a loss as multiply, just because hardware divide is still slow</span></div><div class="line" id="061421"><span class="nick" style="color:#80b1d3"><a href="#061421" label="[06:14:21]">&lt;yanmaani&gt;</a></span><span class="message">I was pointed here</span></div><div class="line" id="061447"><span class="nick" style="color:#80b1d3"><a href="#061447" label="[06:14:47]">&lt;yanmaani&gt;</a></span><span class="message">According to <a rel="nofollow" href="https://guix.gnu.org/en/blog/2020/guix-further-reduces-bootstrap-seed-to-25/">https://guix.gnu.org/en/blog/2020/guix-further-reduces-bootstrap-seed-to-25/</a>,  the bootstrap set is 60MB. But there's tiny linux distros weighing in at 1-2MB - busybox, tcc, and some kernel</span></div><div class="line" id="072124"><span class="nick" style="color:#8dd3c7"><a href="#072124" label="[07:21:24]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: true but we also are working on reducing it all down to just 240 bytes. <a rel="nofollow" href="https://github.com/oriansj/mescc-tools-seed">https://github.com/oriansj/mescc-tools-seed</a> </span></div><div class="line" id="072518"><span class="nick" style="color:#8dd3c7"><a href="#072518" label="[07:25:18]">&lt;OriansJ`&gt;</a></span><span class="message">or more precisely combining two paths to bootstrapping the world; guix down and stage0 up. here is a map of the plan: <a rel="nofollow" href="https://github.com/oriansj/talk-notes/blob/master/Current%20bootstrap%20map.pdf">https://github.com/oriansj/talk-notes/blob/master/Current%20bootstrap%20map.pdf</a>  the only remaining gap is currently mes-m2 and that is entirely my fault.</span></div><div class="line" id="073643"><span class="nick" style="color:#8dd3c7"><a href="#073643" label="[07:36:43]">&lt;OriansJ`&gt;</a></span><span class="message">it also is architecture and host neutral; reproducible and deterministic. eg every binary produced is always 100% bit for bit identical when given the same source code.</span></div><div class="line" id="075033"><span class="nick" style="color:#8dd3c7"><a href="#075033" label="[07:50:33]">&lt;OriansJ`&gt;</a></span><span class="message">The big size floor for guix's bootstrap (prior to mes-m2 getting up to par) is the fact statically compiled guile isn't a small binary and guix doesn't run on mes.c (I provide details if you would like here: <a rel="nofollow" href="https://github.com/oriansj/talk-notes/blob/master/bootstrappable.org">https://github.com/oriansj/talk-notes/blob/master/bootstrappable.org</a>  ) [looks best in emacs org-mode after cloning the repo]</span></div><div class="line" id="080916"><span class="nick" style="color:#8dd3c7"><a href="#080916" label="[08:09:16]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: the standard load/store, arithmetic/logic, comparision and call/jump functions. multiply wouldn't be a big loss either; it is even simpler to implement than division and for terms of 16 and below make for shallow loops. But the lack of consistency in arm standards makes for land mines in bootstrapping. if someone had done this work back in armv4, they would be saying: &quot;what do you mean core instructions were removed or got new</span></div><div class="line" id="080917"><span class="nick" style="color:#8dd3c7"><a href="#080917" label="[08:09:17]">&lt;OriansJ`&gt;</a></span><span class="message">instruction encoding?&quot;</span></div><div class="line" id="081017"><span class="nick" style="color:#8dd3c7"><a href="#081017" label="[08:10:17]">&lt;OriansJ`&gt;</a></span><span class="message">literally not a single binary from armv4 will work correctly on an armv5/6/7/8 system</span></div><div class="line" id="161602"><span class="nick" style="color:#80b1d3"><a href="#161602" label="[16:16:02]">&lt;yanmaani&gt;</a></span><span class="message">OriansJ`: Doesn't that make scheme unsuitable for bootstrapping?</span></div><div class="line" id="162858"><span class="nick" style="color:#80b1d3"><a href="#162858" label="[16:28:58]">&lt;yanmaani&gt;</a></span><span class="message">Wouldn't it make more sense to try and build tcc with cc_x86?</span></div><div class="line" id="162934"><span class="nick" style="color:#80b1d3"><a href="#162934" label="[16:29:34]">&lt;yanmaani&gt;</a></span><span class="message">or m2-planet or that matter</span></div><div class="line" id="163203"><span class="nick" style="color:#6d2462"><a href="#163203" label="[16:32:03]">&lt;stikonas&gt;</a></span><span class="message">yanmaani: tcc is built with mescc which doesn't need guile and guix</span></div><div class="line" id="163213"><span class="nick" style="color:#6d2462"><a href="#163213" label="[16:32:13]">&lt;stikonas&gt;</a></span><span class="message">you can still do bootstrap manually</span></div><div class="line" id="163310"><span class="nick" style="color:#6d2462"><a href="#163310" label="[16:33:10]">&lt;stikonas&gt;</a></span><span class="message">(easy automation would of course be a plus but I don't think it warrants to say that scheme is unsuitable)</span></div><div class="line" id="163402"><span class="nick" style="color:#80b1d3"><a href="#163402" label="[16:34:02]">&lt;yanmaani&gt;</a></span><span class="message">stikonas: If it's so big, I mean</span></div><div class="line" id="163509"><span class="nick" style="color:#6d2462"><a href="#163509" label="[16:35:09]">&lt;stikonas&gt;</a></span><span class="message">guile static executable?</span></div><div class="line" id="163512"><span class="nick" style="color:#6d2462"><a href="#163512" label="[16:35:12]">&lt;stikonas&gt;</a></span><span class="message">yeah, it is big :(</span></div><div class="line" id="163601"><span class="nick" style="color:#80b1d3"><a href="#163601" label="[16:36:01]">&lt;yanmaani&gt;</a></span><span class="message"> <a rel="nofollow" href="https://code.jsoftware.com/wiki/Essays/Incunabulum">https://code.jsoftware.com/wiki/Essays/Incunabulum</a>  wonder if you could interpret J in this</span></div><div class="line" id="163702"><span class="nick" style="color:#80b1d3"><a href="#163702" label="[16:37:02]">&lt;yanmaani&gt;</a></span><span class="message">stikonas: Why can't you modify tcc to build with cc_x86 directly?</span></div><div class="line" id="163756"><span class="nick" style="color:#6d2462"><a href="#163756" label="[16:37:56]">&lt;stikonas&gt;</a></span><span class="message">I don't know. But my guess is that it would be more work</span></div><div class="line" id="163808"><span class="nick" style="color:#6d2462"><a href="#163808" label="[16:38:08]">&lt;stikonas&gt;</a></span><span class="message">well, I guess build with M2-planet...</span></div><div class="line" id="163832"><span class="nick" style="color:#80b1d3"><a href="#163832" label="[16:38:32]">&lt;yanmaani&gt;</a></span><span class="message">oh, tcc needs libc</span></div><div class="line" id="163833"><span class="nick" style="color:#80b1d3"><a href="#163833" label="[16:38:33]">&lt;yanmaani&gt;</a></span><span class="message">that's why</span></div><div class="line" id="163836"><span class="nick" style="color:#80b1d3"><a href="#163836" label="[16:38:36]">&lt;yanmaani&gt;</a></span><span class="message">right</span></div><div class="line" id="163849"><span class="nick" style="color:#6d2462"><a href="#163849" label="[16:38:49]">&lt;stikonas&gt;</a></span><span class="message">oh ok</span></div><div class="line" id="163859"><span class="nick" style="color:#6d2462"><a href="#163859" label="[16:38:59]">&lt;stikonas&gt;</a></span><span class="message">well, there is libc in mes</span></div><div class="line" id="164015"><span class="nick" style="color:#6d2462"><a href="#164015" label="[16:40:15]">&lt;stikonas&gt;</a></span><span class="message">ok, but that's a bit orthogonal to guix bootstrap anyway</span></div><div class="line" id="164251"><span class="nick" style="color:#6d2462"><a href="#164251" label="[16:42:51]">&lt;stikonas&gt;</a></span><span class="message">well, early bootstrap automation is done using kaem is and fairly easy to use. Hopefully, once mes-m2 is ready, tcc will be easy to bootstrap too (e.g. just by running some kaem script)</span></div><div class="line" id="164336"><span class="nick" style="color:#6d2462"><a href="#164336" label="[16:43:36]">&lt;stikonas&gt;</a></span><span class="message">(there is always unbootstrapped kernel in the equation too...)</span></div><div class="line" id="165202"><span class="nick" style="color:#80b1d3"><a href="#165202" label="[16:52:02]">&lt;yanmaani&gt;</a></span><span class="message">Doesn't TempleOS have a tiny kernel?</span></div><div class="line" id="165803"><span class="nick" style="color:#6d2462"><a href="#165803" label="[16:58:03]">&lt;stikonas&gt;</a></span><span class="message">that could be true, but it's still something much bigger than stage0 bootstrap seed</span></div><div class="line" id="165804"><span class="nick" style="color:#80b1d3"><a href="#165804" label="[16:58:04]">&lt;yanmaani&gt;</a></span><span class="message">27 KLOC of HolyC. But it's x86_64 only.</span></div><div class="line" id="165816"><span class="nick" style="color:#80b1d3"><a href="#165816" label="[16:58:16]">&lt;yanmaani&gt;</a></span><span class="message">Does stage0 bootstrap not need a kernel?</span></div><div class="line" id="165825"><span class="nick" style="color:#6d2462"><a href="#165825" label="[16:58:25]">&lt;stikonas&gt;</a></span><span class="message">which is bout 1KB (shell and hex0</span></div><div class="line" id="165831"><span class="nick" style="color:#6d2462"><a href="#165831" label="[16:58:31]">&lt;stikonas&gt;</a></span><span class="message">yanmaani: it depends</span></div><div class="line" id="165905"><span class="nick" style="color:#6d2462"><a href="#165905" label="[16:59:05]">&lt;stikonas&gt;</a></span><span class="message">yanmaani: x86/arm etc bootstrap on linux does need a kernel (it uses syscalls to e.g. read and write files)</span></div><div class="line" id="165915"><span class="nick" style="color:#80b1d3"><a href="#165915" label="[16:59:15]">&lt;yanmaani&gt;</a></span><span class="message">uh</span></div><div class="line" id="165918"><span class="nick" style="color:#80b1d3"><a href="#165918" label="[16:59:18]">&lt;yanmaani&gt;</a></span><span class="message">if it's on linux</span></div><div class="line" id="165931"><span class="nick" style="color:#80b1d3"><a href="#165931" label="[16:59:31]">&lt;yanmaani&gt;</a></span><span class="message">isn't that needing a kernel?</span></div><div class="line" id="165943"><span class="nick" style="color:#6d2462"><a href="#165943" label="[16:59:43]">&lt;stikonas&gt;</a></span><span class="message">well, if it's not on linux, you need to write you own input output driver code...</span></div><div class="line" id="165947"><span class="nick" style="color:#6d2462"><a href="#165947" label="[16:59:47]">&lt;stikonas&gt;</a></span><span class="message">to interface with hardwre</span></div><div class="line" id="165951"><span class="nick" style="color:#80b1d3"><a href="#165951" label="[16:59:51]">&lt;yanmaani&gt;</a></span><span class="message">yes</span></div><div class="line" id="170000"><span class="nick" style="color:#6d2462"><a href="#170000" label="[17:00:00]">&lt;stikonas&gt;</a></span><span class="message">but in principle you can build some custom hardware that uses some kind of tapes...</span></div><div class="line" id="170000"><span class="nick" style="color:#80b1d3"><a href="#170000" label="[17:00:00]">&lt;yanmaani&gt;</a></span><span class="message">templeOS has this</span></div><div class="line" id="170008"><span class="nick" style="color:#80b1d3"><a href="#170008" label="[17:00:08]">&lt;yanmaani&gt;</a></span><span class="message">entire kernel is 27 kloc of C</span></div><div class="line" id="170018"><span class="nick" style="color:#6d2462"><a href="#170018" label="[17:00:18]">&lt;stikonas&gt;</a></span><span class="message">that's still quite a lot</span></div><div class="line" id="170024"><span class="nick" style="color:#80b1d3"><a href="#170024" label="[17:00:24]">&lt;yanmaani&gt;</a></span><span class="message">Less than Linux</span></div><div class="line" id="170030"><span class="nick" style="color:#6d2462"><a href="#170030" label="[17:00:30]">&lt;stikonas&gt;</a></span><span class="message">yes, that's true</span></div><div class="line" id="170040"><span class="nick" style="color:#6d2462"><a href="#170040" label="[17:00:40]">&lt;stikonas&gt;</a></span><span class="message">but it's much more than e.g. cc_x86</span></div><div class="line" id="170107"><span class="nick" style="color:#80b1d3"><a href="#170107" label="[17:01:07]">&lt;yanmaani&gt;</a></span><span class="message">Yes but doesn't that need kernel?</span></div><div class="line" id="170126"><span class="nick" style="color:#6d2462"><a href="#170126" label="[17:01:26]">&lt;stikonas&gt;</a></span><span class="message">cc_x86 needs kernel</span></div><div class="line" id="170139"><span class="nick" style="color:#6d2462"><a href="#170139" label="[17:01:39]">&lt;stikonas&gt;</a></span><span class="message">but I meant you can build some custom arch to run knight instruction sets</span></div><div class="line" id="170146"><span class="nick" style="color:#6d2462"><a href="#170146" label="[17:01:46]">&lt;stikonas&gt;</a></span><span class="message">feed in some tape, you get some tape out</span></div><div class="line" id="170158"><span class="nick" style="color:#80b1d3"><a href="#170158" label="[17:01:58]">&lt;yanmaani&gt;</a></span><span class="message">I'm a bit confused by this. Maybe it's already covered in the FAQ, but wouldn't it make much more sense to reproducibly build and bootstrap a trillion different versions of say TinyCC?</span></div><div class="line" id="170212"><span class="nick" style="color:#80b1d3"><a href="#170212" label="[17:02:12]">&lt;yanmaani&gt;</a></span><span class="message">yeah there's that guy who built a computer with wires</span></div><div class="line" id="170215"><span class="nick" style="color:#6d2462"><a href="#170215" label="[17:02:15]">&lt;stikonas&gt;</a></span><span class="message">e.g. like <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage1/stage1_assembler-0.hex0">https://github.com/oriansj/stage0/blob/master/stage1/stage1_assembler-0.hex0</a> </span></div><div class="line" id="170215"><span class="nick" style="color:#80b1d3"><a href="#170215" label="[17:02:15]">&lt;yanmaani&gt;</a></span><span class="message">and made a c compiler on it</span></div><div class="line" id="170323"><span class="nick" style="color:#80b1d3"><a href="#170323" label="[17:03:23]">&lt;yanmaani&gt;</a></span><span class="message">seems like, if you need a trusted binary kernel, it's better to have this be something small (like tOS) than something big (like linux)</span></div><div class="line" id="170324"><span class="nick" style="color:#6d2462"><a href="#170324" label="[17:03:24]">&lt;stikonas&gt;</a></span><span class="message">but how cna you guaranteed that all of them are not compromised</span></div><div class="line" id="170335"><span class="nick" style="color:#6d2462"><a href="#170335" label="[17:03:35]">&lt;stikonas&gt;</a></span><span class="message">you don't know that temple os is trusted binary kernel</span></div><div class="line" id="170337"><span class="nick" style="color:#80b1d3"><a href="#170337" label="[17:03:37]">&lt;yanmaani&gt;</a></span><span class="message">they all have to be compromised in the same way</span></div><div class="line" id="170346"><span class="nick" style="color:#6d2462"><a href="#170346" label="[17:03:46]">&lt;stikonas&gt;</a></span><span class="message">you either need trusted binary kernel or trusted hardware</span></div><div class="line" id="170427"><span class="nick" style="color:#80b1d3"><a href="#170427" label="[17:04:27]">&lt;yanmaani&gt;</a></span><span class="message">It's unlikely that the adversary would compromise MacOS 8 *and* Mac OS X *and* MS-DOS 6.22 *and* Windows XP *and* Windows 7 in the exact same way</span></div><div class="line" id="170441"><span class="nick" style="color:#80b1d3"><a href="#170441" label="[17:04:41]">&lt;yanmaani&gt;</a></span><span class="message">I know that, but isn't it at least more secure with a smaller kernel?</span></div><div class="line" id="170459"><span class="nick" style="color:#6d2462"><a href="#170459" label="[17:04:59]">&lt;stikonas&gt;</a></span><span class="message">well, it's unlikely that adversary would compromise gcc, msvc, clang in exactly the same  way either...</span></div><div class="line" id="170509"><span class="nick" style="color:#6d2462"><a href="#170509" label="[17:05:09]">&lt;stikonas&gt;</a></span><span class="message">yes, it is more secure with smaller kernel</span></div><div class="line" id="170514"><span class="nick" style="color:#80b1d3"><a href="#170514" label="[17:05:14]">&lt;yanmaani&gt;</a></span><span class="message">Then you have say 100k of random blobs instead of 1MB</span></div><div class="line" id="170537"><span class="nick" style="color:#80b1d3"><a href="#170537" label="[17:05:37]">&lt;yanmaani&gt;</a></span><span class="message">Can't you just cross-compile tcc and make sure it self-hosts reproducibly then? With all the obscure combinations</span></div><div class="line" id="170544"><span class="nick" style="color:#6d2462"><a href="#170544" label="[17:05:44]">&lt;stikonas&gt;</a></span><span class="message">yes, tha'ts true... I was just saying if you want absolutely minimum blobs, you need to work quite hard and at some point deal with hardware</span></div><div class="line" id="170614"><span class="nick" style="color:#80b1d3"><a href="#170614" label="[17:06:14]">&lt;yanmaani&gt;</a></span><span class="message">clang on macos 8, msvc on windows xp, gcc on ms-dos. Seems improbable all of them would be compromised in the same way</span></div><div class="line" id="170629"><span class="nick" style="color:#234e69"><a href="#170629" label="[17:06:29]">&lt;rain1&gt;</a></span><span class="message">regarding templeos</span></div><div class="line" id="170630"><span class="nick" style="color:#6d2462"><a href="#170630" label="[17:06:30]">&lt;stikonas&gt;</a></span><span class="message">well, you can actually replace binary kernel with binary tcc...</span></div><div class="line" id="170642"><span class="nick" style="color:#6d2462"><a href="#170642" label="[17:06:42]">&lt;stikonas&gt;</a></span><span class="message">not sure which is larger</span></div><div class="line" id="170645"><span class="nick" style="color:#80b1d3"><a href="#170645" label="[17:06:45]">&lt;yanmaani&gt;</a></span><span class="message">stikonas: doesn't binary tcc need binary kernel still?</span></div><div class="line" id="170655"><span class="nick" style="color:#234e69"><a href="#170655" label="[17:06:55]">&lt;rain1&gt;</a></span><span class="message">it is self hosted and the official ISOs were tampered with by &quot;fans&quot; that stole the authors  passwords</span></div><div class="line" id="170706"><span class="nick" style="color:#234e69"><a href="#170706" label="[17:07:06]">&lt;rain1&gt;</a></span><span class="message">so there's basically no way to know it isn't infected in some way</span></div><div class="line" id="170708"><span class="nick" style="color:#6d2462"><a href="#170708" label="[17:07:08]">&lt;stikonas&gt;</a></span><span class="message">I think somebody had expermented with tcc as bootloader compiling binary kernel on the fly</span></div><div class="line" id="170733"><span class="nick" style="color:#234e69"><a href="#170733" label="[17:07:33]">&lt;rain1&gt;</a></span><span class="message">we can expect that they only put on a textfile about themselves and didn't infect the compiler, but still worth noting</span></div><div class="line" id="170741"><span class="nick" style="color:#80b1d3"><a href="#170741" label="[17:07:41]">&lt;yanmaani&gt;</a></span><span class="message">rain1: There's archived copies of it etc</span></div><div class="line" id="170746"><span class="nick" style="color:#234e69"><a href="#170746" label="[17:07:46]">&lt;rain1&gt;</a></span><span class="message">asmc boots up and runs tcc</span></div><div class="line" id="170909"><span class="nick" style="color:#80b1d3"><a href="#170909" label="[17:09:09]">&lt;yanmaani&gt;</a></span><span class="message">is asmc a kernel?</span></div><div class="line" id="170924"><span class="nick" style="color:#234e69"><a href="#170924" label="[17:09:24]">&lt;rain1&gt;</a></span><span class="message"> <a rel="nofollow" href="https://gitlab.com/giomasce/asmc">https://gitlab.com/giomasce/asmc</a> </span></div><div class="line" id="171026"><span class="nick" style="color:#80b1d3"><a href="#171026" label="[17:10:26]">&lt;yanmaani&gt;</a></span><span class="message">oh yeah, that's pretty tiny as well</span></div><div class="line" id="183936"><span class="nick" style="color:#8dd3c7"><a href="#183936" label="[18:39:36]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: 1) the cc_* do not require a kernel as indicated by the knight bare metal version implementations. 2) M2-Planet does not require a kernel and can run on bare metal (there is an example main function that hard codes a tape input and tape output. Thus if there is a kernel in C that M2-Planet can build, we can bootstrap it without needing a kernel.</span></div><div class="line" id="184125"><span class="nick" style="color:#8dd3c7"><a href="#184125" label="[18:41:25]">&lt;OriansJ`&gt;</a></span><span class="message">the idea of making a version of TCC that can compile GCC directly and be buildable by M2-Planet was discussed and is the idea of the M3 work that is currently on hold. In short, because I am doing all of the work myself, I will do it however I wish and in the order I find fun.</span></div><div class="line" id="184225"><span class="nick" style="color:#80b1d3"><a href="#184225" label="[18:42:25]">&lt;yanmaani&gt;</a></span><span class="message">What'd need to be stripped out? Does TCC use function pointers and stuff?</span></div><div class="line" id="184243"><span class="nick" style="color:#234e69"><a href="#184243" label="[18:42:43]">&lt;rain1&gt;</a></span><span class="message">did anybody manage to build any libcs with tcc?</span></div><div class="line" id="184248"><span class="nick" style="color:#234e69"><a href="#184248" label="[18:42:48]">&lt;rain1&gt;</a></span><span class="message">i cant remember if musl eventually worked</span></div><div class="line" id="184249"><span class="nick" style="color:#80b1d3"><a href="#184249" label="[18:42:49]">&lt;yanmaani&gt;</a></span><span class="message">Technically you only need to be able to compile the full TCC. Or is there some goal of minimizing the bootstrap stages?</span></div><div class="line" id="184251"><span class="nick" style="color:#8dd3c7"><a href="#184251" label="[18:42:51]">&lt;OriansJ`&gt;</a></span><span class="message">M2-Planet supports function pointers</span></div><div class="line" id="184316"><span class="nick" style="color:#8dd3c7"><a href="#184316" label="[18:43:16]">&lt;OriansJ`&gt;</a></span><span class="message">If anyone else wants to pick up the work and write a proper cross-platform ELF linker in M2-Planet or a proper cross-plaform assembler that generates elf object files. It'll save me the effort.</span></div><div class="line" id="184353"><span class="nick" style="color:#80b1d3"><a href="#184353" label="[18:43:53]">&lt;yanmaani&gt;</a></span><span class="message">Do you need a &quot;real&quot; linker?</span></div><div class="line" id="184402"><span class="nick" style="color:#8dd3c7"><a href="#184402" label="[18:44:02]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: in short TCC's generation of direct binaries makes future porting work harder than required.</span></div><div class="line" id="184446"><span class="nick" style="color:#8dd3c7"><a href="#184446" label="[18:44:46]">&lt;OriansJ`&gt;</a></span><span class="message">So a linker and assembler good enough to cover MesCC's assembly expectations would be enough</span></div><div class="line" id="184557"><span class="nick" style="color:#8dd3c7"><a href="#184557" label="[18:45:57]">&lt;OriansJ`&gt;</a></span><span class="message">ideally compatible with binutils in a minimal way, so that MesCC can leverage binutils to speed up their cross platform porting and will make the GCC bootstrap easier too.</span></div><div class="line" id="184640"><span class="nick" style="color:#8dd3c7"><a href="#184640" label="[18:46:40]">&lt;OriansJ`&gt;</a></span><span class="message">I figure do it right, so that we can finish this once and for all.</span></div><div class="line" id="184819"><span class="nick" style="color:#8dd3c7"><a href="#184819" label="[18:48:19]">&lt;OriansJ`&gt;</a></span><span class="message">More often then not C language abuse (specifically macros) are the primary problem with getting M2-Planet compiling a program. As it supports unions, structs, arrays, if, else, do, while, for and even inline assembly.</span></div><div class="line" id="184909"><span class="nick" style="color:#80b1d3"><a href="#184909" label="[18:49:09]">&lt;yanmaani&gt;</a></span><span class="message">So your goal is to use M2-Planet to compile a linker?</span></div><div class="line" id="184927"><span class="nick" style="color:#8dd3c7"><a href="#184927" label="[18:49:27]">&lt;OriansJ`&gt;</a></span><span class="message">in fact M2-Planet is written in the M2-Planet C subset <a rel="nofollow" href="https://github.com/oriansj/M2-Planet/blob/master/cc_core.c">https://github.com/oriansj/M2-Planet/blob/master/cc_core.c</a> </span></div><div class="line" id="185012"><span class="nick" style="color:#8dd3c7"><a href="#185012" label="[18:50:12]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: my goal with M2-Planet is to build what is required to bootstrap GCC with the fewest of my years spent achieving that task.</span></div><div class="line" id="185047"><span class="nick" style="color:#8dd3c7"><a href="#185047" label="[18:50:47]">&lt;OriansJ`&gt;</a></span><span class="message">Be it via mes-m2+guix or M3 with people who are willing to do the work.</span></div><div class="line" id="185051"><span class="nick" style="color:#80b1d3"><a href="#185051" label="[18:50:51]">&lt;yanmaani&gt;</a></span><span class="message">So if tcc would have a separate linker and be buildable under m2-planet, that'd work?</span></div><div class="line" id="185127"><span class="nick" style="color:#8dd3c7"><a href="#185127" label="[18:51:27]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: if someone is willing to get TCC to be directly buildable under M2-Planet, that would also work</span></div><div class="line" id="185200"><span class="nick" style="color:#8dd3c7"><a href="#185200" label="[18:52:00]">&lt;OriansJ`&gt;</a></span><span class="message">we could do the seperate linker and assembler later when we need to figure out the porting to new platforms</span></div><div class="line" id="185249"><span class="nick" style="color:#80b1d3"><a href="#185249" label="[18:52:49]">&lt;yanmaani&gt;</a></span><span class="message">does m2-planet support all of C save for #define?</span></div><div class="line" id="185331"><span class="nick" style="color:#8dd3c7"><a href="#185331" label="[18:53:31]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: not all but it includes alot of the things you would need to build anything useful in bootstrapping software.</span></div><div class="line" id="185433"><span class="nick" style="color:#80b1d3"><a href="#185433" label="[18:54:33]">&lt;yanmaani&gt;</a></span><span class="message">But what would you need to change about tcc to make it build under m2p?</span></div><div class="line" id="185440"><span class="nick" style="color:#8dd3c7"><a href="#185440" label="[18:54:40]">&lt;OriansJ`&gt;</a></span><span class="message">and anything that it doesn't support but can be exampled in a reasonable test, I can add rather easily</span></div><div class="line" id="185550"><span class="nick" style="color:#8dd3c7"><a href="#185550" label="[18:55:50]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: honestly it looks like a bit of C abuse mostly; even mescc had to remove some of the insanity to compile it.</span></div><div class="line" id="185611"><span class="nick" style="color:#80b1d3"><a href="#185611" label="[18:56:11]">&lt;yanmaani&gt;</a></span><span class="message">What crazy stuff does tcc do?</span></div><div class="line" id="185717"><span class="nick" style="color:#8dd3c7"><a href="#185717" label="[18:57:17]">&lt;OriansJ`&gt;</a></span><span class="message">it is easier if you just look at its source code for a minute and then look at M2-planet's source code for a minute.</span></div><div class="line" id="185726"><span class="nick" style="color:#6b8072"><a href="#185726" label="[18:57:26]">&lt;xentrac&gt;</a></span><span class="message">heh</span></div><div class="line" id="185739"><span class="nick" style="color:#8dd3c7"><a href="#185739" label="[18:57:39]">&lt;OriansJ`&gt;</a></span><span class="message">or simply pass any of the files to M2-Planet and it will explicitly tell you</span></div><div class="line" id="185845"><span class="nick" style="color:#8dd3c7"><a href="#185845" label="[18:58:45]">&lt;OriansJ`&gt;</a></span><span class="message">hence why I have very little motivation to address the gaps in TCC at this exact momement and instead are dealing with the armv7l port of the bootstrap.</span></div><div class="line" id="185925"><span class="nick" style="color:#8dd3c7"><a href="#185925" label="[18:59:25]">&lt;OriansJ`&gt;</a></span><span class="message">it is just alot of work for little payoff. Yet no one else cares enough to even do the basic clearing work</span></div><div class="line" id="190025"><span class="nick" style="color:#8dd3c7"><a href="#190025" label="[19:00:25]">&lt;OriansJ`&gt;</a></span><span class="message">I already went through a similiar process trying to get mes.c buildable via M2-Planet.</span></div><div class="line" id="190050"><span class="nick" style="color:#8dd3c7"><a href="#190050" label="[19:00:50]">&lt;OriansJ`&gt;</a></span><span class="message">It took months just to get a single GCC command to compile the C source code</span></div><div class="line" id="190111"><span class="nick" style="color:#8dd3c7"><a href="#190111" label="[19:01:11]">&lt;OriansJ`&gt;</a></span><span class="message">and TCC is worse</span></div><div class="line" id="190112"><span class="nick" style="color:#6c3d55"><a href="#190112" label="[19:01:12]">&lt;janneke&gt;</a></span><span class="message">rain1: tcc can build the mes lib c :-P</span></div><div class="line" id="190127"><span class="nick" style="color:#234e69"><a href="#190127" label="[19:01:27]">&lt;rain1&gt;</a></span><span class="message">that is great!</span></div><div class="line" id="190212"><span class="nick" style="color:#6c3d55"><a href="#190212" label="[19:02:12]">&lt;janneke&gt;</a></span><span class="message">yeah, it's used in the guix reduced binary seed bootstrap</span></div><div class="line" id="190357"><span class="nick" style="color:#8dd3c7"><a href="#190357" label="[19:03:57]">&lt;OriansJ`&gt;</a></span><span class="message">I get bitched at for not having everything on savannah, yet I don't see anyone picking up even that task.</span></div><div class="line" id="190436"><span class="nick" style="color:#8dd3c7"><a href="#190436" label="[19:04:36]">&lt;OriansJ`&gt;</a></span><span class="message">Because I really look forward to the fight of getting actual binaries approved in savannah</span></div><div class="line" id="190444"><span class="nick" style="color:#8dd3c7"><a href="#190444" label="[19:04:44]">&lt;OriansJ`&gt;</a></span><span class="message">it'll be sooo fun</span></div><div class="line" id="190634"><span class="nick" style="color:#80b1d3"><a href="#190634" label="[19:06:34]">&lt;yanmaani&gt;</a></span><span class="message">&quot;try tape_01 and tape_02 instead&quot;</span></div><div class="line" id="190650"><span class="nick" style="color:#80b1d3"><a href="#190650" label="[19:06:50]">&lt;yanmaani&gt;</a></span><span class="message">what's this mean? ./m2-planet &lt; hello.c &gt; a.out doesn't seem to work</span></div><div class="line" id="191013"><span class="nick" style="color:#80b1d3"><a href="#191013" label="[19:10:13]">&lt;yanmaani&gt;</a></span><span class="message">oh, it's about main()</span></div><div class="line" id="192146"><span class="nick" style="color:#80b1d3"><a href="#192146" label="[19:21:46]">&lt;yanmaani&gt;</a></span><span class="message">For the linker, do you really need one?</span></div><div class="line" id="192227"><span class="nick" style="color:#80b1d3"><a href="#192227" label="[19:22:27]">&lt;yanmaani&gt;</a></span><span class="message">Can't you just use the preprocessor to concatenate all the files, ensure no symbols are globally duplicated, and compile?</span></div><div class="line" id="203700"><span class="nick" style="color:#d9d9d9"><a href="#203700" label="[20:37:00]">&lt;`Lion&gt;</a></span><span class="message">preprocessor?</span></div><div class="line" id="203703"><span class="nick" style="color:#d9d9d9"><a href="#203703" label="[20:37:03]">&lt;`Lion&gt;</a></span><span class="message">just use cat :)</span></div><div class="line" id="203720"><span class="nick" style="color:#d9d9d9"><a href="#203720" label="[20:37:20]">&lt;`Lion&gt;</a></span><span class="message">best linker ever</span></div><div class="line" id="204920"><span class="nick" style="color:#8dd3c7"><a href="#204920" label="[20:49:20]">&lt;OriansJ`&gt;</a></span><span class="message">yanmaani: the primary job of a linker is to resolve and fix references (hex2 does this just fine). The primary job of an assembler is turn human words into binary encodings (M1 does this just fine) and `Lion we have catm which unlike cat doesn't require a shell to produce useful files</span></div><div class="line" id="205755"><span class="nick" style="color:#80b1d3"><a href="#205755" label="[20:57:55]">&lt;yanmaani&gt;</a></span><span class="message">OriansJ`: Can't you just include the libc in each input source file?</span></div><div class="line" id="205847"><span class="nick" style="color:#8dd3c7"><a href="#205847" label="[20:58:47]">&lt;OriansJ`&gt;</a></span><span class="message">you didn't look at any of the M2-Planet tests did you?</span></div><div class="line" id="210003"><span class="nick" style="color:#8dd3c7"><a href="#210003" label="[21:00:03]">&lt;OriansJ`&gt;</a></span><span class="message">The reason for the new proper linker and assembler written in M2-Planet C; is so that one could do development in gnu assembler and be able to directly build that code without having to convert it into the constraints of mescc-tools</span></div><div class="line" id="234603"><span class="nick" style="color:#2e2a4a"><a href="#234603" label="[23:46:03]">&lt;fossy&gt;</a></span><span class="message">&lt;OriansJ`&gt; the idea of making a version of TCC that can compile GCC directly and be buildable by M2-Planet was discussed and is the idea of the M3 work that is currently on hold. In short, because I am doing all of the work myself, I will do it however I wish and in the order I find fun.</span></div><div class="line" id="234612"><span class="nick" style="color:#2e2a4a"><a href="#234612" label="[23:46:12]">&lt;fossy&gt;</a></span><span class="message">this is completely fair btw</span></div><div class="line" id="235049"><span class="nick" style="color:#2e2a4a"><a href="#235049" label="[23:50:49]">&lt;fossy&gt;</a></span><span class="message">there's no point doing this if we dont find what we are doing interesting, we wont be interested in maintaining it</span></div><br /></div></body></html>