<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2021-04-23.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000733"><span class="nick" style="color:#389600"><a href="#000733" label="[00:07:33]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: if bash is doing CD before mkdir finishes and cmp before echo &gt; file completes; a delay might not work as the cd command is just a naked call to sys_chdir and mkdir is just a naked call to sys_mkdir; sync would atleast force a consistent file system state prior to the cmp or cd</span></div><div class="line" id="000935"><span class="nick" style="color:#389600"><a href="#000935" label="[00:09:35]">&lt;OriansJ&gt;</a></span><span class="message">we are talking about 6-8 instructions to do a mkdir syscall here and then another 6-8 instructions for the cd</span></div><div class="line" id="001040"><span class="nick" style="color:#8dd3c7"><a href="#001040" label="[00:10:40]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: you're right if the machine reboots in between the two commands</span></div><div class="line" id="001041"><span class="nick" style="color:#8dd3c7"><a href="#001041" label="[00:10:41]">&lt;xentrac&gt;</a></span><span class="message">otherwise no</span></div><div class="line" id="001307"><span class="nick" style="color:#389600"><a href="#001307" label="[00:13:07]">&lt;OriansJ&gt;</a></span><span class="message">I don't see how from the perspective of the kernel such an error can occur unless the sys_chdir syscall arrives before the sys_mkdir syscall does</span></div><div class="line" id="001629"><span class="nick" style="color:#389600"><a href="#001629" label="[00:16:29]">&lt;OriansJ&gt;</a></span><span class="message">and on a single cpu system where sys_exit has to be called prior to the shell being informed of a process terminating to execute the next command;</span></div><div class="line" id="001838"><span class="nick" style="color:#389600"><a href="#001838" label="[00:18:38]">&lt;OriansJ&gt;</a></span><span class="message">because wait is being used in bash to ensure it doesn't execute the next command unti lthe first is finished. unless bash special cases builtins and executes them without waiting for the result of a sys_wait to indicate process completion.</span></div><div class="line" id="002015"><span class="nick" style="color:#389600"><a href="#002015" label="[00:20:15]">&lt;OriansJ&gt;</a></span><span class="message">\</span></div><div class="line" id="002208"><span class="nick" style="color:#389600"><a href="#002208" label="[00:22:08]">&lt;OriansJ&gt;</a></span><span class="message">look I might be wrong here but I would like to understand how I am wrong so that we can prove that I am wrong and improve my understanding</span></div><div class="line" id="002442"><span class="nick" style="color:#389600"><a href="#002442" label="[00:24:42]">&lt;OriansJ&gt;</a></span><span class="message">hence why I am explaining my understanding so that it be tested and revised where wrong.</span></div><div class="line" id="002702"><span class="nick" style="color:#389600"><a href="#002702" label="[00:27:02]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: to your question sync is a trivial program, you just call void sync(void); from #include &lt;unistd.h&gt; or in x86 assembly put 36 in eax and do int 0x80</span></div><div class="line" id="003229"><span class="nick" style="color:#389600"><a href="#003229" label="[00:32:29]">&lt;OriansJ&gt;</a></span><span class="message">or I could write a program that does mkdir followed by chdir and if the chdir fails but the mkdir succeeds, we might have a filesystem bug that sync inserted between the two would force correct behavior.</span></div><div class="line" id="004321"><span class="nick" style="color:#8dd3c7"><a href="#004321" label="[00:43:21]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: agreed</span></div><div class="line" id="004351"><span class="nick" style="color:#8dd3c7"><a href="#004351" label="[00:43:51]">&lt;xentrac&gt;</a></span><span class="message">I think bash does special-case builtins but not in a way that should cause the cd to ever fail</span></div><div class="line" id="004353"><span class="nick" style="color:#389600"><a href="#004353" label="[00:43:53]">&lt;OriansJ&gt;</a></span><span class="message">now there is a second possibility I can imagine for mkdir and chdir failing and that the mkdir program is buggy and received -1 from sys_mkdir and still returned success or the libc always returns zero regardless of what sys_mkdir returns.</span></div><div class="line" id="004428"><span class="nick" style="color:#389600"><a href="#004428" label="[00:44:28]">&lt;OriansJ&gt;</a></span><span class="message">both of those should be very easy to spot in the source code</span></div><div class="line" id="004431"><span class="nick" style="color:#8dd3c7"><a href="#004431" label="[00:44:31]">&lt;xentrac&gt;</a></span><span class="message">ooh, I hadn't thought of that</span></div><div class="line" id="004440"><span class="nick" style="color:#389600"><a href="#004440" label="[00:44:40]">&lt;OriansJ&gt;</a></span><span class="message">just a simple grep -R mkdir should be enough to find it</span></div><div class="line" id="004458"><span class="nick" style="color:#8dd3c7"><a href="#004458" label="[00:44:58]">&lt;xentrac&gt;</a></span><span class="message">if you can get the error to reproduce under strace -ff it should also be easy to see what went wrong</span></div><div class="line" id="004613"><span class="nick" style="color:#389600"><a href="#004613" label="[00:46:13]">&lt;OriansJ&gt;</a></span><span class="message">but looking at meslibc's lib/linux/mkdir.c that isn't the case and in musl I doubt they would have made such an obvious bug</span></div><div class="line" id="004645"><span class="nick" style="color:#389600"><a href="#004645" label="[00:46:45]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: one would either have to bootstrap strace or include a static version of it to use</span></div><div class="line" id="004715"><span class="nick" style="color:#8dd3c7"><a href="#004715" label="[00:47:15]">&lt;xentrac&gt;</a></span><span class="message">you could run the bootstrap build process on a machine that already has working Linux?</span></div><div class="line" id="004742"><span class="nick" style="color:#389600"><a href="#004742" label="[00:47:42]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well live-bootstrap requires you to provide a working posix kernel</span></div><div class="line" id="004800"><span class="nick" style="color:#389600"><a href="#004800" label="[00:48:00]">&lt;OriansJ&gt;</a></span><span class="message">but outside that the only binaries are those in my bootstrap-seeds</span></div><div class="line" id="004819"><span class="nick" style="color:#389600"><a href="#004819" label="[00:48:19]">&lt;OriansJ&gt;</a></span><span class="message">everything else is built from source</span></div><div class="line" id="004822"><span class="nick" style="color:#8dd3c7"><a href="#004822" label="[00:48:22]">&lt;xentrac&gt;</a></span><span class="message">I know</span></div><div class="line" id="004834"><span class="nick" style="color:#389600"><a href="#004834" label="[00:48:34]">&lt;OriansJ&gt;</a></span><span class="message">and checksum'd for sanity checking along the way</span></div><div class="line" id="004839"><span class="nick" style="color:#8dd3c7"><a href="#004839" label="[00:48:39]">&lt;xentrac&gt;</a></span><span class="message">I didn't mean you could require people to run it on a machine that already has a working userland</span></div><div class="line" id="004857"><span class="nick" style="color:#8dd3c7"><a href="#004857" label="[00:48:57]">&lt;xentrac&gt;</a></span><span class="message">I meant that in order to track down a bug in it, you could run it on a machine that already has a working userland</span></div><div class="line" id="004921"><span class="nick" style="color:#389600"><a href="#004921" label="[00:49:21]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: fair</span></div><div class="line" id="004924"><span class="nick" style="color:#8dd3c7"><a href="#004924" label="[00:49:24]">&lt;xentrac&gt;</a></span><span class="message">much as one might run it under qemu, for example</span></div><div class="line" id="005138"><span class="nick" style="color:#389600"><a href="#005138" label="[00:51:38]">&lt;OriansJ&gt;</a></span><span class="message">and showing up 0.5% of the time under a qemu environment that is checksumed and known exactly seems more like a zebra type bug than a horse type bug</span></div><div class="line" id="005257"><span class="nick" style="color:#389600"><a href="#005257" label="[00:52:57]">&lt;OriansJ&gt;</a></span><span class="message">Because the runs should be 100% identical; heck the only thing that might be different is the time</span></div><div class="line" id="005349"><span class="nick" style="color:#8dd3c7"><a href="#005349" label="[00:53:49]">&lt;xentrac&gt;</a></span><span class="message">yeah, clearly something is behaving nondeterministically, and concurrency bugs are the most likely zebra there</span></div><div class="line" id="005420"><span class="nick" style="color:#389600"><a href="#005420" label="[00:54:20]">&lt;OriansJ&gt;</a></span><span class="message">but we could eliminate that possibility with: -rtc &quot;2006-06-17T16:01:21&quot; or something consistent</span></div><div class="line" id="005447"><span class="nick" style="color:#389600"><a href="#005447" label="[00:54:47]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: how does one have concurrency bugs in a single core vm?</span></div><div class="line" id="005503"><span class="nick" style="color:#8dd3c7"><a href="#005503" label="[00:55:03]">&lt;xentrac&gt;</a></span><span class="message">context switching on interrupts</span></div><div class="line" id="005545"><span class="nick" style="color:#389600"><a href="#005545" label="[00:55:45]">&lt;OriansJ&gt;</a></span><span class="message">The only interrupts would be from the disk writing data and the clock as no network or user input is involved.</span></div><div class="line" id="005553"><span class="nick" style="color:#8dd3c7"><a href="#005553" label="[00:55:53]">&lt;xentrac&gt;</a></span><span class="message">yeah</span></div><div class="line" id="005618"><span class="nick" style="color:#8dd3c7"><a href="#005618" label="[00:56:18]">&lt;xentrac&gt;</a></span><span class="message">even if you set the clock starting time to something fixed, I think the clock interrupts in qemu are based on real wallclock time (so you can play games) and not VM time</span></div><div class="line" id="005653"><span class="nick" style="color:#8dd3c7"><a href="#005653" label="[00:56:53]">&lt;xentrac&gt;</a></span><span class="message">normally Linux arranges for the clock to interrupt it 100 times a second, 4096 in recent kernels</span></div><div class="line" id="005718"><span class="nick" style="color:#389600"><a href="#005718" label="[00:57:18]">&lt;OriansJ&gt;</a></span><span class="message">we could tune that down to 1 per second</span></div><div class="line" id="005837"><span class="nick" style="color:#8dd3c7"><a href="#005837" label="[00:58:37]">&lt;xentrac&gt;</a></span><span class="message">that would increase the fraction of such nondeterministic bugs that go undetected for months or years, I suppose</span></div><div class="line" id="005845"><span class="nick" style="color:#8dd3c7"><a href="#005845" label="[00:58:45]">&lt;xentrac&gt;</a></span><span class="message">and make them harder to debug</span></div><div class="line" id="005954"><span class="nick" style="color:#389600"><a href="#005954" label="[00:59:54]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: depends if our goal is to find and fix kernel bugs or avoid them to a level that the odds of someone building live-bootstrap hitting them is effectively zero</span></div><div class="line" id="010252"><span class="nick" style="color:#389600"><a href="#010252" label="[01:02:52]">&lt;OriansJ&gt;</a></span><span class="message">because we are probably going to do a bootstrap kernel in the future and that is what live-bootstrap will run on until it is able to properly bootstrap an exact version of Linux.</span></div><div class="line" id="010525"><span class="nick" style="color:#8dd3c7"><a href="#010525" label="[01:05:25]">&lt;xentrac&gt;</a></span><span class="message">ultimately we should replace Linux with a kernel small enough to be hand-auditable, but I don't have one in my shirt pocket at the moment</span></div><div class="line" id="010554"><span class="nick" style="color:#389600"><a href="#010554" label="[01:05:54]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well fortunately we have bauen1 here to help us with that.</span></div><div class="line" id="010600"><span class="nick" style="color:#8dd3c7"><a href="#010600" label="[01:06:00]">&lt;xentrac&gt;</a></span><span class="message">yay bauen1</span></div><div class="line" id="010611"><span class="nick" style="color:#8dd3c7"><a href="#010611" label="[01:06:11]">&lt;xentrac&gt;</a></span><span class="message">I did learn something vaguely relevant this weekend</span></div><div class="line" id="010626"><span class="nick" style="color:#389600"><a href="#010626" label="[01:06:26]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: care to share with the rest of the class?</span></div><div class="line" id="010640"><span class="nick" style="color:#8dd3c7"><a href="#010640" label="[01:06:40]">&lt;xentrac&gt;</a></span><span class="message">JLCPCB has a newish PCB assembly service</span></div><div class="line" id="010655"><span class="nick" style="color:#8dd3c7"><a href="#010655" label="[01:06:55]">&lt;xentrac&gt;</a></span><span class="message">traditionally PCB assembly outsourcing takes six weeks and US$500</span></div><div class="line" id="010740"><span class="nick" style="color:#8dd3c7"><a href="#010740" label="[01:07:40]">&lt;xentrac&gt;</a></span><span class="message">but lots of people have reported JLCPCB's service takes 1½–2 weeks and they've gotten boards for under US$100</span></div><div class="line" id="010832"><span class="nick" style="color:#389600"><a href="#010832" label="[01:08:32]">&lt;OriansJ&gt;</a></span><span class="message">looks like they have a special off out too <a rel="nofollow" href="https://support.jlcpcb.com/article/146-2-for-1-4-layer-pcbs">https://support.jlcpcb.com/article/146-2-for-1-4-layer-pcbs</a> </span></div><div class="line" id="010918"><span class="nick" style="color:#8dd3c7"><a href="#010918" label="[01:09:18]">&lt;xentrac&gt;</a></span><span class="message">I scoped out the limits and the &quot;basic&quot; parts list and it looks like a CPU built out of discrete logic (74HC14s, 74HC08s, CD4051s, 74HC573s, and so on) should be doable for under US$50, conceivably even under US$25</span></div><div class="line" id="010934"><span class="nick" style="color:#389600"><a href="#010934" label="[01:09:34]">&lt;OriansJ&gt;</a></span><span class="message">nice</span></div><div class="line" id="010940"><span class="nick" style="color:#8dd3c7"><a href="#010940" label="[01:09:40]">&lt;xentrac&gt;</a></span><span class="message">and maybe be 100 mm × 100 mm</span></div><div class="line" id="010957"><span class="nick" style="color:#8dd3c7"><a href="#010957" label="[01:09:57]">&lt;xentrac&gt;</a></span><span class="message">like, a 16-bit CPU</span></div><div class="line" id="011109"><span class="nick" style="color:#8dd3c7"><a href="#011109" label="[01:11:09]">&lt;xentrac&gt;</a></span><span class="message">you still have the problem of how to audit your memory hardware, and it would be pretty hard to detect if they replaced one of your 74HC14s with an FPGA programmed to emulate a 74HC14, but that seems like an unlikely threat at the moment</span></div><div class="line" id="011121"><span class="nick" style="color:#8dd3c7"><a href="#011121" label="[01:11:21]">&lt;xentrac&gt;</a></span><span class="message">so it'd be a significant step in the direction of full auditability</span></div><div class="line" id="011301"><span class="nick" style="color:#389600"><a href="#011301" label="[01:13:01]">&lt;OriansJ&gt;</a></span><span class="message">agreed</span></div><div class="line" id="011315"><span class="nick" style="color:#8dd3c7"><a href="#011315" label="[01:13:15]">&lt;xentrac&gt;</a></span><span class="message">I have a version of Meta5ix recompiling itself to C in about 1.2 million instructions, which is fast enough to be practical on even a sub-MIPS 16-bit processor; I haven't yet gotten it to compile itself to amd64 assembly, let alone an assembly language for a 16-bit machine</span></div><div class="line" id="011339"><span class="nick" style="color:#8dd3c7"><a href="#011339" label="[01:13:39]">&lt;xentrac&gt;</a></span><span class="message"> <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/meta5ix2c.m5">http://canonical.org/~kragen/sw/dev3/meta5ix2c.m5</a> </span></div><div class="line" id="011359"><span class="nick" style="color:#8dd3c7"><a href="#011359" label="[01:13:59]">&lt;xentrac&gt;</a></span><span class="message">and I think I can probably beat that by a factor of 3 to 5</span></div><div class="line" id="011447"><span class="nick" style="color:#8dd3c7"><a href="#011447" label="[01:14:47]">&lt;xentrac&gt;</a></span><span class="message">(speeding up a C program 3× by rewriting it in assembly is unusual, but interpreters are a special case)</span></div><div class="line" id="011514"><span class="nick" style="color:#8dd3c7"><a href="#011514" label="[01:15:14]">&lt;xentrac&gt;</a></span><span class="message">I hadn't mentioned any of this stuff here because it's at best tangentially relevant to live-bootstrap and not very finished yet</span></div><div class="line" id="011517"><span class="nick" style="color:#389600"><a href="#011517" label="[01:15:17]">&lt;OriansJ&gt;</a></span><span class="message">well I am interested in the idea</span></div><div class="line" id="011702"><span class="nick" style="color:#389600"><a href="#011702" label="[01:17:02]">&lt;OriansJ&gt;</a></span><span class="message">and I do have some funds for my future hardware work available to help someone else do the work</span></div><div class="line" id="011959"><span class="nick" style="color:#389600"><a href="#011959" label="[01:19:59]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: bootstrapping hardware is the last stage of bootstrapping work anyone will ever have to do.</span></div><div class="line" id="012031"><span class="nick" style="color:#389600"><a href="#012031" label="[01:20:31]">&lt;OriansJ&gt;</a></span><span class="message">So it is fair game to discussion and sharing</span></div><div class="line" id="012221"><span class="nick" style="color:#389600"><a href="#012221" label="[01:22:21]">&lt;OriansJ&gt;</a></span><span class="message">although hardware by itself isn't useful without software and I would wish to encourage CPU ISAs that are human writable/readable; even if it means a few extra chips</span></div><div class="line" id="012231"><span class="nick" style="color:#389600"><a href="#012231" label="[01:22:31]">&lt;OriansJ&gt;</a></span><span class="message">or less instruction density.</span></div><div class="line" id="012422"><span class="nick" style="color:#389600"><a href="#012422" label="[01:24:22]">&lt;OriansJ&gt;</a></span><span class="message">because I refuse to write cc_oisc in oisc assembly</span></div><div class="line" id="012429"><span class="nick" style="color:#8dd3c7"><a href="#012429" label="[01:24:29]">&lt;xentrac&gt;</a></span><span class="message">haha</span></div><div class="line" id="012446"><span class="nick" style="color:#389600"><a href="#012446" label="[01:24:46]">&lt;OriansJ&gt;</a></span><span class="message">or cc_brainfuck in brainfukck</span></div><div class="line" id="012446"><span class="nick" style="color:#8dd3c7"><a href="#012446" label="[01:24:46]">&lt;xentrac&gt;</a></span><span class="message">yes, and I recall you had a few choice words for the RISC-V instruction formats as well :)</span></div><div class="line" id="012645"><span class="nick" style="color:#389600"><a href="#012645" label="[01:26:45]">&lt;OriansJ&gt;</a></span><span class="message">in a sane architecture doing load R0 0x1 and load R0 0x2 shouldn't require 2 different M1 DEFINE statements unless those statements are DEFINE load ... and DEFINE R0 ..</span></div><div class="line" id="012857"><span class="nick" style="color:#389600"><a href="#012857" label="[01:28:57]">&lt;OriansJ&gt;</a></span><span class="message">heck look at x86 only int 0x80 is the only DEFINE needed for syscalls and the same for AMD64, armv7l and knight-posix</span></div><div class="line" id="012931"><span class="nick" style="color:#389600"><a href="#012931" label="[01:29:31]">&lt;OriansJ&gt;</a></span><span class="message">but AArch64 and RISC-V nope a seperate DEFINE for each and EVERY single syscall supported.</span></div><div class="line" id="013032"><span class="nick" style="color:#389600"><a href="#013032" label="[01:30:32]">&lt;OriansJ&gt;</a></span><span class="message">it delayed the untar.c work in M2libc</span></div><div class="line" id="013158"><span class="nick" style="color:#389600"><a href="#013158" label="[01:31:58]">&lt;OriansJ&gt;</a></span><span class="message">because of instead of doing something sane like LOAD R8 !0x12 or LOAD R8 @0x12 or LOAD R8 %0x12; I had to write a brand new define and validate the hex encoding</span></div><div class="line" id="013356"><span class="nick" style="color:#8dd3c7"><a href="#013356" label="[01:33:56]">&lt;xentrac&gt;</a></span><span class="message">I learned last week that the versions of strace and valgrind I was using don't support int $0x80 on amd64</span></div><div class="line" id="013404"><span class="nick" style="color:#8dd3c7"><a href="#013404" label="[01:34:04]">&lt;xentrac&gt;</a></span><span class="message">I switched to using the syscall instruction</span></div><div class="line" id="013440"><span class="nick" style="color:#8dd3c7"><a href="#013440" label="[01:34:40]">&lt;xentrac&gt;</a></span><span class="message">also all the system call numbers are different</span></div><div class="line" id="013505"><span class="nick" style="color:#8dd3c7"><a href="#013505" label="[01:35:05]">&lt;xentrac&gt;</a></span><span class="message">no idea why</span></div><div class="line" id="015813"><span class="nick" style="color:#389600"><a href="#015813" label="[01:58:13]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: because int 0x80 isn't an amd64 syscall but an x86 syscall</span></div><div class="line" id="015918"><span class="nick" style="color:#389600"><a href="#015918" label="[01:59:18]">&lt;OriansJ&gt;</a></span><span class="message">and the AMD64 abi and the x86 abi have different numbers for the syscalls because the AMD engineers profiled the most frequent syscalls and ordered them for AMD64</span></div><div class="line" id="020023"><span class="nick" style="color:#389600"><a href="#020023" label="[02:00:23]">&lt;OriansJ&gt;</a></span><span class="message">hence 60 | sys_exit instead of 1 | sys_exit</span></div><div class="line" id="020037"><span class="nick" style="color:#389600"><a href="#020037" label="[02:00:37]">&lt;OriansJ&gt;</a></span><span class="message">the x86 syscalls are numbered in the order Linus implemented them</span></div><div class="line" id="020256"><span class="nick" style="color:#8dd3c7"><a href="#020256" label="[02:02:56]">&lt;xentrac&gt;</a></span><span class="message">oh, is that why they're in that order?  why is it beneficial to put more frequent ones first?</span></div><div class="line" id="020329"><span class="nick" style="color:#8dd3c7"><a href="#020329" label="[02:03:29]">&lt;xentrac&gt;</a></span><span class="message">amd64 Linux does support the int $0x80 system calls though, and with the i386 system call numbers</span></div><div class="line" id="020341"><span class="nick" style="color:#8dd3c7"><a href="#020341" label="[02:03:41]">&lt;xentrac&gt;</a></span><span class="message">but (at least this version of) valgrind and strace don't</span></div><div class="line" id="020541"><span class="nick" style="color:#8dd3c7"><a href="#020541" label="[02:05:41]">&lt;xentrac&gt;</a></span><span class="message">(even for 64-bit executables)</span></div><div class="line" id="020556"><span class="nick" style="color:#8dd3c7"><a href="#020556" label="[02:05:56]">&lt;xentrac&gt;</a></span><span class="message">actually strace *does* support them for i386 executables</span></div><div class="line" id="021802"><span class="nick" style="color:#389600"><a href="#021802" label="[02:18:02]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well mov eax !0x7F takes 2 bytes but mov eax @0x80 takes 3 and mov eax %0x8000 takes 5</span></div><div class="line" id="021941"><span class="nick" style="color:#389600"><a href="#021941" label="[02:19:41]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: I believe the int 0x80 behavior is only if LEGACY MODE is enabled; which was designed to run 32bit x86 binaries.</span></div><div class="line" id="022145"><span class="nick" style="color:#389600"><a href="#022145" label="[02:21:45]">&lt;OriansJ&gt;</a></span><span class="message">hence why the register mapping for arguments corresponds with the x86 registers and not the amd64 registers which are different (%rdi | %rsi | %rdx | %r10 vs %ebx | %ecx | %edx | %esi)</span></div><div class="line" id="022234"><span class="nick" style="color:#8dd3c7"><a href="#022234" label="[02:22:34]">&lt;xentrac&gt;</a></span><span class="message">yeah, I ran into that too, that was annoying as hell</span></div><div class="line" id="022256"><span class="nick" style="color:#389600"><a href="#022256" label="[02:22:56]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: but it makes perfect sense if the goal is running legacy binaries</span></div><div class="line" id="022312"><span class="nick" style="color:#389600"><a href="#022312" label="[02:23:12]">&lt;OriansJ&gt;</a></span><span class="message">and not for new binaries</span></div><div class="line" id="022312"><span class="nick" style="color:#8dd3c7"><a href="#022312" label="[02:23:12]">&lt;xentrac&gt;</a></span><span class="message">legacy binaries can't run in 64-bit mode though</span></div><div class="line" id="022344"><span class="nick" style="color:#8dd3c7"><a href="#022344" label="[02:23:44]">&lt;xentrac&gt;</a></span><span class="message">this was a 64-bit binary</span></div><div class="line" id="022356"><span class="nick" style="color:#8dd3c7"><a href="#022356" label="[02:23:56]">&lt;xentrac&gt;</a></span><span class="message">like I said strace and valgrind work fine for i386 binaries on amd64</span></div><div class="line" id="022401"><span class="nick" style="color:#389600"><a href="#022401" label="[02:24:01]">&lt;OriansJ&gt;</a></span><span class="message">you really shouldn't ever use int with 64bit binaries</span></div><div class="line" id="022403"><span class="nick" style="color:#8dd3c7"><a href="#022403" label="[02:24:03]">&lt;xentrac&gt;</a></span><span class="message">or for amd64 binaries using syscall</span></div><div class="line" id="022418"><span class="nick" style="color:#8dd3c7"><a href="#022418" label="[02:24:18]">&lt;xentrac&gt;</a></span><span class="message">yes, strace agrees with you about that</span></div><div class="line" id="022422"><span class="nick" style="color:#8dd3c7"><a href="#022422" label="[02:24:22]">&lt;xentrac&gt;</a></span><span class="message">it was really very unhappy with me</span></div><div class="line" id="022443"><span class="nick" style="color:#8dd3c7"><a href="#022443" label="[02:24:43]">&lt;xentrac&gt;</a></span><span class="message">IIRC valgrind dumped core</span></div><div class="line" id="022448"><span class="nick" style="color:#389600"><a href="#022448" label="[02:24:48]">&lt;OriansJ&gt;</a></span><span class="message">well normal compilation paths should never produce such monsters</span></div><div class="line" id="022512"><span class="nick" style="color:#8dd3c7"><a href="#022512" label="[02:25:12]">&lt;xentrac&gt;</a></span><span class="message">indeed not, yet the kernel supports it</span></div><div class="line" id="022533"><span class="nick" style="color:#8dd3c7"><a href="#022533" label="[02:25:33]">&lt;xentrac&gt;</a></span><span class="message">I guess if they're going to reorder the system call numbers anyway, they might as well reorder *all* of them, not just the ones that move across the 127-128 boundary</span></div><div class="line" id="022538"><span class="nick" style="color:#389600"><a href="#022538" label="[02:25:38]">&lt;OriansJ&gt;</a></span><span class="message">even the kernel devs don't consider that a supported</span></div><div class="line" id="022612"><span class="nick" style="color:#389600"><a href="#022612" label="[02:26:12]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well they did reorder all of them based on the same set they worked with</span></div><div class="line" id="022616"><span class="nick" style="color:#8dd3c7"><a href="#022616" label="[02:26:16]">&lt;xentrac&gt;</a></span><span class="message">right</span></div><div class="line" id="022648"><span class="nick" style="color:#8dd3c7"><a href="#022648" label="[02:26:48]">&lt;xentrac&gt;</a></span><span class="message">I was thinking &quot;okay fine so we don't want uncommon syscalls to be above 127, but what's the benefit in moving exit from 1 to 60?&quot; and that was my answer</span></div><div class="line" id="022718"><span class="nick" style="color:#8dd3c7"><a href="#022718" label="[02:27:18]">&lt;xentrac&gt;</a></span><span class="message">does int $0x80 work in amd64 binaries on current Linux?  they did eventually remove extfs and a.out support</span></div><div class="line" id="022813"><span class="nick" style="color:#389600"><a href="#022813" label="[02:28:13]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well on hardened builds, hasn't worked for years.</span></div><div class="line" id="022925"><span class="nick" style="color:#389600"><a href="#022925" label="[02:29:25]">&lt;OriansJ&gt;</a></span><span class="message">but on vanilla linux, not certain; it isn't a maintained code path</span></div><div class="line" id="022931"><span class="nick" style="color:#8dd3c7"><a href="#022931" label="[02:29:31]">&lt;xentrac&gt;</a></span><span class="message">yeah</span></div><div class="line" id="022944"><span class="nick" style="color:#8dd3c7"><a href="#022944" label="[02:29:44]">&lt;xentrac&gt;</a></span><span class="message">I think when they removed extfs it hadn't been a maintained code path for 20 years</span></div><div class="line" id="022956"><span class="nick" style="color:#8dd3c7"><a href="#022956" label="[02:29:56]">&lt;xentrac&gt;</a></span><span class="message">but probably the timeline for that kind of thing is going to shorten</span></div><div class="line" id="023028"><span class="nick" style="color:#389600"><a href="#023028" label="[02:30:28]">&lt;OriansJ&gt;</a></span><span class="message">depends if there is an in the wild exploit in that code path</span></div><div class="line" id="023041"><span class="nick" style="color:#389600"><a href="#023041" label="[02:30:41]">&lt;OriansJ&gt;</a></span><span class="message">then it can be broken real quick</span></div><div class="line" id="023048"><span class="nick" style="color:#389600"><a href="#023048" label="[02:30:48]">&lt;OriansJ&gt;</a></span><span class="message">with no one noticing</span></div><div class="line" id="023106"><span class="nick" style="color:#389600"><a href="#023106" label="[02:31:06]">&lt;OriansJ&gt;</a></span><span class="message">except maybe you and other people who do crazy things with their compilers</span></div><div class="line" id="023306"><span class="nick" style="color:#389600"><a href="#023306" label="[02:33:06]">&lt;OriansJ&gt;</a></span><span class="message">heck Linux broke ELF segment loading back in the 4.x series; which forced janneke and I to change how we wrote hex2 elf headers</span></div><div class="line" id="023407"><span class="nick" style="color:#389600"><a href="#023407" label="[02:34:07]">&lt;OriansJ&gt;</a></span><span class="message">it wasn't a news story or anyone else really care; because it turned out we were abusing the ELF spec too much and the day came that the code path was simply *FIXED*</span></div><div class="line" id="023631"><span class="nick" style="color:#8dd3c7"><a href="#023631" label="[02:36:31]">&lt;xentrac&gt;</a></span><span class="message">what was the problem?</span></div><div class="line" id="023747"><span class="nick" style="color:#8dd3c7"><a href="#023747" label="[02:37:47]">&lt;xentrac&gt;</a></span><span class="message">I ran into a thing in stoneknifeforth where I was compiling executables with a load address of 0x1000</span></div><div class="line" id="023811"><span class="nick" style="color:#8dd3c7"><a href="#023811" label="[02:38:11]">&lt;xentrac&gt;</a></span><span class="message">and then at some point Linux changed vm.mmap_min_addr to 0x10000 by default</span></div><div class="line" id="023817"><span class="nick" style="color:#389600"><a href="#023817" label="[02:38:17]">&lt;OriansJ&gt;</a></span><span class="message">The binaries would segfault on load</span></div><div class="line" id="023838"><span class="nick" style="color:#8dd3c7"><a href="#023838" label="[02:38:38]">&lt;xentrac&gt;</a></span><span class="message">I mean, what was the etiology, not the symptom?</span></div><div class="line" id="023909"><span class="nick" style="color:#8dd3c7"><a href="#023909" label="[02:39:09]">&lt;xentrac&gt;</a></span><span class="message">tekknolagi ran into the problem in his fork of SKF and fixed it</span></div><div class="line" id="023956"><span class="nick" style="color:#8dd3c7"><a href="#023956" label="[02:39:56]">&lt;xentrac&gt;</a></span><span class="message">rumor has it that 0x8048000 comes from Xenix</span></div><div class="line" id="024110"><span class="nick" style="color:#389600"><a href="#024110" label="[02:41:10]">&lt;OriansJ&gt;</a></span><span class="message">if I remember correctly we loaded the same segement as read-only+execute-only and read/write and it applied both to become read/write/execute and then linux updated and it just became read/write and couldn't execute -&gt; BOOM</span></div><div class="line" id="024210"><span class="nick" style="color:#8dd3c7"><a href="#024210" label="[02:42:10]">&lt;xentrac&gt;</a></span><span class="message">oh, that makes some sense, yeah</span></div><div class="line" id="024239"><span class="nick" style="color:#389600"><a href="#024239" label="[02:42:39]">&lt;OriansJ&gt;</a></span><span class="message">well all the bugs when you look at them make perfect sense in the bootstrap</span></div><div class="line" id="024244"><span class="nick" style="color:#8dd3c7"><a href="#024244" label="[02:42:44]">&lt;xentrac&gt;</a></span><span class="message">although httpdito gets Linux to map the same page of the executable as RX and RW successfully.  it's just that they're two separate mappings</span></div><div class="line" id="024307"><span class="nick" style="color:#8dd3c7"><a href="#024307" label="[02:43:07]">&lt;xentrac&gt;</a></span><span class="message">I think StoneKnifeForth may actually do the same thing</span></div><div class="line" id="024325"><span class="nick" style="color:#389600"><a href="#024325" label="[02:43:25]">&lt;OriansJ&gt;</a></span><span class="message">readelf -a foo produced garbage because blood-elf wasn't doing things wrong but when we fixed blood-elf readelf -a foo suddenly zero errors</span></div><div class="line" id="024414"><span class="nick" style="color:#389600"><a href="#024414" label="[02:44:14]">&lt;OriansJ&gt;</a></span><span class="message">^wrong^right^</span></div><div class="line" id="024457"><span class="nick" style="color:#389600"><a href="#024457" label="[02:44:57]">&lt;OriansJ&gt;</a></span><span class="message">So abuses of interfaces and ABIs might work for a while but in the end; it will blow up in our faces.</span></div><div class="line" id="024537"><span class="nick" style="color:#389600"><a href="#024537" label="[02:45:37]">&lt;OriansJ&gt;</a></span><span class="message">hence why I've gotten more strict about doing things the proper way, even if it means more code or work.</span></div><div class="line" id="024702"><span class="nick" style="color:#8dd3c7"><a href="#024702" label="[02:47:02]">&lt;xentrac&gt;</a></span><span class="message">oh, yeah, I agree that doing things the proper way — and even the mainstream way — is often safer</span></div><div class="line" id="024721"><span class="nick" style="color:#8dd3c7"><a href="#024721" label="[02:47:21]">&lt;xentrac&gt;</a></span><span class="message">I think 0x1000 was a legal load address too</span></div><div class="line" id="024901"><span class="nick" style="color:#8dd3c7"><a href="#024901" label="[02:49:01]">&lt;xentrac&gt;</a></span><span class="message">hmm actually SKF is mapping a single RWE segment too.  readelf -a has no trouble with it, but objdump silently fails</span></div><div class="line" id="024940"><span class="nick" style="color:#8dd3c7"><a href="#024940" label="[02:49:40]">&lt;xentrac&gt;</a></span><span class="message">httpdito, however, loads two segments, one &quot;R E&quot; and one &quot;RW&quot;</span></div><div class="line" id="025129"><span class="nick" style="color:#8dd3c7"><a href="#025129" label="[02:51:29]">&lt;xentrac&gt;</a></span><span class="message">they are of course in the same page because the httpdito executable is 2060 bytes; it doesn't have space for two pages</span></div><div class="line" id="025214"><span class="nick" style="color:#8dd3c7"><a href="#025214" label="[02:52:14]">&lt;xentrac&gt;</a></span><span class="message">so I bet SKF will fail on current Linux thanks to the same thing you are talking about above.  thanks for letting me know!</span></div><div class="line" id="030836"><span class="nick" style="color:#389600"><a href="#030836" label="[03:08:36]">&lt;OriansJ&gt;</a></span><span class="message">we all learn from each other to do what we never could do alone</span></div><div class="line" id="031855"><span class="nick" style="color:#8dd3c7"><a href="#031855" label="[03:18:55]">&lt;xentrac&gt;</a></span><span class="message">I keep trying but nothing happens</span></div><div class="line" id="033049"><span class="nick" style="color:#389600"><a href="#033049" label="[03:30:49]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: I wouldn't say the collective results could be classified as &quot;but nothing happens&quot; if anything I'd say it would a fucking spectacular success.</span></div><div class="line" id="033326"><span class="nick" style="color:#8dd3c7"><a href="#033326" label="[03:33:26]">&lt;xentrac&gt;</a></span><span class="message">no, I keep trying to learn, but nothing happens</span></div><div class="line" id="033344"><span class="nick" style="color:#8dd3c7"><a href="#033344" label="[03:33:44]">&lt;xentrac&gt;</a></span><span class="message">I'm glad your efforts have been more successful --- spectacularly so, I'd say</span></div><div class="line" id="033603"><span class="nick" style="color:#8dd3c7"><a href="#033603" label="[03:36:03]">&lt;xentrac&gt;</a></span><span class="message">sorry about the ambiguity</span></div><div class="line" id="033627"><span class="nick" style="color:#8dd3c7"><a href="#033627" label="[03:36:27]">&lt;xentrac&gt;</a></span><span class="message">I certainly didn't mean that I keep trying to make you learn!  that wouldn't even make sense</span></div><div class="line" id="035559"><span class="nick" style="color:#389600"><a href="#035559" label="[03:55:59]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: one can only learn things they honestly believe are worth learning.</span></div><div class="line" id="040636"><span class="nick" style="color:#389600"><a href="#040636" label="[04:06:36]">&lt;OriansJ&gt;</a></span><span class="message">so the repeated trying to learn and failing is in itself an important lesson. You don't believe commiting that knowledge to memory is worth the effort.</span></div><div class="line" id="040713"><span class="nick" style="color:#8dd3c7"><a href="#040713" label="[04:07:13]">&lt;xentrac&gt;</a></span><span class="message">that's one hypothesis</span></div><div class="line" id="040736"><span class="nick" style="color:#389600"><a href="#040736" label="[04:07:36]">&lt;OriansJ&gt;</a></span><span class="message">So if you wish to keep that knowledge commit it to your external memory and cross-reference it in all the ways you can imagine it being needed.</span></div><div class="line" id="040758"><span class="nick" style="color:#8dd3c7"><a href="#040758" label="[04:07:58]">&lt;xentrac&gt;</a></span><span class="message">yeah, in Dercuano I was moderately successful at that</span></div><div class="line" id="040834"><span class="nick" style="color:#389600"><a href="#040834" label="[04:08:34]">&lt;OriansJ&gt;</a></span><span class="message">indeed, the cross-reference and linkage needed work but it certainly a good approximation.</span></div><div class="line" id="040851"><span class="nick" style="color:#8dd3c7"><a href="#040851" label="[04:08:51]">&lt;xentrac&gt;</a></span><span class="message">Bush's Memex didn't have grep, but Augment/NLS had it by 01969, and I use it a lot on Dercuano (and Derctuo)</span></div><div class="line" id="040911"><span class="nick" style="color:#8dd3c7"><a href="#040911" label="[04:09:11]">&lt;xentrac&gt;</a></span><span class="message">yeah, the other thing that really needs work there is executability</span></div><div class="line" id="040956"><span class="nick" style="color:#389600"><a href="#040956" label="[04:09:56]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: grep -iR is one of my favorite code tricks but I prefer a good index more when working on something structured for my external storage.</span></div><div class="line" id="041021"><span class="nick" style="color:#389600"><a href="#041021" label="[04:10:21]">&lt;OriansJ&gt;</a></span><span class="message">emacs org-mode is my bread and butter for notes</span></div><div class="line" id="041025"><span class="nick" style="color:#8dd3c7"><a href="#041025" label="[04:10:25]">&lt;xentrac&gt;</a></span><span class="message">doing calculations in a shell buffer and copying and pasting them into text (or in longhand and then photostatting them, as Bush proposed) is a damn poor alternative to a spreadsheet</span></div><div class="line" id="041034"><span class="nick" style="color:#8dd3c7"><a href="#041034" label="[04:10:34]">&lt;xentrac&gt;</a></span><span class="message">org-mode is pretty great, yeah</span></div><div class="line" id="041125"><span class="nick" style="color:#8dd3c7"><a href="#041125" label="[04:11:25]">&lt;xentrac&gt;</a></span><span class="message">and ^S/^R is often superior to grep for full-text search just because it's faster</span></div><div class="line" id="041153"><span class="nick" style="color:#8dd3c7"><a href="#041153" label="[04:11:53]">&lt;xentrac&gt;</a></span><span class="message">^S M-r gives you incremental regexp search, too</span></div><div class="line" id="041409"><span class="nick" style="color:#389600"><a href="#041409" label="[04:14:09]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: I honestly haven't memorized regex search keybindings in emacs; just C-s and C-r</span></div><div class="line" id="041444"><span class="nick" style="color:#389600"><a href="#041444" label="[04:14:44]">&lt;OriansJ&gt;</a></span><span class="message">but that might because my notes are heavily topic clustered</span></div><div class="line" id="043343"><span class="nick" style="color:#8dd3c7"><a href="#043343" label="[04:33:43]">&lt;xentrac&gt;</a></span><span class="message">I use emacs for searching a lot of things I didn't write</span></div><div class="line" id="043348"><span class="nick" style="color:#8dd3c7"><a href="#043348" label="[04:33:48]">&lt;xentrac&gt;</a></span><span class="message">M-. is pretty useful too</span></div><div class="line" id="062218"><span class="nick">***</span><span class="message notice">lukedashjr is now known as luke-jr</span></div><div class="line" id="102005"><span class="nick" style="color:#6b8072"><a href="#102005" label="[10:20:05]">&lt;bauen1&gt;</a></span><span class="message">OriansJ: the runs aren't quite identical yet the last time i looked, gforce_de1977 made a huge parallel run with make --debug and there where still some differences, mostly due to timing</span></div><div class="line" id="102216"><span class="nick" style="color:#6b8072"><a href="#102216" label="[10:22:16]">&lt;bauen1&gt;</a></span><span class="message">xentrac: you would probabaly want to build a microkernel, starting with basically a library as os, building a basic hypervisor / message passing microkernel and start adding components until you provide enough POSIX for live-bootstrap</span></div><div class="line" id="102707"><span class="nick" style="color:#6b8072"><a href="#102707" label="[10:27:07]">&lt;bauen1&gt;</a></span><span class="message">this way you can start from a baremetal monitor running at the highest privilege level, start writing helper functions, e.g. hex0 by hand, then load source code in some way, verify it, use it to compile a hypervisor/message passing microkernel, move yourself to a userspace task and start adding components as you need them, possibly reusing earlier code</span></div><div class="line" id="102721"><span class="nick" style="color:#6b8072"><a href="#102721" label="[10:27:21]">&lt;bauen1&gt;</a></span><span class="message">and you won't need to reboot, which is quite messy</span></div><div class="line" id="102759"><span class="nick" style="color:#6b8072"><a href="#102759" label="[10:27:59]">&lt;bauen1&gt;</a></span><span class="message">when you have enough POSIX interface implemented, you run live-bootstrap sysa ; at the end of which you reboot into linux</span></div><div class="line" id="131854"><span class="nick" style="color:#80b1d3"><a href="#131854" label="[13:18:54]">&lt;gforce_de1977&gt;</a></span><span class="message">stikonas: fossy: i dont want to be euphoric, but till now (264 CI-runs) there are zero errors. Seems that my mkdir() overloading changes something....will report more in 4 hours</span></div><div class="line" id="132003"><span class="nick" style="color:#80b1d3"><a href="#132003" label="[13:20:03]">&lt;gforce_de1977&gt;</a></span><span class="message">at the very beginning: <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/helpers.sh.txt">http://intercity-vpn.de/bootstrap/helpers.sh.txt</a> </span></div><div class="line" id="132032"><span class="nick" style="color:#80b1d3"><a href="#132032" label="[13:20:32]">&lt;gforce_de1977&gt;</a></span><span class="message">(but now with sync || true )</span></div><div class="line" id="132118"><span class="nick" style="color:#6b8072"><a href="#132118" label="[13:21:18]">&lt;bauen1&gt;</a></span><span class="message">gforce_de1977: as someone pointed out above, you could also try to run it with strace to see if there are any differences / why the error happens</span></div><div class="line" id="132213"><span class="nick" style="color:#80b1d3"><a href="#132213" label="[13:22:13]">&lt;gforce_de1977&gt;</a></span><span class="message">bauen1: yes, i will do this on next run (so running each mkdir with a statically build mkdir)</span></div><div class="line" id="132231"><span class="nick" style="color:#80b1d3"><a href="#132231" label="[13:22:31]">&lt;gforce_de1977&gt;</a></span><span class="message">(... statically build strace)</span></div><div class="line" id="174657"><span class="nick" style="color:#80b1d3"><a href="#174657" label="[17:46:57]">&lt;gforce_de1977&gt;</a></span><span class="message">ok, in my massrun 311 out of 312 CI-runs are *OK*, there was only 1 failed build: <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/bootstrap.log-multilog-17-1619151233.txt">http://intercity-vpn.de/bootstrap/bootstrap.log-multilog-17-1619151233.txt</a> </span></div><div class="line" id="174737"><span class="nick" style="color:#80b1d3"><a href="#174737" label="[17:47:37]">&lt;gforce_de1977&gt;</a></span><span class="message">that means: we have a HEISENBUG: when i insert debug statement, the bug goes away 8-)))</span></div><div class="line" id="174835"><span class="nick" style="color:#80b1d3"><a href="#174835" label="[17:48:35]">&lt;gforce_de1977&gt;</a></span><span class="message">in the next massrun, i will output &quot;/after/automake-1.15.1/build/automake-1.15.1/doc/amhello/amhello-output.tmp&quot; if above error happens again....lets see what is inside</span></div><div class="line" id="190341"><span class="nick" style="color:#6b8072"><a href="#190341" label="[19:03:41]">&lt;bauen1&gt;</a></span><span class="message">gforce_de1977: maybe you could dump the rootfs of every run ? or at least keep those around that do fail</span></div><div class="line" id="200040"><span class="nick" style="color:#80b1d3"><a href="#200040" label="[20:00:40]">&lt;gforce_de1977&gt;</a></span><span class="message">bauen1: i will think about it. no HDD and no networking. but i can just base64 everything to stdout/logfile.</span></div><div class="line" id="212928"><span class="nick" style="color:#6d2462"><a href="#212928" label="[21:29:28]">&lt;Hagfish&gt;</a></span><span class="message">for any other project, that would be a really dirty hack</span></div><div class="line" id="213022"><span class="nick" style="color:#6d2462"><a href="#213022" label="[21:30:22]">&lt;Hagfish&gt;</a></span><span class="message">it reminds me of the guy who got the original ipod to dump its firmware as an audio file in a custom format that he got it to play (with an ACE exploit)</span></div><div class="line" id="214608"><span class="nick" style="color:#80b1d3"><a href="#214608" label="[21:46:08]">&lt;gforce_de1977&gt;</a></span><span class="message">mass-test is already running: it will dump all files in /after to &quot;screen&quot;: <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/helpers.sh.txt">http://intercity-vpn.de/bootstrap/helpers.sh.txt</a>  | see default_src_compile()</span></div><div class="line" id="214624"><span class="nick" style="color:#80b1d3"><a href="#214624" label="[21:46:24]">&lt;gforce_de1977&gt;</a></span><span class="message">(only if there is an error)</span></div><div class="line" id="224942"><span class="nick" style="color:#6d2462"><a href="#224942" label="[22:49:42]">&lt;Hagfish&gt;</a></span><span class="message">#    cat &quot;builtins/pipesize.h&quot; || true</span></div><div class="line" id="225007"><span class="nick" style="color:#6d2462"><a href="#225007" label="[22:50:07]">&lt;Hagfish&gt;</a></span><span class="message">is that defending against the file not existing, or cat not existing?</span></div><br /></div></body></html>