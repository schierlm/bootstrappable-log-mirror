<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-06-05.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000022"><span class="nick" style="color:#8dd3c7"><a href="#000022" label="[00:00:22]">&lt;oriansj&gt;</a></span><span class="message">oohh, I could make stdout be the default output target</span></div><div class="line" id="000028"><span class="nick" style="color:#8dd3c7"><a href="#000028" label="[00:00:28]">&lt;oriansj&gt;</a></span><span class="message">/dev/stdout to be precise</span></div><div class="line" id="000043"><span class="nick" style="color:#8dd3c7"><a href="#000043" label="[00:00:43]">&lt;oriansj&gt;</a></span><span class="message">should make testing easier</span></div><div class="line" id="000056"><span class="nick" style="color:#8dd3c7"><a href="#000056" label="[00:00:56]">&lt;oriansj&gt;</a></span><span class="message">and fuzzing safe</span></div><div class="line" id="000550"><span class="nick" style="color:#2e2a4a"><a href="#000550" label="[00:05:50]">&lt;muurkha&gt;</a></span><span class="message">stdin being default input and stdout being default output is more convenient in a lot of ways, but of course we can't do that before we have ways to redirect input and output</span></div><div class="line" id="000846"><span class="nick" style="color:#8dd3c7"><a href="#000846" label="[00:08:46]">&lt;oriansj&gt;</a></span><span class="message">muurkha: we have no pipes at this stage</span></div><div class="line" id="000949"><span class="nick" style="color:#6b8072"><a href="#000949" label="[00:09:49]">&lt;Hagfish&gt;</a></span><span class="message">speaking of testing, is there any instrumentation set up for measuring test coverage of some reasonable segment of the bootstrap path?</span></div><div class="line" id="001051"><span class="nick" style="color:#6b8072"><a href="#001051" label="[00:10:51]">&lt;Hagfish&gt;</a></span><span class="message">maybe not test coverage, but execution coverage?</span></div><div class="line" id="001118"><span class="nick" style="color:#6b8072"><a href="#001118" label="[00:11:18]">&lt;Hagfish&gt;</a></span><span class="message">i don't imagine anyone would start deleting functions from e.g. the tcc source if we found they weren't ever used, but it might provide some insights</span></div><div class="line" id="001149"><span class="nick" style="color:#8dd3c7"><a href="#001149" label="[00:11:49]">&lt;oriansj&gt;</a></span><span class="message">well i have AFL setup and testing scripts to check for segfaults in all stage0-posix pieces but I don't think that is what you mean</span></div><div class="line" id="001203"><span class="nick" style="color:#6b8072"><a href="#001203" label="[00:12:03]">&lt;Hagfish&gt;</a></span><span class="message">AFL can generate minimal testcases, right?</span></div><div class="line" id="001217"><span class="nick" style="color:#6b8072"><a href="#001217" label="[00:12:17]">&lt;Hagfish&gt;</a></span><span class="message">can it generate a minimal coverage corpus?</span></div><div class="line" id="001237"><span class="nick" style="color:#8dd3c7"><a href="#001237" label="[00:12:37]">&lt;oriansj&gt;</a></span><span class="message">Hagfish: segfaulting and crashing cases but not known good test cases</span></div><div class="line" id="001243"><span class="nick" style="color:#6b8072"><a href="#001243" label="[00:12:43]">&lt;Hagfish&gt;</a></span><span class="message">ah, pity</span></div><div class="line" id="001331"><span class="nick" style="color:#8dd3c7"><a href="#001331" label="[00:13:31]">&lt;oriansj&gt;</a></span><span class="message">well, I would never reject if someone were to create more test cases for any of the various pieces</span></div><div class="line" id="001342"><span class="nick" style="color:#6b8072"><a href="#001342" label="[00:13:42]">&lt;Hagfish&gt;</a></span><span class="message">of course</span></div><div class="line" id="001407"><span class="nick" style="color:#8dd3c7"><a href="#001407" label="[00:14:07]">&lt;oriansj&gt;</a></span><span class="message">I just haven't had time to do that beyound the basic level so far</span></div><div class="line" id="001448"><span class="nick" style="color:#6b8072"><a href="#001448" label="[00:14:48]">&lt;Hagfish&gt;</a></span><span class="message">i've never thought about what testing assembly code would look like</span></div><div class="line" id="001519"><span class="nick" style="color:#6b8072"><a href="#001519" label="[00:15:19]">&lt;Hagfish&gt;</a></span><span class="message">is it possible to just statically analyse that all code is reached for a few given inputs?</span></div><div class="line" id="001955"><span class="nick" style="color:#8dd3c7"><a href="#001955" label="[00:19:55]">&lt;oriansj&gt;</a></span><span class="message">Hagfish: the same as one would write a test for a C program or a python program. write a file with valid inputs and compare the output result against what known good values should be</span></div><div class="line" id="002108"><span class="nick" style="color:#2e2a4a"><a href="#002108" label="[00:21:08]">&lt;muurkha&gt;</a></span><span class="message">oriansj: I didn't mean pipes, just file redirection</span></div><div class="line" id="002120"><span class="nick" style="color:#8dd3c7"><a href="#002120" label="[00:21:20]">&lt;oriansj&gt;</a></span><span class="message">muurkha: we don't have that either</span></div><div class="line" id="002122"><span class="nick" style="color:#2e2a4a"><a href="#002122" label="[00:21:22]">&lt;muurkha&gt;</a></span><span class="message">I know</span></div><div class="line" id="002141"><span class="nick" style="color:#2e2a4a"><a href="#002141" label="[00:21:41]">&lt;muurkha&gt;</a></span><span class="message">that's why I said &quot;of course we can't do that before we have ways to redirect input and output&quot;</span></div><div class="line" id="002153"><span class="nick" style="color:#8dd3c7"><a href="#002153" label="[00:21:53]">&lt;oriansj&gt;</a></span><span class="message">Hagfish: think ruby spec tests if you are wish</span></div><div class="line" id="002208"><span class="nick" style="color:#6b8072"><a href="#002208" label="[00:22:08]">&lt;Hagfish&gt;</a></span><span class="message">oriansj: i don't think i can define code being &quot;correct&quot; any better than that.  it just feels like treating the code as a black box, which doesn't give any insights if the test fails</span></div><div class="line" id="002212"><span class="nick" style="color:#8dd3c7"><a href="#002212" label="[00:22:12]">&lt;oriansj&gt;</a></span><span class="message">^are^^</span></div><div class="line" id="002242"><span class="nick" style="color:#8dd3c7"><a href="#002242" label="[00:22:42]">&lt;oriansj&gt;</a></span><span class="message">Hagfish: You can easily target a single code path in all of the assembly pieces</span></div><div class="line" id="002251"><span class="nick" style="color:#2e2a4a"><a href="#002251" label="[00:22:51]">&lt;muurkha&gt;</a></span><span class="message">but it does simplify things to not have each program opening and closing its own input and output files</span></div><div class="line" id="002444"><span class="nick" style="color:#6b8072"><a href="#002444" label="[00:24:44]">&lt;Hagfish&gt;</a></span><span class="message">oriansj: i guess statically analysing code probably quite quickly bumps into the Halting Problem or exploding complexity as you try to reason about what else the code could have done if there were a bug</span></div><div class="line" id="002603"><span class="nick" style="color:#8dd3c7"><a href="#002603" label="[00:26:03]">&lt;oriansj&gt;</a></span><span class="message">muurkha: replace -f foo -o foo .... ummm it seems simple enough for me</span></div><div class="line" id="002645"><span class="nick" style="color:#8dd3c7"><a href="#002645" label="[00:26:45]">&lt;oriansj&gt;</a></span><span class="message">Hagfish: also we tried to make the assembly code as small and simple as possible</span></div><div class="line" id="002659"><span class="nick" style="color:#6b8072"><a href="#002659" label="[00:26:59]">&lt;Hagfish&gt;</a></span><span class="message">yes, good</span></div><div class="line" id="002710"><span class="nick" style="color:#8dd3c7"><a href="#002710" label="[00:27:10]">&lt;oriansj&gt;</a></span><span class="message">so it'll definitely fail badly if given questionable input</span></div><div class="line" id="002752"><span class="nick" style="color:#8dd3c7"><a href="#002752" label="[00:27:52]">&lt;oriansj&gt;</a></span><span class="message">So you could do an output compare between hex0, hex1, hex2 in assembly with mescc-tools hex2 and the output should always be identical</span></div><div class="line" id="002806"><span class="nick" style="color:#8dd3c7"><a href="#002806" label="[00:28:06]">&lt;oriansj&gt;</a></span><span class="message">same for M0 and M1</span></div><div class="line" id="002820"><span class="nick" style="color:#8dd3c7"><a href="#002820" label="[00:28:20]">&lt;oriansj&gt;</a></span><span class="message">cc_* does have a C version which it should directly match</span></div><div class="line" id="002833"><span class="nick" style="color:#6b8072"><a href="#002833" label="[00:28:33]">&lt;Hagfish&gt;</a></span><span class="message">yeah, that sort of makes the different versions be test suites for each other</span></div><div class="line" id="002941"><span class="nick" style="color:#8dd3c7"><a href="#002941" label="[00:29:41]">&lt;oriansj&gt;</a></span><span class="message">not ideal but something we certainly can improve given enough effort</span></div><div class="line" id="003005"><span class="nick" style="color:#6b8072"><a href="#003005" label="[00:30:05]">&lt;Hagfish&gt;</a></span><span class="message">and i think you're right, a decent test just has to be a simple input (that can be reasoned about) and the relevant expected outputs, so that the failure mode makes it clear which part of the implementation needs fixing</span></div><div class="line" id="003127"><span class="nick" style="color:#8dd3c7"><a href="#003127" label="[00:31:27]">&lt;oriansj&gt;</a></span><span class="message">so simple that it obviously is correct has benefits ^_^</span></div><div class="line" id="003136"><span class="nick" style="color:#80b1d3"><a href="#003136" label="[00:31:36]">&lt;stikonas&gt;</a></span><span class="message">oriansj: thanks, I'll try although probably not today</span></div><div class="line" id="003155"><span class="nick" style="color:#8dd3c7"><a href="#003155" label="[00:31:55]">&lt;oriansj&gt;</a></span><span class="message">stikonas: no worries, I'll be tweaking today anyway</span></div><div class="line" id="003217"><span class="nick" style="color:#80b1d3"><a href="#003217" label="[00:32:17]">&lt;stikonas&gt;</a></span><span class="message">was doing a lot of driving and hiking in the mountains today, so a bit tired</span></div><div class="line" id="003530"><span class="nick" style="color:#8dd3c7"><a href="#003530" label="[00:35:30]">&lt;oriansj&gt;</a></span><span class="message">stikonas: then absolutely relax and enjoy yourself. no rush</span></div><div class="line" id="003818"><span class="nick" style="color:#8dd3c7"><a href="#003818" label="[00:38:18]">&lt;oriansj&gt;</a></span><span class="message">muurkha: but sure, I'll include /dev/stdin for the default input (assuming fseek(input, 0, SEEK_END); works correctly with that)</span></div><div class="line" id="003828"><span class="nick" style="color:#2e2a4a"><a href="#003828" label="[00:38:28]">&lt;muurkha&gt;</a></span><span class="message">oriansj: it's simple to invoke, but replace.c has to open() or fopen() the files and also parse more arguments</span></div><div class="line" id="003906"><span class="nick" style="color:#8dd3c7"><a href="#003906" label="[00:39:06]">&lt;oriansj&gt;</a></span><span class="message">muurkha: we do the fopen *after* all of the arguments are parsed</span></div><div class="line" id="003912"><span class="nick" style="color:#2e2a4a"><a href="#003912" label="[00:39:12]">&lt;muurkha&gt;</a></span><span class="message">right, of course</span></div><div class="line" id="003937"><span class="nick" style="color:#2e2a4a"><a href="#003937" label="[00:39:37]">&lt;muurkha&gt;</a></span><span class="message">and in itself that is not a huge amount of complexity, it's just that each of the other programs in the early-stage bootstrap has to duplicate that same small amount of extra complexity</span></div><div class="line" id="003954"><span class="nick" style="color:#2e2a4a"><a href="#003954" label="[00:39:54]">&lt;muurkha&gt;</a></span><span class="message">or unbootstrap or whatever</span></div><div class="line" id="003958"><span class="nick" style="color:#2e2a4a"><a href="#003958" label="[00:39:58]">&lt;muurkha&gt;</a></span><span class="message">even though a lot of them read one input and write to one output</span></div><div class="line" id="004027"><span class="nick" style="color:#8dd3c7"><a href="#004027" label="[00:40:27]">&lt;oriansj&gt;</a></span><span class="message">well doing replace a few times is pretty easy to reason about and audit</span></div><div class="line" id="004101"><span class="nick" style="color:#2e2a4a"><a href="#004101" label="[00:41:01]">&lt;muurkha&gt;</a></span><span class="message">yeah, I'm not saying the replace command is a bad idea</span></div><div class="line" id="004130"><span class="nick" style="color:#8dd3c7"><a href="#004130" label="[00:41:30]">&lt;oriansj&gt;</a></span><span class="message">just the pattern of -f file -o output is duplicated functionality</span></div><div class="line" id="004130"><span class="nick" style="color:#2e2a4a"><a href="#004130" label="[00:41:30]">&lt;muurkha&gt;</a></span><span class="message">I'm saying that moving a little bit of its complexity into kaem or something similar would reduce the overall system complexity</span></div><div class="line" id="004133"><span class="nick" style="color:#2e2a4a"><a href="#004133" label="[00:41:33]">&lt;muurkha&gt;</a></span><span class="message">right</span></div><div class="line" id="004150"><span class="nick" style="color:#2e2a4a"><a href="#004150" label="[00:41:50]">&lt;muurkha&gt;</a></span><span class="message">it would also make it a little easier to audit I think</span></div><div class="line" id="004216"><span class="nick" style="color:#2e2a4a"><a href="#004216" label="[00:42:16]">&lt;muurkha&gt;</a></span><span class="message">because there are less places where some program opens a file for output which could potentially be overwriting something unexpected</span></div><div class="line" id="004254"><span class="nick" style="color:#8dd3c7"><a href="#004254" label="[00:42:54]">&lt;oriansj&gt;</a></span><span class="message">tempfiles are pretty easy to audit and being able to see every processing step as an audit record means that questionable changes can be traced back to the source program</span></div><div class="line" id="004513"><span class="nick" style="color:#8dd3c7"><a href="#004513" label="[00:45:13]">&lt;oriansj&gt;</a></span><span class="message">so the chain M2 -f input.c -o input.M1 &amp;&amp; M1 -f input.M1 -o input.hex2 &amp;&amp; hex2 -f input.hex2 -o input vs M2 -f input.c | M1 -- | hex2 -o input</span></div><div class="line" id="004543"><span class="nick" style="color:#2e2a4a"><a href="#004543" label="[00:45:43]">&lt;muurkha&gt;</a></span><span class="message">I agree</span></div><div class="line" id="004650"><span class="nick" style="color:#2e2a4a"><a href="#004650" label="[00:46:50]">&lt;muurkha&gt;</a></span><span class="message">fwiw a super stupid replace.c without file opening or string library functions is 60 lines of C: <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/replace.c">http://canonical.org/~kragen/sw/dev3/replace.c</a> </span></div><div class="line" id="004705"><span class="nick" style="color:#2e2a4a"><a href="#004705" label="[00:47:05]">&lt;muurkha&gt;</a></span><span class="message">I don't think we have enum support until tcc tho</span></div><div class="line" id="004735"><span class="nick" style="color:#8dd3c7"><a href="#004735" label="[00:47:35]">&lt;oriansj&gt;</a></span><span class="message">nor fprintf</span></div><div class="line" id="004757"><span class="nick" style="color:#8dd3c7"><a href="#004757" label="[00:47:57]">&lt;oriansj&gt;</a></span><span class="message">and I allow \n to be in my patterns</span></div><div class="line" id="004807"><span class="nick" style="color:#8dd3c7"><a href="#004807" label="[00:48:07]">&lt;oriansj&gt;</a></span><span class="message">fgets would break on \n</span></div><div class="line" id="004909"><span class="nick" style="color:#2e2a4a"><a href="#004909" label="[00:49:09]">&lt;muurkha&gt;</a></span><span class="message">this implementation works okay with \n in the pattern, as long as it's at the end</span></div><div class="line" id="005002"><span class="nick" style="color:#8dd3c7"><a href="#005002" label="[00:50:02]">&lt;oriansj&gt;</a></span><span class="message">true</span></div><div class="line" id="005030"><span class="nick" style="color:#2e2a4a"><a href="#005030" label="[00:50:30]">&lt;muurkha&gt;</a></span><span class="message">but I didn't think that was important</span></div><div class="line" id="005100"><span class="nick" style="color:#8dd3c7"><a href="#005100" label="[00:51:00]">&lt;oriansj&gt;</a></span><span class="message">and you can bust the buffer</span></div><div class="line" id="005119"><span class="nick" style="color:#2e2a4a"><a href="#005119" label="[00:51:19]">&lt;muurkha&gt;</a></span><span class="message">undetectedly?</span></div><div class="line" id="005127"><span class="nick" style="color:#8dd3c7"><a href="#005127" label="[00:51:27]">&lt;oriansj&gt;</a></span><span class="message">but you do support nulls in your input/output</span></div><div class="line" id="005151"><span class="nick" style="color:#8dd3c7"><a href="#005151" label="[00:51:51]">&lt;oriansj&gt;</a></span><span class="message">muurkha: o replaced by ooo</span></div><div class="line" id="005228"><span class="nick" style="color:#8dd3c7"><a href="#005228" label="[00:52:28]">&lt;oriansj&gt;</a></span><span class="message">my version would just turn hello world into hellooo wooorld</span></div><div class="line" id="005230"><span class="nick" style="color:#2e2a4a"><a href="#005230" label="[00:52:30]">&lt;muurkha&gt;</a></span><span class="message">it crashes with &quot;./replace: string too long&quot; in that case</span></div><div class="line" id="005241"><span class="nick" style="color:#2e2a4a"><a href="#005241" label="[00:52:41]">&lt;muurkha&gt;</a></span><span class="message">if I feed it 3000 o's</span></div><div class="line" id="005315"><span class="nick" style="color:#2e2a4a"><a href="#005315" label="[00:53:15]">&lt;muurkha&gt;</a></span><span class="message">it does have a much nastier problem actually</span></div><div class="line" id="005407"><span class="nick" style="color:#2e2a4a"><a href="#005407" label="[00:54:07]">&lt;muurkha&gt;</a></span><span class="message">if you run it as ./replace bab x</span></div><div class="line" id="005433"><span class="nick" style="color:#2e2a4a"><a href="#005433" label="[00:54:33]">&lt;muurkha&gt;</a></span><span class="message">and you feed it a line consisting of babbabbab... many times (I tested with 3001 repetitions)</span></div><div class="line" id="005500"><span class="nick" style="color:#2e2a4a"><a href="#005500" label="[00:55:00]">&lt;muurkha&gt;</a></span><span class="message">it outputs xxxxx...xxbabxxxx... with three unreplaced &quot;bab&quot;s</span></div><div class="line" id="005528"><span class="nick" style="color:#2e2a4a"><a href="#005528" label="[00:55:28]">&lt;muurkha&gt;</a></span><span class="message">I blame fgets!</span></div><div class="line" id="005716"><span class="nick" style="color:#2e2a4a"><a href="#005716" label="[00:57:16]">&lt;muurkha&gt;</a></span><span class="message">because with fgets there's no reliable way to tell the difference between an input line that lacks a &quot;\n&quot; because it ends with EOF and one that lacks a &quot;\n&quot; because fgets ran out of buffer space</span></div><div class="line" id="005802"><span class="nick" style="color:#2e2a4a"><a href="#005802" label="[00:58:02]">&lt;muurkha&gt;</a></span><span class="message">if it happens that the input line is shorter than the buffer then you know it's the former</span></div><div class="line" id="005922"><span class="nick" style="color:#2e2a4a"><a href="#005922" label="[00:59:22]">&lt;muurkha&gt;</a></span><span class="message">fixed tho</span></div><div class="line" id="005955"><span class="nick" style="color:#2e2a4a"><a href="#005955" label="[00:59:55]">&lt;muurkha&gt;</a></span><span class="message">it does successfully turn hello world into hellooo wooorld of course</span></div><div class="line" id="010158"><span class="nick" style="color:#2e2a4a"><a href="#010158" label="[01:01:58]">&lt;muurkha&gt;</a></span><span class="message">it doesn't really handle nulls in the input or output; fgets doesn't tell you how many bytes it read, so you're reduced to looking for nulls, and argv also doesn't tell you how long the argument strings are, so again you're reduced to looking for nulls</span></div><div class="line" id="010903"><span class="nick" style="color:#2e2a4a"><a href="#010903" label="[01:09:03]">&lt;muurkha&gt;</a></span><span class="message">it'd be kind of fun to compile a pattern-replacement pair into a KMP-style state machine</span></div><div class="line" id="010940"><span class="nick" style="color:#2e2a4a"><a href="#010940" label="[01:09:40]">&lt;muurkha&gt;</a></span><span class="message">you stick an input byte into it, it changes state and emits zero or more output bytes</span></div><div class="line" id="011207"><span class="nick" style="color:#2e2a4a"><a href="#011207" label="[01:12:07]">&lt;muurkha&gt;</a></span><span class="message">harder to tell if such a compiler is buggy though.  this find/cmove loop is dumb enough that probably you could see if it was buggy</span></div><div class="line" id="011600"><span class="nick" style="color:#2e2a4a"><a href="#011600" label="[01:16:00]">&lt;muurkha&gt;</a></span><span class="message">surely find() could be expressed better.  probably with struct slice { char *s; char *end; char *buf_end; } the whole program could be expressed better</span></div><div class="line" id="012136"><span class="nick" style="color:#8dd3c7"><a href="#012136" label="[01:21:36]">&lt;oriansj&gt;</a></span><span class="message">well a single fixed buffer that the input is pushed through which either matches or doesn't match the pattern is about as simple as it can get</span></div><div class="line" id="012203"><span class="nick" style="color:#2e2a4a"><a href="#012203" label="[01:22:03]">&lt;muurkha&gt;</a></span><span class="message">do you mean what I wrote in that replace.c, or something else?</span></div><div class="line" id="012219"><span class="nick" style="color:#8dd3c7"><a href="#012219" label="[01:22:19]">&lt;oriansj&gt;</a></span><span class="message">muurkha: that is what my replace.c does</span></div><div class="line" id="012302"><span class="nick" style="color:#8dd3c7"><a href="#012302" label="[01:23:02]">&lt;oriansj&gt;</a></span><span class="message">just pushes in bytes at the end of the buffer and shift by 1 until it either matches or end of file</span></div><div class="line" id="012417"><span class="nick" style="color:#2e2a4a"><a href="#012417" label="[01:24:17]">&lt;muurkha&gt;</a></span><span class="message">that is indeed simpler than looping over lines</span></div><div class="line" id="012420"><span class="nick" style="color:#80b1d3"><a href="#012420" label="[01:24:20]">&lt;stikonas&gt;</a></span><span class="message">fossy: another packaging bug <a rel="nofollow" href="https://github.com/fosslinux/live-bootstrap/issues/180">https://github.com/fosslinux/live-bootstrap/issues/180</a> </span></div><div class="line" id="012429"><span class="nick" style="color:#2e2a4a"><a href="#012429" label="[01:24:29]">&lt;muurkha&gt;</a></span><span class="message">is that what you mean?</span></div><div class="line" id="012452"><span class="nick" style="color:#80b1d3"><a href="#012452" label="[01:24:52]">&lt;stikonas&gt;</a></span><span class="message">fossy: automake includes build month</span></div><div class="line" id="012633"><span class="nick" style="color:#8dd3c7"><a href="#012633" label="[01:26:33]">&lt;oriansj&gt;</a></span><span class="message">so [][][][][][a] -&gt; [][][][][a][b] -&gt; [][][][a][b][c] -&gt; [][][a][b][c][d] -&gt; [][a][b][c][d][e] -&gt; [a][b][c][d][e][f] -&gt;  [b][c][d][e][f][g] sort of pattern</span></div><div class="line" id="012730"><span class="nick" style="color:#8dd3c7"><a href="#012730" label="[01:27:30]">&lt;oriansj&gt;</a></span><span class="message">on match , just dump the replacement and clear the buffer</span></div><div class="line" id="012751"><span class="nick" style="color:#8dd3c7"><a href="#012751" label="[01:27:51]">&lt;oriansj&gt;</a></span><span class="message">hence why null is just ignored and not supported in my replace.c</span></div><div class="line" id="012920"><span class="nick" style="color:#2e2a4a"><a href="#012920" label="[01:29:20]">&lt;muurkha&gt;</a></span><span class="message">aha, similar to the &quot;stick an input byte into it, it changes state and emits zero or more output bytes&quot; thing I was saying, but with an actual buffer and emitting some bytes later than you strictly need to</span></div><div class="line" id="012928"><span class="nick" style="color:#2e2a4a"><a href="#012928" label="[01:29:28]">&lt;muurkha&gt;</a></span><span class="message">that's probably a better approach!</span></div><div class="line" id="012941"><span class="nick" style="color:#2e2a4a"><a href="#012941" label="[01:29:41]">&lt;muurkha&gt;</a></span><span class="message">maybe a little slower but definitely simpler</span></div><div class="line" id="013213"><span class="nick" style="color:#2e2a4a"><a href="#013213" label="[01:32:13]">&lt;muurkha&gt;</a></span><span class="message">(the KMP-style state machine approach is that you don't need an actual buffer; if you're in state 3 then you know that the last 3 bytes you saw were the first 3 bytes of the pattern/needle, so if the next byte is a mismatch, you know that the &quot;buffered&quot; bytes you need to spit out are the first three bytes of the pattern)</span></div><div class="line" id="013315"><span class="nick" style="color:#2e2a4a"><a href="#013315" label="[01:33:15]">&lt;muurkha&gt;</a></span><span class="message">(and then usually you transition to state 0 or 1, but in cases of patterns like &quot;abad&quot; you might transition to some other state instead, which is the tricky part about KMP search)</span></div><div class="line" id="013611"><span class="nick" style="color:#2e2a4a"><a href="#013611" label="[01:36:11]">&lt;muurkha&gt;</a></span><span class="message">I guess you're using null instead of a counter to keep track of how many bytes you have in the buffer?  a counter might be just as simple</span></div><div class="line" id="013945"><span class="nick" style="color:#8dd3c7"><a href="#013945" label="[01:39:45]">&lt;oriansj&gt;</a></span><span class="message">muurkha: trimming down my replace.c it is just 74lines <a rel="nofollow" href="https://paste.debian.net/1243058/">https://paste.debian.net/1243058/</a> </span></div><div class="line" id="014039"><span class="nick" style="color:#2e2a4a"><a href="#014039" label="[01:40:39]">&lt;muurkha&gt;</a></span><span class="message">nice</span></div><div class="line" id="014103"><span class="nick" style="color:#8dd3c7"><a href="#014103" label="[01:41:03]">&lt;oriansj&gt;</a></span><span class="message">if I drop the buffering it should be a handful smaller</span></div><div class="line" id="014118"><span class="nick" style="color:#2e2a4a"><a href="#014118" label="[01:41:18]">&lt;muurkha&gt;</a></span><span class="message">more readable too</span></div><div class="line" id="014134"><span class="nick" style="color:#2e2a4a"><a href="#014134" label="[01:41:34]">&lt;muurkha&gt;</a></span><span class="message">ah but it's using string.h</span></div><div class="line" id="014154"><span class="nick" style="color:#2e2a4a"><a href="#014154" label="[01:41:54]">&lt;muurkha&gt;</a></span><span class="message">sizeof(char) is defined to be 1 btw</span></div><div class="line" id="014233"><span class="nick" style="color:#2e2a4a"><a href="#014233" label="[01:42:33]">&lt;muurkha&gt;</a></span><span class="message">more readable than the replace.c I wrote, I mean, not more readable than your previous version</span></div><div class="line" id="014547"><span class="nick" style="color:#2e2a4a"><a href="#014547" label="[01:45:47]">&lt;muurkha&gt;</a></span><span class="message">in ANSI C, if you're on a machine like a TI DSP where a char is 32 bits, sizeof(int32_t) is also 1.  that is, sizeof is defined in terms of multiples of sizeof(char), not in multiples of 8 bits or something.  disclaimer: I haven't ever actually used C on such a machine!</span></div><div class="line" id="014845"><span class="nick" style="color:#2e2a4a"><a href="#014845" label="[01:48:45]">&lt;muurkha&gt;</a></span><span class="message">not sure if GCC has a warning for &quot;* sizeof(char)&quot; but it probably should</span></div><div class="line" id="015711"><span class="nick" style="color:#2e2a4a"><a href="#015711" label="[01:57:11]">&lt;muurkha&gt;</a></span><span class="message">probably it isn't intentional that you're setting hold[pattern_length-1] to hold[pattern_length] before you set it to buffer[buffer_index]</span></div><div class="line" id="015800"><span class="nick" style="color:#8dd3c7"><a href="#015800" label="[01:58:00]">&lt;oriansj&gt;</a></span><span class="message">dropping the buffering gets it down to 60 lines: <a rel="nofollow" href="https://paste.debian.net/1243061/">https://paste.debian.net/1243061/</a> </span></div><div class="line" id="015808"><span class="nick" style="color:#2e2a4a"><a href="#015808" label="[01:58:08]">&lt;muurkha&gt;</a></span><span class="message">though I guess it's harmless since hold is allocated with 4 extra bytes in it</span></div><div class="line" id="015912"><span class="nick" style="color:#2e2a4a"><a href="#015912" label="[01:59:12]">&lt;muurkha&gt;</a></span><span class="message">very nice.  and you're even counting the blank lines and comments, so it's really more like 55 very clear lines</span></div><div class="line" id="020043"><span class="nick" style="color:#2e2a4a"><a href="#020043" label="[02:00:43]">&lt;muurkha&gt;</a></span><span class="message">if you don't like writing while (i &lt; pattern_length - 1) you could avoid the suspicious read of hold[pattern_length] by saying size_t i = 1; while (i &lt; pattern_length) { hold[i-1] = hold[i]; i = i + 1; }</span></div><div class="line" id="020230"><span class="nick" style="color:#2e2a4a"><a href="#020230" label="[02:02:30]">&lt;muurkha&gt;</a></span><span class="message">it's maybe undesirable to keep fgetcing on the input once you've already seen an EOF on it, just because it keeps you from handling terminal input</span></div><div class="line" id="020309"><span class="nick" style="color:#2e2a4a"><a href="#020309" label="[02:03:09]">&lt;muurkha&gt;</a></span><span class="message">also maybe undesirable to signal being invoked without enough command-line arguments with &quot;Segmentation violation&quot;</span></div><div class="line" id="032804"><span class="nick" style="color:#8dd3c7"><a href="#032804" label="[03:28:04]">&lt;oriansj&gt;</a></span><span class="message">muurkha: so yeah, more dense and simple is easy but the complexity does allow a more clear user experience</span></div><div class="line" id="032932"><span class="nick" style="color:#8dd3c7"><a href="#032932" label="[03:29:32]">&lt;oriansj&gt;</a></span><span class="message">I could probably add a line like: if(argc &lt; 4) { puts(&quot;need replace input pattern replacement [output]&quot;); exit(EXIT_FAILURE);}</span></div><div class="line" id="033012"><span class="nick" style="color:#8dd3c7"><a href="#033012" label="[03:30:12]">&lt;oriansj&gt;</a></span><span class="message">which would clear up that segment violation</span></div><div class="line" id="033409"><span class="nick" style="color:#8dd3c7"><a href="#033409" label="[03:34:09]">&lt;oriansj&gt;</a></span><span class="message">I also could merge read_next_byte and check_match to save an additional 5 lines</span></div><div class="line" id="033627"><span class="nick" style="color:#8dd3c7"><a href="#033627" label="[03:36:27]">&lt;oriansj&gt;</a></span><span class="message">using hold[i++] would also be a cheap way to cut 2 lines</span></div><div class="line" id="034308"><span class="nick" style="color:#8dd3c7"><a href="#034308" label="[03:43:08]">&lt;oriansj&gt;</a></span><span class="message">so down to 41 lines: <a rel="nofollow" href="https://paste.debian.net/1243070/">https://paste.debian.net/1243070/</a> </span></div><div class="line" id="034333"><span class="nick" style="color:#8dd3c7"><a href="#034333" label="[03:43:33]">&lt;oriansj&gt;</a></span><span class="message">only the ++ behavior is invalid for M2-Planet</span></div><div class="line" id="035746"><span class="nick" style="color:#8dd3c7"><a href="#035746" label="[03:57:46]">&lt;oriansj&gt;</a></span><span class="message">ok now down to 31 lines (and a little ugly): <a rel="nofollow" href="https://paste.debian.net/1243071/">https://paste.debian.net/1243071/</a> </span></div><div class="line" id="040718"><span class="nick" style="color:#8dd3c7"><a href="#040718" label="[04:07:18]">&lt;oriansj&gt;</a></span><span class="message">and using linux C formatting saves a couple extra lines: <a rel="nofollow" href="https://paste.debian.net/1243073/">https://paste.debian.net/1243073/</a>  21 lines, single C expression per line</span></div><div class="line" id="040824"><span class="nick" style="color:#8dd3c7"><a href="#040824" label="[04:08:24]">&lt;oriansj&gt;</a></span><span class="message">if I do lisp line formatting it goes down to 18 lines</span></div><div class="line" id="041443"><span class="nick" style="color:#8dd3c7"><a href="#041443" label="[04:14:43]">&lt;oriansj&gt;</a></span><span class="message">hmmm; why the heck isn't while(0 != hold[i-1]) hold[i--] = 0; not decrementing i at all</span></div><div class="line" id="043225"><span class="nick" style="color:#8dd3c7"><a href="#043225" label="[04:32:25]">&lt;oriansj&gt;</a></span><span class="message">17 lines: <a rel="nofollow" href="https://paste.debian.net/1243077/">https://paste.debian.net/1243077/</a> </span></div><div class="line" id="043637"><span class="nick" style="color:#8dd3c7"><a href="#043637" label="[04:36:37]">&lt;oriansj&gt;</a></span><span class="message">I probably could turn that into ascii art without adding lines but I probably wasted enough time proving the point</span></div><div class="line" id="045220"><span class="nick" style="color:#8dd3c7"><a href="#045220" label="[04:52:20]">&lt;oriansj&gt;</a></span><span class="message">getting rid of the file opening and #include &lt;string.h&gt;; but making it more readable: 34 lines <a rel="nofollow" href="https://paste.debian.net/1243078/">https://paste.debian.net/1243078/</a> </span></div><div class="line" id="075124"><span class="nick" style="color:#8dd3c7"><a href="#075124" label="[07:51:24]">&lt;oriansj&gt;</a></span><span class="message">now the real question, is this too agressive? <a rel="nofollow" href="https://pdp10.guru/stage0">https://pdp10.guru/stage0</a> </span></div><div class="line" id="082831"><span class="nick" style="color:#6d2462"><a href="#082831" label="[08:28:31]">*</a></span><span class="message">pabs3 would say yes :)</span></div><div class="line" id="102049"><span class="nick" style="color:#234e69"><a href="#102049" label="[10:20:49]">&lt;unmatched-paren&gt;</a></span><span class="message">yes</span></div><div class="line" id="115101"><span class="nick" style="color:#6c3d55"><a href="#115101" label="[11:51:01]">&lt;fossy&gt;</a></span><span class="message">stikonas[m]: ugh, i swear i fixed that...</span></div><div class="line" id="115153"><span class="nick" style="color:#6c3d55"><a href="#115153" label="[11:51:53]">&lt;fossy&gt;</a></span><span class="message">yes that is quite aggressive...</span></div><div class="line" id="115500"><span class="nick" style="color:#234e69"><a href="#115500" label="[11:55:00]">&lt;unmatched-paren&gt;</a></span><span class="message">i'd personally write it in a way that celebrates the achievements we've made, instead of trying to middle-finger all the detractors</span></div><div class="line" id="115510"><span class="nick" style="color:#6c3d55"><a href="#115510" label="[11:55:10]">&lt;fossy&gt;</a></span><span class="message">agreed</span></div><div class="line" id="115537"><span class="nick" style="color:#6c3d55"><a href="#115537" label="[11:55:37]">&lt;fossy&gt;</a></span><span class="message">it doesn't really help people to contribute when it's aggressive</span></div><div class="line" id="115655"><span class="nick" style="color:#6c3d55"><a href="#115655" label="[11:56:55]">&lt;fossy&gt;</a></span><span class="message">stikonas[m]: hm, so i fixed it for *some* things <a rel="nofollow" href="https://github.com/fosslinux/live-bootstrap/blob/master/sysa/help2man-1.36.4/patches/date.patch">https://github.com/fosslinux/live-bootstrap/blob/master/sysa/help2man-1.36.4/patches/date.patch</a> </span></div><div class="line" id="115709"><span class="nick" style="color:#234e69"><a href="#115709" label="[11:57:09]">&lt;unmatched-paren&gt;</a></span><span class="message">fossy: yeah, it alienates people</span></div><div class="line" id="115754"><span class="nick" style="color:#6c3d55"><a href="#115754" label="[11:57:54]">&lt;fossy&gt;</a></span><span class="message">now why isn't that patch working there, is help2man not regening the manpage?</span></div><div class="line" id="142551"><span class="nick" style="color:#8dd3c7"><a href="#142551" label="[14:25:51]">&lt;oriansj&gt;</a></span><span class="message">I guess, I'll have to rewrite a good bit</span></div><div class="line" id="145842"><span class="nick" style="color:#d9d9d9"><a href="#145842" label="[14:58:42]">&lt;stikonas[m]&gt;</a></span><span class="message">Yeah, less aggressive would be better</span></div><div class="line" id="150258"><span class="nick" style="color:#234e69"><a href="#150258" label="[15:02:58]">&lt;unmatched-paren&gt;</a></span><span class="message">as much fun as it might be to vent at the people who said it was impossible, you certainly don't want to make enemies of them</span></div><div class="line" id="152116"><span class="nick" style="color:#8dd3c7"><a href="#152116" label="[15:21:16]">&lt;oriansj&gt;</a></span><span class="message">I guess I was just doing a bit too much Jason Scott</span></div><div class="line" id="152500"><span class="nick" style="color:#8dd3c7"><a href="#152500" label="[15:25:00]">&lt;oriansj&gt;</a></span><span class="message">especially the archive warrior, we are here to save your shit routine. But it does seem to rhyme with bootstrapping-team: we are here to bootstrap your shit</span></div><div class="line" id="165835"><span class="nick" style="color:#2e2a4a"><a href="#165835" label="[16:58:35]">&lt;muurkha&gt;</a></span><span class="message">on the contrary, the people who said it was impossible are the ones who build your reputation</span></div><div class="line" id="165835"><span class="nick" style="color:#2e2a4a"><a href="#165835" label="[16:58:35]">&lt;muurkha&gt;</a></span><span class="message">your enemie sare the people who say it's trivial</span></div><div class="line" id="165913"><span class="nick" style="color:#2e2a4a"><a href="#165913" label="[16:59:13]">&lt;muurkha&gt;</a></span><span class="message">oriansj: I think &quot;Segmentation violation&quot; is preferable to writing an error message to stdout</span></div><div class="line" id="184526"><span class="nick" style="color:#8dd3c7"><a href="#184526" label="[18:45:26]">&lt;oriansj&gt;</a></span><span class="message">muurkha: generally I disagree with that perspective but I was kinda pushing to see how far I could get</span></div><div class="line" id="184556"><span class="nick" style="color:#8dd3c7"><a href="#184556" label="[18:45:56]">&lt;oriansj&gt;</a></span><span class="message">and a 17line replace.c is a bit terse</span></div><div class="line" id="184634"><span class="nick" style="color:#8dd3c7"><a href="#184634" label="[18:46:34]">&lt;oriansj&gt;</a></span><span class="message">and it would have cost 3 lines to honestly provide the correct exit behavior for bad input</span></div><div class="line" id="184729"><span class="nick" style="color:#2e2a4a"><a href="#184729" label="[18:47:29]">&lt;muurkha&gt;</a></span><span class="message">you disagree with the perspective of not corrupting output data with error messages?</span></div><div class="line" id="184755"><span class="nick" style="color:#8dd3c7"><a href="#184755" label="[18:47:55]">&lt;oriansj&gt;</a></span><span class="message">muurkha: oh, I only write error messages to stderr not stdout</span></div><div class="line" id="184921"><span class="nick" style="color:#2e2a4a"><a href="#184921" label="[18:49:21]">&lt;muurkha&gt;</a></span><span class="message">ah, I meant 01:29 &lt;@oriansj&gt; I could probably add a line like: if(argc &lt; 4) { puts(&quot;need replace input pattern replacement [output]&quot;); exit(EXIT_FAILURE);}</span></div><div class="line" id="184949"><span class="nick" style="color:#2e2a4a"><a href="#184949" label="[18:49:49]">&lt;muurkha&gt;</a></span><span class="message">I agree that the message itself is better than &quot;Segmentation violation&quot; :)</span></div><div class="line" id="185032"><span class="nick" style="color:#8dd3c7"><a href="#185032" label="[18:50:32]">&lt;oriansj&gt;</a></span><span class="message">and fputs would enable a proper write to stderr instead of puts</span></div><div class="line" id="185123"><span class="nick" style="color:#2e2a4a"><a href="#185123" label="[18:51:23]">&lt;muurkha&gt;</a></span><span class="message">yeah.  write(2, &quot;need replace input pattern replacement [output]&quot;, 54); is hard to audit</span></div><div class="line" id="185424"><span class="nick" style="color:#8dd3c7"><a href="#185424" label="[18:54:24]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well fcntl.h includes #define STDERR_FILENO 2</span></div><div class="line" id="185505"><span class="nick" style="color:#2e2a4a"><a href="#185505" label="[18:55:05]">&lt;muurkha&gt;</a></span><span class="message">to me the 2 is not the hard part</span></div><div class="line" id="185517"><span class="nick" style="color:#8dd3c7"><a href="#185517" label="[18:55:17]">&lt;oriansj&gt;</a></span><span class="message">the counting of the bytes in the string</span></div><div class="line" id="185535"><span class="nick" style="color:#8dd3c7"><a href="#185535" label="[18:55:35]">&lt;oriansj&gt;</a></span><span class="message">hence why fputs instead of write</span></div><div class="line" id="185538"><span class="nick" style="color:#2e2a4a"><a href="#185538" label="[18:55:38]">&lt;muurkha&gt;</a></span><span class="message">right</span></div><div class="line" id="190332"><span class="nick" style="color:#8dd3c7"><a href="#190332" label="[19:03:32]">&lt;oriansj&gt;</a></span><span class="message">but if one allows error.h we can get away with: <a rel="nofollow" href="https://paste.debian.net/1243125/">https://paste.debian.net/1243125/</a> </span></div><div class="line" id="190512"><span class="nick" style="color:#8dd3c7"><a href="#190512" label="[19:05:12]">&lt;oriansj&gt;</a></span><span class="message">but 12 lines could get shaved if we just #include &lt;string.h&gt;</span></div><div class="line" id="200358"><span class="nick" style="color:#6b8072"><a href="#200358" label="[20:03:58]">&lt;Hagfish&gt;</a></span><span class="message">muurkha:  &quot;the people who said it was impossible are the ones who build your reputation&quot; &lt;-- that's such a positive mental hack, thank you</span></div><div class="line" id="205601"><span class="nick" style="color:#bc80bd"><a href="#205601" label="[20:56:01]">&lt;bauen1&gt;</a></span><span class="message">muurkha: yes that's sadly true way too often</span></div><div class="line" id="205611"><span class="nick" style="color:#d9d9d9"><a href="#205611" label="[20:56:11]">&lt;stikonas[m]&gt;</a></span><span class="message">fossy: I think help2man is renenerating manpage, else the date wouldn't be current month</span></div><div class="line" id="205646"><span class="nick" style="color:#d9d9d9"><a href="#205646" label="[20:56:46]">&lt;stikonas[m]&gt;</a></span><span class="message">I think I'll push the new hash to unbreak the build and then we can sort it out properly</span></div><div class="line" id="220913"><span class="nick" style="color:#2e2a4a"><a href="#220913" label="[22:09:13]">&lt;muurkha&gt;</a></span><span class="message">what is, bauen1?</span></div><div class="line" id="221009"><span class="nick" style="color:#2e2a4a"><a href="#221009" label="[22:10:09]">&lt;muurkha&gt;</a></span><span class="message">Hagfish: it's also strategically useful, not just mentally.  it gives you a free, deniable way to inflate your own reputation: fervently praise the people who said it was impossible</span></div><div class="line" id="221119"><span class="nick" style="color:#2e2a4a"><a href="#221119" label="[22:11:19]">&lt;muurkha&gt;</a></span><span class="message">by saying that such-and-such is a respected computer scientist (rather than just some loser shitposting on a forum) you are making your own achievement (doing what they said was impossible) seem more impressive.  but it doesn't sound like you're bragging!  it sounds like you're being humble</span></div><div class="line" id="221154"><span class="nick" style="color:#2e2a4a"><a href="#221154" label="[22:11:54]">&lt;muurkha&gt;</a></span><span class="message">also it reduces their motivation to continue to claim that it's impossible and that you haven't actually done it</span></div><div class="line" id="224740"><span class="nick" style="color:#bc80bd"><a href="#224740" label="[22:47:40]">&lt;bauen1&gt;</a></span><span class="message">muurkha: the thing Hagfish quoted</span></div><div class="line" id="224830"><span class="nick" style="color:#6b8072"><a href="#224830" label="[22:48:30]">&lt;Hagfish&gt;</a></span><span class="message">it's like a form of mental jujitsu, where the more negativity you face, the happier you are, and you defeat your enemy by helping their self-esteem.  it's incredible</span></div><div class="line" id="224940"><span class="nick" style="color:#6b8072"><a href="#224940" label="[22:49:40]">&lt;Hagfish&gt;</a></span><span class="message">or it's like a jedi mind trick, making your adversary say  &quot;you're right, maybe i should go away and rethink my life choices...&quot;</span></div><div class="line" id="230020"><span class="nick" style="color:#2e2a4a"><a href="#230020" label="[23:00:20]">&lt;muurkha&gt;</a></span><span class="message">also those people give you useful information; things that everyone thinks are trivial are often not worth spending your time on</span></div><div class="line" id="230037"><span class="nick" style="color:#2e2a4a"><a href="#230037" label="[23:00:37]">&lt;muurkha&gt;</a></span><span class="message">if you have money or subordinates you can get someone else to do them</span></div><div class="line" id="230844"><span class="nick" style="color:#8dd3c7"><a href="#230844" label="[23:08:44]">&lt;oriansj&gt;</a></span><span class="message">muurkha: much like the idea, no fight is worth entering unless there is the risk you will be knocked the fuck out but also a slim chance to win. If no risk of getting knocked out, it is below you. If no chance of success, discretion is the better part of valor.</span></div><div class="line" id="231634"><span class="nick" style="color:#8dd3c7"><a href="#231634" label="[23:16:34]">&lt;oriansj&gt;</a></span><span class="message">So pick up goals you think are just a little too hard for you and either get knocked out or discover that you are a stronger person than you thought you were. The more you lose, the farther you are along the path to becoming the best version of yourself.</span></div><br /></div></body></html>