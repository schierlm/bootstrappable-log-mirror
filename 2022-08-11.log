<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-08-11.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000049"><span class="nick" style="color:#389600"><a href="#000049" label="[00:00:49]">&lt;stikonas&gt;</a></span><span class="message">some of work is far less interesting, like changing ; comments into #</span></div><div class="line" id="000106"><span class="nick" style="color:#389600"><a href="#000106" label="[00:01:06]">&lt;stikonas&gt;</a></span><span class="message">(nasm/clang differences)</span></div><div class="line" id="000222"><span class="nick" style="color:#389600"><a href="#000222" label="[00:02:22]">&lt;stikonas&gt;</a></span><span class="message">but I had to use clang since it natively supports UEFI PE32 binaries</span></div><div class="line" id="002756"><span class="nick" style="color:#2e2a4a"><a href="#002756" label="[00:27:56]">&lt;theruran&gt;</a></span><span class="message">I am not disputing the need for C compiler and libc to bootstrap *everything written in C*. But to tell me that C is necessary to build an operating system is some bullshit. For one thing, there is Pre-Scheme that was already used to write the Scheme48 VM. For another, there is Ada which is objectively better than C. Another person may argue for Rust, but whatever - C is not the only choice.</span></div><div class="line" id="003000"><span class="nick" style="color:#2e2a4a"><a href="#003000" label="[00:30:00]">&lt;theruran&gt;</a></span><span class="message">I find it disturbing the affinity for C here. It is an old language that has proven itself unfit for modern applications. And I wasn't suggesting &quot;replace C with Scheme&quot;, I was asking about how to get C out of a branched bootstrap path.</span></div><div class="line" id="003426"><span class="nick" style="color:#6b8072"><a href="#003426" label="[00:34:26]">&lt;vagrantc&gt;</a></span><span class="message">how bootstrappable are those other languages?</span></div><div class="line" id="003438"><span class="nick" style="color:#6b8072"><a href="#003438" label="[00:34:38]">&lt;vagrantc&gt;</a></span><span class="message">i mean, that's what it really comes down to</span></div><div class="line" id="003501"><span class="nick" style="color:#6b8072"><a href="#003501" label="[00:35:01]">&lt;vagrantc&gt;</a></span><span class="message">there's also the question of ... who wants to work on what? :)</span></div><div class="line" id="003524"><span class="nick" style="color:#2e2a4a"><a href="#003524" label="[00:35:24]">&lt;theruran&gt;</a></span><span class="message">vagrantc: Ada is not very bootstrappable right now. and I am asking these questions because it makes no sense to me to bring C into the bootstrap path of Ada or Scheme. and you all seem to take it for granted</span></div><div class="line" id="003810"><span class="nick" style="color:#2e2a4a"><a href="#003810" label="[00:38:10]">&lt;theruran&gt;</a></span><span class="message">apparently C's &quot;easy readability&quot; did not stop people from causing thousands of CVEs</span></div><div class="line" id="003838"><span class="nick" style="color:#6b8072"><a href="#003838" label="[00:38:38]">&lt;vagrantc&gt;</a></span><span class="message">different tools for different folks ... demonstrate another bootstrap path without C that works and i'm sure people will welcome it :)</span></div><div class="line" id="003908"><span class="nick" style="color:#6b8072"><a href="#003908" label="[00:39:08]">&lt;vagrantc&gt;</a></span><span class="message">having multiple independent bootstrap paths is valuable in and of itself</span></div><div class="line" id="004013"><span class="nick" style="color:#6b8072"><a href="#004013" label="[00:40:13]">&lt;vagrantc&gt;</a></span><span class="message">that said, people have worked a fair amount on a C bootstrap path, and come very far with it, so ... it's kind of a selection bias with the people who've been working on things?</span></div><div class="line" id="004017"><span class="nick" style="color:#2e2a4a"><a href="#004017" label="[00:40:17]">&lt;theruran&gt;</a></span><span class="message">oriansj apparently gave me misleading information then, and I was trying to find out why</span></div><div class="line" id="004225"><span class="nick" style="color:#6b8072"><a href="#004225" label="[00:42:25]">&lt;vagrantc&gt;</a></span><span class="message">i read that as oriansj came to some conclusions based at having looked at options...</span></div><div class="line" id="004352"><span class="nick" style="color:#6b8072"><a href="#004352" label="[00:43:52]">&lt;vagrantc&gt;</a></span><span class="message">people might still have their disagreements, but at the end of the day, work on what motivates you</span></div><div class="line" id="004406"><span class="nick" style="color:#2e2a4a"><a href="#004406" label="[00:44:06]">&lt;theruran&gt;</a></span><span class="message">he said earlier that the Knight assembler is written in C and M1 and hex2, as a response to my questions about lisp.s</span></div><div class="line" id="004410"><span class="nick" style="color:#6b8072"><a href="#004410" label="[00:44:10]">&lt;vagrantc&gt;</a></span><span class="message">i would imagine it would be welcome to find other implementations</span></div><div class="line" id="004427"><span class="nick" style="color:#2e2a4a"><a href="#004427" label="[00:44:27]">&lt;theruran&gt;</a></span><span class="message">which made me even more confused until I checked it myself</span></div><div class="line" id="004952"><span class="nick" style="color:#389600"><a href="#004952" label="[00:49:52]">&lt;stikonas&gt;</a></span><span class="message">I don't think people say that C is the only choice</span></div><div class="line" id="005016"><span class="nick" style="color:#389600"><a href="#005016" label="[00:50:16]">&lt;stikonas&gt;</a></span><span class="message">I was just pointing out that most people are familiar with C and hence that's what is mostly used</span></div><div class="line" id="005029"><span class="nick" style="color:#389600"><a href="#005029" label="[00:50:29]">&lt;stikonas&gt;</a></span><span class="message">nobody would reject stuff just because it's non C</span></div><div class="line" id="005220"><span class="nick" style="color:#389600"><a href="#005220" label="[00:52:20]">&lt;stikonas&gt;</a></span><span class="message">the main rule is that person who gets to devide is the one who is doing the work</span></div><div class="line" id="005239"><span class="nick" style="color:#389600"><a href="#005239" label="[00:52:39]">&lt;stikonas&gt;</a></span><span class="message">if somebody is willing to do scheme programming then yes, why not</span></div><div class="line" id="005331"><span class="nick" style="color:#6b8072"><a href="#005331" label="[00:53:31]">&lt;vagrantc&gt;</a></span><span class="message">it would be great to be in a position to have to decide between two bootstrapping paths :)</span></div><div class="line" id="005407"><span class="nick" style="color:#389600"><a href="#005407" label="[00:54:07]">&lt;stikonas&gt;</a></span><span class="message">we can't even decide between 2 arches</span></div><div class="line" id="005415"><span class="nick" style="color:#389600"><a href="#005415" label="[00:54:15]">&lt;stikonas&gt;</a></span><span class="message">the whole chain only works for x86</span></div><div class="line" id="011648"><span class="nick" style="color:#80b1d3"><a href="#011648" label="[01:16:48]">&lt;oriansj&gt;</a></span><span class="message">theruran: I hope I didn't give you the impression that C is the only solution.</span></div><div class="line" id="011703"><span class="nick" style="color:#80b1d3"><a href="#011703" label="[01:17:03]">&lt;oriansj&gt;</a></span><span class="message">It is just the only one we have right now.</span></div><div class="line" id="011748"><span class="nick" style="color:#80b1d3"><a href="#011748" label="[01:17:48]">&lt;oriansj&gt;</a></span><span class="message">It is certainly possible to write Kernels in Assembly, Lisp and FORTH and they have certainly be done in the past</span></div><div class="line" id="011904"><span class="nick" style="color:#6d2462"><a href="#011904" label="[01:19:04]">&lt;muurkha&gt;</a></span><span class="message">also Pascal or Oberon</span></div><div class="line" id="011948"><span class="nick" style="color:#80b1d3"><a href="#011948" label="[01:19:48]">&lt;oriansj&gt;</a></span><span class="message">in fact the builder-hex0 work was entirely done in hex0 and I am planning on using that as well</span></div><div class="line" id="012017"><span class="nick" style="color:#6d2462"><a href="#012017" label="[01:20:17]">&lt;muurkha&gt;</a></span><span class="message">stikonas: most Scheme implementations lose less than an order of magnitude of performance compared to C, and to some extent the increased difficulty of maintenance is offset by being able to write a lot less code</span></div><div class="line" id="012036"><span class="nick" style="color:#6d2462"><a href="#012036" label="[01:20:36]">&lt;muurkha&gt;</a></span><span class="message">I don't know that Common Lisp vs. Scheme makes much of a difference</span></div><div class="line" id="012116"><span class="nick" style="color:#80b1d3"><a href="#012116" label="[01:21:16]">&lt;oriansj&gt;</a></span><span class="message">The only bias encouraged here is against the belief in magic. There isn't a person here that wouldn't celebrate progress (regardless of the language used in achieving it)</span></div><div class="line" id="012119"><span class="nick" style="color:#389600"><a href="#012119" label="[01:21:19]">&lt;stikonas&gt;</a></span><span class="message">mes is at least 2 orders of magnite slower</span></div><div class="line" id="012130"><span class="nick" style="color:#6d2462"><a href="#012130" label="[01:21:30]">&lt;muurkha&gt;</a></span><span class="message">you can get tail calls and call/cc easily if you're willing to take an additional performance hit and allocate your activation records on the heap instead of a stack</span></div><div class="line" id="012134"><span class="nick" style="color:#389600"><a href="#012134" label="[01:21:34]">&lt;stikonas&gt;</a></span><span class="message">maybe even 3</span></div><div class="line" id="012209"><span class="nick" style="color:#389600"><a href="#012209" label="[01:22:09]">&lt;stikonas&gt;</a></span><span class="message">building tcc takes almost 10 minutes with mes here</span></div><div class="line" id="012212"><span class="nick" style="color:#6d2462"><a href="#012212" label="[01:22:12]">&lt;muurkha&gt;</a></span><span class="message">I think there are lots of times where people have written Lisp interpreters in assembly, often single individuals in less than a year</span></div><div class="line" id="012219"><span class="nick" style="color:#389600"><a href="#012219" label="[01:22:19]">&lt;stikonas&gt;</a></span><span class="message">but fractions of the second to rebuild tcc with tcc</span></div><div class="line" id="012233"><span class="nick" style="color:#389600"><a href="#012233" label="[01:22:33]">&lt;stikonas&gt;</a></span><span class="message">but speed is not always important in bootstrapping</span></div><div class="line" id="012239"><span class="nick" style="color:#6d2462"><a href="#012239" label="[01:22:39]">&lt;muurkha&gt;</a></span><span class="message">they weren't Common Lisp because by the time we had Common Lisp there were better implementation languages available</span></div><div class="line" id="012256"><span class="nick" style="color:#6d2462"><a href="#012256" label="[01:22:56]">&lt;muurkha&gt;</a></span><span class="message">like MACLISP or C</span></div><div class="line" id="012402"><span class="nick" style="color:#6d2462"><a href="#012402" label="[01:24:02]">&lt;muurkha&gt;</a></span><span class="message">stikonas: I'm surprised clang has its own assembler!  maybe that's why -m32 didn't work, it wasn't gas</span></div><div class="line" id="012500"><span class="nick" style="color:#6d2462"><a href="#012500" label="[01:25:00]">&lt;muurkha&gt;</a></span><span class="message">theruran: I'm not convinced that Ada is objectively better than C but if you're up for implementing an Ada compiler in assembly, or in a small subset of Ada that can be compile with assembly, that would be super useful</span></div><div class="line" id="012554"><span class="nick" style="color:#6d2462"><a href="#012554" label="[01:25:54]">&lt;muurkha&gt;</a></span><span class="message">stikonas: yeah, mes is a very slow Scheme</span></div><div class="line" id="012558"><span class="nick" style="color:#234e69"><a href="#012558" label="[01:25:58]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, if clang was using GAS then it wouldn't be able to output uefi applications</span></div><div class="line" id="012621"><span class="nick" style="color:#6d2462"><a href="#012621" label="[01:26:21]">&lt;muurkha&gt;</a></span><span class="message">really?  I thought you could build for UEFI with GCC and gas</span></div><div class="line" id="012650"><span class="nick" style="color:#234e69"><a href="#012650" label="[01:26:50]">&lt;stikonas[m]&gt;</a></span><span class="message">I think you need to do additional magic with objcopy</span></div><div class="line" id="012729"><span class="nick" style="color:#6d2462"><a href="#012729" label="[01:27:29]">&lt;muurkha&gt;</a></span><span class="message">oh, could be</span></div><div class="line" id="012803"><span class="nick" style="color:#6d2462"><a href="#012803" label="[01:28:03]">&lt;muurkha&gt;</a></span><span class="message">anyway a simple tree-walking Lisp interpreter will generally be about 100× slower than C</span></div><div class="line" id="012813"><span class="nick" style="color:#80b1d3"><a href="#012813" label="[01:28:13]">&lt;oriansj&gt;</a></span><span class="message">heck if I remember correctly even Guix doesn't have a proper bootstrap for Ada yet as no one yet picked up the task of: extend Ada/Ed to support Ada 95, then bootstrap GNAT</span></div><div class="line" id="012821"><span class="nick" style="color:#234e69"><a href="#012821" label="[01:28:21]">&lt;stikonas[m]&gt;</a></span><span class="message">Whereas for clang you just need to set cflags and lflags</span></div><div class="line" id="012845"><span class="nick" style="color:#234e69"><a href="#012845" label="[01:28:45]">&lt;stikonas[m]&gt;</a></span><span class="message">Yea, I think ada is not yet bootsrappable</span></div><div class="line" id="012853"><span class="nick" style="color:#80b1d3"><a href="#012853" label="[01:28:53]">&lt;oriansj&gt;</a></span><span class="message">so even with GCC and all of Guix available we don't have a proper completed Ada bootstrap yet</span></div><div class="line" id="012900"><span class="nick" style="color:#6d2462"><a href="#012900" label="[01:29:00]">&lt;muurkha&gt;</a></span><span class="message">but a still relatively simple Lisp compiler can get slowdowns of under 10×</span></div><div class="line" id="012925"><span class="nick" style="color:#234e69"><a href="#012925" label="[01:29:25]">&lt;stikonas[m]&gt;</a></span><span class="message">10x slowdown is probably fine</span></div><div class="line" id="012951"><span class="nick" style="color:#80b1d3"><a href="#012951" label="[01:29:51]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I don't think speed is a good reason to not use a tool in bootstrapping when there is no better path available yet.</span></div><div class="line" id="012955"><span class="nick" style="color:#234e69"><a href="#012955" label="[01:29:55]">&lt;stikonas[m]&gt;</a></span><span class="message">1000x is slightly annoying but still much better than no bootstrap</span></div><div class="line" id="013005"><span class="nick" style="color:#234e69"><a href="#013005" label="[01:30:05]">&lt;stikonas[m]&gt;</a></span><span class="message">Exactly</span></div><div class="line" id="013158"><span class="nick" style="color:#80b1d3"><a href="#013158" label="[01:31:58]">&lt;oriansj&gt;</a></span><span class="message">heck, a year long build time to bootstrap GHC would be a dream compared to the &quot;not possible now&quot;  build time</span></div><div class="line" id="013327"><span class="nick" style="color:#6b8072"><a href="#013327" label="[01:33:27]">&lt;vagrantc&gt;</a></span><span class="message">works is better than could work :)</span></div><div class="line" id="013548"><span class="nick" style="color:#80b1d3"><a href="#013548" label="[01:35:48]">&lt;oriansj&gt;</a></span><span class="message">also nothing attracts contributors more than visible progress towards a tangible goal</span></div><div class="line" id="013830"><span class="nick" style="color:#80b1d3"><a href="#013830" label="[01:38:30]">&lt;oriansj&gt;</a></span><span class="message">and there are certainly a good few people here who love Lisp (myself included but I admit 4 years in assembly and hex2 really hurt my lisp programming skills)</span></div><div class="line" id="013936"><span class="nick" style="color:#80b1d3"><a href="#013936" label="[01:39:36]">&lt;oriansj&gt;</a></span><span class="message">including the brilliant mind behind solving the Guile bootstrapping problem: <a rel="nofollow" href="https://github.com/schierlm/guile-psyntax-bootstrapping">https://github.com/schierlm/guile-psyntax-bootstrapping</a> </span></div><div class="line" id="014540"><span class="nick" style="color:#6d2462"><a href="#014540" label="[01:45:40]">&lt;muurkha&gt;</a></span><span class="message">oriansj: you can't get a year-long build to finish successfully</span></div><div class="line" id="014648"><span class="nick" style="color:#6d2462"><a href="#014648" label="[01:46:48]">&lt;muurkha&gt;</a></span><span class="message">but I agree that the potentially higher speed of a possible but not written program is not a good reason to abstain from using something</span></div><div class="line" id="014706"><span class="nick" style="color:#6d2462"><a href="#014706" label="[01:47:06]">&lt;muurkha&gt;</a></span><span class="message">&quot;works&quot; is better than &quot;could work&quot;, or as Christine Lavin said:</span></div><div class="line" id="014714"><span class="nick" style="color:#80b1d3"><a href="#014714" label="[01:47:14]">&lt;oriansj&gt;</a></span><span class="message">muurkha: if you mean in terms of debugging and making operational, you are probably right but I was thinking more in terms of it works but on a slow machine it might take that long.</span></div><div class="line" id="014714"><span class="nick" style="color:#6d2462"><a href="#014714" label="[01:47:14]">&lt;muurkha&gt;</a></span><span class="message">&quot;The reality of me cannot compete with the dreams you have of her&quot;</span></div><div class="line" id="014732"><span class="nick" style="color:#6d2462"><a href="#014732" label="[01:47:32]">&lt;muurkha&gt;</a></span><span class="message">yeah, I meant in terms of debugging and making operational</span></div><div class="line" id="014816"><span class="nick" style="color:#6d2462"><a href="#014816" label="[01:48:16]">&lt;muurkha&gt;</a></span><span class="message">speed helps a lot with bringing stuff up</span></div><div class="line" id="014917"><span class="nick" style="color:#6d2462"><a href="#014917" label="[01:49:17]">&lt;muurkha&gt;</a></span><span class="message">the great advantage of Forth over C is that when you suspect you forgot to byteswap the data written to the I/O port or whatever, it takes you five seconds to try the fix and find out if that solved the problem, instead of 30 seconds or ten minutes</span></div><div class="line" id="014936"><span class="nick" style="color:#6d2462"><a href="#014936" label="[01:49:36]">&lt;muurkha&gt;</a></span><span class="message">to recompile your application and reflash the ROM on the board</span></div><div class="line" id="014937"><span class="nick" style="color:#80b1d3"><a href="#014937" label="[01:49:37]">&lt;oriansj&gt;</a></span><span class="message">or in the words of my friend Rachael when she was 16, dream boys are nice and all but you actually show up to put out.</span></div><div class="line" id="014949"><span class="nick" style="color:#6d2462"><a href="#014949" label="[01:49:49]">&lt;muurkha&gt;</a></span><span class="message">ha</span></div><div class="line" id="015332"><span class="nick" style="color:#80b1d3"><a href="#015332" label="[01:53:32]">&lt;oriansj&gt;</a></span><span class="message">well FORTH is absolutely killer in its niche, no doubts.</span></div><div class="line" id="015632"><span class="nick" style="color:#2e2a4a"><a href="#015632" label="[01:56:32]">&lt;theruran&gt;</a></span><span class="message">I am not that concerned about a slow LISP interpreter early in the bootstrapping path. later in the path compilers can be made</span></div><div class="line" id="015640"><span class="nick" style="color:#6d2462"><a href="#015640" label="[01:56:40]">&lt;muurkha&gt;</a></span><span class="message">I think it might be, but I can't confirm that from personal experience.  but my strong suspicion at this point is that that niche is not &quot;programming language&quot; but rather &quot;interactive computing environment&quot;</span></div><div class="line" id="015818"><span class="nick" style="color:#2e2a4a"><a href="#015818" label="[01:58:18]">&lt;theruran&gt;</a></span><span class="message">oriansj: you still did not answer my question</span></div><div class="line" id="015942"><span class="nick" style="color:#6d2462"><a href="#015942" label="[01:59:42]">&lt;muurkha&gt;</a></span><span class="message">theruran: I must have missed your question because I thought oriansj had answered it</span></div><div class="line" id="015954"><span class="nick" style="color:#234e69"><a href="#015954" label="[01:59:54]">&lt;stikonas[m]&gt;</a></span><span class="message">Ask again</span></div><div class="line" id="020016"><span class="nick" style="color:#6d2462"><a href="#020016" label="[02:00:16]">&lt;muurkha&gt;</a></span><span class="message">what was it?</span></div><div class="line" id="020119"><span class="nick" style="color:#2e2a4a"><a href="#020119" label="[02:01:19]">&lt;theruran&gt;</a></span><span class="message">&lt;@oriansj&gt; well the knight assembler is written in C, M1 and hex2</span></div><div class="line" id="020119"><span class="nick" style="color:#2e2a4a"><a href="#020119" label="[02:01:19]">&lt;theruran&gt;</a></span><span class="message">I don't understand. looking at stage0 and looks like lisp.s only needs M0-compact (and the pieces up to that point)</span></div><div class="line" id="020227"><span class="nick" style="color:#234e69"><a href="#020227" label="[02:02:27]">&lt;stikonas[m]&gt;</a></span><span class="message">What is knight assembler? Knight VM or M0 for knight</span></div><div class="line" id="020241"><span class="nick" style="color:#234e69"><a href="#020241" label="[02:02:41]">&lt;stikonas[m]&gt;</a></span><span class="message">Knight VM is definitely C</span></div><div class="line" id="020251"><span class="nick" style="color:#2e2a4a"><a href="#020251" label="[02:02:51]">&lt;theruran&gt;</a></span><span class="message">so I suppose the question is: what Knight assembler? and why is this a response to a question about lisp.s</span></div><div class="line" id="020257"><span class="nick" style="color:#234e69"><a href="#020257" label="[02:02:57]">&lt;stikonas[m]&gt;</a></span><span class="message">But that's VM</span></div><div class="line" id="020259"><span class="nick" style="color:#2e2a4a"><a href="#020259" label="[02:02:59]">&lt;theruran&gt;</a></span><span class="message">I see that Knight VM is written in C</span></div><div class="line" id="020333"><span class="nick" style="color:#2e2a4a"><a href="#020333" label="[02:03:33]">&lt;theruran&gt;</a></span><span class="message">I suppose there is no M0 for x86_64 yet?</span></div><div class="line" id="020345"><span class="nick" style="color:#2e2a4a"><a href="#020345" label="[02:03:45]">&lt;theruran&gt;</a></span><span class="message">only M2, which depends on C</span></div><div class="line" id="020349"><span class="nick" style="color:#234e69"><a href="#020349" label="[02:03:49]">&lt;stikonas[m]&gt;</a></span><span class="message">There is</span></div><div class="line" id="020400"><span class="nick" style="color:#234e69"><a href="#020400" label="[02:04:00]">&lt;stikonas[m]&gt;</a></span><span class="message">POSIX version</span></div><div class="line" id="020413"><span class="nick" style="color:#2e2a4a"><a href="#020413" label="[02:04:13]">&lt;theruran&gt;</a></span><span class="message">OK in the stage0-posix tree</span></div><div class="line" id="020431"><span class="nick" style="color:#234e69"><a href="#020431" label="[02:04:31]">&lt;stikonas[m]&gt;</a></span><span class="message">And I'll have UEFI version in a week or so</span></div><div class="line" id="020506"><span class="nick" style="color:#2e2a4a"><a href="#020506" label="[02:05:06]">&lt;theruran&gt;</a></span><span class="message">but no lisp.s in x86_64 M0, right?</span></div><div class="line" id="020515"><span class="nick" style="color:#234e69"><a href="#020515" label="[02:05:15]">&lt;stikonas[m]&gt;</a></span><span class="message">No</span></div><div class="line" id="020545"><span class="nick" style="color:#234e69"><a href="#020545" label="[02:05:45]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, that's because nobody write any software for lisp.s</span></div><div class="line" id="020609"><span class="nick" style="color:#2e2a4a"><a href="#020609" label="[02:06:09]">&lt;theruran&gt;</a></span><span class="message">you mean, &quot;right.&quot; ?</span></div><div class="line" id="020615"><span class="nick" style="color:#234e69"><a href="#020615" label="[02:06:15]">&lt;stikonas[m]&gt;</a></span><span class="message">So on knight it was bootstrapped but not used</span></div><div class="line" id="020631"><span class="nick" style="color:#234e69"><a href="#020631" label="[02:06:31]">&lt;stikonas[m]&gt;</a></span><span class="message">I meant wrote</span></div><div class="line" id="020709"><span class="nick" style="color:#234e69"><a href="#020709" label="[02:07:09]">&lt;stikonas[m]&gt;</a></span><span class="message">And then unfinished bootstrap paths tend not to be done by people doing ports, e.g POSIX port</span></div><div class="line" id="020714"><span class="nick" style="color:#80b1d3"><a href="#020714" label="[02:07:14]">&lt;oriansj&gt;</a></span><span class="message">theruran: the first thing that needs to be known is Knight is an instruction set architecture. Like VAX, PDP-11 and IBM 360</span></div><div class="line" id="020738"><span class="nick" style="color:#234e69"><a href="#020738" label="[02:07:38]">&lt;stikonas[m]&gt;</a></span><span class="message">Because everybody is doing minimal amount of work to get to goal</span></div><div class="line" id="020800"><span class="nick" style="color:#80b1d3"><a href="#020800" label="[02:08:00]">&lt;oriansj&gt;</a></span><span class="message">the knight vm is just a VM like qemu but which supports the knight instruction set</span></div><div class="line" id="020807"><span class="nick" style="color:#2e2a4a"><a href="#020807" label="[02:08:07]">&lt;theruran&gt;</a></span><span class="message">stikonas[m]: you answered no, but you meant yes or 'right'</span></div><div class="line" id="020825"><span class="nick" style="color:#234e69"><a href="#020825" label="[02:08:25]">&lt;stikonas[m]&gt;</a></span><span class="message">Oh indeed</span></div><div class="line" id="020850"><span class="nick" style="color:#234e69"><a href="#020850" label="[02:08:50]">&lt;stikonas[m]&gt;</a></span><span class="message">I meant right</span></div><div class="line" id="020913"><span class="nick" style="color:#234e69"><a href="#020913" label="[02:09:13]">&lt;stikonas[m]&gt;</a></span><span class="message">But I got confused by another typo in the following line</span></div><div class="line" id="020925"><span class="nick" style="color:#234e69"><a href="#020925" label="[02:09:25]">&lt;stikonas[m]&gt;</a></span><span class="message">write-&gt;wrote</span></div><div class="line" id="020927"><span class="nick" style="color:#2e2a4a"><a href="#020927" label="[02:09:27]">&lt;theruran&gt;</a></span><span class="message">OK. so the x86_64 defs are there for M0? just need to translate lisp.s from Knight to x86_64</span></div><div class="line" id="021008"><span class="nick" style="color:#234e69"><a href="#021008" label="[02:10:08]">&lt;stikonas[m]&gt;</a></span><span class="message">And adjust syscall numbers</span></div><div class="line" id="021020"><span class="nick" style="color:#2e2a4a"><a href="#021020" label="[02:10:20]">&lt;theruran&gt;</a></span><span class="message">alright</span></div><div class="line" id="021034"><span class="nick" style="color:#234e69"><a href="#021034" label="[02:10:34]">&lt;stikonas[m]&gt;</a></span><span class="message">But you can consider it part of translation</span></div><div class="line" id="021308"><span class="nick" style="color:#80b1d3"><a href="#021308" label="[02:13:08]">&lt;oriansj&gt;</a></span><span class="message">M0 is assembly but assembly is never portable between instruction set architectures and porting work will need to be done when moving an assembly program between instruction set architectures (sometimes it is easier to just rewrite from scratch)</span></div><div class="line" id="021444"><span class="nick" style="color:#234e69"><a href="#021444" label="[02:14:44]">&lt;stikonas[m]&gt;</a></span><span class="message">I heavily used x86/arm assembly when porting stage0-posix to riscv</span></div><div class="line" id="021455"><span class="nick" style="color:#234e69"><a href="#021455" label="[02:14:55]">&lt;stikonas[m]&gt;</a></span><span class="message">Assembly itself is not portable</span></div><div class="line" id="021505"><span class="nick" style="color:#234e69"><a href="#021505" label="[02:15:05]">&lt;stikonas[m]&gt;</a></span><span class="message">But they all have similar concepts</span></div><div class="line" id="021510"><span class="nick" style="color:#80b1d3"><a href="#021510" label="[02:15:10]">&lt;oriansj&gt;</a></span><span class="message">for example knight has div r0, r1, r2 as valid assembly but x86 and AMD64 would need several instructions (and a couple scratch registers) to approximate that</span></div><div class="line" id="021710"><span class="nick" style="color:#234e69"><a href="#021710" label="[02:17:10]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, yes, e.g. push rax would need 2 instructions on risc-v but still main building blocks are similar</span></div><div class="line" id="021715"><span class="nick" style="color:#80b1d3"><a href="#021715" label="[02:17:15]">&lt;oriansj&gt;</a></span><span class="message">(as long as one sticks to register architectures and not something very different like stack or Memory-Memory machines)</span></div><div class="line" id="021741"><span class="nick" style="color:#234e69"><a href="#021741" label="[02:17:41]">&lt;stikonas[m]&gt;</a></span><span class="message">Yeah, those might be more different</span></div><div class="line" id="021817"><span class="nick" style="color:#234e69"><a href="#021817" label="[02:18:17]">&lt;stikonas[m]&gt;</a></span><span class="message">But x86, amd64, aarch64, risc-v just differ in minor details</span></div><div class="line" id="021854"><span class="nick" style="color:#234e69"><a href="#021854" label="[02:18:54]">&lt;stikonas[m]&gt;</a></span><span class="message">And since we have x86 port that is low on registers</span></div><div class="line" id="021906"><span class="nick" style="color:#80b1d3"><a href="#021906" label="[02:19:06]">&lt;oriansj&gt;</a></span><span class="message">and a human reading and rewriting can crib rather effectively</span></div><div class="line" id="021907"><span class="nick" style="color:#234e69"><a href="#021907" label="[02:19:07]">&lt;stikonas[m]&gt;</a></span><span class="message">All other ports have plenty of free registers</span></div><div class="line" id="022036"><span class="nick" style="color:#234e69"><a href="#022036" label="[02:20:36]">&lt;stikonas[m]&gt;</a></span><span class="message">theruran: any thoughts on what you are going to build after lisp.s port?</span></div><div class="line" id="022150"><span class="nick" style="color:#80b1d3"><a href="#022150" label="[02:21:50]">&lt;oriansj&gt;</a></span><span class="message">theruran: to your specific question M0-compact is just an optimization of M0 which is just a single architecture version of M1</span></div><div class="line" id="022318"><span class="nick" style="color:#234e69"><a href="#022318" label="[02:23:18]">&lt;stikonas[m]&gt;</a></span><span class="message">What is simplified in compact version?</span></div><div class="line" id="022422"><span class="nick" style="color:#80b1d3"><a href="#022422" label="[02:24:22]">&lt;oriansj&gt;</a></span><span class="message">stikonas: it optimizes the amount of memory needed to build bigger programs written in M0 assembly</span></div><div class="line" id="022517"><span class="nick" style="color:#80b1d3"><a href="#022517" label="[02:25:17]">&lt;oriansj&gt;</a></span><span class="message">the naive M0 tends to ballon with memory requirements when building things like the output of cc_*/M2-Planet</span></div><div class="line" id="022519"><span class="nick" style="color:#234e69"><a href="#022519" label="[02:25:19]">&lt;stikonas[m]&gt;</a></span><span class="message">Oh I think on risc-v I might have done something too</span></div><div class="line" id="022544"><span class="nick" style="color:#234e69"><a href="#022544" label="[02:25:44]">&lt;stikonas[m]&gt;</a></span><span class="message">Probably calculated length of string before mallocing</span></div><div class="line" id="022657"><span class="nick" style="color:#6d2462"><a href="#022657" label="[02:26:57]">&lt;muurkha&gt;</a></span><span class="message">djb's &quot;qhasm&quot; proposal seems like it might be portable enough to be useful between instruction set architectures</span></div><div class="line" id="022727"><span class="nick" style="color:#6d2462"><a href="#022727" label="[02:27:27]">&lt;muurkha&gt;</a></span><span class="message">also of course SNOBOL4 was written in assembly and was portable between ISAs</span></div><div class="line" id="022843"><span class="nick" style="color:#6d2462"><a href="#022843" label="[02:28:43]">&lt;muurkha&gt;</a></span><span class="message">you could very reasonably compile div r0, r1, r2 to a short instruction sequence on amd64 as long as you reserve one or two registers as scratch registers for the &quot;assembler&quot;</span></div><div class="line" id="022923"><span class="nick" style="color:#80b1d3"><a href="#022923" label="[02:29:23]">&lt;oriansj&gt;</a></span><span class="message">muurkha: 1's complement and symmetric complement and floating point only architectures disagree.</span></div><div class="line" id="022944"><span class="nick" style="color:#6d2462"><a href="#022944" label="[02:29:44]">&lt;muurkha&gt;</a></span><span class="message">an i386 port that is low on registers (that's what you mean by x86, right?) could use memory for some of the &quot;registers&quot;.  certainly that's what you'd do on the 6502</span></div><div class="line" id="023044"><span class="nick" style="color:#6d2462"><a href="#023044" label="[02:30:44]">&lt;muurkha&gt;</a></span><span class="message">not familiar with symmetric complement, but I'm pretty sure SNOBOL4's implementation worked on both 1's-complement and 2's-complement machines</span></div><div class="line" id="023301"><span class="nick" style="color:#80b1d3"><a href="#023301" label="[02:33:01]">&lt;oriansj&gt;</a></span><span class="message">4bits would be 0000 -&gt; zero, 1111 -&gt; NaN, 1* -&gt; negative 0* -&gt; positive, 1110 -&gt; -1; 0001 -&gt; 1</span></div><div class="line" id="023535"><span class="nick" style="color:#80b1d3"><a href="#023535" label="[02:35:35]">&lt;oriansj&gt;</a></span><span class="message">I wonder how string comparison could work on 1's complement without also covering the -0 case; let alone the problem of architectures that don't have a condition register and those that don't have the ability to use registers for conditional jumps</span></div><div class="line" id="024120"><span class="nick" style="color:#6d2462"><a href="#024120" label="[02:41:20]">&lt;muurkha&gt;</a></span><span class="message">1's complement does suffer the problem that you need separate signed and unsigned comparisons, addition, and subtraction instructions</span></div><div class="line" id="024159"><span class="nick" style="color:#6d2462"><a href="#024159" label="[02:41:59]">&lt;muurkha&gt;</a></span><span class="message">almost nothing can use registers for conditional jumps, ARM is the only exception I can think of</span></div><div class="line" id="024222"><span class="nick" style="color:#80b1d3"><a href="#024222" label="[02:42:22]">&lt;oriansj&gt;</a></span><span class="message">knight, MIPS, Sparc, Alpha</span></div><div class="line" id="024239"><span class="nick" style="color:#6d2462"><a href="#024239" label="[02:42:39]">&lt;muurkha&gt;</a></span><span class="message">but when you're programming you handle that by reversing the sense of the condition and jumping over an unconditional jump</span></div><div class="line" id="024253"><span class="nick" style="color:#6d2462"><a href="#024253" label="[02:42:53]">&lt;muurkha&gt;</a></span><span class="message">well within the powers of a simple macro system</span></div><div class="line" id="024319"><span class="nick" style="color:#6d2462"><a href="#024319" label="[02:43:19]">&lt;muurkha&gt;</a></span><span class="message">yeah, I don't know the assembly languages of Knight, MIPS, SPARC, or Alpha ;)</span></div><div class="line" id="024348"><span class="nick" style="color:#80b1d3"><a href="#024348" label="[02:43:48]">&lt;oriansj&gt;</a></span><span class="message">at that point you just have multiple different programs written in assembly just sitting together in a single source code base with nothing actually shared.</span></div><div class="line" id="024621"><span class="nick" style="color:#2e2a4a"><a href="#024621" label="[02:46:21]">&lt;theruran&gt;</a></span><span class="message">If I can concentrate long enough to write x86_64 lisp.s, then my first thought is to port the next thing that has required C. M1?</span></div><div class="line" id="024923"><span class="nick" style="color:#80b1d3"><a href="#024923" label="[02:49:23]">&lt;oriansj&gt;</a></span><span class="message">theruran: well if you finish this port <a rel="nofollow" href="https://github.com/oriansj/slow-utils">https://github.com/oriansj/slow-utils</a>  you can make MesCC no longer have to depend on  any binaries except mes.c</span></div><div class="line" id="024931"><span class="nick" style="color:#234e69"><a href="#024931" label="[02:49:31]">&lt;stikonas[m]&gt;</a></span><span class="message">It was M2-Planet</span></div><div class="line" id="025023"><span class="nick" style="color:#80b1d3"><a href="#025023" label="[02:50:23]">&lt;oriansj&gt;</a></span><span class="message">then some work on a scheme compiler would enable theruran to entirely skip the C work</span></div><div class="line" id="025030"><span class="nick" style="color:#234e69"><a href="#025030" label="[02:50:30]">&lt;stikonas[m]&gt;</a></span><span class="message">But I guess you don't want to port lisp.s just to use it to build C compiler</span></div><div class="line" id="025117"><span class="nick" style="color:#80b1d3"><a href="#025117" label="[02:51:17]">&lt;oriansj&gt;</a></span><span class="message">as theruran could just compile mescc and slow-utils into a single binary which would be able to self-host</span></div><div class="line" id="025144"><span class="nick" style="color:#234e69"><a href="#025144" label="[02:51:44]">&lt;stikonas[m]&gt;</a></span><span class="message">That's an option...</span></div><div class="line" id="025212"><span class="nick" style="color:#234e69"><a href="#025212" label="[02:52:12]">&lt;stikonas[m]&gt;</a></span><span class="message">Probably a lot of work but if theruran finds it fun then good</span></div><div class="line" id="025220"><span class="nick" style="color:#80b1d3"><a href="#025220" label="[02:52:20]">&lt;oriansj&gt;</a></span><span class="message">and theruran here is a scheme compiler which could save you some time: <a rel="nofollow" href="http://canonical.org/~kragen/sw/urscheme/">http://canonical.org/~kragen/sw/urscheme/</a> </span></div><div class="line" id="025636"><span class="nick" style="color:#6d2462"><a href="#025636" label="[02:56:36]">&lt;muurkha&gt;</a></span><span class="message">oriansj: the idea is that your &quot;assembler&quot; (or macro package) knows how to assemble things like three-argument div or conditional jump to register for a given platform</span></div><div class="line" id="025657"><span class="nick" style="color:#6d2462"><a href="#025657" label="[02:56:57]">&lt;muurkha&gt;</a></span><span class="message">that's how SNOBOL4 achieved its incredible degree of portability</span></div><div class="line" id="025837"><span class="nick" style="color:#80b1d3"><a href="#025837" label="[02:58:37]">&lt;oriansj&gt;</a></span><span class="message">muurkha: sounds like SNOBOL4 just did a simple high level language which compiled to native or an O-code sort of machine</span></div><div class="line" id="025901"><span class="nick" style="color:#6d2462"><a href="#025901" label="[02:59:01]">&lt;muurkha&gt;</a></span><span class="message">well, kind of, but the O-code instructions were implemented as assembler macros</span></div><div class="line" id="025907"><span class="nick" style="color:#6d2462"><a href="#025907" label="[02:59:07]">&lt;muurkha&gt;</a></span><span class="message">rather than interpreted at runtime</span></div><div class="line" id="030000"><span class="nick" style="color:#80b1d3"><a href="#030000" label="[03:00:00]">&lt;oriansj&gt;</a></span><span class="message">so %define ADD_R0_R1 add rax, rbx sort of thing</span></div><div class="line" id="030049"><span class="nick" style="color:#6d2462"><a href="#030049" label="[03:00:49]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="030049"><span class="nick" style="color:#80b1d3"><a href="#030049" label="[03:00:49]">&lt;oriansj&gt;</a></span><span class="message">with a human having to figure out the right combination of replacement strings to make it sorta work</span></div><div class="line" id="030155"><span class="nick" style="color:#6d2462"><a href="#030155" label="[03:01:55]">&lt;muurkha&gt;</a></span><span class="message">yeah.  very similar to Ur-Scheme really, but without reordering prefix notation into postfix</span></div><div class="line" id="030214"><span class="nick" style="color:#234e69"><a href="#030214" label="[03:02:14]">&lt;stikonas[m]&gt;</a></span><span class="message">So kind of cross platform M0</span></div><div class="line" id="030238"><span class="nick" style="color:#234e69"><a href="#030238" label="[03:02:38]">&lt;stikonas[m]&gt;</a></span><span class="message">Can't we already do that with M0?</span></div><div class="line" id="030254"><span class="nick" style="color:#234e69"><a href="#030254" label="[03:02:54]">&lt;stikonas[m]&gt;</a></span><span class="message">Just needs suitable definition file</span></div><div class="line" id="030314"><span class="nick" style="color:#234e69"><a href="#030314" label="[03:03:14]">&lt;stikonas[m]&gt;</a></span><span class="message">And possibly two passes</span></div><div class="line" id="030358"><span class="nick" style="color:#80b1d3"><a href="#030358" label="[03:03:58]">&lt;oriansj&gt;</a></span><span class="message">hmmm <a rel="nofollow" href="https://www.regressive.org/snobol4/doc/arizona/s4d58.pdf">https://www.regressive.org/snobol4/doc/arizona/s4d58.pdf</a> </span></div><div class="line" id="030412"><span class="nick" style="color:#6d2462"><a href="#030412" label="[03:04:12]">&lt;muurkha&gt;</a></span><span class="message">also <a rel="nofollow" href="https://archive.org/details/macroimplementat0000gris">https://archive.org/details/macroimplementat0000gris</a> </span></div><div class="line" id="030444"><span class="nick" style="color:#80b1d3"><a href="#030444" label="[03:04:44]">&lt;oriansj&gt;</a></span><span class="message">stikonas: with a boatload more effort, absolutely</span></div><div class="line" id="030524"><span class="nick" style="color:#234e69"><a href="#030524" label="[03:05:24]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, yes, it would be harder to write that cross-platform M0</span></div><div class="line" id="030558"><span class="nick" style="color:#234e69"><a href="#030558" label="[03:05:58]">&lt;stikonas[m]&gt;</a></span><span class="message">And in one more step we get it via cc_* anyway</span></div><div class="line" id="030627"><span class="nick" style="color:#80b1d3"><a href="#030627" label="[03:06:27]">&lt;oriansj&gt;</a></span><span class="message">well it would have to be M1 because M0 isn't cross-platform and doesn't handle things that are different between ports</span></div><div class="line" id="030636"><span class="nick" style="color:#6d2462"><a href="#030636" label="[03:06:36]">&lt;muurkha&gt;</a></span><span class="message">worth mentioning that the reason SNOBOL4 was written like this was that C didn't exist yet</span></div><div class="line" id="030655"><span class="nick" style="color:#80b1d3"><a href="#030655" label="[03:06:55]">&lt;oriansj&gt;</a></span><span class="message">and people complained too much</span></div><div class="line" id="030709"><span class="nick" style="color:#6d2462"><a href="#030709" label="[03:07:09]">&lt;muurkha&gt;</a></span><span class="message">they wrote the SNOBOL4 replacement, Icon (now Unicon), in C</span></div><div class="line" id="030711"><span class="nick" style="color:#80b1d3"><a href="#030711" label="[03:07:11]">&lt;oriansj&gt;</a></span><span class="message">about incompatibility and bugs in versions that they hadn't written</span></div><div class="line" id="030737"><span class="nick" style="color:#6d2462"><a href="#030737" label="[03:07:37]">&lt;muurkha&gt;</a></span><span class="message">haha</span></div><div class="line" id="190508"><span class="nick" style="color:#2e2a4a"><a href="#190508" label="[19:05:08]">&lt;theruran&gt;</a></span><span class="message">what is the difference between M0 and M1?</span></div><div class="line" id="190545"><span class="nick" style="color:#6c3d55"><a href="#190545" label="[19:05:45]">&lt;unmatched-paren&gt;</a></span><span class="message">theruran: iiuc: M1 is a slightly improved version of M0 that adds labels</span></div><div class="line" id="190551"><span class="nick" style="color:#6c3d55"><a href="#190551" label="[19:05:51]">&lt;unmatched-paren&gt;</a></span><span class="message">Ah, wait</span></div><div class="line" id="190602"><span class="nick" style="color:#6c3d55"><a href="#190602" label="[19:06:02]">&lt;unmatched-paren&gt;</a></span><span class="message">i'm conflating hex0/hex1 and M0/M1</span></div><div class="line" id="190605"><span class="nick" style="color:#6c3d55"><a href="#190605" label="[19:06:05]">&lt;unmatched-paren&gt;</a></span><span class="message">ignore me :)</span></div><div class="line" id="190845"><span class="nick" style="color:#389600"><a href="#190845" label="[19:08:45]">&lt;stikonas&gt;</a></span><span class="message">theruran: M1 is slightly improved version of M0 that is cross-platform</span></div><div class="line" id="190904"><span class="nick" style="color:#389600"><a href="#190904" label="[19:09:04]">&lt;stikonas&gt;</a></span><span class="message">so M1 should support all arches (not just the one that is being bootstrapped)</span></div><div class="line" id="190914"><span class="nick" style="color:#389600"><a href="#190914" label="[19:09:14]">&lt;stikonas&gt;</a></span><span class="message">and M1 should be able to print better error messages</span></div><div class="line" id="190927"><span class="nick" style="color:#389600"><a href="#190927" label="[19:09:27]">&lt;stikonas&gt;</a></span><span class="message">e.g. print if we used DEFINE that is not defined</span></div><div class="line" id="190938"><span class="nick" style="color:#389600"><a href="#190938" label="[19:09:38]">&lt;stikonas&gt;</a></span><span class="message">M0 simply exits with non-zero error code</span></div><div class="line" id="191007"><span class="nick" style="color:#389600"><a href="#191007" label="[19:10:07]">&lt;stikonas&gt;</a></span><span class="message">also M1 supports multiple input files</span></div><div class="line" id="191023"><span class="nick" style="color:#389600"><a href="#191023" label="[19:10:23]">&lt;stikonas&gt;</a></span><span class="message">with M0 it is &quot;M0 in.M1 out.hex2&quot;</span></div><div class="line" id="191108"><span class="nick" style="color:#389600"><a href="#191108" label="[19:11:08]">&lt;stikonas&gt;</a></span><span class="message">with M1 you can have &quot;M1 --architecture x86 --little-endian --file header.M1 --file program.M1 --output output.hex2&quot;</span></div><div class="line" id="191131"><span class="nick" style="color:#389600"><a href="#191131" label="[19:11:31]">&lt;stikonas&gt;</a></span><span class="message">also M0 might have more limitations</span></div><div class="line" id="191159"><span class="nick" style="color:#389600"><a href="#191159" label="[19:11:59]">&lt;stikonas&gt;</a></span><span class="message">e.g. it might only support uppercases hexes (liek 0xA but not 0xa), etc...</span></div><div class="line" id="191253"><span class="nick" style="color:#389600"><a href="#191253" label="[19:12:53]">&lt;stikonas&gt;</a></span><span class="message">there are also two hex2's one is written in hex1 the other in C or you can write it in some other high level language</span></div><div class="line" id="193823"><span class="nick" style="color:#2e2a4a"><a href="#193823" label="[19:38:23]">&lt;theruran&gt;</a></span><span class="message">and M1 is written in combination C and M0?</span></div><div class="line" id="202510"><span class="nick" style="color:#389600"><a href="#202510" label="[20:25:10]">&lt;stikonas&gt;</a></span><span class="message">theruran: M1 is written in C</span></div><div class="line" id="202545"><span class="nick" style="color:#389600"><a href="#202545" label="[20:25:45]">&lt;stikonas&gt;</a></span><span class="message">it's then compiled using M2-Planet into M1, hex2 and eventually binary</span></div><br /></div></body></html>