<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-11-08.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="020638"><span class="nick" style="color:#389600"><a href="#020638" label="[02:06:38]">&lt;stikonas&gt;</a></span><span class="message">oriansj: when you have some free time (but no rush) could you please review <a rel="nofollow" href="https://github.com/oriansj/M2-Planet/pull/44">https://github.com/oriansj/M2-Planet/pull/44</a> </span></div><div class="line" id="205918"><span class="nick" style="color:#8dd3c7"><a href="#205918" label="[20:59:18]">&lt;oriansj&gt;</a></span><span class="message">stikonas: not all stacks grow in the same direction</span></div><div class="line" id="210003"><span class="nick" style="color:#8dd3c7"><a href="#210003" label="[21:00:03]">&lt;oriansj&gt;</a></span><span class="message">and the reason some grow positive and some grow negative because that is the difference between the architectures.</span></div><div class="line" id="210126"><span class="nick" style="color:#2e2a4a"><a href="#210126" label="[21:01:26]">&lt;muurkha&gt;</a></span><span class="message">which architectures have positive-growing stacks?  maybe S/360?</span></div><div class="line" id="210221"><span class="nick" style="color:#6b8072"><a href="#210221" label="[21:02:21]">&lt;sam_&gt;</a></span><span class="message">hppa, ia64 sometimes iirc</span></div><div class="line" id="210223"><span class="nick" style="color:#6b8072"><a href="#210223" label="[21:02:23]">&lt;sam_&gt;</a></span><span class="message">not sure about others</span></div><div class="line" id="210237"><span class="nick" style="color:#2e2a4a"><a href="#210237" label="[21:02:37]">&lt;muurkha&gt;</a></span><span class="message">oh neat, thanks</span></div><div class="line" id="210246"><span class="nick" style="color:#2e2a4a"><a href="#210246" label="[21:02:46]">&lt;muurkha&gt;</a></span><span class="message">I've actually used hppa and never realized that</span></div><div class="line" id="210258"><span class="nick" style="color:#2e2a4a"><a href="#210258" label="[21:02:58]">&lt;muurkha&gt;</a></span><span class="message">I don't think I ever used Itanic</span></div><div class="line" id="210340"><span class="nick" style="color:#6b8072"><a href="#210340" label="[21:03:40]">&lt;sam_&gt;</a></span><span class="message"> <a rel="nofollow" href="https://stackoverflow.com/questions/664744/what-is-the-direction-of-stack-growth-in-most-modern-systems?noredirect=1">https://stackoverflow.com/questions/664744/what-is-the-direction-of-stack-growth-in-most-modern-systems?noredirect=1</a>  apparently sparc can do either but convention is down (TIL)</span></div><div class="line" id="210347"><span class="nick" style="color:#6b8072"><a href="#210347" label="[21:03:47]">&lt;sam_&gt;</a></span><span class="message">i swear ia64 has a weird bi-directional thing</span></div><div class="line" id="210350"><span class="nick" style="color:#6b8072"><a href="#210350" label="[21:03:50]">&lt;sam_&gt;</a></span><span class="message">but yeah hppa is the big one</span></div><div class="line" id="210413"><span class="nick" style="color:#2e2a4a"><a href="#210413" label="[21:04:13]">&lt;muurkha&gt;</a></span><span class="message">yeah on sparc it's up to the register window wraparound fault handler</span></div><div class="line" id="210525"><span class="nick" style="color:#6b8072"><a href="#210525" label="[21:05:25]">&lt;sam_&gt;</a></span><span class="message">tangential but i'm interested if anyone else feels the same way</span></div><div class="line" id="210529"><span class="nick" style="color:#6b8072"><a href="#210529" label="[21:05:29]">&lt;sam_&gt;</a></span><span class="message">why does nobody talk about arm be?</span></div><div class="line" id="210533"><span class="nick" style="color:#6b8072"><a href="#210533" label="[21:05:33]">&lt;sam_&gt;</a></span><span class="message">like if you google it, you would think it doesn'te xist</span></div><div class="line" id="210558"><span class="nick" style="color:#6b8072"><a href="#210558" label="[21:05:58]">&lt;sam_&gt;</a></span><span class="message">(or barely exists, or most hw isn't capable of it, despite the fact they can)</span></div><div class="line" id="210617"><span class="nick" style="color:#8dd3c7"><a href="#210617" label="[21:06:17]">&lt;oriansj&gt;</a></span><span class="message">not to mention a bunch of 8/16 bit processors grow their stack in the correct direction</span></div><div class="line" id="210652"><span class="nick" style="color:#8dd3c7"><a href="#210652" label="[21:06:52]">&lt;oriansj&gt;</a></span><span class="message">68000, knight, etc</span></div><div class="line" id="210745"><span class="nick" style="color:#2e2a4a"><a href="#210745" label="[21:07:45]">&lt;muurkha&gt;</a></span><span class="message">:)</span></div><div class="line" id="210758"><span class="nick" style="color:#8dd3c7"><a href="#210758" label="[21:07:58]">&lt;oriansj&gt;</a></span><span class="message">and risc-v if you choose the correct instructions</span></div><div class="line" id="210759"><span class="nick" style="color:#2e2a4a"><a href="#210759" label="[21:07:59]">&lt;muurkha&gt;</a></span><span class="message">hey, don't be dissing my bro 68000</span></div><div class="line" id="210841"><span class="nick" style="color:#2e2a4a"><a href="#210841" label="[21:08:41]">&lt;muurkha&gt;</a></span><span class="message">he's got 32 full, thick, rich bits in every register</span></div><div class="line" id="210852"><span class="nick" style="color:#8dd3c7"><a href="#210852" label="[21:08:52]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well the split address/data registers was a bad idea but the cold-fire follow-on did fix it</span></div><div class="line" id="210952"><span class="nick" style="color:#8dd3c7"><a href="#210952" label="[21:09:52]">&lt;oriansj&gt;</a></span><span class="message">stikonas: merged</span></div><div class="line" id="211015"><span class="nick" style="color:#389600"><a href="#211015" label="[21:10:15]">&lt;stikonas&gt;</a></span><span class="message">oriansj: thanks</span></div><div class="line" id="211031"><span class="nick" style="color:#389600"><a href="#211031" label="[21:10:31]">&lt;stikonas&gt;</a></span><span class="message">oriansj: well, for stacks that grow the other direction there is no need to adjust struct offsets</span></div><div class="line" id="211034"><span class="nick" style="color:#2e2a4a"><a href="#211034" label="[21:10:34]">&lt;muurkha&gt;</a></span><span class="message">it's at least a debatable idea.  a lot of processors did that, like the CDC 6600, both because commonly your addresses are an inconvenient size for data, and because it saves you an operand bit in every operand field</span></div><div class="line" id="211058"><span class="nick" style="color:#389600"><a href="#211058" label="[21:10:58]">&lt;stikonas&gt;</a></span><span class="message">for normal stacks that grow downwards, I had to put struct at the bottom of the allocated space, so that positive struct offsets end up in the right location</span></div><div class="line" id="211110"><span class="nick" style="color:#2e2a4a"><a href="#211110" label="[21:11:10]">&lt;muurkha&gt;</a></span><span class="message">the disadvantage is that it makes your instruction set less orthogonal and sometimes requires ugly workarounds, though I don't remember any of those on the 68k</span></div><div class="line" id="211119"><span class="nick" style="color:#389600"><a href="#211119" label="[21:11:19]">&lt;stikonas&gt;</a></span><span class="message">but if I understand, everything that M2-Planet supports had downwards stacks</span></div><div class="line" id="211250"><span class="nick" style="color:#389600"><a href="#211250" label="[21:12:50]">&lt;stikonas&gt;</a></span><span class="message">anyway, struct support in M2-Planet is now much more complete</span></div><div class="line" id="211357"><span class="nick" style="color:#8dd3c7"><a href="#211357" label="[21:13:57]">&lt;oriansj&gt;</a></span><span class="message">stikonas: I appreciate you helping to make M2-Planet a more complete C compiler ^_^</span></div><div class="line" id="211556"><span class="nick" style="color:#2e2a4a"><a href="#211556" label="[21:15:56]">&lt;muurkha&gt;</a></span><span class="message">:)</span></div><div class="line" id="211617"><span class="nick" style="color:#8dd3c7"><a href="#211617" label="[21:16:17]">&lt;oriansj&gt;</a></span><span class="message">the problem with stacks growing down is you either need to put your code at some address above the stack area (and below your heap area) or you need to setup guard pages (assuming your architecture supports it) to prevent your program from being altered by stack variables</span></div><div class="line" id="211751"><span class="nick" style="color:#8dd3c7"><a href="#211751" label="[21:17:51]">&lt;oriansj&gt;</a></span><span class="message">of course if your architecture doesn't treat wrapping around the top to the bottom address (and/or bottowm to top address) as an exception, it doesn't save you much either.</span></div><div class="line" id="212548"><span class="nick" style="color:#2e2a4a"><a href="#212548" label="[21:25:48]">&lt;muurkha&gt;</a></span><span class="message">you know, it'd be nice to have hardware that traps when your stack pointer exceeds a limit</span></div><div class="line" id="212652"><span class="nick" style="color:#2e2a4a"><a href="#212652" label="[21:26:52]">&lt;muurkha&gt;</a></span><span class="message">it's the kind of thing that's easy and cheap in hardware (assuming you have traps already and that they don't use the stack) and a pain in software</span></div><div class="line" id="212714"><span class="nick" style="color:#2e2a4a"><a href="#212714" label="[21:27:14]">&lt;muurkha&gt;</a></span><span class="message">you could use the same kind of thing for fast generational GC</span></div><div class="line" id="212919"><span class="nick" style="color:#2e2a4a"><a href="#212919" label="[21:29:19]">&lt;muurkha&gt;</a></span><span class="message">I mean I know currently fashionable CPUs with OoO and speculative execution don't benefit much</span></div><div class="line" id="220718"><span class="nick" style="color:#8dd3c7"><a href="#220718" label="[22:07:18]">&lt;oriansj&gt;</a></span><span class="message">muurkha: you mean like x86 segments, well yes bounds pointers work well if your address is too small or you lack proper virtual memory support</span></div><div class="line" id="221325"><span class="nick" style="color:#2e2a4a"><a href="#221325" label="[22:13:25]">&lt;muurkha&gt;</a></span><span class="message">not like x86 segments, because those don't have bounds and because in the GC case you don't want to apply the same bounds to object pointers that you apply to the allocation pointer</span></div><div class="line" id="221532"><span class="nick" style="color:#8dd3c7"><a href="#221532" label="[22:15:32]">&lt;oriansj&gt;</a></span><span class="message"> so more like the Burroughs Large Systems architecture</span></div><div class="line" id="221537"><span class="nick" style="color:#8dd3c7"><a href="#221537" label="[22:15:37]">&lt;oriansj&gt;</a></span><span class="message">'s segments?</span></div><div class="line" id="221555"><span class="nick" style="color:#2e2a4a"><a href="#221555" label="[22:15:55]">&lt;muurkha&gt;</a></span><span class="message">well, those do at least have the bounds, but they still don't handle the other consideration I mentioned</span></div><div class="line" id="221558"><span class="nick" style="color:#2e2a4a"><a href="#221558" label="[22:15:58]">&lt;muurkha&gt;</a></span><span class="message">let me elucidate</span></div><div class="line" id="221623"><span class="nick" style="color:#2e2a4a"><a href="#221623" label="[22:16:23]">&lt;muurkha&gt;</a></span><span class="message">what i mean is that an open-coded pointer-bumping nursery allocator in a generational GC is typically 3-5 instructions: copy the bump-pointer register into some other register, add some compile-time constant to it, compare the new value against some bound (possibly in another register or possibly a compile-time constant) and conditionally call the garbage collector</span></div><div class="line" id="221659"><span class="nick" style="color:#2e2a4a"><a href="#221659" label="[22:16:59]">&lt;muurkha&gt;</a></span><span class="message">(if you have exceeded the bound)</span></div><div class="line" id="221747"><span class="nick" style="color:#2e2a4a"><a href="#221747" label="[22:17:47]">&lt;muurkha&gt;</a></span><span class="message">this is the main CPU hog in hot loops in a lot of pure-functional code, because it needs to allocate new memory for every new larger-than-a-register value it computes</span></div><div class="line" id="221807"><span class="nick" style="color:#8dd3c7"><a href="#221807" label="[22:18:07]">&lt;oriansj&gt;</a></span><span class="message">so per segment exception pointers?</span></div><div class="line" id="221848"><span class="nick" style="color:#8dd3c7"><a href="#221848" label="[22:18:48]">&lt;oriansj&gt;</a></span><span class="message">sounds like tagged memory would be a better match</span></div><div class="line" id="221849"><span class="nick" style="color:#2e2a4a"><a href="#221849" label="[22:18:49]">&lt;muurkha&gt;</a></span><span class="message">when the GC gets invoked it copies all the (hopefully few) surviving objects in the nursery out into the next generation, and it rewrites all the pointers to them, and possibly the pointer that was just allocated as well</span></div><div class="line" id="221946"><span class="nick" style="color:#2e2a4a"><a href="#221946" label="[22:19:46]">&lt;muurkha&gt;</a></span><span class="message">the crucial part here is that when user code follows a pointer, it doesn't normally know whether that pointer points into the nursery or not.  in fact it might change from one moment to the next if the garbage collector got invoked in between</span></div><div class="line" id="222051"><span class="nick" style="color:#2e2a4a"><a href="#222051" label="[22:20:51]">&lt;muurkha&gt;</a></span><span class="message">now, if you had the CPU trap whenever you incremented the allocation pointer past the bound, the 3???5 instruction allocation sequence would become 2 instructions, which makes a lot of difference on an in-order processor</span></div><div class="line" id="222108"><span class="nick" style="color:#8dd3c7"><a href="#222108" label="[22:21:08]">&lt;oriansj&gt;</a></span><span class="message">hmmm, I am not a fan of hardware garbage collectors. I see their advantages and recognize the benefits that they bring but I don't feel they are the right abstraction in hardware.</span></div><div class="line" id="222111"><span class="nick" style="color:#2e2a4a"><a href="#222111" label="[22:21:11]">&lt;muurkha&gt;</a></span><span class="message">but you don't want to trap whenever *any* pointer into the nursery goes out of the bounds of the nursery</span></div><div class="line" id="222126"><span class="nick" style="color:#2e2a4a"><a href="#222126" label="[22:21:26]">&lt;muurkha&gt;</a></span><span class="message">yeah, I'm not suggesting a hardware garbage collector or Burroughs-style segmentation or tagged memory</span></div><div class="line" id="222240"><span class="nick" style="color:#2e2a4a"><a href="#222240" label="[22:22:40]">&lt;muurkha&gt;</a></span><span class="message">I'm saying that a CPU that invoked a trap handler when you bumped the allocation pointer out of the nursery would speed up the allocation fast path on in-order CPUs, which would speed up a lot of things</span></div><div class="line" id="222424"><span class="nick" style="color:#2e2a4a"><a href="#222424" label="[22:24:24]">&lt;muurkha&gt;</a></span><span class="message">I guess you could do this with Burroughs-style segmentation if your ordinary object pointers were (segment, offset) pairs.  when they were nursery objects the segment would be the nursery segment, and when the GC came around it would rewrite them to be pointers into some other segment</span></div><div class="line" id="222425"><span class="nick" style="color:#8dd3c7"><a href="#222425" label="[22:24:25]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well that is the thing, not many things should need to be reallocated</span></div><div class="line" id="222442"><span class="nick" style="color:#2e2a4a"><a href="#222442" label="[22:24:42]">&lt;muurkha&gt;</a></span><span class="message">you mean copying is bad?</span></div><div class="line" id="222510"><span class="nick" style="color:#2e2a4a"><a href="#222510" label="[22:25:10]">&lt;muurkha&gt;</a></span><span class="message">(but Burroughs-style segmentation is definitely not what I had in mind, even if it wouldn't be actually incompatible as I thought at first)</span></div><div class="line" id="222511"><span class="nick" style="color:#8dd3c7"><a href="#222511" label="[22:25:11]">&lt;oriansj&gt;</a></span><span class="message">when you don't have to copy, why waste the cycles copying</span></div><div class="line" id="222528"><span class="nick" style="color:#8dd3c7"><a href="#222528" label="[22:25:28]">&lt;oriansj&gt;</a></span><span class="message">copy-on-write is perfectly reasonable</span></div><div class="line" id="222536"><span class="nick" style="color:#2e2a4a"><a href="#222536" label="[22:25:36]">&lt;muurkha&gt;</a></span><span class="message">well, because it turns out that programs written using generational copying collectors are usually faster than programs that do the same task written using explicit allocation and freeing</span></div><div class="line" id="222611"><span class="nick" style="color:#2e2a4a"><a href="#222611" label="[22:26:11]">&lt;muurkha&gt;</a></span><span class="message">I mean, heap allocation.  programs that do the same task with only stack allocation are even faster when they are possible</span></div><div class="line" id="222658"><span class="nick" style="color:#2e2a4a"><a href="#222658" label="[22:26:58]">&lt;muurkha&gt;</a></span><span class="message">also, programs written using garbage collection (of whatever kind) are usually simpler than programs that use explicit heap allocation and freeing, even now that we have Rust to automate the freeing</span></div><div class="line" id="222743"><span class="nick" style="color:#8dd3c7"><a href="#222743" label="[22:27:43]">&lt;oriansj&gt;</a></span><span class="message">well if the freeing of memory can be calculated at compile time, is it really garbage collection?</span></div><div class="line" id="223436"><span class="nick" style="color:#2e2a4a"><a href="#223436" label="[22:34:36]">&lt;muurkha&gt;</a></span><span class="message">sometimes people call it that, but I'm talking about the cases where it can't</span></div><div class="line" id="224029"><span class="nick" style="color:#2e2a4a"><a href="#224029" label="[22:40:29]">&lt;muurkha&gt;</a></span><span class="message">I think tagged memory and stuff is interesting too, it's just a different thing</span></div><div class="line" id="224117"><span class="nick" style="color:#2e2a4a"><a href="#224117" label="[22:41:17]">&lt;muurkha&gt;</a></span><span class="message">the same kind of bounding thing is useful for stack segmentation and thus reducing the cost of multithreading and call/cc</span></div><div class="line" id="233749"><span class="nick" style="color:#389600"><a href="#233749" label="[23:37:49]">&lt;stikonas&gt;</a></span><span class="message">oriansj: I suspect the next low hanging fruit for M2-Planet are local arrays, though I won't be working on them (at least for now)</span></div><div class="line" id="041541"><span class="nick" style="color:#8dd3c7"><a href="#041541" label="[04:15:41]">&lt;oriansj&gt;</a></span><span class="message">stikonas: or array initialization</span></div><div class="line" id="041745"><span class="nick" style="color:#8dd3c7"><a href="#041745" label="[04:17:45]">&lt;oriansj&gt;</a></span><span class="message">but M2-Planet is already well past the minimal C feature set to write clean C code and do real useful work; and now it is just a matter of slowly expanding to the level needed for any code that wants to be M2-Planet bootstrapped.</span></div><div class="line" id="042432"><span class="nick" style="color:#2e2a4a"><a href="#042432" label="[04:24:32]">&lt;muurkha&gt;</a></span><span class="message">do you think that's a good idea?  maybe it would be better to compile that other code with tcc</span></div><div class="line" id="042448"><span class="nick" style="color:#2e2a4a"><a href="#042448" label="[04:24:48]">&lt;muurkha&gt;</a></span><span class="message">I mean every new feature is a potential backdoor, right?</span></div><div class="line" id="042714"><span class="nick" style="color:#8dd3c7"><a href="#042714" label="[04:27:14]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well at this point it isn't about what I think is a good idea or not but rather what C features other people *need*</span></div><div class="line" id="042911"><span class="nick" style="color:#8dd3c7"><a href="#042911" label="[04:29:11]">&lt;oriansj&gt;</a></span><span class="message">and as long as it remains buildable by cc_*; then any backdoor would have to be in the vary easy to reason about assembly (in M2libc) or in C code (Which is missing most of the easy to abuse C features) so it would be relatively easy to reason about.</span></div><div class="line" id="043253"><span class="nick" style="color:#8dd3c7"><a href="#043253" label="[04:32:53]">&lt;oriansj&gt;</a></span><span class="message">and any constructs that look abusive (or atleast more complex than any of the code in M2-Mesoplanet or blynn-compiler) should immediately be suspect.</span></div><br /></div></body></html>