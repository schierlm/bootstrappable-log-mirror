<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-11-02.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="001014"><span class="nick" style="color:#8dd3c7"><a href="#001014" label="[00:10:14]">&lt;muurkha&gt;</a></span><span class="message">stikonas: do you think a buddy malloc will be simpler than a PDP-11-style first-fit free-list malloc?  or is it that the efficiency gain will be worth the extra complexit?</span></div><div class="line" id="001137"><span class="nick" style="color:#2e2a4a"><a href="#001137" label="[00:11:37]">&lt;stikonas&gt;</a></span><span class="message">well, I guess first fit might be simpler</span></div><div class="line" id="001145"><span class="nick" style="color:#2e2a4a"><a href="#001145" label="[00:11:45]">&lt;stikonas&gt;</a></span><span class="message">maybe it's worth considering that too</span></div><div class="line" id="001158"><span class="nick" style="color:#2e2a4a"><a href="#001158" label="[00:11:58]">&lt;stikonas&gt;</a></span><span class="message">given that we don't care too much about efficiency but care about readability</span></div><div class="line" id="001556"><span class="nick" style="color:#2e2a4a"><a href="#001556" label="[00:15:56]">&lt;stikonas&gt;</a></span><span class="message">well, actually the simplest thing to do is not to implement any free at all...</span></div><div class="line" id="001616"><span class="nick" style="color:#2e2a4a"><a href="#001616" label="[00:16:16]">&lt;stikonas&gt;</a></span><span class="message">just port malloc away from _brk to block style allocator...</span></div><div class="line" id="005020"><span class="nick" style="color:#6b8072"><a href="#005020" label="[00:50:20]">&lt;stikonas[m]&gt;</a></span><span class="message">I guess that would be first step in and case no matter what allocator is used</span></div><div class="line" id="012558"><span class="nick" style="color:#80b1d3"><a href="#012558" label="[01:25:58]">&lt;oriansj&gt;</a></span><span class="message">well we need a bit of complexity to do block tracking (otherwise every 3byte malloc would end up using a full block [4KB+]) and at which point we might as make free work.</span></div><div class="line" id="013306"><span class="nick" style="color:#2e2a4a"><a href="#013306" label="[01:33:06]">&lt;stikonas&gt;</a></span><span class="message">oriansj: can't we do something even simpler kind of keep current linear allocation [new_malloc_ptr = old malloc + requested memory] if there is enough memory in current e.g. 4 KiB block, if there isn't then request from OS (either using brk or in UEFI allocate_pages) the minimum number of pages that would fit current malloc request</span></div><div class="line" id="013321"><span class="nick" style="color:#2e2a4a"><a href="#013321" label="[01:33:21]">&lt;stikonas&gt;</a></span><span class="message">so if we do many 3 byte mallocs, they'll all go to the same block</span></div><div class="line" id="013429"><span class="nick" style="color:#2e2a4a"><a href="#013429" label="[01:34:29]">&lt;stikonas&gt;</a></span><span class="message">though if you do 3 byte malloc followed by 10 KiB malloc, then yes 3 byte malloc will end up using full block once, though if you request another 3 byte malloc, it might fit at the end of 10 KiB earlier allocation</span></div><div class="line" id="013514"><span class="nick" style="color:#2e2a4a"><a href="#013514" label="[01:35:14]">&lt;stikonas&gt;</a></span><span class="message">we can tweak block size a bit</span></div><div class="line" id="013535"><span class="nick" style="color:#2e2a4a"><a href="#013535" label="[01:35:35]">&lt;stikonas&gt;</a></span><span class="message">basically in the limit block size -&gt; infinity we go back to the current behaviour</span></div><div class="line" id="013602"><span class="nick" style="color:#2e2a4a"><a href="#013602" label="[01:36:02]">&lt;stikonas&gt;</a></span><span class="message">or is something like that too simple?</span></div><div class="line" id="013756"><span class="nick" style="color:#2e2a4a"><a href="#013756" label="[01:37:56]">&lt;stikonas&gt;</a></span><span class="message">basically mallocs bigget than block size could potentially waste up to block size of memory</span></div><div class="line" id="014008"><span class="nick" style="color:#2e2a4a"><a href="#014008" label="[01:40:08]">&lt;stikonas&gt;</a></span><span class="message">so I think in the worst case we would end up wasting half of a memory</span></div><div class="line" id="014052"><span class="nick" style="color:#2e2a4a"><a href="#014052" label="[01:40:52]">&lt;stikonas&gt;</a></span><span class="message">though I expect in practice it should be much better</span></div><div class="line" id="014246"><span class="nick" style="color:#2e2a4a"><a href="#014246" label="[01:42:46]">&lt;stikonas&gt;</a></span><span class="message">as I think we do very few big mallocs in stage0</span></div><div class="line" id="014249"><span class="nick" style="color:#2e2a4a"><a href="#014249" label="[01:42:49]">&lt;stikonas&gt;</a></span><span class="message">it's mostly structs</span></div><div class="line" id="014329"><span class="nick" style="color:#2e2a4a"><a href="#014329" label="[01:43:29]">&lt;stikonas&gt;</a></span><span class="message">possibly one exception would be user_stack</span></div><div class="line" id="014416"><span class="nick" style="color:#2e2a4a"><a href="#014416" label="[01:44:16]">&lt;stikonas&gt;</a></span><span class="message">hmm, I'll have to think what's better</span></div><div class="line" id="014430"><span class="nick" style="color:#2e2a4a"><a href="#014430" label="[01:44:30]">&lt;stikonas&gt;</a></span><span class="message">if tracking is not too complex, maybe it's still worth it</span></div><div class="line" id="014547"><span class="nick" style="color:#2e2a4a"><a href="#014547" label="[01:45:47]">&lt;stikonas&gt;</a></span><span class="message">first-fit allocator is actually very similar to this</span></div><div class="line" id="014555"><span class="nick" style="color:#2e2a4a"><a href="#014555" label="[01:45:55]">&lt;stikonas&gt;</a></span><span class="message">just a bit of tracking to make free work</span></div><div class="line" id="043307"><span class="nick" style="color:#6d2462"><a href="#043307" label="[04:33:07]">&lt;fossy&gt;</a></span><span class="message">oriansj: i agree with stikonas[m] regarding git-lfs</span></div><div class="line" id="043430"><span class="nick" style="color:#6d2462"><a href="#043430" label="[04:34:30]">&lt;fossy&gt;</a></span><span class="message">i also don't really want the default option to be any kind of centralised system, the closer we can get to the original hosters the better, especially if all tarballs could be compromised in one step</span></div><div class="line" id="043445"><span class="nick" style="color:#6d2462"><a href="#043445" label="[04:34:45]">&lt;fossy&gt;</a></span><span class="message">for internal usage it makes a lot of sense to have a centralised server tho, so thats a good optin imo</span></div><div class="line" id="111811"><span class="nick" style="color:#80b1d3"><a href="#111811" label="[11:18:11]">&lt;oriansj&gt;</a></span><span class="message">I had a weird idea for dependency management. require a specification to namespace. That way upstream code changes to a library can't break one's code.</span></div><div class="line" id="141730"><span class="nick">***</span><span class="message notice">civodul` is now known as civodul</span></div><div class="line" id="145328"><span class="nick">***</span><span class="message notice">civodul` is now known as civodul</span></div><div class="line" id="161409"><span class="nick" style="color:#8dd3c7"><a href="#161409" label="[16:14:09]">&lt;muurkha&gt;</a></span><span class="message">I was looking at RISC-V implementations yesterday and I found this one that fits into 1000 LUTs on an iCE40 FPGA and is a little less than 300 lines of code: <a rel="nofollow" href="https://github.com/sylefeb/Silice/blob/master/projects/ice-v/README.md">https://github.com/sylefeb/Silice/blob/master/projects/ice-v/README.md</a> </span></div><div class="line" id="161459"><span class="nick" style="color:#8dd3c7"><a href="#161459" label="[16:14:59]">&lt;muurkha&gt;</a></span><span class="message">about 20 million instructions per second on a US$5 FPGA</span></div><div class="line" id="161527"><span class="nick" style="color:#8dd3c7"><a href="#161527" label="[16:15:27]">&lt;muurkha&gt;</a></span><span class="message">that's only RV32I though, it doesn't have a user/supervisor mode split or virtual memory</span></div><div class="line" id="230918"><span class="nick" style="color:#80b1d3"><a href="#230918" label="[23:09:18]">&lt;oriansj&gt;</a></span><span class="message">muurkha: only executing from BRAM seems like a rather serious limitation at 128 Kilobits (4KB)</span></div><div class="line" id="231009"><span class="nick" style="color:#80b1d3"><a href="#231009" label="[23:10:09]">&lt;oriansj&gt;</a></span><span class="message">at the high end of the iCE40 family and 0bits on the low end</span></div><div class="line" id="231057"><span class="nick" style="color:#8dd3c7"><a href="#231057" label="[23:10:57]">&lt;muurkha&gt;</a></span><span class="message">it's 1 megabit, 128 kilobytes</span></div><div class="line" id="231101"><span class="nick" style="color:#80b1d3"><a href="#231101" label="[23:11:01]">&lt;oriansj&gt;</a></span><span class="message">(correction 16KB of 4Kb blocks)</span></div><div class="line" id="231133"><span class="nick" style="color:#8dd3c7"><a href="#231133" label="[23:11:33]">&lt;muurkha&gt;</a></span><span class="message">also 128 kilobits would be 16 kilobytes, which is plenty of RAM for a compiler toolchain if you also have mass storage</span></div><div class="line" id="231159"><span class="nick" style="color:#80b1d3"><a href="#231159" label="[23:11:59]">&lt;oriansj&gt;</a></span><span class="message">the datasheet says Up to 128 kbits sysMEM™ Embedded Block</span></div><div class="line" id="231213"><span class="nick" style="color:#8dd3c7"><a href="#231213" label="[23:12:13]">&lt;muurkha&gt;</a></span><span class="message">for the iCE40UP5K?</span></div><div class="line" id="231226"><span class="nick" style="color:#80b1d3"><a href="#231226" label="[23:12:26]">&lt;oriansj&gt;</a></span><span class="message">iCE40™ LP/HX Family Data Sheet</span></div><div class="line" id="231237"><span class="nick" style="color:#8dd3c7"><a href="#231237" label="[23:12:37]">&lt;muurkha&gt;</a></span><span class="message">yeah, those are a little smaller</span></div><div class="line" id="231338"><span class="nick" style="color:#8dd3c7"><a href="#231338" label="[23:13:38]">&lt;muurkha&gt;</a></span><span class="message">(though some of them actually have more LUTs than the iCE40UP5K I have)</span></div><div class="line" id="231416"><span class="nick" style="color:#8dd3c7"><a href="#231416" label="[23:14:16]">&lt;muurkha&gt;</a></span><span class="message">FPGAs are good at moving data in and out of them rapidly, and I think this one can handle a few gigabytes per second of I/O bandwidth, so external mass storage is a significantly more powerful thing to add than, like, the floppy drive on a Commodore PET</span></div><div class="line" id="231518"><span class="nick" style="color:#80b1d3"><a href="#231518" label="[23:15:18]">&lt;oriansj&gt;</a></span><span class="message">umm Up to 120 kb sysMEM™ Embedded Block RAM for iCE40 UltraPlus™ Family</span></div><div class="line" id="231603"><span class="nick" style="color:#8dd3c7"><a href="#231603" label="[23:16:03]">&lt;muurkha&gt;</a></span><span class="message">yeah, but it also has 1024 kilobits of single port SRAM</span></div><div class="line" id="231630"><span class="nick" style="color:#8dd3c7"><a href="#231630" label="[23:16:30]">&lt;muurkha&gt;</a></span><span class="message">the LP/HX don't</span></div><div class="line" id="231644"><span class="nick" style="color:#8dd3c7"><a href="#231644" label="[23:16:44]">&lt;muurkha&gt;</a></span><span class="message">you're looking at the HX because ice-v/README.md talks about the HX1K, right?</span></div><div class="line" id="231702"><span class="nick" style="color:#80b1d3"><a href="#231702" label="[23:17:02]">&lt;oriansj&gt;</a></span><span class="message">bingo</span></div><div class="line" id="231707"><span class="nick" style="color:#8dd3c7"><a href="#231707" label="[23:17:07]">&lt;muurkha&gt;</a></span><span class="message">but that's just because it's the smallest FPGA it will run on (well, maybe the UL1K)</span></div><div class="line" id="231728"><span class="nick" style="color:#8dd3c7"><a href="#231728" label="[23:17:28]">&lt;muurkha&gt;</a></span><span class="message">the UP5K has the same kind of LUTs, is supported by the same toolchains, and runs at the same speed</span></div><div class="line" id="231739"><span class="nick" style="color:#8dd3c7"><a href="#231739" label="[23:17:39]">&lt;muurkha&gt;</a></span><span class="message">it just has a mebibit of SPRAM</span></div><div class="line" id="231747"><span class="nick" style="color:#80b1d3"><a href="#231747" label="[23:17:47]">&lt;oriansj&gt;</a></span><span class="message">but yeah it does appear the UP family can have up to 1024 kb Single Port SRAM in addition; which might be enough to do something useful in</span></div><div class="line" id="231811"><span class="nick" style="color:#8dd3c7"><a href="#231811" label="[23:18:11]">&lt;muurkha&gt;</a></span><span class="message">even 16KiB is plenty to do something useful in though</span></div><div class="line" id="231837"><span class="nick" style="color:#80b1d3"><a href="#231837" label="[23:18:37]">&lt;oriansj&gt;</a></span><span class="message">useful is a very broad category</span></div><div class="line" id="231850"><span class="nick" style="color:#8dd3c7"><a href="#231850" label="[23:18:50]">&lt;muurkha&gt;</a></span><span class="message">to do a self-hosting development environment in a high-level langauge</span></div><div class="line" id="231853"><span class="nick" style="color:#8dd3c7"><a href="#231853" label="[23:18:53]">&lt;muurkha&gt;</a></span><span class="message">since you can hook it up to an external Flash or even SRAM</span></div><div class="line" id="231859"><span class="nick" style="color:#80b1d3"><a href="#231859" label="[23:18:59]">&lt;oriansj&gt;</a></span><span class="message">but it is probably viable for some of the early bootstrapping steps</span></div><div class="line" id="231918"><span class="nick" style="color:#8dd3c7"><a href="#231918" label="[23:19:18]">&lt;muurkha&gt;</a></span><span class="message">you can boot Linux on that FPGA, people have</span></div><div class="line" id="231926"><span class="nick" style="color:#80b1d3"><a href="#231926" label="[23:19:26]">&lt;oriansj&gt;</a></span><span class="message">as 128KB is enough for cc_* with a few tweaks</span></div><div class="line" id="232025"><span class="nick" style="color:#8dd3c7"><a href="#232025" label="[23:20:25]">&lt;muurkha&gt;</a></span><span class="message">the stretch goal with that chip is not &quot;run a C compiler&quot;</span></div><div class="line" id="232047"><span class="nick" style="color:#8dd3c7"><a href="#232047" label="[23:20:47]">&lt;muurkha&gt;</a></span><span class="message">it's &quot;resynthesize the SoC bitstream from HDL&quot;</span></div><div class="line" id="232128"><span class="nick" style="color:#80b1d3"><a href="#232128" label="[23:21:28]">&lt;oriansj&gt;</a></span><span class="message">with external RAM probably but using only internal; it'll be painful</span></div><div class="line" id="232136"><span class="nick" style="color:#80b1d3"><a href="#232136" label="[23:21:36]">&lt;oriansj&gt;</a></span><span class="message">and a boatload of swapping</span></div><div class="line" id="232913"><span class="nick" style="color:#80b1d3"><a href="#232913" label="[23:29:13]">&lt;oriansj&gt;</a></span><span class="message">unless I missed something important (like slice running on bare metal); then we are talking a kernel, filesystem and possible extra abstractions.</span></div><div class="line" id="234648"><span class="nick" style="color:#8dd3c7"><a href="#234648" label="[23:46:48]">&lt;muurkha&gt;</a></span><span class="message">well, I haven't done it, but I don't think it's particularly more painful using external RAM than internal.  also though 128 KiB is 2-4 times the size of the machines people used to run Turbo Pascal and BDS C on, and those machines ran at 0.3 MIPS instead of 15-20 MIPS</span></div><br /></div></body></html>