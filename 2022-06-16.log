<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-06-16.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000724"><span class="nick">***</span><span class="message notice">saksophony_ is now known as saksophony</span></div><div class="line" id="000724"><span class="nick">***</span><span class="message notice">lh_ is now known as lh</span></div><div class="line" id="000724"><span class="nick">***</span><span class="message notice">alethkit_ is now known as alethkit</span></div><div class="line" id="000725"><span class="nick">***</span><span class="message notice">achaninja_ is now known as achaninja</span></div><div class="line" id="000726"><span class="nick">***</span><span class="message notice">sm2n_ is now known as sm2n</span></div><div class="line" id="000726"><span class="nick">***</span><span class="message notice">unmatched-paren_ is now known as unmatched-paren</span></div><div class="line" id="002526"><span class="nick">***</span><span class="message notice">pi1 is now known as johnjaye</span></div><div class="line" id="002625"><span class="nick" style="color:#8dd3c7"><a href="#002625" label="[00:26:25]">&lt;oriansj&gt;</a></span><span class="message">now the 4/8bit processor seems to be limited to 8words of DATA RAM (4/8bytes) and a 7bit address space doesn't leave much room to do much but 127 instructions might be enough to do hex0</span></div><div class="line" id="002652"><span class="nick" style="color:#2e2a4a"><a href="#002652" label="[00:26:52]">&lt;johnjaye&gt;</a></span><span class="message">is there a good academic paper on bootstrappability?</span></div><div class="line" id="002752"><span class="nick" style="color:#8dd3c7"><a href="#002752" label="[00:27:52]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: in general or you mean specific cases (like say bootstrapping the ocaml language)</span></div><div class="line" id="002823"><span class="nick" style="color:#2e2a4a"><a href="#002823" label="[00:28:23]">&lt;johnjaye&gt;</a></span><span class="message">i suppose in general. like what are the costs and benefits of bootstrapping a compiler vs compiling the compiler with the compiler.</span></div><div class="line" id="002913"><span class="nick" style="color:#8dd3c7"><a href="#002913" label="[00:29:13]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: ummm we use compilers to bootstrap compilers; we just write the base compiler in assembly</span></div><div class="line" id="002947"><span class="nick" style="color:#2e2a4a"><a href="#002947" label="[00:29:47]">&lt;johnjaye&gt;</a></span><span class="message">oh ok.</span></div><div class="line" id="002959"><span class="nick" style="color:#2e2a4a"><a href="#002959" label="[00:29:59]">&lt;johnjaye&gt;</a></span><span class="message">i thought bootstrapping had some kind of theoretical properties like that.</span></div><div class="line" id="003054"><span class="nick" style="color:#8dd3c7"><a href="#003054" label="[00:30:54]">&lt;oriansj&gt;</a></span><span class="message">for example here is a C compiler written in RISC-V assembly: <a rel="nofollow" href="https://github.com/oriansj/stage0-posix-riscv32/blob/master/cc_riscv32.M1">https://github.com/oriansj/stage0-posix-riscv32/blob/master/cc_riscv32.M1</a> </span></div><div class="line" id="003208"><span class="nick" style="color:#8dd3c7"><a href="#003208" label="[00:32:08]">&lt;oriansj&gt;</a></span><span class="message">and yes there are a good deal of theoretical properties for bootstrapping but in practical terms, ultimately you either bootstrap a language in a high level language or in assembly</span></div><div class="line" id="003236"><span class="nick" style="color:#8dd3c7"><a href="#003236" label="[00:32:36]">&lt;oriansj&gt;</a></span><span class="message">So if you have a high level compiler you can trust, it is usually much easier just to use that</span></div><div class="line" id="003314"><span class="nick" style="color:#8dd3c7"><a href="#003314" label="[00:33:14]">&lt;oriansj&gt;</a></span><span class="message">but if you have no high level compiler you trust, there really isn't any other option but to build a compiler written in assembly</span></div><div class="line" id="003343"><span class="nick" style="color:#8dd3c7"><a href="#003343" label="[00:33:43]">&lt;oriansj&gt;</a></span><span class="message">(or high level interpreter)</span></div><div class="line" id="003533"><span class="nick" style="color:#8dd3c7"><a href="#003533" label="[00:35:33]">&lt;oriansj&gt;</a></span><span class="message">as one could write a compiler in a high level interpreted language: (such as scheme) <a rel="nofollow" href="https://github.com/oriansj/mes-m2">https://github.com/oriansj/mes-m2</a> </span></div><div class="line" id="003600"><span class="nick" style="color:#8dd3c7"><a href="#003600" label="[00:36:00]">&lt;oriansj&gt;</a></span><span class="message">but that interpreter has to be written in either a high level language or in assembly</span></div><div class="line" id="003631"><span class="nick" style="color:#8dd3c7"><a href="#003631" label="[00:36:31]">&lt;oriansj&gt;</a></span><span class="message">(schemes tend to be written in C and FORTHs tend to be written in Assembly)</span></div><div class="line" id="003748"><span class="nick" style="color:#6b8072"><a href="#003748" label="[00:37:48]">&lt;stikonas&gt;</a></span><span class="message">johnjaye: sadly there isn't that much theory in bootstrapping. It's actually fairly simple</span></div><div class="line" id="003903"><span class="nick" style="color:#2e2a4a"><a href="#003903" label="[00:39:03]">&lt;johnjaye&gt;</a></span><span class="message">i see. well fair enough.</span></div><div class="line" id="003954"><span class="nick" style="color:#6b8072"><a href="#003954" label="[00:39:54]">&lt;stikonas&gt;</a></span><span class="message">you can maybe see some connections to self-referential paradoxes in some  places</span></div><div class="line" id="004120"><span class="nick" style="color:#6b8072"><a href="#004120" label="[00:41:20]">&lt;stikonas&gt;</a></span><span class="message">e.g. let's say you build sha256sum. On it's own it can't be used to prove that it's not malicious binary</span></div><div class="line" id="004129"><span class="nick" style="color:#2e2a4a"><a href="#004129" label="[00:41:29]">&lt;johnjaye&gt;</a></span><span class="message">can you bootstrap with a compiler written in pcode or IR?</span></div><div class="line" id="004203"><span class="nick" style="color:#6b8072"><a href="#004203" label="[00:42:03]">&lt;stikonas&gt;</a></span><span class="message">I guess you can but the compilers we have are non-optimizing</span></div><div class="line" id="004212"><span class="nick" style="color:#6b8072"><a href="#004212" label="[00:42:12]">&lt;stikonas&gt;</a></span><span class="message">so there isn't really any IR or pcode</span></div><div class="line" id="004212"><span class="nick" style="color:#8dd3c7"><a href="#004212" label="[00:42:12]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: and what exactly do you think will be running that pcode or IR?</span></div><div class="line" id="004222"><span class="nick" style="color:#6b8072"><a href="#004222" label="[00:42:22]">&lt;stikonas&gt;</a></span><span class="message">and yes, that too</span></div><div class="line" id="004332"><span class="nick" style="color:#6b8072"><a href="#004332" label="[00:43:32]">&lt;stikonas&gt;</a></span><span class="message">M2-Planet (the simplest subset of C compiler that is still written in C) and slightly simpler cc_x86 (even smaller subset of C compiler written in assembly) are very simple compilers, they just go over the source (single-pass) and basically directly spit assembly out</span></div><div class="line" id="004346"><span class="nick" style="color:#6b8072"><a href="#004346" label="[00:43:46]">&lt;stikonas&gt;</a></span><span class="message">(they do keep a bit of state to deal with local variables, etc but not much)</span></div><div class="line" id="004442"><span class="nick" style="color:#2e2a4a"><a href="#004442" label="[00:44:42]">&lt;johnjaye&gt;</a></span><span class="message">meaning there's not much to be gained from optimizing it? i'm not sure i get it</span></div><div class="line" id="004500"><span class="nick" style="color:#6b8072"><a href="#004500" label="[00:45:00]">&lt;stikonas&gt;</a></span><span class="message">meaning that optimizations are not important for bootstrapping</span></div><div class="line" id="004512"><span class="nick" style="color:#6b8072"><a href="#004512" label="[00:45:12]">&lt;stikonas&gt;</a></span><span class="message">you use your compiler once to build something more complicated</span></div><div class="line" id="004535"><span class="nick" style="color:#6b8072"><a href="#004535" label="[00:45:35]">&lt;stikonas&gt;</a></span><span class="message">compiler optimizations only matter if you use compiler program a lot</span></div><div class="line" id="004555"><span class="nick" style="color:#8dd3c7"><a href="#004555" label="[00:45:55]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: does 5 minutes seem like a huge problem that would benefit by shaving off seconds?</span></div><div class="line" id="004627"><span class="nick" style="color:#6b8072"><a href="#004627" label="[00:46:27]">&lt;stikonas&gt;</a></span><span class="message">and most of the slowdown actually comes from interpreter (mes)</span></div><div class="line" id="004636"><span class="nick" style="color:#6b8072"><a href="#004636" label="[00:46:36]">&lt;stikonas&gt;</a></span><span class="message">M2-Planet builds really fast</span></div><div class="line" id="004647"><span class="nick" style="color:#6b8072"><a href="#004647" label="[00:46:47]">&lt;stikonas&gt;</a></span><span class="message">oriansj: was it something like 250k lines per second?</span></div><div class="line" id="004706"><span class="nick" style="color:#8dd3c7"><a href="#004706" label="[00:47:06]">&lt;oriansj&gt;</a></span><span class="message">stikonas: yes</span></div><div class="line" id="004711"><span class="nick" style="color:#2e2a4a"><a href="#004711" label="[00:47:11]">&lt;johnjaye&gt;</a></span><span class="message">hmm i see</span></div><div class="line" id="004728"><span class="nick" style="color:#2e2a4a"><a href="#004728" label="[00:47:28]">&lt;johnjaye&gt;</a></span><span class="message">wait is lines per second a real metric?</span></div><div class="line" id="004730"><span class="nick" style="color:#8dd3c7"><a href="#004730" label="[00:47:30]">&lt;oriansj&gt;</a></span><span class="message">that was the worst case performance</span></div><div class="line" id="004750"><span class="nick" style="color:#8dd3c7"><a href="#004750" label="[00:47:50]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: yes when self-hosted; it is 2Mloc/second when built by GCC</span></div><div class="line" id="004837"><span class="nick" style="color:#6b8072"><a href="#004837" label="[00:48:37]">&lt;stikonas&gt;</a></span><span class="message">basically bootstrap goes something like hex0-&gt;hex1-&gt;hex2 (linker)-&gt;M0 (assembler)-&gt;cc_x86 (C compiler)-&gt; M2-Planet (C compiler) -&gt; mes (scheme interpreter) -&gt; mescc (C compiler) -&gt; tcc (C compiler)</span></div><div class="line" id="004905"><span class="nick" style="color:#6b8072"><a href="#004905" label="[00:49:05]">&lt;stikonas&gt;</a></span><span class="message">if you run this chain everything is quite fast (compilation takes maybe a second) except for interpreted code</span></div><div class="line" id="004923"><span class="nick" style="color:#6b8072"><a href="#004923" label="[00:49:23]">&lt;stikonas&gt;</a></span><span class="message">building tcc maybe 8 mintues</span></div><div class="line" id="005001"><span class="nick" style="color:#2e2a4a"><a href="#005001" label="[00:50:01]">&lt;johnjaye&gt;</a></span><span class="message">why is that a chain of multiple assemblers and multiple compilers</span></div><div class="line" id="005013"><span class="nick" style="color:#2e2a4a"><a href="#005013" label="[00:50:13]">&lt;johnjaye&gt;</a></span><span class="message">shouldn't it be compiler makes a compiler?</span></div><div class="line" id="005024"><span class="nick" style="color:#6b8072"><a href="#005024" label="[00:50:24]">&lt;stikonas&gt;</a></span><span class="message">how do you get 1st compiler?</span></div><div class="line" id="005029"><span class="nick" style="color:#6b8072"><a href="#005029" label="[00:50:29]">&lt;stikonas&gt;</a></span><span class="message">you write it in assembly</span></div><div class="line" id="005042"><span class="nick" style="color:#2e2a4a"><a href="#005042" label="[00:50:42]">&lt;johnjaye&gt;</a></span><span class="message">right</span></div><div class="line" id="005049"><span class="nick" style="color:#8dd3c7"><a href="#005049" label="[00:50:49]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: short version: mescc got to building TCC before M2-Mesoplanet could</span></div><div class="line" id="005121"><span class="nick" style="color:#6b8072"><a href="#005121" label="[00:51:21]">&lt;stikonas&gt;</a></span><span class="message">oriansj: I think johnjaye is asking why this chain has both assemblers and compilers</span></div><div class="line" id="005129"><span class="nick" style="color:#8dd3c7"><a href="#005129" label="[00:51:29]">&lt;oriansj&gt;</a></span><span class="message">Elapsed (wall clock) time (h:mm:ss or m:ss): 1:35.29 from zero to mescc</span></div><div class="line" id="005140"><span class="nick" style="color:#6b8072"><a href="#005140" label="[00:51:40]">&lt;stikonas&gt;</a></span><span class="message">(and that's including extra tools)</span></div><div class="line" id="005250"><span class="nick" style="color:#6b8072"><a href="#005250" label="[00:52:50]">&lt;stikonas&gt;</a></span><span class="message">basically we want to build compiler from the smallest possible binary seed</span></div><div class="line" id="005259"><span class="nick" style="color:#6b8072"><a href="#005259" label="[00:52:59]">&lt;stikonas&gt;</a></span><span class="message">you can't build it without any seed at all</span></div><div class="line" id="005311"><span class="nick" style="color:#8dd3c7"><a href="#005311" label="[00:53:11]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: to the question of why the complexity, it has to do with minimizing development and review efforts</span></div><div class="line" id="005320"><span class="nick" style="color:#6b8072"><a href="#005320" label="[00:53:20]">&lt;stikonas&gt;</a></span><span class="message">and large binary seed (e.g. 1 MiB can't be easily inspected by human)</span></div><div class="line" id="005336"><span class="nick" style="color:#8dd3c7"><a href="#005336" label="[00:53:36]">&lt;oriansj&gt;</a></span><span class="message"> but a few hundred bytes can be</span></div><div class="line" id="005341"><span class="nick" style="color:#6b8072"><a href="#005341" label="[00:53:41]">&lt;stikonas&gt;</a></span><span class="message">yes, hex code is hard to inspect and write</span></div><div class="line" id="005407"><span class="nick" style="color:#6b8072"><a href="#005407" label="[00:54:07]">&lt;stikonas&gt;</a></span><span class="message">once you have hex1, it can do some of the calculations for you and it becomes easier</span></div><div class="line" id="005411"><span class="nick" style="color:#8dd3c7"><a href="#005411" label="[00:54:11]">&lt;oriansj&gt;</a></span><span class="message">so we do it as little as possible</span></div><div class="line" id="005415"><span class="nick" style="color:#6b8072"><a href="#005415" label="[00:54:15]">&lt;stikonas&gt;</a></span><span class="message">still somewhat tedious</span></div><div class="line" id="005442"><span class="nick" style="color:#6b8072"><a href="#005442" label="[00:54:42]">&lt;stikonas&gt;</a></span><span class="message">hex2 is slightly improved version of hex1, removes some of the limitations</span></div><div class="line" id="005444"><span class="nick" style="color:#8dd3c7"><a href="#005444" label="[00:54:44]">&lt;oriansj&gt;</a></span><span class="message">but each is easier to work in than the previous step</span></div><div class="line" id="005452"><span class="nick" style="color:#8dd3c7"><a href="#005452" label="[00:54:52]">&lt;oriansj&gt;</a></span><span class="message">and more powerful</span></div><div class="line" id="005508"><span class="nick" style="color:#8dd3c7"><a href="#005508" label="[00:55:08]">&lt;oriansj&gt;</a></span><span class="message">tools are made with each step</span></div><div class="line" id="005530"><span class="nick" style="color:#6b8072"><a href="#005530" label="[00:55:30]">&lt;stikonas&gt;</a></span><span class="message">well, once we have M2-Planet we compile loads of other tools</span></div><div class="line" id="005536"><span class="nick" style="color:#6b8072"><a href="#005536" label="[00:55:36]">&lt;stikonas&gt;</a></span><span class="message">since it's already C compiler</span></div><div class="line" id="005600"><span class="nick" style="color:#6b8072"><a href="#005600" label="[00:56:00]">&lt;stikonas&gt;</a></span><span class="message">after M0 programming is basically assembly programming but we only need to write 1 program in it (cc_*)</span></div><div class="line" id="005601"><span class="nick" style="color:#2e2a4a"><a href="#005601" label="[00:56:01]">&lt;johnjaye&gt;</a></span><span class="message">i see</span></div><div class="line" id="005633"><span class="nick" style="color:#6b8072"><a href="#005633" label="[00:56:33]">&lt;stikonas&gt;</a></span><span class="message">cc_* builds its cross-platform variant in C (M2-Planet)</span></div><div class="line" id="005639"><span class="nick" style="color:#6b8072"><a href="#005639" label="[00:56:39]">&lt;stikonas&gt;</a></span><span class="message">and after that it's just normal programing</span></div><div class="line" id="005648"><span class="nick" style="color:#6b8072"><a href="#005648" label="[00:56:48]">&lt;stikonas&gt;</a></span><span class="message">although in somewhat restricted subset of C</span></div><div class="line" id="005657"><span class="nick" style="color:#6b8072"><a href="#005657" label="[00:56:57]">&lt;stikonas&gt;</a></span><span class="message">but perfectly readable for any C programmer</span></div><div class="line" id="005712"><span class="nick" style="color:#8dd3c7"><a href="#005712" label="[00:57:12]">&lt;oriansj&gt;</a></span><span class="message">with standard C libraries</span></div><div class="line" id="005742"><span class="nick" style="color:#6b8072"><a href="#005742" label="[00:57:42]">&lt;stikonas&gt;</a></span><span class="message">yes, e.g. untar <a rel="nofollow" href="https://github.com/oriansj/mescc-tools-extra/blob/master/untar.c">https://github.com/oriansj/mescc-tools-extra/blob/master/untar.c</a> </span></div><div class="line" id="005837"><span class="nick" style="color:#6b8072"><a href="#005837" label="[00:58:37]">&lt;stikonas&gt;</a></span><span class="message">and everything can run automated and build GCC</span></div><div class="line" id="005906"><span class="nick" style="color:#2e2a4a"><a href="#005906" label="[00:59:06]">&lt;johnjaye&gt;</a></span><span class="message">is this all about guix or is it a separate project?</span></div><div class="line" id="005909"><span class="nick" style="color:#6b8072"><a href="#005909" label="[00:59:09]">&lt;stikonas&gt;</a></span><span class="message">by starting with 2 small binaries (357 byte hex0 and 757 byte kaem-minimal shell)</span></div><div class="line" id="005937"><span class="nick" style="color:#6b8072"><a href="#005937" label="[00:59:37]">&lt;stikonas&gt;</a></span><span class="message">it's not just guix although guix does that too</span></div><div class="line" id="005948"><span class="nick" style="color:#8dd3c7"><a href="#005948" label="[00:59:48]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: well it is bigger than Guix but yes many guix people are also here and it did start on #guix</span></div><div class="line" id="010021"><span class="nick" style="color:#6b8072"><a href="#010021" label="[01:00:21]">&lt;stikonas&gt;</a></span><span class="message">but we have scripts that are completely independent of guix</span></div><div class="line" id="010023"><span class="nick" style="color:#8dd3c7"><a href="#010023" label="[01:00:23]">&lt;oriansj&gt;</a></span><span class="message">and the work is integrated in Guix</span></div><div class="line" id="010040"><span class="nick" style="color:#2e2a4a"><a href="#010040" label="[01:00:40]">&lt;johnjaye&gt;</a></span><span class="message">oh ok</span></div><div class="line" id="010058"><span class="nick" style="color:#6b8072"><a href="#010058" label="[01:00:58]">&lt;stikonas&gt;</a></span><span class="message">and some other people also tried writing their own bootstrap chains</span></div><div class="line" id="010100"><span class="nick" style="color:#8dd3c7"><a href="#010100" label="[01:01:00]">&lt;oriansj&gt;</a></span><span class="message">and we encourage people to create any bootstrap chain they trust</span></div><div class="line" id="010102"><span class="nick" style="color:#6b8072"><a href="#010102" label="[01:01:02]">&lt;stikonas&gt;</a></span><span class="message">but it's mostly 2 implementations</span></div><div class="line" id="010111"><span class="nick" style="color:#2e2a4a"><a href="#010111" label="[01:01:11]">&lt;johnjaye&gt;</a></span><span class="message">i heard about it there yes. it seems to me the main reason you would want bootstrapping is for that whole build everything declaratively thing?</span></div><div class="line" id="010115"><span class="nick" style="color:#6b8072"><a href="#010115" label="[01:01:15]">&lt;stikonas&gt;</a></span><span class="message">Guix (which starts with hex0 and static guile binary)</span></div><div class="line" id="010125"><span class="nick" style="color:#6b8072"><a href="#010125" label="[01:01:25]">&lt;stikonas&gt;</a></span><span class="message">and live-bootstrap (which starts with hex0 and kaem-minimal)</span></div><div class="line" id="010225"><span class="nick" style="color:#6b8072"><a href="#010225" label="[01:02:25]">&lt;stikonas&gt;</a></span><span class="message">well, declarative building is mostly guix thing</span></div><div class="line" id="010259"><span class="nick" style="color:#6b8072"><a href="#010259" label="[01:02:59]">&lt;stikonas&gt;</a></span><span class="message">live-bootstrap focusses more on not allowing any pre-generated files (e.g. configure scripts are banned, or e.g. pre-built bison parsers)</span></div><div class="line" id="010313"><span class="nick" style="color:#6b8072"><a href="#010313" label="[01:03:13]">&lt;stikonas&gt;</a></span><span class="message">and also does reproducibility a bit better than guix</span></div><div class="line" id="010320"><span class="nick" style="color:#6b8072"><a href="#010320" label="[01:03:20]">&lt;stikonas&gt;</a></span><span class="message">though guix tries to be quite reproducible too</span></div><div class="line" id="010332"><span class="nick" style="color:#8dd3c7"><a href="#010332" label="[01:03:32]">&lt;oriansj&gt;</a></span><span class="message">and declarative building requires a declarative language (like Guile)</span></div><div class="line" id="010352"><span class="nick" style="color:#6b8072"><a href="#010352" label="[01:03:52]">&lt;stikonas&gt;</a></span><span class="message">well, in Guix you have packages written in Guile</span></div><div class="line" id="010414"><span class="nick" style="color:#6b8072"><a href="#010414" label="[01:04:14]">&lt;stikonas&gt;</a></span><span class="message">live-bootstrap is basically just some collection of shell scripts</span></div><div class="line" id="010423"><span class="nick" style="color:#6b8072"><a href="#010423" label="[01:04:23]">&lt;stikonas&gt;</a></span><span class="message">mostly bash</span></div><div class="line" id="010446"><span class="nick" style="color:#8dd3c7"><a href="#010446" label="[01:04:46]">&lt;oriansj&gt;</a></span><span class="message">so bootstrapping is very much what you feel comfortable with</span></div><div class="line" id="010447"><span class="nick" style="color:#6b8072"><a href="#010447" label="[01:04:47]">&lt;stikonas&gt;</a></span><span class="message">but it's self-contained and does not need big interpreted like guile</span></div><div class="line" id="010514"><span class="nick" style="color:#80b1d3"><a href="#010514" label="[01:05:14]">&lt;vagrantc&gt;</a></span><span class="message">does it actually use features of &quot;bash&quot; specifically, as opposed to &quot;sh&quot; ?</span></div><div class="line" id="010528"><span class="nick" style="color:#6b8072"><a href="#010528" label="[01:05:28]">&lt;stikonas&gt;</a></span><span class="message">vagrantc: yes, plenty</span></div><div class="line" id="010533"><span class="nick" style="color:#6b8072"><a href="#010533" label="[01:05:33]">&lt;stikonas&gt;</a></span><span class="message">well, once bash is built</span></div><div class="line" id="010535"><span class="nick" style="color:#8dd3c7"><a href="#010535" label="[01:05:35]">&lt;oriansj&gt;</a></span><span class="message">Guix is comfortable with the static guile binary and live-bootstrap sticks to the bootstrap-seeds</span></div><div class="line" id="010549"><span class="nick" style="color:#6b8072"><a href="#010549" label="[01:05:49]">&lt;stikonas&gt;</a></span><span class="message">vagrantc: before bash is built it's just a list of commands (kaem scripts)</span></div><div class="line" id="010556"><span class="nick" style="color:#80b1d3"><a href="#010556" label="[01:05:56]">&lt;vagrantc&gt;</a></span><span class="message">stikonas: i assumed you waited till it was built to use it :)</span></div><div class="line" id="010637"><span class="nick" style="color:#80b1d3"><a href="#010637" label="[01:06:37]">&lt;vagrantc&gt;</a></span><span class="message">i'm not sure &quot;guix is comfortable&quot; so much as that is as far as it has gotten so far</span></div><div class="line" id="010650"><span class="nick" style="color:#8dd3c7"><a href="#010650" label="[01:06:50]">&lt;oriansj&gt;</a></span><span class="message">vagrantc: bashisms are a far smaller issue if the only shells you have are bash and kaem</span></div><div class="line" id="010743"><span class="nick" style="color:#6b8072"><a href="#010743" label="[01:07:43]">&lt;stikonas&gt;</a></span><span class="message">kaem can't run POSIX compatible sh files anyway</span></div><div class="line" id="010746"><span class="nick" style="color:#6b8072"><a href="#010746" label="[01:07:46]">&lt;stikonas&gt;</a></span><span class="message">it's even more restricted</span></div><div class="line" id="010753"><span class="nick" style="color:#80b1d3"><a href="#010753" label="[01:07:53]">&lt;vagrantc&gt;</a></span><span class="message">guix is a project that started out with a large (but at least known) set of binary seeds and has been chipping away at them...</span></div><div class="line" id="010800"><span class="nick" style="color:#6b8072"><a href="#010800" label="[01:08:00]">&lt;stikonas&gt;</a></span><span class="message">though it now has aliases and if else fi statements</span></div><div class="line" id="010814"><span class="nick" style="color:#6b8072"><a href="#010814" label="[01:08:14]">&lt;stikonas&gt;</a></span><span class="message">yeah,  and live-bootstrap started vice verse</span></div><div class="line" id="010822"><span class="nick" style="color:#8dd3c7"><a href="#010822" label="[01:08:22]">&lt;oriansj&gt;</a></span><span class="message">vagrantc: well if guix wanted to get away from that Guile binary, they would have to move their bootstrap out of guix itself</span></div><div class="line" id="010823"><span class="nick" style="color:#6b8072"><a href="#010823" label="[01:08:23]">&lt;stikonas&gt;</a></span><span class="message">it started with a small seed and was building on top of that</span></div><div class="line" id="010917"><span class="nick" style="color:#80b1d3"><a href="#010917" label="[01:09:17]">&lt;vagrantc&gt;</a></span><span class="message">stikonas: exactly</span></div><div class="line" id="010957"><span class="nick" style="color:#80b1d3"><a href="#010957" label="[01:09:57]">&lt;vagrantc&gt;</a></span><span class="message">oriansj: or just port guix to mes's scheme interpreter :)</span></div><div class="line" id="011008"><span class="nick" style="color:#6b8072"><a href="#011008" label="[01:10:08]">&lt;stikonas&gt;</a></span><span class="message">vagrantc: that's probably easier said than done</span></div><div class="line" id="011027"><span class="nick" style="color:#80b1d3"><a href="#011027" label="[01:10:27]">&lt;vagrantc&gt;</a></span><span class="message">indeed :)</span></div><div class="line" id="011028"><span class="nick" style="color:#6b8072"><a href="#011028" label="[01:10:28]">&lt;stikonas&gt;</a></span><span class="message">I think even  gash is very experimental on mes\</span></div><div class="line" id="011046"><span class="nick" style="color:#8dd3c7"><a href="#011046" label="[01:10:46]">&lt;oriansj&gt;</a></span><span class="message">vagrantc: at that point mes.c would be functionality the same as guile; which would be freaking cool</span></div><div class="line" id="011059"><span class="nick" style="color:#6d2462"><a href="#011059" label="[01:10:59]">&lt;muurkha&gt;</a></span><span class="message">oriansj: I'm curious whether it's more broadly applicable than the 4004; have you read the paper?  I haven't yet</span></div><div class="line" id="011131"><span class="nick" style="color:#6d2462"><a href="#011131" label="[01:11:31]">&lt;muurkha&gt;</a></span><span class="message">hmm, 8 words of data RAM and a 7-bit address space sounds too small</span></div><div class="line" id="011209"><span class="nick" style="color:#6d2462"><a href="#011209" label="[01:12:09]">&lt;muurkha&gt;</a></span><span class="message">I haven't found a way to build a usable CPU in under about 2500 transistors</span></div><div class="line" id="011229"><span class="nick" style="color:#8dd3c7"><a href="#011229" label="[01:12:29]">&lt;oriansj&gt;</a></span><span class="message">muurkha: the 4004 supported a 12 bit address space</span></div><div class="line" id="011234"><span class="nick" style="color:#8dd3c7"><a href="#011234" label="[01:12:34]">&lt;oriansj&gt;</a></span><span class="message">so aside from being cheap as heck, it is worse than the 4004 in every technical way</span></div><div class="line" id="011314"><span class="nick" style="color:#8dd3c7"><a href="#011314" label="[01:13:14]">&lt;oriansj&gt;</a></span><span class="message">muurkha: define usable CPU</span></div><div class="line" id="011331"><span class="nick" style="color:#2e2a4a"><a href="#011331" label="[01:13:31]">&lt;johnjaye&gt;</a></span><span class="message">which paper?</span></div><div class="line" id="011341"><span class="nick" style="color:#6d2462"><a href="#011341" label="[01:13:41]">&lt;muurkha&gt;</a></span><span class="message">johnjaye: yeah, you could write a P-code interpreter in assembly, then write a compiler in P-code.  arguably that's what you're doing when you program in Forth :)</span></div><div class="line" id="011348"><span class="nick" style="color:#2e2a4a"><a href="#011348" label="[01:13:48]">&lt;johnjaye&gt;</a></span><span class="message">haha ok</span></div><div class="line" id="011414"><span class="nick" style="color:#2e2a4a"><a href="#011414" label="[01:14:14]">&lt;johnjaye&gt;</a></span><span class="message">most obvious ideas have probably been thought of and done. it's just hard to figure out what the project is named</span></div><div class="line" id="011419"><span class="nick" style="color:#6d2462"><a href="#011419" label="[01:14:19]">&lt;muurkha&gt;</a></span><span class="message">22:45 &lt; stikonas&gt; compiler optimizations only matter if you use compiler program a lot</span></div><div class="line" id="011426"><span class="nick" style="color:#8dd3c7"><a href="#011426" label="[01:14:26]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: <a rel="nofollow" href="http://passat.crhc.illinois.edu/isca22_02.pdf">http://passat.crhc.illinois.edu/isca22_02.pdf</a> </span></div><div class="line" id="011437"><span class="nick" style="color:#6d2462"><a href="#011437" label="[01:14:37]">&lt;muurkha&gt;</a></span><span class="message">I think this should say &quot;compiler optimizations only matter if you use the compiled program a lot&quot;</span></div><div class="line" id="011450"><span class="nick" style="color:#6d2462"><a href="#011450" label="[01:14:50]">&lt;muurkha&gt;</a></span><span class="message">and I'd add &quot;much&quot;</span></div><div class="line" id="011458"><span class="nick" style="color:#6d2462"><a href="#011458" label="[01:14:58]">&lt;muurkha&gt;</a></span><span class="message">that is, they only matter much</span></div><div class="line" id="011508"><span class="nick" style="color:#6b8072"><a href="#011508" label="[01:15:08]">&lt;stikonas&gt;</a></span><span class="message">muurkha: yes, though I was thinking compiled program is the next compiler</span></div><div class="line" id="011606"><span class="nick" style="color:#8dd3c7"><a href="#011606" label="[01:16:06]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well the RISC-II had only 40,760 transistors of which 1:  26496</span></div><div class="line" id="011630"><span class="nick" style="color:#8dd3c7"><a href="#011630" label="[01:16:30]">&lt;oriansj&gt;</a></span><span class="message">26,496 were used for the 138registers</span></div><div class="line" id="011650"><span class="nick" style="color:#2e2a4a"><a href="#011650" label="[01:16:50]">&lt;johnjaye&gt;</a></span><span class="message">anyway i was just curious about the organizational relationships. all these terms are really new and strange sounding. mes. m2. ccx86.</span></div><div class="line" id="011742"><span class="nick" style="color:#8dd3c7"><a href="#011742" label="[01:17:42]">&lt;oriansj&gt;</a></span><span class="message">(assuming 32bits at 6 transistors per register bit)</span></div><div class="line" id="011754"><span class="nick" style="color:#8dd3c7"><a href="#011754" label="[01:17:54]">&lt;oriansj&gt;</a></span><span class="message">so 1:  14264</span></div><div class="line" id="011838"><span class="nick" style="color:#6d2462"><a href="#011838" label="[01:18:38]">&lt;muurkha&gt;</a></span><span class="message">oriansj: I think my working definition of &quot;usable CPU&quot; is one that can run a high-level-language interpreter</span></div><div class="line" id="011851"><span class="nick" style="color:#6d2462"><a href="#011851" label="[01:18:51]">&lt;muurkha&gt;</a></span><span class="message">oriansj: yeah, I said 2500, not 25000</span></div><div class="line" id="011859"><span class="nick" style="color:#8dd3c7"><a href="#011859" label="[01:18:59]">&lt;oriansj&gt;</a></span><span class="message">johnjaye: can you be more precise in what you are looking for?</span></div><div class="line" id="011859"><span class="nick" style="color:#6b8072"><a href="#011859" label="[01:18:59]">&lt;stikonas&gt;</a></span><span class="message">johnjaye: it's just a name of some programs</span></div><div class="line" id="011902"><span class="nick" style="color:#6b8072"><a href="#011902" label="[01:19:02]">&lt;stikonas&gt;</a></span><span class="message">johnjaye: just like gcc is just a name</span></div><div class="line" id="011931"><span class="nick" style="color:#8dd3c7"><a href="#011931" label="[01:19:31]">&lt;oriansj&gt;</a></span><span class="message">muurkha: oooh that is much harder</span></div><div class="line" id="011935"><span class="nick" style="color:#6d2462"><a href="#011935" label="[01:19:35]">&lt;muurkha&gt;</a></span><span class="message">stikonas: yes, agreed</span></div><div class="line" id="011943"><span class="nick" style="color:#6b8072"><a href="#011943" label="[01:19:43]">&lt;stikonas&gt;</a></span><span class="message">sometimes there is some acronym behind but in the end any name is just a name</span></div><div class="line" id="011957"><span class="nick" style="color:#2e2a4a"><a href="#011957" label="[01:19:57]">&lt;johnjaye&gt;</a></span><span class="message">kaem is the world's worst build manager. is ee</span></div><div class="line" id="012005"><span class="nick" style="color:#6d2462"><a href="#012005" label="[01:20:05]">&lt;muurkha&gt;</a></span><span class="message">oriansj: the bit-serial version of Calculus Vaporis should weigh in around 2500 transistors</span></div><div class="line" id="012007"><span class="nick" style="color:#6b8072"><a href="#012007" label="[01:20:07]">&lt;stikonas&gt;</a></span><span class="message">kaem is anagram for make</span></div><div class="line" id="012024"><span class="nick" style="color:#2e2a4a"><a href="#012024" label="[01:20:24]">&lt;johnjaye&gt;</a></span><span class="message">well gcc is just a name sure. but it's also a huge part of the software ecosystem and millions of lines of code (guessing)</span></div><div class="line" id="012031"><span class="nick" style="color:#6d2462"><a href="#012031" label="[01:20:31]">&lt;muurkha&gt;</a></span><span class="message">there's a graffiti artist near here who makes these big elaborate mural-sized tags all over town that say &quot;KAEM&quot;</span></div><div class="line" id="012040"><span class="nick" style="color:#6d2462"><a href="#012040" label="[01:20:40]">&lt;muurkha&gt;</a></span><span class="message">I should take some photos to share</span></div><div class="line" id="012048"><span class="nick" style="color:#8dd3c7"><a href="#012048" label="[01:20:48]">&lt;oriansj&gt;</a></span><span class="message">muurkha: yes please</span></div><div class="line" id="012119"><span class="nick" style="color:#6d2462"><a href="#012119" label="[01:21:19]">&lt;muurkha&gt;</a></span><span class="message">those 2500 transistors don't include RAM, just registers and logic</span></div><div class="line" id="012204"><span class="nick" style="color:#8dd3c7"><a href="#012204" label="[01:22:04]">&lt;oriansj&gt;</a></span><span class="message">even the PDP-8/s is 519 logic gates</span></div><div class="line" id="012207"><span class="nick" style="color:#6b8072"><a href="#012207" label="[01:22:07]">&lt;stikonas&gt;</a></span><span class="message">M2 is kind of a sequence. We have M0 (assembler written in arch), then there is M1 (cross-platform assembler writtne in C) and M2-Planet (C compiler in C)</span></div><div class="line" id="012221"><span class="nick" style="color:#6d2462"><a href="#012221" label="[01:22:21]">&lt;muurkha&gt;</a></span><span class="message">yeah, Calculus Vaporis is about 600 IIRC</span></div><div class="line" id="012227"><span class="nick" style="color:#6b8072"><a href="#012227" label="[01:22:27]">&lt;stikonas&gt;</a></span><span class="message">though maybe oriansj has better explanation for M2</span></div><div class="line" id="012253"><span class="nick" style="color:#6d2462"><a href="#012253" label="[01:22:53]">&lt;muurkha&gt;</a></span><span class="message">like the PDP-8, it also has a 12-bit address space (of 12-bit words) and so plausibly could run something like a BASIC interpreter, though I haven't written one for it and might be disappointed if its instruction set turns out to be too bad at density</span></div><div class="line" id="012253"><span class="nick" style="color:#6b8072"><a href="#012253" label="[01:22:53]">&lt;stikonas&gt;</a></span><span class="message">johnjaye: cc_x86 is even simpler (cc is c compiler)</span></div><div class="line" id="012335"><span class="nick" style="color:#6b8072"><a href="#012335" label="[01:23:35]">&lt;stikonas&gt;</a></span><span class="message">johnjaye: mes is probably the most curious naming: Maxwell's Equations of Software</span></div><div class="line" id="012338"><span class="nick" style="color:#8dd3c7"><a href="#012338" label="[01:23:38]">&lt;oriansj&gt;</a></span><span class="message">muurkha: actually the PDP-8 instruction set could be simpified without being hard to program</span></div><div class="line" id="012348"><span class="nick" style="color:#6d2462"><a href="#012348" label="[01:23:48]">&lt;muurkha&gt;</a></span><span class="message">johnjaye: yeah, GCC is millions of lines of code</span></div><div class="line" id="012414"><span class="nick" style="color:#6b8072"><a href="#012414" label="[01:24:14]">&lt;stikonas&gt;</a></span><span class="message">johnjaye: that's because mes interpreter can run mescc compiler that can build mes</span></div><div class="line" id="012429"><span class="nick" style="color:#6b8072"><a href="#012429" label="[01:24:29]">&lt;stikonas&gt;</a></span><span class="message">some somewhat similar to how electromagnetic field behaves</span></div><div class="line" id="012429"><span class="nick" style="color:#6d2462"><a href="#012429" label="[01:24:29]">&lt;muurkha&gt;</a></span><span class="message">a non-bit-serial version of Calculus Vaporis is more like 4500 transistors</span></div><div class="line" id="012519"><span class="nick" style="color:#8dd3c7"><a href="#012519" label="[01:25:19]">&lt;oriansj&gt;</a></span><span class="message">one could remove the rotate instructions from the PDP-8 and byte swap; not to mention the multiply and divide instructions</span></div><div class="line" id="012709"><span class="nick" style="color:#8dd3c7"><a href="#012709" label="[01:27:09]">&lt;oriansj&gt;</a></span><span class="message">the subtract/skip instruction would be simpler as a jump if zero instruction</span></div><div class="line" id="012810"><span class="nick" style="color:#8dd3c7"><a href="#012810" label="[01:28:10]">&lt;oriansj&gt;</a></span><span class="message">drop from 12bits to 8bits should simplify a few things as well</span></div><div class="line" id="012826"><span class="nick" style="color:#8dd3c7"><a href="#012826" label="[01:28:26]">&lt;oriansj&gt;</a></span><span class="message">just increase the PC from 12bits to 16bits</span></div><div class="line" id="012930"><span class="nick" style="color:#8dd3c7"><a href="#012930" label="[01:29:30]">&lt;oriansj&gt;</a></span><span class="message">using an expanded instruction encoding could also be used to simplify decoding</span></div><div class="line" id="013023"><span class="nick" style="color:#6d2462"><a href="#013023" label="[01:30:23]">&lt;muurkha&gt;</a></span><span class="message">I don't think the PDP-8/S had multiply and divide, did it?</span></div><div class="line" id="013127"><span class="nick" style="color:#6d2462"><a href="#013127" label="[01:31:27]">&lt;muurkha&gt;</a></span><span class="message">dropping the instruction word, the memory word size, and/or the address bus width from 12 to 8 bits would indeed reduce the number of transistors needed, but it would probably also drop below being a usable CPU</span></div><div class="line" id="013149"><span class="nick" style="color:#8dd3c7"><a href="#013149" label="[01:31:49]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/PDP-8#Group_3">https://en.wikipedia.org/wiki/PDP-8#Group_3</a> </span></div><div class="line" id="013220"><span class="nick" style="color:#6d2462"><a href="#013220" label="[01:32:20]">&lt;muurkha&gt;</a></span><span class="message">you could switch from being word-oriented to being byte-oriented though</span></div><div class="line" id="013223"><span class="nick" style="color:#8dd3c7"><a href="#013223" label="[01:32:23]">&lt;oriansj&gt;</a></span><span class="message">8bit accumulator and 16bit address space is enough for a C compiler</span></div><div class="line" id="013327"><span class="nick" style="color:#6d2462"><a href="#013327" label="[01:33:27]">&lt;muurkha&gt;</a></span><span class="message">yeah, for sure</span></div><div class="line" id="013345"><span class="nick" style="color:#6d2462"><a href="#013345" label="[01:33:45]">&lt;muurkha&gt;</a></span><span class="message">lots of examples of that, I have one on the desk in front of me right now in fact</span></div><div class="line" id="013410"><span class="nick" style="color:#8dd3c7"><a href="#013410" label="[01:34:10]">&lt;oriansj&gt;</a></span><span class="message">add, sub, xor, nand, jump if zero, LOAD, LOADI8, STORE would be sufficient for easy programming</span></div><div class="line" id="013510"><span class="nick" style="color:#6d2462"><a href="#013510" label="[01:35:10]">&lt;muurkha&gt;</a></span><span class="message">I know about the group-3 instructions, I just dont think the PDP-8/S had the MQ register and thus the relevant instructions, did it?</span></div><div class="line" id="013523"><span class="nick" style="color:#8dd3c7"><a href="#013523" label="[01:35:23]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I don't know</span></div><div class="line" id="013543"><span class="nick" style="color:#6d2462"><a href="#013543" label="[01:35:43]">&lt;muurkha&gt;</a></span><span class="message">did it have an EAE?</span></div><div class="line" id="013601"><span class="nick" style="color:#6d2462"><a href="#013601" label="[01:36:01]">&lt;muurkha&gt;</a></span><span class="message">WP says, The EAE was an option on the original PDP-8,[17] the 8/I,[18] and the 8/E, but it is an integral part of the Intersil 6100 microprocessor.&quot;</span></div><div class="line" id="013640"><span class="nick" style="color:#6d2462"><a href="#013640" label="[01:36:40]">&lt;muurkha&gt;</a></span><span class="message">you don't really need XOR a an instruction</span></div><div class="line" id="013708"><span class="nick" style="color:#6d2462"><a href="#013708" label="[01:37:08]">&lt;muurkha&gt;</a></span><span class="message">you probably do, however, need some way to compare integers for ordering (≤, ≥)</span></div><div class="line" id="013727"><span class="nick" style="color:#6d2462"><a href="#013727" label="[01:37:27]">&lt;muurkha&gt;</a></span><span class="message">*as an instruction</span></div><div class="line" id="013833"><span class="nick" style="color:#6d2462"><a href="#013833" label="[01:38:33]">&lt;muurkha&gt;</a></span><span class="message">I guess that for an 8-bit subtraction result you could NAND with 0x80 to preserve only the sign bit, then compare the result to 0</span></div><div class="line" id="013848"><span class="nick" style="color:#6d2462"><a href="#013848" label="[01:38:48]">&lt;muurkha&gt;</a></span><span class="message">nd that would give you a way to compare integers for ordering</span></div><div class="line" id="013922"><span class="nick" style="color:#6d2462"><a href="#013922" label="[01:39:22]">&lt;muurkha&gt;</a></span><span class="message">wait, not zero, 0xFF</span></div><div class="line" id="013945"><span class="nick" style="color:#6d2462"><a href="#013945" label="[01:39:45]">&lt;muurkha&gt;</a></span><span class="message">so you'd have to NAND with 0xFF or 0x7F to map either 0x7F or 0xFF to zero, and then you could do it</span></div><div class="line" id="014043"><span class="nick" style="color:#6b8072"><a href="#014043" label="[01:40:43]">&lt;stikonas&gt;</a></span><span class="message">well, you almost never need any specific instruction as is shown by one instruction ISA</span></div><div class="line" id="014129"><span class="nick" style="color:#8dd3c7"><a href="#014129" label="[01:41:29]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well cmp with greater and less bits being set is an optimization. Only subtraction is needed</span></div><div class="line" id="014145"><span class="nick" style="color:#6d2462"><a href="#014145" label="[01:41:45]">&lt;muurkha&gt;</a></span><span class="message">oriansj: right</span></div><div class="line" id="014202"><span class="nick" style="color:#8dd3c7"><a href="#014202" label="[01:42:02]">&lt;oriansj&gt;</a></span><span class="message">jump if negative is a cheap optimization one can do as well</span></div><div class="line" id="014206"><span class="nick" style="color:#6d2462"><a href="#014206" label="[01:42:06]">&lt;muurkha&gt;</a></span><span class="message">add is also an optimization from that POV, which is why Calculus Vaporis doesn't have it</span></div><div class="line" id="014216"><span class="nick" style="color:#6d2462"><a href="#014216" label="[01:42:16]">&lt;muurkha&gt;</a></span><span class="message">but it's an important one</span></div><div class="line" id="014219"><span class="nick" style="color:#8dd3c7"><a href="#014219" label="[01:42:19]">&lt;oriansj&gt;</a></span><span class="message">jump if positive exists also in knight</span></div><div class="line" id="014243"><span class="nick" style="color:#6d2462"><a href="#014243" label="[01:42:43]">&lt;muurkha&gt;</a></span><span class="message">stikonas: yeah, I mean that in practice the dynamic number of XORs is so low that evaluating XORs with a NAND instruction will have minimal performance impact</span></div><div class="line" id="014252"><span class="nick" style="color:#6d2462"><a href="#014252" label="[01:42:52]">&lt;muurkha&gt;</a></span><span class="message">or code size impact</span></div><div class="line" id="014304"><span class="nick" style="color:#6d2462"><a href="#014304" label="[01:43:04]">&lt;muurkha&gt;</a></span><span class="message">(because the static number of XORs is also low)</span></div><div class="line" id="014330"><span class="nick" style="color:#6b8072"><a href="#014330" label="[01:43:30]">&lt;stikonas&gt;</a></span><span class="message">yes, for riscv64 in stage0-posix we have 6 uses in hex1 and 6 in hex2</span></div><div class="line" id="014331"><span class="nick" style="color:#8dd3c7"><a href="#014331" label="[01:43:31]">&lt;oriansj&gt;</a></span><span class="message">jmp.nz (not zero), jmp.z (zero), jmp.n (negative), jmp.p (positive) would be quite easy to work with</span></div><div class="line" id="014332"><span class="nick" style="color:#6d2462"><a href="#014332" label="[01:43:32]">&lt;muurkha&gt;</a></span><span class="message">not true, I think, of sign comparisons, addition, or right shift</span></div><div class="line" id="014341"><span class="nick" style="color:#6b8072"><a href="#014341" label="[01:43:41]">&lt;stikonas&gt;</a></span><span class="message">(probably in same places)</span></div><div class="line" id="014401"><span class="nick" style="color:#6b8072"><a href="#014401" label="[01:44:01]">&lt;stikonas&gt;</a></span><span class="message">and for other non-word arches we might have even fewer xors</span></div><div class="line" id="014404"><span class="nick" style="color:#6d2462"><a href="#014404" label="[01:44:04]">&lt;muurkha&gt;</a></span><span class="message">if you remove those I think you get a significant slowdown</span></div><div class="line" id="014427"><span class="nick" style="color:#8dd3c7"><a href="#014427" label="[01:44:27]">&lt;oriansj&gt;</a></span><span class="message">a single bit shift would probably eat a good few transistors</span></div><div class="line" id="014439"><span class="nick" style="color:#6d2462"><a href="#014439" label="[01:44:39]">&lt;muurkha&gt;</a></span><span class="message">not transistors, no, just wires</span></div><div class="line" id="014510"><span class="nick" style="color:#8dd3c7"><a href="#014510" label="[01:45:10]">&lt;oriansj&gt;</a></span><span class="message">muurkha: nice</span></div><div class="line" id="014519"><span class="nick" style="color:#6d2462"><a href="#014519" label="[01:45:19]">&lt;muurkha&gt;</a></span><span class="message">hey man, I didn't do it</span></div><div class="line" id="014520"><span class="nick" style="color:#6d2462"><a href="#014520" label="[01:45:20]">&lt;muurkha&gt;</a></span><span class="message">indexed store is also a pretty useful optimization, and was omitted from the 8080</span></div><div class="line" id="014547"><span class="nick" style="color:#6d2462"><a href="#014547" label="[01:45:47]">&lt;muurkha&gt;</a></span><span class="message">(but not RV32I or even RV32E)</span></div><div class="line" id="014609"><span class="nick" style="color:#8dd3c7"><a href="#014609" label="[01:46:09]">&lt;oriansj&gt;</a></span><span class="message">that would just be store r0 [r1]</span></div><div class="line" id="014625"><span class="nick" style="color:#8dd3c7"><a href="#014625" label="[01:46:25]">&lt;oriansj&gt;</a></span><span class="message">but that would cost additional registers</span></div><div class="line" id="014630"><span class="nick" style="color:#6d2462"><a href="#014630" label="[01:46:30]">&lt;muurkha&gt;</a></span><span class="message">no, by indexed store I mean store r0 [r1+8]</span></div><div class="line" id="014654"><span class="nick" style="color:#8dd3c7"><a href="#014654" label="[01:46:54]">&lt;oriansj&gt;</a></span><span class="message">oh, no need for that at all</span></div><div class="line" id="014707"><span class="nick" style="color:#8dd3c7"><a href="#014707" label="[01:47:07]">&lt;oriansj&gt;</a></span><span class="message">it'll only save a single instruction</span></div><div class="line" id="014708"><span class="nick" style="color:#6d2462"><a href="#014708" label="[01:47:08]">&lt;muurkha&gt;</a></span><span class="message">no, you can do without it, but it's expensive</span></div><div class="line" id="014713"><span class="nick" style="color:#6d2462"><a href="#014713" label="[01:47:13]">&lt;muurkha&gt;</a></span><span class="message">it's also missing on the PDP-8</span></div><div class="line" id="014725"><span class="nick" style="color:#6d2462"><a href="#014725" label="[01:47:25]">&lt;muurkha&gt;</a></span><span class="message">yeah, but it saves a single instruction almost every single time you access memory :)</span></div><div class="line" id="014820"><span class="nick" style="color:#8dd3c7"><a href="#014820" label="[01:48:20]">&lt;oriansj&gt;</a></span><span class="message">well if you look at my knight code: you'll see it isn't that big of a benefit</span></div><div class="line" id="014900"><span class="nick" style="color:#6d2462"><a href="#014900" label="[01:49:00]">&lt;muurkha&gt;</a></span><span class="message">it's certainly possible to write code without it</span></div><div class="line" id="014916"><span class="nick" style="color:#6d2462"><a href="#014916" label="[01:49:16]">&lt;muurkha&gt;</a></span><span class="message">I mean you can store most variables at fixed memory locations</span></div><div class="line" id="015006"><span class="nick" style="color:#6d2462"><a href="#015006" label="[01:50:06]">&lt;muurkha&gt;</a></span><span class="message">but that gets painful anytime there's more than one of something</span></div><div class="line" id="015011"><span class="nick" style="color:#8dd3c7"><a href="#015011" label="[01:50:11]">&lt;oriansj&gt;</a></span><span class="message">well I do load r0 [r0] a good bit (because -&gt;next is always at offset zero there)</span></div><div class="line" id="015159"><span class="nick" style="color:#6d2462"><a href="#015159" label="[01:51:59]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="015211"><span class="nick" style="color:#8dd3c7"><a href="#015211" label="[01:52:11]">&lt;oriansj&gt;</a></span><span class="message">4 registers would really simplify things</span></div><div class="line" id="015229"><span class="nick" style="color:#6d2462"><a href="#015229" label="[01:52:29]">&lt;muurkha&gt;</a></span><span class="message">also I think call and return instructions are pretty useful</span></div><div class="line" id="015245"><span class="nick" style="color:#8dd3c7"><a href="#015245" label="[01:52:45]">&lt;oriansj&gt;</a></span><span class="message">they do simplify a great many things</span></div><div class="line" id="015312"><span class="nick" style="color:#6d2462"><a href="#015312" label="[01:53:12]">&lt;muurkha&gt;</a></span><span class="message">if you don't have a return instruction you really need a way to jmp to a register value, otherwise you end up having to use self-modifying code for switch, return, and ad-hoc polymorphism (function pointers)</span></div><div class="line" id="015323"><span class="nick" style="color:#8dd3c7"><a href="#015323" label="[01:53:23]">&lt;oriansj&gt;</a></span><span class="message">store-pc, load-pc would work</span></div><div class="line" id="015406"><span class="nick" style="color:#6d2462"><a href="#015406" label="[01:54:06]">&lt;muurkha&gt;</a></span><span class="message">in your list add, sub, xor, nand, jump if zero, LOAD, LOADI8, STORE also omits immediates and 8-bit stores.  which, yeah, you can do without, but again it's awkward</span></div><div class="line" id="015427"><span class="nick" style="color:#8dd3c7"><a href="#015427" label="[01:54:27]">&lt;oriansj&gt;</a></span><span class="message">LOADI8 is loading of an 8bit immediate</span></div><div class="line" id="015448"><span class="nick" style="color:#8dd3c7"><a href="#015448" label="[01:54:48]">&lt;oriansj&gt;</a></span><span class="message">and we are only loading 8bits and storing 8bits</span></div><div class="line" id="015548"><span class="nick" style="color:#8dd3c7"><a href="#015548" label="[01:55:48]">&lt;oriansj&gt;</a></span><span class="message">if I were to do a 16bit ALU then yes you would want LOAD, LOAD8, STORE, STORE8 and LOADI16</span></div><div class="line" id="015619"><span class="nick" style="color:#8dd3c7"><a href="#015619" label="[01:56:19]">&lt;oriansj&gt;</a></span><span class="message">LOAD8U (possibly if you wanted to not sign extend)</span></div><div class="line" id="015845"><span class="nick" style="color:#6d2462"><a href="#015845" label="[01:58:45]">&lt;muurkha&gt;</a></span><span class="message">oh, I misunderstood</span></div><div class="line" id="015854"><span class="nick" style="color:#6d2462"><a href="#015854" label="[01:58:54]">&lt;muurkha&gt;</a></span><span class="message">agreed then</span></div><div class="line" id="015914"><span class="nick" style="color:#6d2462"><a href="#015914" label="[01:59:14]">&lt;muurkha&gt;</a></span><span class="message">the 6502 had an 8-bit accumulator and two 8-bit pointers</span></div><div class="line" id="020004"><span class="nick" style="color:#6d2462"><a href="#020004" label="[02:00:04]">&lt;muurkha&gt;</a></span><span class="message">it would have benefited a lot from an 8-bit zero-page pointer (which was added on the 65816) and a PC-page addressing mode</span></div><div class="line" id="020015"><span class="nick" style="color:#8dd3c7"><a href="#020015" label="[02:00:15]">&lt;oriansj&gt;</a></span><span class="message">if one wanted to be extra easy to work with: add a 16bit stack pointer (as an 8bit stack is bleh) and push, pop, call and return be the only things that impacted it with the default value being 0xFFFFFFFF</span></div><div class="line" id="020052"><span class="nick" style="color:#8dd3c7"><a href="#020052" label="[02:00:52]">&lt;oriansj&gt;</a></span><span class="message">muurkha: yeah the 6809 did that idea to optimize for smaller code size</span></div><div class="line" id="020107"><span class="nick" style="color:#6d2462"><a href="#020107" label="[02:01:07]">&lt;muurkha&gt;</a></span><span class="message">you can do without 8-bit loads on a machine with a more-than-8-bit accumulator if you support unaligned access (as you normally would if you had an 8-bit data bus)</span></div><div class="line" id="020128"><span class="nick" style="color:#8dd3c7"><a href="#020128" label="[02:01:28]">&lt;oriansj&gt;</a></span><span class="message">and we can cheat very hard too</span></div><div class="line" id="020141"><span class="nick" style="color:#8dd3c7"><a href="#020141" label="[02:01:41]">&lt;oriansj&gt;</a></span><span class="message">put the registers in RAM itself</span></div><div class="line" id="020151"><span class="nick" style="color:#6d2462"><a href="#020151" label="[02:01:51]">&lt;muurkha&gt;</a></span><span class="message">well, the 6502 kind of does</span></div><div class="line" id="020157"><span class="nick" style="color:#6d2462"><a href="#020157" label="[02:01:57]">&lt;muurkha&gt;</a></span><span class="message">the zero page is the registers</span></div><div class="line" id="020204"><span class="nick" style="color:#6d2462"><a href="#020204" label="[02:02:04]">&lt;muurkha&gt;</a></span><span class="message">the 6502 does okay with an 8-bit stack but it isn't really usable as a C stack</span></div><div class="line" id="020239"><span class="nick" style="color:#8dd3c7"><a href="#020239" label="[02:02:39]">&lt;oriansj&gt;</a></span><span class="message">ACCUMULATOR in 0x00000000, PC in 0x00000002 and Stack in 0xFFFFFFFD</span></div><div class="line" id="020316"><span class="nick" style="color:#8dd3c7"><a href="#020316" label="[02:03:16]">&lt;oriansj&gt;</a></span><span class="message">yeah you can't do a C compiler using the 6502 hardware stack and instead have to manually manage your own which is a huge pain</span></div><div class="line" id="020330"><span class="nick" style="color:#6d2462"><a href="#020330" label="[02:03:30]">&lt;muurkha&gt;</a></span><span class="message">yeah, the PDP-10, PDP-X, and I think the PDP-8 mapped their architectural registers into the memory space</span></div><div class="line" id="020414"><span class="nick" style="color:#2e2a4a"><a href="#020414" label="[02:04:14]">&lt;johnjaye&gt;</a></span><span class="message">i wonder if the pdp8/pdp11 were the earliest processors that could actually have a language like C on them</span></div><div class="line" id="020438"><span class="nick" style="color:#6d2462"><a href="#020438" label="[02:04:38]">&lt;muurkha&gt;</a></span><span class="message">no, the PDP-8 didn't come out until 01965</span></div><div class="line" id="020522"><span class="nick" style="color:#6d2462"><a href="#020522" label="[02:05:22]">&lt;muurkha&gt;</a></span><span class="message">there were lots of processors from the 01950s that would have been adequate for C and a few that would have been fine</span></div><div class="line" id="020532"><span class="nick" style="color:#8dd3c7"><a href="#020532" label="[02:05:32]">&lt;oriansj&gt;</a></span><span class="message">well 8bit accumulator, 16bit PC and 16bit stack would only cost 240 transistors (assuming 6transistors per bit)</span></div><div class="line" id="020605"><span class="nick" style="color:#6d2462"><a href="#020605" label="[02:06:05]">&lt;muurkha&gt;</a></span><span class="message">that doesn't count the transistors to increment and decrement them, or the muxes to put those values onto different buses</span></div><div class="line" id="020705"><span class="nick" style="color:#8dd3c7"><a href="#020705" label="[02:07:05]">&lt;oriansj&gt;</a></span><span class="message">true but that is what I used to estimate the transistor counts used in the RISC-II register file</span></div><div class="line" id="020724"><span class="nick" style="color:#8dd3c7"><a href="#020724" label="[02:07:24]">&lt;oriansj&gt;</a></span><span class="message">so if I am under-estimating here, the savings also would be larger there</span></div><div class="line" id="020729"><span class="nick" style="color:#6d2462"><a href="#020729" label="[02:07:29]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="021019"><span class="nick" style="color:#6d2462"><a href="#021019" label="[02:10:19]">&lt;muurkha&gt;</a></span><span class="message">johnjaye: things that make C hard to implement include tagged memory (Burroughs 5000), non-byte-addressable memory (most scientific machines of the 01950s up to the 01990s and also the Nova and Tandem, though C implementations on TI DSPs solved this problem by simply making their chars 32 bits wide), a lack of bitwise operations (all BCD computers including most &quot;business&quot; machines from the</span></div><div class="line" id="021025"><span class="nick" style="color:#6d2462"><a href="#021025" label="[02:10:25]">&lt;muurkha&gt;</a></span><span class="message">01950s), and not enough memory space (the HP 9100A, the GreenArrays F18A)</span></div><div class="line" id="021039"><span class="nick" style="color:#8dd3c7"><a href="#021039" label="[02:10:39]">&lt;oriansj&gt;</a></span><span class="message">but if the 6502 is any indicator with 3,510 transistors and the majority of which in the decode logic</span></div><div class="line" id="021052"><span class="nick" style="color:#6d2462"><a href="#021052" label="[02:10:52]">&lt;muurkha&gt;</a></span><span class="message">that doesn't count the depletion-mode transistors</span></div><div class="line" id="021119"><span class="nick" style="color:#6d2462"><a href="#021119" label="[02:11:19]">&lt;muurkha&gt;</a></span><span class="message">which bring the total to 4528</span></div><div class="line" id="021145"><span class="nick" style="color:#8dd3c7"><a href="#021145" label="[02:11:45]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://monster6502.com/">https://monster6502.com/</a> </span></div><div class="line" id="021147"><span class="nick" style="color:#6d2462"><a href="#021147" label="[02:11:47]">&lt;muurkha&gt;</a></span><span class="message">the 6502 or 8080 or PDP-8 isn't hard to implement C on, it's just that C code on them runs slowly</span></div><div class="line" id="021156"><span class="nick" style="color:#8dd3c7"><a href="#021156" label="[02:11:56]">&lt;oriansj&gt;</a></span><span class="message">Total active transistors: 4237</span></div><div class="line" id="021207"><span class="nick" style="color:#6d2462"><a href="#021207" label="[02:12:07]">&lt;muurkha&gt;</a></span><span class="message">yeah, the MonSter 6502 uses resistors for some of the depletion loads, I think</span></div><div class="line" id="021224"><span class="nick" style="color:#2e2a4a"><a href="#021224" label="[02:12:24]">&lt;johnjaye&gt;</a></span><span class="message">oh ok</span></div><div class="line" id="021533"><span class="nick" style="color:#6d2462"><a href="#021533" label="[02:15:33]">&lt;muurkha&gt;</a></span><span class="message">in theory a sufficiently smart C compiler could get C code to run fast on them, though I don't think such a thing has been written</span></div><div class="line" id="021629"><span class="nick" style="color:#6d2462"><a href="#021629" label="[02:16:29]">&lt;muurkha&gt;</a></span><span class="message">but it's a different level of performance problem than not having bitwise operations in your CPU because your bytes range from 0 to 99</span></div><div class="line" id="021718"><span class="nick" style="color:#6d2462"><a href="#021718" label="[02:17:18]">&lt;muurkha&gt;</a></span><span class="message">or not being able to byte-address half of your memory space because it's 128 KiB and your registers are only 16 bits (I think that was Tandem)</span></div><div class="line" id="021756"><span class="nick" style="color:#8dd3c7"><a href="#021756" label="[02:17:56]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://www.pagetable.com/?p=39">https://www.pagetable.com/?p=39</a> </span></div><div class="line" id="022030"><span class="nick" style="color:#8dd3c7"><a href="#022030" label="[02:20:30]">&lt;oriansj&gt;</a></span><span class="message">well we could extend the PC and stack to 24bits which would be more than enough to run an operating system and C compiler</span></div><div class="line" id="022156"><span class="nick" style="color:#6d2462"><a href="#022156" label="[02:21:56]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="http://www.righto.com/2013/01/a-small-part-of-6502-chip-explained.html">http://www.righto.com/2013/01/a-small-part-of-6502-chip-explained.html</a>  is one citation for the 4528 number</span></div><div class="line" id="022214"><span class="nick" style="color:#8dd3c7"><a href="#022214" label="[02:22:14]">&lt;oriansj&gt;</a></span><span class="message">adding overflow (for add) and borrow (for subtract) bits; jump.o (jump if overflow) and jump.b (jump if borrow) would enable efficient multibyte arithmetic</span></div><div class="line" id="022216"><span class="nick" style="color:#6d2462"><a href="#022216" label="[02:22:16]">&lt;muurkha&gt;</a></span><span class="message">if you were doing it in CMOS instead of NMOS you'd probably need 7000 transistors or so</span></div><div class="line" id="022311"><span class="nick" style="color:#6d2462"><a href="#022311" label="[02:23:11]">&lt;muurkha&gt;</a></span><span class="message">oriansj: C requires you to be able to take the addresses of local variables, so if your stack pointer is 24 bits then pointer variables in C also need to be 24 bits</span></div><div class="line" id="022449"><span class="nick" style="color:#6d2462"><a href="#022449" label="[02:24:49]">&lt;muurkha&gt;</a></span><span class="message">which likely means that you need at least one other 24-bit register that isn't the PC or SP.  although maybe if you don't have interrupts, or they run on a separate stack, you could get away with saving the SP in RAM at a fixed location, loading your pointer into the SP, and using push and pop to dereference the pointer :)</span></div><div class="line" id="022450"><span class="nick" style="color:#8dd3c7"><a href="#022450" label="[02:24:50]">&lt;oriansj&gt;</a></span><span class="message">muurkha: nope but it would make things prettier</span></div><div class="line" id="022526"><span class="nick" style="color:#6d2462"><a href="#022526" label="[02:25:26]">&lt;muurkha&gt;</a></span><span class="message">no, I mean you can't implement the semantics of C if you can't take the addresses of local variables, or if local variables aren't allocated dynamically to permit recursion</span></div><div class="line" id="022535"><span class="nick" style="color:#6d2462"><a href="#022535" label="[02:25:35]">&lt;muurkha&gt;</a></span><span class="message">it's not just a matter of making things prettier</span></div><div class="line" id="022554"><span class="nick" style="color:#8dd3c7"><a href="#022554" label="[02:25:54]">&lt;oriansj&gt;</a></span><span class="message">muurkha: hence load-pc would be reading a memory address</span></div><div class="line" id="022614"><span class="nick" style="color:#2e2a4a"><a href="#022614" label="[02:26:14]">&lt;johnjaye&gt;</a></span><span class="message">i had no idea people still new about the burroughs 5000 or those other machines</span></div><div class="line" id="022617"><span class="nick" style="color:#6d2462"><a href="#022617" label="[02:26:17]">&lt;muurkha&gt;</a></span><span class="message">load-pc is just indirect jump, that's a different issue</span></div><div class="line" id="022632"><span class="nick" style="color:#6d2462"><a href="#022632" label="[02:26:32]">&lt;muurkha&gt;</a></span><span class="message">johnjaye: I don't know much about it, I've just read a book is all</span></div><div class="line" id="022911"><span class="nick" style="color:#8dd3c7"><a href="#022911" label="[02:29:11]">&lt;oriansj&gt;</a></span><span class="message">muurkha: we could simulate 32/16bit support in functions</span></div><div class="line" id="022936"><span class="nick" style="color:#8dd3c7"><a href="#022936" label="[02:29:36]">&lt;oriansj&gt;</a></span><span class="message">so we wouldn't needtfgbvhrdjeugjeklerrhfkrdirigidbjbvnkifdlcgfg</span></div><div class="line" id="023003"><span class="nick" style="color:#6d2462"><a href="#023003" label="[02:30:03]">&lt;muurkha&gt;</a></span><span class="message">hello tiny orians offspring</span></div><div class="line" id="023003"><span class="nick" style="color:#8dd3c7"><a href="#023003" label="[02:30:03]">&lt;oriansj&gt;</a></span><span class="message">yep</span></div><div class="line" id="023010"><span class="nick" style="color:#6d2462"><a href="#023010" label="[02:30:10]">&lt;muurkha&gt;</a></span><span class="message">welcome to the world</span></div><div class="line" id="023029"><span class="nick" style="color:#8dd3c7"><a href="#023029" label="[02:30:29]">&lt;oriansj&gt;</a></span><span class="message">so yeah, only an 8bit accumulator would be needed</span></div><div class="line" id="023048"><span class="nick" style="color:#6d2462"><a href="#023048" label="[02:30:48]">&lt;muurkha&gt;</a></span><span class="message">yeah, you don't need a bigger accumulator to have bigger pointers</span></div><div class="line" id="023054"><span class="nick" style="color:#8dd3c7"><a href="#023054" label="[02:30:54]">&lt;oriansj&gt;</a></span><span class="message">and we could just do the sweet-16 register approach for the C code</span></div><div class="line" id="023124"><span class="nick" style="color:#6d2462"><a href="#023124" label="[02:31:24]">&lt;muurkha&gt;</a></span><span class="message">yes, but only if you have a CPU instruction that is capable of reading from a 24-bit address</span></div><div class="line" id="023130"><span class="nick" style="color:#6d2462"><a href="#023130" label="[02:31:30]">&lt;muurkha&gt;</a></span><span class="message">so you need some 24-bit pointer register</span></div><div class="line" id="023142"><span class="nick" style="color:#8dd3c7"><a href="#023142" label="[02:31:42]">&lt;oriansj&gt;</a></span><span class="message">nope</span></div><div class="line" id="023156"><span class="nick" style="color:#6d2462"><a href="#023156" label="[02:31:56]">&lt;muurkha&gt;</a></span><span class="message">(or writing to a 24-bit address)</span></div><div class="line" id="023213"><span class="nick" style="color:#6d2462"><a href="#023213" label="[02:32:13]">&lt;muurkha&gt;</a></span><span class="message">that is, if your local variables on the stack can be at arbitrary 24-bit addresses</span></div><div class="line" id="023306"><span class="nick" style="color:#8dd3c7"><a href="#023306" label="[02:33:06]">&lt;oriansj&gt;</a></span><span class="message">you modify the LOAD instruction in memory to point to the local variable</span></div><div class="line" id="023451"><span class="nick" style="color:#8dd3c7"><a href="#023451" label="[02:34:51]">&lt;oriansj&gt;</a></span><span class="message">as you can either do load instructions that cover the whole address space or do pointer register</span></div><div class="line" id="023817"><span class="nick" style="color:#6d2462"><a href="#023817" label="[02:38:17]">&lt;muurkha&gt;</a></span><span class="message">that does work if the LOAD instruction has a 24-bit address field in it!  but that just means that your 24+-bit register in the CPU is the current-instruction register</span></div><div class="line" id="023838"><span class="nick" style="color:#8dd3c7"><a href="#023838" label="[02:38:38]">&lt;oriansj&gt;</a></span><span class="message">or if we wanted to get clever: 24bit stack and PC, 16bit accumulator and 8bit page register</span></div><div class="line" id="023849"><span class="nick" style="color:#6d2462"><a href="#023849" label="[02:38:49]">&lt;muurkha&gt;</a></span><span class="message">yeah, that would work</span></div><div class="line" id="023933"><span class="nick" style="color:#6d2462"><a href="#023933" label="[02:39:33]">&lt;muurkha&gt;</a></span><span class="message">the current-instruction register is not an architectural register, in the sense that you can't access its contents with instructions, but it still costs transistors per bit</span></div><div class="line" id="024014"><span class="nick" style="color:#6d2462"><a href="#024014" label="[02:40:14]">&lt;muurkha&gt;</a></span><span class="message">hmm, we should probably do some experiments rather than just talking</span></div><div class="line" id="024024"><span class="nick" style="color:#8dd3c7"><a href="#024024" label="[02:40:24]">&lt;oriansj&gt;</a></span><span class="message">well PC relative operations are not essential for C but knowing the stack pointer might be</span></div><div class="line" id="024300"><span class="nick" style="color:#6d2462"><a href="#024300" label="[02:43:00]">&lt;muurkha&gt;</a></span><span class="message">yeah, PC-relative operations are useful for position-independent code</span></div><div class="line" id="024319"><span class="nick" style="color:#6d2462"><a href="#024319" label="[02:43:19]">&lt;muurkha&gt;</a></span><span class="message">which is nice for shared libraries</span></div><div class="line" id="024324"><span class="nick" style="color:#8dd3c7"><a href="#024324" label="[02:43:24]">&lt;oriansj&gt;</a></span><span class="message">so push page register and pop page register and copy stack pointer to accumulator and page register might be required</span></div><div class="line" id="024340"><span class="nick" style="color:#6d2462"><a href="#024340" label="[02:43:40]">&lt;muurkha&gt;</a></span><span class="message">even the PDP-8's tightwad version of PC-relative memory access is enough for relocating shared libraries</span></div><div class="line" id="024747"><span class="nick" style="color:#8dd3c7"><a href="#024747" label="[02:47:47]">&lt;oriansj&gt;</a></span><span class="message">well if we wanted things to be as simple as possible for assembly programmers we would have 4 registers R0 (accumulator), R1 (index), R2 (stack) and R3 (PC)</span></div><div class="line" id="024924"><span class="nick" style="color:#8dd3c7"><a href="#024924" label="[02:49:24]">&lt;oriansj&gt;</a></span><span class="message">and so all operations such as pushing onto the stack and loading relative to the PC is the same as loading from the accumulator</span></div><div class="line" id="025611"><span class="nick" style="color:#8dd3c7"><a href="#025611" label="[02:56:11]">&lt;oriansj&gt;</a></span><span class="message">the RCA 1802 was 5,000 transistors</span></div><div class="line" id="025628"><span class="nick" style="color:#8dd3c7"><a href="#025628" label="[02:56:28]">&lt;oriansj&gt;</a></span><span class="message">had a set of sixteen registers of 16 bits each</span></div><div class="line" id="025725"><span class="nick" style="color:#8dd3c7"><a href="#025725" label="[02:57:25]">&lt;oriansj&gt;</a></span><span class="message">and that was C2L CMOS technology</span></div><div class="line" id="025813"><span class="nick" style="color:#8dd3c7"><a href="#025813" label="[02:58:13]">&lt;oriansj&gt;</a></span><span class="message">ran C and Basic</span></div><div class="line" id="025902"><span class="nick" style="color:#8dd3c7"><a href="#025902" label="[02:59:02]">&lt;oriansj&gt;</a></span><span class="message">so assuming 6 transistors per register bit; 1:  1536</span></div><div class="line" id="025914"><span class="nick" style="color:#8dd3c7"><a href="#025914" label="[02:59:14]">&lt;oriansj&gt;</a></span><span class="message">1536 transistors for the registers</span></div><div class="line" id="025931"><span class="nick" style="color:#8dd3c7"><a href="#025931" label="[02:59:31]">&lt;oriansj&gt;</a></span><span class="message">and we could get by 1/4th that</span></div><div class="line" id="030044"><span class="nick" style="color:#8dd3c7"><a href="#030044" label="[03:00:44]">&lt;oriansj&gt;</a></span><span class="message">we absolutely don't need the I/O logic either</span></div><div class="line" id="130736"><span class="nick" style="color:#6d2462"><a href="#130736" label="[13:07:36]">&lt;muurkha&gt;</a></span><span class="message">yeah, 5000 is doable, that's bigger than the 6502</span></div><div class="line" id="130746"><span class="nick" style="color:#6d2462"><a href="#130746" label="[13:07:46]">&lt;muurkha&gt;</a></span><span class="message">or the Intersil 6100 PDP-8-on-a-chip</span></div><br /></div></body></html>