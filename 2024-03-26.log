<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2024-03-26.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="015208"><span class="nick" style="color:#389600"><a href="#015208" label="[01:52:08]">&lt;fossy&gt;</a></span><span class="message">&quot;can anyone help me to write the rootfs.py file in bash language&quot;????</span></div><div class="line" id="015214"><span class="nick" style="color:#389600"><a href="#015214" label="[01:52:14]">&lt;fossy&gt;</a></span><span class="message">confusion</span></div><div class="line" id="020111"><span class="nick" style="color:#8dd3c7"><a href="#020111" label="[02:01:11]">&lt;oriansj&gt;</a></span><span class="message">ludocode: love the idea, glad to see something in progress. Odd to not support arrays and structs when they only take only a few lines of assembly and really clean up the C code you can write.</span></div><div class="line" id="020244"><span class="nick" style="color:#2e2a4a"><a href="#020244" label="[02:02:44]">&lt;stikonas&gt;</a></span><span class="message">fossy: I think it's the same Guest that asked something similar a month or so ago</span></div><div class="line" id="020309"><span class="nick" style="color:#2e2a4a"><a href="#020309" label="[02:03:09]">&lt;stikonas&gt;</a></span><span class="message">but yes, I don't really understand the need</span></div><div class="line" id="020324"><span class="nick" style="color:#2e2a4a"><a href="#020324" label="[02:03:24]">&lt;stikonas&gt;</a></span><span class="message">and if you don't like python, you could just follow manual instructions</span></div><div class="line" id="020337"><span class="nick" style="color:#2e2a4a"><a href="#020337" label="[02:03:37]">&lt;stikonas&gt;</a></span><span class="message">and write bash script or similar based on that</span></div><div class="line" id="020438"><span class="nick" style="color:#2e2a4a"><a href="#020438" label="[02:04:38]">&lt;stikonas&gt;</a></span><span class="message">fossy: have you managed to make any progress on that montly reproducibility issue?</span></div><div class="line" id="020515"><span class="nick" style="color:#2e2a4a"><a href="#020515" label="[02:05:15]">&lt;stikonas&gt;</a></span><span class="message">was it diffutils 3.10?</span></div><div class="line" id="022641"><span class="nick" style="color:#8dd3c7"><a href="#022641" label="[02:26:41]">&lt;oriansj&gt;</a></span><span class="message">although the hex and vm implementation appears to be over 6KB.</span></div><div class="line" id="022726"><span class="nick" style="color:#8dd3c7"><a href="#022726" label="[02:27:26]">&lt;oriansj&gt;</a></span><span class="message">which is a bit of an audit problem.</span></div><div class="line" id="022744"><span class="nick" style="color:#8dd3c7"><a href="#022744" label="[02:27:44]">&lt;oriansj&gt;</a></span><span class="message">and there is the question of the driver for the vm flows</span></div><div class="line" id="023225"><span class="nick" style="color:#8dd3c7"><a href="#023225" label="[02:32:25]">&lt;oriansj&gt;</a></span><span class="message">and have you taken a look at the sweet-16 instruction set?</span></div><div class="line" id="035502"><span class="nick" style="color:#6b8072"><a href="#035502" label="[03:55:02]">&lt;ludocode&gt;</a></span><span class="message">Yeah, in retrospect putting arrays in the first stage compiler would have made life a bit easier for some of the second stages. Mostly at the time I was just really trying to limit the amount of assembly I had to write</span></div><div class="line" id="035629"><span class="nick" style="color:#6b8072"><a href="#035629" label="[03:56:29]">&lt;ludocode&gt;</a></span><span class="message">It can always be changed after the fact. Right now the second stage compiler is completely done aside from whatever bugs are gonna crop up, and it implements most of C89 plus some C99 so it's not really an issue anymore.</span></div><div class="line" id="035721"><span class="nick" style="color:#6b8072"><a href="#035721" label="[03:57:21]">&lt;ludocode&gt;</a></span><span class="message">Hex and VM together are above 6 KB of hexadecimal machine code, yep. A lot of that is padding and data, I really did not want to be conservative with error messages and such, but yes it's a lot</span></div><div class="line" id="035955"><span class="nick" style="color:#6b8072"><a href="#035955" label="[03:59:55]">&lt;ludocode&gt;</a></span><span class="message">Minimizing size of the machine code is not really a primary goal. I'm a lot more interested in the aliens/archaeology/etc. bootstrapping problem than the trusting trust problem to be honest, so the VM is really the critical feature of this, and the fact that it can be implemented in pure machine code is kind of a bonus / side goal</span></div><div class="line" id="040235"><span class="nick" style="color:#6b8072"><a href="#040235" label="[04:02:35]">&lt;ludocode&gt;</a></span><span class="message">And in any case the machine code is really heavily documented, it's more comments than code. I do think it's reasonably auditable, maybe not trivially so but certainly within the capabilities of anyone who cares about the trusting trust problem</span></div><div class="line" id="040610"><span class="nick" style="color:#6b8072"><a href="#040610" label="[04:06:10]">&lt;ludocode&gt;</a></span><span class="message">I hadn't seen sweet-16, that's pretty cool. I probably should have spent more time researching instruction sets before starting because there are some obvious mistakes in Onramp, like the lack of shift instructions. I intend to change the bytecode over time to fix some of these problems, right now it works so I figure it's more important to work on the full compiler</span></div><div class="line" id="041238"><span class="nick" style="color:#8dd3c7"><a href="#041238" label="[04:12:38]">&lt;oriansj&gt;</a></span><span class="message">ludocode: completely fair.</span></div><div class="line" id="041703"><span class="nick" style="color:#8dd3c7"><a href="#041703" label="[04:17:03]">&lt;oriansj&gt;</a></span><span class="message">rotate instructions don't really end up being useful and fixed instruction size isn't as helpful as you would expect for a single state machine</span></div><div class="line" id="041910"><span class="nick" style="color:#8dd3c7"><a href="#041910" label="[04:19:10]">&lt;oriansj&gt;</a></span><span class="message">and call reg (or jump-link reg reg) is all you need to support true function pointers in C efficiently.</span></div><div class="line" id="042259"><span class="nick" style="color:#8dd3c7"><a href="#042259" label="[04:22:59]">&lt;oriansj&gt;</a></span><span class="message">if your goal was a minimal VM for C, a stack machine with 8bit instructions probably would be a tighter fit</span></div><div class="line" id="042318"><span class="nick" style="color:#6b8072"><a href="#042318" label="[04:23:18]">&lt;ludocode&gt;</a></span><span class="message">Yeah the reason it doesn't have function pointers is mainly about type storage, nothing to do with the instruction set. Types aren't stored as a tree of declarators, there are no references from types to other types. Really simple to implement but it means function pointer types aren't really possible</span></div><div class="line" id="042537"><span class="nick" style="color:#6b8072"><a href="#042537" label="[04:25:37]">&lt;ludocode&gt;</a></span><span class="message">I used rotate just because I was really trying to limit to 16 instructions and it was possible to implement both shifts with one rotate. Turned out to be a terrible idea, implementing a shift using rotate takes like 15 instructions, and shifts are used all the time and rotate never. (whereas xor can be implemented with just three instructions, and+or+sub, so I should have just gotten rid of xor and put in both shifts. That's what I</span></div><div class="line" id="042537"><span class="nick" style="color:#6b8072"><a href="#042537" label="[04:25:37]">&lt;ludocode&gt;</a></span><span class="message">intend to change later)</span></div><div class="line" id="042653"><span class="nick" style="color:#6b8072"><a href="#042653" label="[04:26:53]">&lt;ludocode&gt;</a></span><span class="message">Anyway the reason the VM is so big isn't really the instruction set. Most of the VM is about host integration: passing command-line arguments and environment variables into the VM and bridging the filesystem through all the system calls</span></div><div class="line" id="042701"><span class="nick" style="color:#8dd3c7"><a href="#042701" label="[04:27:01]">&lt;oriansj&gt;</a></span><span class="message">and it appears you are using a full byte per register?</span></div><div class="line" id="042736"><span class="nick" style="color:#6b8072"><a href="#042736" label="[04:27:36]">&lt;ludocode&gt;</a></span><span class="message">Yeah the bytecode is really not meant to be space efficient, it's meant to be really easy to read/write. That's another advantage of the fixed instruction size, everything lines up in a hexdump</span></div><div class="line" id="042836"><span class="nick" style="color:#8dd3c7"><a href="#042836" label="[04:28:36]">&lt;oriansj&gt;</a></span><span class="message">well you could go MMIX and just have 256 registers</span></div><div class="line" id="042900"><span class="nick" style="color:#6b8072"><a href="#042900" label="[04:29:00]">&lt;ludocode&gt;</a></span><span class="message">Another big advantage of fixed instruction size is it's way easier to manually calculate relative jumps, the relative jump instruction uses words rather than bytes</span></div><div class="line" id="042902"><span class="nick" style="color:#8dd3c7"><a href="#042902" label="[04:29:02]">&lt;oriansj&gt;</a></span><span class="message">it wouldn't add any complexity to the VM, just to its runtime requirements</span></div><div class="line" id="042959"><span class="nick" style="color:#6b8072"><a href="#042959" label="[04:29:59]">&lt;ludocode&gt;</a></span><span class="message">That would make the bytecode pretty terrible to write because there would be no way to write small immediate values. Right now with 0x80-0x8F as registers, values 0x00-0x7F are positive constants and 0x90-0xFF are negative constants</span></div><div class="line" id="043108"><span class="nick" style="color:#8dd3c7"><a href="#043108" label="[04:31:08]">&lt;oriansj&gt;</a></span><span class="message">well you would have instructions like addi and the like; which could then use the space used by the registers to provide the immediate and you'd have the full range</span></div><div class="line" id="043109"><span class="nick" style="color:#6b8072"><a href="#043109" label="[04:31:09]">&lt;ludocode&gt;</a></span><span class="message">I originally made the bytecode variable instruction length, the immediate load instruction was 6 bytes and syscall was 2 bytes for example, and I thought about making divide 5 bytes so it could output quotient and modulus into separate registers. But fixed instruction size turned out to be way better</span></div><div class="line" id="043129"><span class="nick" style="color:#6b8072"><a href="#043129" label="[04:31:29]">&lt;ludocode&gt;</a></span><span class="message">Yeah sure but then you have a lot more than 16 instructions :)</span></div><div class="line" id="043219"><span class="nick" style="color:#8dd3c7"><a href="#043219" label="[04:32:19]">&lt;oriansj&gt;</a></span><span class="message">ludocode: sometimes added complexity in one part reduces complexity in other parts</span></div><div class="line" id="043305"><span class="nick" style="color:#8dd3c7"><a href="#043305" label="[04:33:05]">&lt;oriansj&gt;</a></span><span class="message">but I agree on the byte counting being annoying.</span></div><div class="line" id="043307"><span class="nick" style="color:#6b8072"><a href="#043307" label="[04:33:07]">&lt;ludocode&gt;</a></span><span class="message">Plus it's way easier to audit with distinct values for immediate vs. register bytes. If you see 0x80 it's pretty much guaranteed to be a register. As opposed to having separate add vs. addi, you have to look at the instruction to figure out whether its argument is a register or immediate</span></div><div class="line" id="043349"><span class="nick" style="color:#6b8072"><a href="#043349" label="[04:33:49]">&lt;ludocode&gt;</a></span><span class="message">I find the bytecode extremely readable, probably has a lot to do with it being so space inefficient lol</span></div><div class="line" id="043441"><span class="nick" style="color:#8dd3c7"><a href="#043441" label="[04:34:41]">&lt;oriansj&gt;</a></span><span class="message">well, self-written bytecode usually is quite easy to follow. Reading other people's is a good bit harder.</span></div><div class="line" id="043500"><span class="nick" style="color:#6b8072"><a href="#043500" label="[04:35:00]">&lt;ludocode&gt;</a></span><span class="message">true, I suppose that will be the real test, if anyone can understand what I wrote haha</span></div><div class="line" id="043553"><span class="nick" style="color:#8dd3c7"><a href="#043553" label="[04:35:53]">&lt;oriansj&gt;</a></span><span class="message">well reading bytecode requires either me being familiar with it or having to look at documentation constantly</span></div><div class="line" id="043651"><span class="nick" style="color:#8dd3c7"><a href="#043651" label="[04:36:51]">&lt;oriansj&gt;</a></span><span class="message">but as your goal is universal bootstrap that even aliens could use; it could be ignored entirely</span></div><div class="line" id="043657"><span class="nick" style="color:#6b8072"><a href="#043657" label="[04:36:57]">&lt;ludocode&gt;</a></span><span class="message">Yeah I wanted to make a one-page cheat sheet that could be printed or put up on a second monitor or whatever, sort of like Robert Elder's one page CPU. I had a separate quick reference document at one point, I think I didn't include it when I ported the code to GitHub</span></div><div class="line" id="043807"><span class="nick" style="color:#8dd3c7"><a href="#043807" label="[04:38:07]">&lt;oriansj&gt;</a></span><span class="message">have you seen the blynn-compiler vm?</span></div><div class="line" id="043831"><span class="nick" style="color:#6b8072"><a href="#043831" label="[04:38:31]">&lt;ludocode&gt;</a></span><span class="message">Neat, haven't seen that no</span></div><div class="line" id="044043"><span class="nick" style="color:#8dd3c7"><a href="#044043" label="[04:40:43]">&lt;oriansj&gt;</a></span><span class="message">or how about Binary Lambda Calculus? <a rel="nofollow" href="https://tromp.github.io/cl/Binary_lambda_calculus.html">https://tromp.github.io/cl/Binary_lambda_calculus.html</a> </span></div><div class="line" id="044233"><span class="nick" style="color:#8dd3c7"><a href="#044233" label="[04:42:33]">&lt;oriansj&gt;</a></span><span class="message">the entire VM was implemented in 29 bytes</span></div><div class="line" id="044235"><span class="nick" style="color:#6b8072"><a href="#044235" label="[04:42:35]">&lt;ludocode&gt;</a></span><span class="message">Nope, not that either</span></div><div class="line" id="044727"><span class="nick" style="color:#8dd3c7"><a href="#044727" label="[04:47:27]">&lt;oriansj&gt;</a></span><span class="message">one can implement SKI calculus in it in just 34 bits</span></div><div class="line" id="044943"><span class="nick" style="color:#6b8072"><a href="#044943" label="[04:49:43]">&lt;ludocode&gt;</a></span><span class="message">I'm sure there are lots of VM designs that can be made super small, but those don't really seem practical for implementing a C compiler</span></div><div class="line" id="045045"><span class="nick" style="color:#6b8072"><a href="#045045" label="[04:50:45]">&lt;ludocode&gt;</a></span><span class="message">Performance is an issue, the Onramp VM isn't super fast despite having an instruction set that maps reasonably well to real hardware. Those VMs that operate on individual bits are surely not going to be fast enough to build anything real on top</span></div><div class="line" id="045110"><span class="nick" style="color:#8dd3c7"><a href="#045110" label="[04:51:10]">&lt;oriansj&gt;</a></span><span class="message">well any VM design can be used to implement a C compiler (assuming your assembly language isn't garbage)</span></div><div class="line" id="045220"><span class="nick" style="color:#8dd3c7"><a href="#045220" label="[04:52:20]">&lt;oriansj&gt;</a></span><span class="message">The problem with any VM is getting a nice assembly language bootstrapped and after that it is all relatively simple.</span></div><div class="line" id="045306"><span class="nick" style="color:#6b8072"><a href="#045306" label="[04:53:06]">&lt;ludocode&gt;</a></span><span class="message">Sure but if your VM is 100,000x slower than real hardware then the bootstrap could take months. That's not practical</span></div><div class="line" id="045336"><span class="nick" style="color:#8dd3c7"><a href="#045336" label="[04:53:36]">&lt;oriansj&gt;</a></span><span class="message">well, 100Kx slower is very unlikely</span></div><div class="line" id="045338"><span class="nick" style="color:#6b8072"><a href="#045338" label="[04:53:38]">&lt;ludocode&gt;</a></span><span class="message">I actually did this with Onramp, I implemented a VM in POSIX shell :) it's under platform/vm/sh/. It's totally useless because it's about 100,000x slower than the VMs written in machine code and C</span></div><div class="line" id="045419"><span class="nick" style="color:#8dd3c7"><a href="#045419" label="[04:54:19]">&lt;oriansj&gt;</a></span><span class="message">1Kx slower isn't that bad; it is fast enough to bootstrap all the way up in 3 minutes</span></div><div class="line" id="045439"><span class="nick" style="color:#8dd3c7"><a href="#045439" label="[04:54:39]">&lt;oriansj&gt;</a></span><span class="message">so 100Kx slower would just be 300 minutes</span></div><div class="line" id="045610"><span class="nick" style="color:#6b8072"><a href="#045610" label="[04:56:10]">&lt;ludocode&gt;</a></span><span class="message">If you implement a VM for the Binary Lambda Calculus in machine code, and you built, say, a 16-bit assembly language on top of it, do you think it would be 1000x slower than a real CPU? I would guess it would be even much slower than that</span></div><div class="line" id="045745"><span class="nick" style="color:#8dd3c7"><a href="#045745" label="[04:57:45]">&lt;oriansj&gt;</a></span><span class="message">well it is fast enough to run this: <a rel="nofollow" href="https://paste.debian.net/1312031">https://paste.debian.net/1312031</a>  fast enough that one never sees a pause in its rotation.</span></div><div class="line" id="045836"><span class="nick" style="color:#6b8072"><a href="#045836" label="[04:58:36]">&lt;ludocode&gt;</a></span><span class="message">Is that already implemented? A C compiler on top of the binary lambda calculus?</span></div><div class="line" id="045908"><span class="nick" style="color:#8dd3c7"><a href="#045908" label="[04:59:08]">&lt;oriansj&gt;</a></span><span class="message">ludocode: bootstrapped -&gt; no; compiled as a target yes</span></div><div class="line" id="045943"><span class="nick" style="color:#6b8072"><a href="#045943" label="[04:59:43]">&lt;ludocode&gt;</a></span><span class="message">neat</span></div><div class="line" id="045949"><span class="nick" style="color:#8dd3c7"><a href="#045949" label="[04:59:49]">&lt;oriansj&gt;</a></span><span class="message">which is why your goal is a good bit easier than trusting trust bootstrapping.</span></div><div class="line" id="050058"><span class="nick" style="color:#6b8072"><a href="#050058" label="[05:00:58]">&lt;ludocode&gt;</a></span><span class="message">Sure, I mean I'm not a CPU designer by any means, I'm sure someone could design a much better instruction set with a much smaller VM. I designed what I felt was practical, and what made bootstrapping comfortable, without worrying too much about size.</span></div><div class="line" id="050115"><span class="nick" style="color:#6b8072"><a href="#050115" label="[05:01:15]">&lt;ludocode&gt;</a></span><span class="message">In any case the main size overhead is in the filesystem. I wanted the VM to have syscalls such that the compiler can interact with the host environment's filesystem exactly like a normal compiler would. The interface to Onramp is a normal unix compiler like GCC, it works the same way.</span></div><div class="line" id="050153"><span class="nick" style="color:#6b8072"><a href="#050153" label="[05:01:53]">&lt;ludocode&gt;</a></span><span class="message">If you make a really tiny VM with the intention of building the filesystem inside of it, there's no way to interface that naturally with a host environment.</span></div><div class="line" id="050219"><span class="nick" style="color:#8dd3c7"><a href="#050219" label="[05:02:19]">&lt;oriansj&gt;</a></span><span class="message">well FORTH does a pretty solid job of that</span></div><div class="line" id="050351"><span class="nick" style="color:#6b8072"><a href="#050351" label="[05:03:51]">&lt;ludocode&gt;</a></span><span class="message">Onramp supports both freestanding and hosted. I haven't written a freestanding VM yet but I suspect it will be about half the size of the hosted VM since you don't have to implement any filesystem syscalls or any argument/environment passing</span></div><div class="line" id="050408"><span class="nick" style="color:#6b8072"><a href="#050408" label="[05:04:08]">&lt;ludocode&gt;</a></span><span class="message">3KB is still a lot bigger than the VMs you're suggesting of course but it seems reasonably small to me for what I consider to be a really comfortable bytecode</span></div><div class="line" id="050503"><span class="nick" style="color:#8dd3c7"><a href="#050503" label="[05:05:03]">&lt;oriansj&gt;</a></span><span class="message">well supporting disk and user I/O is a good bit more complex than just 5 POSIX I/O syscalls</span></div><div class="line" id="050551"><span class="nick" style="color:#8dd3c7"><a href="#050551" label="[05:05:51]">&lt;oriansj&gt;</a></span><span class="message">as hardware these days lies</span></div><div class="line" id="050745"><span class="nick" style="color:#6b8072"><a href="#050745" label="[05:07:45]">&lt;ludocode&gt;</a></span><span class="message">A scripted bootstrap from stored media doesn't technically require any I/O at all. It could just implement an in-memory filesystem and bootstrap all the way up to compiling a real native kernel and chainboot into it.</span></div><div class="line" id="050817"><span class="nick" style="color:#6b8072"><a href="#050817" label="[05:08:17]">&lt;ludocode&gt;</a></span><span class="message">Obviously you would want a console output but even that is just for debugging</span></div><div class="line" id="050901"><span class="nick" style="color:#8dd3c7"><a href="#050901" label="[05:09:01]">&lt;oriansj&gt;</a></span><span class="message">aside from the initial load into memory (assuming it is large enough to hold everything)</span></div><div class="line" id="050957"><span class="nick" style="color:#8dd3c7"><a href="#050957" label="[05:09:57]">&lt;oriansj&gt;</a></span><span class="message">and it all disappears on reboot</span></div><div class="line" id="051040"><span class="nick" style="color:#6b8072"><a href="#051040" label="[05:10:40]">&lt;ludocode&gt;</a></span><span class="message">Yeah sure. I would eventually want to implement read/write sector syscalls to page stuff to disk during this process. builder-hex0 does something like this to output its final image to disk right? how much machine code does that take?</span></div><div class="line" id="051116"><span class="nick" style="color:#8dd3c7"><a href="#051116" label="[05:11:16]">&lt;oriansj&gt;</a></span><span class="message">well that very much depends on the machine in question.</span></div><div class="line" id="051132"><span class="nick" style="color:#6b8072"><a href="#051132" label="[05:11:32]">&lt;ludocode&gt;</a></span><span class="message">The disappearing on reboot seems like an advantage to me :) Once you're in the native kernel it seems to me the first thing you'd want to do is rebuild itself with itself, persist that to disk instead of whatever the bootstrap process built</span></div><div class="line" id="051210"><span class="nick" style="color:#8dd3c7"><a href="#051210" label="[05:12:10]">&lt;oriansj&gt;</a></span><span class="message">ludocode: would a 2 stage vm be a valid option for you?</span></div><div class="line" id="051247"><span class="nick" style="color:#6b8072"><a href="#051247" label="[05:12:47]">&lt;ludocode&gt;</a></span><span class="message">Sure. I talk about that a bit in one of the docs in Onramp actually, you can certainly implement the VM in multiple stages</span></div><div class="line" id="051247"><span class="nick" style="color:#8dd3c7"><a href="#051247" label="[05:12:47]">&lt;oriansj&gt;</a></span><span class="message">like a minimal VM for the steps up till you have a C compiler and then do a massively expanded VM for better performance and full features?</span></div><div class="line" id="051312"><span class="nick" style="color:#6b8072"><a href="#051312" label="[05:13:12]">&lt;ludocode&gt;</a></span><span class="message">Oh I see what you mean. I suppose that is also possible, but I'm not sure if there's much point to that</span></div><div class="line" id="051338"><span class="nick" style="color:#6b8072"><a href="#051338" label="[05:13:38]">&lt;ludocode&gt;</a></span><span class="message">Instead of an expanded VM I imagine you'd be better off compiling to something like LLVM or QBE, something that can be translated to machine code</span></div><div class="line" id="051347"><span class="nick" style="color:#8dd3c7"><a href="#051347" label="[05:13:47]">&lt;oriansj&gt;</a></span><span class="message">well if the second stage VM is more well known, you could leverage the work of others to speed up your development and reduce the amount of effort required.</span></div><div class="line" id="051421"><span class="nick" style="color:#8dd3c7"><a href="#051421" label="[05:14:21]">&lt;oriansj&gt;</a></span><span class="message">for example a RISC-V 64bit instruction set VM</span></div><div class="line" id="051450"><span class="nick" style="color:#8dd3c7"><a href="#051450" label="[05:14:50]">&lt;oriansj&gt;</a></span><span class="message">then you could leverage the RISC-V bootstrap work for GCC and the like</span></div><div class="line" id="051748"><span class="nick" style="color:#6b8072"><a href="#051748" label="[05:17:48]">&lt;ludocode&gt;</a></span><span class="message">I'm not sure what you mean, or what the use case is for that. Do you mean to use Onramp to compile a RISC-V emulator to then run the GUIX bootstrap on top of it?</span></div><div class="line" id="051823"><span class="nick" style="color:#6b8072"><a href="#051823" label="[05:18:23]">&lt;ludocode&gt;</a></span><span class="message">I suppose that's already possible with what I've built so far for Onramp. I don't really see why you'd want to though</span></div><div class="line" id="052032"><span class="nick" style="color:#8dd3c7"><a href="#052032" label="[05:20:32]">&lt;oriansj&gt;</a></span><span class="message">well I guess if GCC and the like isn't a goal, then I can see how trying to support it seems like a wasted or pointless effort.</span></div><div class="line" id="052332"><span class="nick" style="color:#6b8072"><a href="#052332" label="[05:23:32]">&lt;ludocode&gt;</a></span><span class="message">No, GCC is definitely the goal, but I'm hoping to be able to take a much more direct path</span></div><div class="line" id="052411"><span class="nick" style="color:#8dd3c7"><a href="#052411" label="[05:24:11]">&lt;oriansj&gt;</a></span><span class="message">otherwise porting TCC, GCC and related would require you to add support for your custom architecture to all of them; which will take years of effort.</span></div><div class="line" id="052505"><span class="nick" style="color:#8dd3c7"><a href="#052505" label="[05:25:05]">&lt;oriansj&gt;</a></span><span class="message">RISC-V has been a work in progress for a couple years now</span></div><div class="line" id="052558"><span class="nick" style="color:#6b8072"><a href="#052558" label="[05:25:58]">&lt;ludocode&gt;</a></span><span class="message">Yeah but I don't intend for any of those to output Onramp bytecode. I just want to get TinyCC running on Onramp, and outputting machine code</span></div><div class="line" id="052628"><span class="nick" style="color:#8dd3c7"><a href="#052628" label="[05:26:28]">&lt;oriansj&gt;</a></span><span class="message">outputting machine code for which architectures?</span></div><div class="line" id="052655"><span class="nick" style="color:#6b8072"><a href="#052655" label="[05:26:55]">&lt;ludocode&gt;</a></span><span class="message">Well x86 or x86_64 to start.</span></div><div class="line" id="052754"><span class="nick" style="color:#8dd3c7"><a href="#052754" label="[05:27:54]">&lt;oriansj&gt;</a></span><span class="message">so Onramp is designed to stop once TCC is bootstrapped and everything else is just some host native work?</span></div><div class="line" id="052909"><span class="nick" style="color:#6b8072"><a href="#052909" label="[05:29:09]">&lt;ludocode&gt;</a></span><span class="message">If I can get TinyCC running, then I'm hoping I can get it to compile a small toy POSIX kernel like Fiwix or Tilck (or even an old version of Linux which TinyCC did actually compile at one point.) I realize TinyCC can't compile those toy kernels at the moment, it's missing linker scripts for example, but I think it's possible to fill in the blanks myself, and the authors of those kernels might be interested in helping as well if they</span></div><div class="line" id="052909"><span class="nick" style="color:#6b8072"><a href="#052909" label="[05:29:09]">&lt;ludocode&gt;</a></span><span class="message">learn that it might be possible to bootstrap them this way</span></div><div class="line" id="052946"><span class="nick" style="color:#6b8072"><a href="#052946" label="[05:29:46]">&lt;ludocode&gt;</a></span><span class="message">Yeah pretty much. The idea would be Onramp -&gt; TinyCC -&gt; Kernel+musl+BusyBox, then chainboot into it.</span></div><div class="line" id="053033"><span class="nick" style="color:#8dd3c7"><a href="#053033" label="[05:30:33]">&lt;oriansj&gt;</a></span><span class="message">ludocode: We use TinyCC to compile Fiwix</span></div><div class="line" id="053045"><span class="nick" style="color:#6b8072"><a href="#053045" label="[05:30:45]">&lt;ludocode&gt;</a></span><span class="message">Oh great. So yeah, that's what I want to do</span></div><div class="line" id="053058"><span class="nick" style="color:#8dd3c7"><a href="#053058" label="[05:30:58]">&lt;oriansj&gt;</a></span><span class="message">the steps are already in live-bootstrap</span></div><div class="line" id="053126"><span class="nick" style="color:#6b8072"><a href="#053126" label="[05:31:26]">&lt;ludocode&gt;</a></span><span class="message">Cool. I didn't know live-bootstrap compiled Fiwix. I haven't looked at it in a while I guess</span></div><div class="line" id="053236"><span class="nick" style="color:#8dd3c7"><a href="#053236" label="[05:32:36]">&lt;oriansj&gt;</a></span><span class="message">it is the bare-metal bootstrapping work stikonas and fossy and rick-masters have put together with the help of the Fiwix kernel's author's help.</span></div><div class="line" id="053314"><span class="nick" style="color:#6b8072"><a href="#053314" label="[05:33:14]">&lt;ludocode&gt;</a></span><span class="message">Awesome. Sounds like they already did exactly what I was imagining, that's great news</span></div><div class="line" id="053341"><span class="nick" style="color:#8dd3c7"><a href="#053341" label="[05:33:41]">&lt;oriansj&gt;</a></span><span class="message">(there are also a few other people who chipped in and did amazing work but as I am aiming to do a brief intro, I apologize for skipping the mentions)</span></div><div class="line" id="053505"><span class="nick" style="color:#6b8072"><a href="#053505" label="[05:35:05]">&lt;ludocode&gt;</a></span><span class="message">So yeah I basically want to try do the same thing on Onramp. I'm probably a year away from even starting that because I need to get the final stage compiler and preprocessor done enough that it can compile TinyCC, but that's one of my goals</span></div><div class="line" id="053627"><span class="nick" style="color:#8dd3c7"><a href="#053627" label="[05:36:27]">&lt;oriansj&gt;</a></span><span class="message">have you seen <a rel="nofollow" href="https://github.com/cosinusoidally/tcc_bootstrap_alt">https://github.com/cosinusoidally/tcc_bootstrap_alt</a>  ?</span></div><div class="line" id="053648"><span class="nick" style="color:#8dd3c7"><a href="#053648" label="[05:36:48]">&lt;oriansj&gt;</a></span><span class="message">it uses the Javascript VM to bootstrap TCC</span></div><div class="line" id="054143"><span class="nick" style="color:#6b8072"><a href="#054143" label="[05:41:43]">&lt;ludocode&gt;</a></span><span class="message">Oh neat, I had not seen that.</span></div><div class="line" id="054359"><span class="nick" style="color:#8dd3c7"><a href="#054359" label="[05:43:59]">&lt;oriansj&gt;</a></span><span class="message">You might find a few more gems in the IRC history logs (that I can't remember off the top of my head) that may inspire or provide alternates you prefer.</span></div><div class="line" id="054409"><span class="nick" style="color:#6b8072"><a href="#054409" label="[05:44:09]">&lt;ludocode&gt;</a></span><span class="message">Thanks</span></div><div class="line" id="054438"><span class="nick" style="color:#8dd3c7"><a href="#054438" label="[05:44:38]">&lt;oriansj&gt;</a></span><span class="message">and thanks for exploring the universal bootstrap VM solution space</span></div><div class="line" id="054445"><span class="nick" style="color:#6b8072"><a href="#054445" label="[05:44:45]">&lt;ludocode&gt;</a></span><span class="message">Thanks for spending so much time with me talking about this, it's really helpful. I'm glad I finally got somebody to look at my silly compiler for aliens :)</span></div><div class="line" id="054611"><span class="nick" style="color:#8dd3c7"><a href="#054611" label="[05:46:11]">&lt;oriansj&gt;</a></span><span class="message">ludocode: I get it, for the first couple years there were only a handful of us here to discuss the stage0 bootstrap work.</span></div><div class="line" id="054658"><span class="nick" style="color:#8dd3c7"><a href="#054658" label="[05:46:58]">&lt;oriansj&gt;</a></span><span class="message">You'll only get encouragement, suggestions and recommendations for improvement; people here are nice and helpful.</span></div><div class="line" id="055232"><span class="nick" style="color:#8dd3c7"><a href="#055232" label="[05:52:32]">&lt;oriansj&gt;</a></span><span class="message">and don't be afraid to chat, just please understand we are kind of spread around the world and it might take a bit before a solid response can be generated.</span></div><div class="line" id="055527"><span class="nick" style="color:#6b8072"><a href="#055527" label="[05:55:27]">&lt;ludocode&gt;</a></span><span class="message">Thanks</span></div><div class="line" id="114545"><span class="nick" style="color:#80b1d3"><a href="#114545" label="[11:45:45]">&lt;lrvick2&gt;</a></span><span class="message">Was trying to drop savannah in stagex and noticed <a rel="nofollow" href="http://git.savannah.gnu.org/cgit/coreutils.git/snapshot/coreutils-8.32.tar.gz">http://git.savannah.gnu.org/cgit/coreutils.git/snapshot/coreutils-8.32.tar.gz</a>  vs <a rel="nofollow" href="https://mirrors.kernel.org/gnu/coreutils/coreutils-8.32.tar.gz">https://mirrors.kernel.org/gnu/coreutils/coreutils-8.32.tar.gz</a>  have substantial differences. Many files exclusive to each side. For instance the latter includes things like primes.h and the former does not.</span></div><div class="line" id="114557"><span class="nick" style="color:#80b1d3"><a href="#114557" label="[11:45:57]">&lt;lrvick2&gt;</a></span><span class="message">Has anyone eyeballed this one already?</span></div><div class="line" id="115434"><span class="nick" style="color:#6d2462"><a href="#115434" label="[11:54:34]">&lt;Foxboron&gt;</a></span><span class="message">lrvick2: You are comparing apples to oranges, most likely. The snapshot/ is a &quot;git archive&quot; of the repo while mirrors.kernel.org is probably a separate process</span></div><div class="line" id="115532"><span class="nick" style="color:#6d2462"><a href="#115532" label="[11:55:32]">&lt;Foxboron&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/coreutils/coreutils/blob/master/src/local.mk#L67">https://github.com/coreutils/coreutils/blob/master/src/local.mk#L67</a> </span></div><div class="line" id="115712"><span class="nick" style="color:#6d2462"><a href="#115712" label="[11:57:12]">&lt;Foxboron&gt;</a></span><span class="message">Yes, so `make dist` vs `git archive`. The git snapshot is not something that should be used in this case</span></div><div class="line" id="120510"><span class="nick" style="color:#80b1d3"><a href="#120510" label="[12:05:10]">&lt;lrvick2&gt;</a></span><span class="message">Fair. Only case replacing a dozen savannah links with other mirrors where a hash changed. and in this case a 10x size increase as well.</span></div><div class="line" id="120535"><span class="nick" style="color:#80b1d3"><a href="#120535" label="[12:05:35]">&lt;lrvick2&gt;</a></span><span class="message">the kernel.org copy is also signed by a maintainer at least</span></div><div class="line" id="121959"><span class="nick" style="color:#6d2462"><a href="#121959" label="[12:19:59]">&lt;Foxboron&gt;</a></span><span class="message">Well yes, if you care about authenticating sources then the git snapshots is the worst place you can go.</span></div><div class="line" id="124945"><span class="nick" style="color:#8dd3c7"><a href="#124945" label="[12:49:45]">&lt;oriansj&gt;</a></span><span class="message">well not the worst but yeah, sha1sum is breakable with a bit of money.</span></div><div class="line" id="125744"><span class="nick" style="color:#6d2462"><a href="#125744" label="[12:57:44]">&lt;Foxboron&gt;</a></span><span class="message">oriansj: Not really breakable, you can do collisions in currently some very specific scenarios and no proofs it would work on git repos yet</span></div><div class="line" id="125752"><span class="nick" style="color:#6d2462"><a href="#125752" label="[12:57:52]">&lt;Foxboron&gt;</a></span><span class="message">it's *probably* just a matter of time though</span></div><div class="line" id="145915"><span class="nick" style="color:#234e69"><a href="#145915" label="[14:59:15]">&lt;pabs3&gt;</a></span><span class="message">plasma41: from #breezy:</span></div><div class="line" id="145917"><span class="nick" style="color:#234e69"><a href="#145917" label="[14:59:17]">&lt;pabs3&gt;</a></span><span class="message">&lt;jelmer&gt; older versions of Breezy (3.4 and older) are still pure-Python</span></div><div class="line" id="145918"><span class="nick" style="color:#234e69"><a href="#145918" label="[14:59:18]">&lt;pabs3&gt;</a></span><span class="message">&lt;jelmer&gt; but we have no plans to make the rust code optional</span></div><div class="line" id="155003"><span class="nick" style="color:#6c3d55"><a href="#155003" label="[15:50:03]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;Andrius Štikonas&gt; you need rust for desktop stuff anyway, so there isn't much point in avoiding it after initial system bootstrap</span></div><div class="line" id="164135"><span class="nick" style="color:#6c3d55"><a href="#164135" label="[16:41:35]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;cosinusoidally&gt; Have there been any attempts to create some intermediate steps between M0 and cc_x86? For me it's a bit of a leap from small assembly language programs to something like cc_x86. I've been playing around with otccelf (<a rel="nofollow" href="https://bellard.org/otcc/">https://bellard.org/otcc/</a>  a version of the precursor to tcc but with elf output support). When compiled, otccelf is slightly smaller than cc_x86, but it's very hard to understand and...</span></div><div class="line" id="164141"><span class="nick" style="color:#6c3d55"><a href="#164141" label="[16:41:41]">&lt;matrix_bridge&gt;</a></span><span class="message">... doubly so in assembly form.</span></div><div class="line" id="164348"><span class="nick" style="color:#8dd3c7"><a href="#164348" label="[16:43:48]">&lt;oriansj&gt;</a></span><span class="message">well we did do a Lisp in M0 and a FORTH in M0</span></div><div class="line" id="164416"><span class="nick" style="color:#8dd3c7"><a href="#164416" label="[16:44:16]">&lt;oriansj&gt;</a></span><span class="message">they are both smaller and simpler than cc_*</span></div><div class="line" id="164655"><span class="nick" style="color:#8dd3c7"><a href="#164655" label="[16:46:55]">&lt;oriansj&gt;</a></span><span class="message">it is just that Lisp and FORTH don't end up making a much shorter C compiler than M0 assembly</span></div><div class="line" id="164742"><span class="nick" style="color:#8dd3c7"><a href="#164742" label="[16:47:42]">&lt;oriansj&gt;</a></span><span class="message">it is basically 1-3 assembly instructions per line of C code</span></div><div class="line" id="164941"><span class="nick" style="color:#8dd3c7"><a href="#164941" label="[16:49:41]">&lt;oriansj&gt;</a></span><span class="message">considerable time has been spent on Both on FORTH and Lisp (do a garbage collected lisp in assembly is a bitch)</span></div><div class="line" id="165416"><span class="nick" style="color:#6c3d55"><a href="#165416" label="[16:54:16]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;cosinusoidally&gt; This one <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage2/forth.s">https://github.com/oriansj/stage0/blob/master/stage2/forth.s</a>  ? Is that knight assembly? I did start making an attempt to port otccelf to forth, specifically the buzzard2 dialect of forth, but I gave up pretty quickly when I ran into issues trying to break out of nested loop. Probably also doesn't help that I've never written forth before.</span></div><div class="line" id="165625"><span class="nick" style="color:#6c3d55"><a href="#165625" label="[16:56:25]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;cosinusoidally&gt; buzzard2 starts off with a ~200 line implementation of a dialect it calls &quot;first&quot; and then uses first to implement what it calls &quot;third&quot; (which is its own dialect of not quite forth)</span></div><div class="line" id="172616"><span class="nick" style="color:#8dd3c7"><a href="#172616" label="[17:26:16]">&lt;oriansj&gt;</a></span><span class="message">cosinusoidally: correct</span></div><div class="line" id="172815"><span class="nick" style="color:#8dd3c7"><a href="#172815" label="[17:28:15]">&lt;oriansj&gt;</a></span><span class="message">yeah Caleb Ristvedt did an impressive job with stage3/inital_library.fs to making that FORTH much more ANSI standard</span></div><div class="line" id="173937"><span class="nick" style="color:#8dd3c7"><a href="#173937" label="[17:39:37]">&lt;oriansj&gt;</a></span><span class="message">but yeah, basically we found that there is no magic in implementing a compiler, only a bunch of tedious detail tracking.</span></div><div class="line" id="174047"><span class="nick" style="color:#8dd3c7"><a href="#174047" label="[17:40:47]">&lt;oriansj&gt;</a></span><span class="message">stack state, where variables are located, how to operate on them, in what order and how to load/store them</span></div><div class="line" id="190113"><span class="nick" style="color:#6c3d55"><a href="#190113" label="[19:01:13]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;Andrius Štikonas&gt; And cc_x86 is very readable if you start working on it</span></div><div class="line" id="190123"><span class="nick" style="color:#6c3d55"><a href="#190123" label="[19:01:23]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;Andrius Štikonas&gt; Especially with new gas style macros</span></div><div class="line" id="201447"><span class="nick" style="color:#8dd3c7"><a href="#201447" label="[20:14:47]">&lt;oriansj&gt;</a></span><span class="message">also cc_x86.M1 took less than 24 hours to write, debug and self-host M2-Planet from. So it shouldn't take more than a day or two for something to know every detail about it (or look at the C version of it that exists in stage0's high level prototypes folder)</span></div><br /></div></body></html>