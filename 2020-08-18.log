<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2020-08-18.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="001130"><span class="nick" style="color:#8dd3c7"><a href="#001130" label="[00:11:30]">&lt;OriansJ`&gt;</a></span><span class="message">Hagfish: well it is certainly interesting to see someone try to bootstrap such ancient software. (and shows the pain of such an approach)</span></div><div class="line" id="021130"><span class="nick" style="color:#2e2a4a"><a href="#021130" label="[02:11:30]">&lt;Hagfish&gt;</a></span><span class="message"> <a rel="nofollow" href="https://xkcd.com/2347/">https://xkcd.com/2347/</a> </span></div><div class="line" id="021135"><span class="nick" style="color:#2e2a4a"><a href="#021135" label="[02:11:35]">&lt;Hagfish&gt;</a></span><span class="message">it do be like that sometimes</span></div><div class="line" id="030143"><span class="nick" style="color:#8dd3c7"><a href="#030143" label="[03:01:43]">&lt;OriansJ`&gt;</a></span><span class="message">Hagfish: more like all of the time; especially when you look at guix build graphs</span></div><div class="line" id="030328"><span class="nick" style="color:#8dd3c7"><a href="#030328" label="[03:03:28]">&lt;OriansJ`&gt;</a></span><span class="message">although I am tempted to use a ripoff of that image as the stage0 logo but with labels of various programs in the stack</span></div><div class="line" id="030402"><span class="nick" style="color:#8dd3c7"><a href="#030402" label="[03:04:02]">&lt;OriansJ`&gt;</a></span><span class="message">probably with this dpendency chain at the bottom: <a rel="nofollow" href="https://github.com/oriansj/talk-notes/blob/master/Current%20bootstrap%20map.pdf">https://github.com/oriansj/talk-notes/blob/master/Current%20bootstrap%20map.pdf</a> </span></div><div class="line" id="030445"><span class="nick" style="color:#8dd3c7"><a href="#030445" label="[03:04:45]">&lt;OriansJ`&gt;</a></span><span class="message">with the one super shaky piece at the bottom, with a slightly larger piece on top and so on</span></div><div class="line" id="030518"><span class="nick" style="color:#8dd3c7"><a href="#030518" label="[03:05:18]">&lt;OriansJ`&gt;</a></span><span class="message">with a single arrow, going &quot;we are here, don't fuck it up&quot;</span></div><div class="line" id="044216"><span class="nick">***</span><span class="message notice">luizhenrique is now known as LHLaurini</span></div><div class="line" id="090240"><span class="nick" style="color:#6b8072"><a href="#090240" label="[09:02:40]">&lt;bauen1&gt;</a></span><span class="message">the website is down</span></div><div class="line" id="090247"><span class="nick" style="color:#6b8072"><a href="#090247" label="[09:02:47]">&lt;bauen1&gt;</a></span><span class="message">not sure who to ping \o/</span></div><div class="line" id="090309"><span class="nick" style="color:#6b8072"><a href="#090309" label="[09:03:09]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: but either it's you or you know who to ping</span></div><div class="line" id="091308"><span class="nick" style="color:#80b1d3"><a href="#091308" label="[09:13:08]">&lt;janneke&gt;</a></span><span class="message">bauen1: thanks</span></div><div class="line" id="092500"><span class="nick" style="color:#6d2462"><a href="#092500" label="[09:25:00]">&lt;rain1&gt;</a></span><span class="message">seeing that bootstrap map is very exciting. So it is just this part in the middle</span></div><div class="line" id="105827"><span class="nick" style="color:#6b8072"><a href="#105827" label="[10:58:27]">&lt;bauen1&gt;</a></span><span class="message">by the way has anyone tried to implement a backdoor or rather a bug in e.g. stage0 that can propagate all the way into e.g. mes or tinycc or gcc ?</span></div><div class="line" id="113324"><span class="nick" style="color:#6d2462"><a href="#113324" label="[11:33:24]">&lt;rain1&gt;</a></span><span class="message">i don't think so but imagine such a backdoor: It would mean evil-stage0 is 100x bigger than normal stage0</span></div><div class="line" id="113340"><span class="nick" style="color:#6d2462"><a href="#113340" label="[11:33:40]">&lt;rain1&gt;</a></span><span class="message">at least that is what i'd expect</span></div><div class="line" id="114350"><span class="nick" style="color:#6b8072"><a href="#114350" label="[11:43:50]">&lt;bauen1&gt;</a></span><span class="message">rain1: true, i was also thinking about maybe abusing unicode once again in the stage1 source code to trick the casual reader into compiling malicious code</span></div><div class="line" id="115740"><span class="nick" style="color:#6b8072"><a href="#115740" label="[11:57:40]">&lt;bauen1&gt;</a></span><span class="message">the backdoor itself probably wouldn't be very huge, it would probably amount to modifying the write_byte method to check for a specific sequence and if it is found write it's own code instead</span></div><div class="line" id="115805"><span class="nick" style="color:#6b8072"><a href="#115805" label="[11:58:05]">&lt;bauen1&gt;</a></span><span class="message">perhaps 32 - 128 bytes</span></div><div class="line" id="115831"><span class="nick" style="color:#6b8072"><a href="#115831" label="[11:58:31]">&lt;bauen1&gt;</a></span><span class="message">writing a backdoor that can also propagate to the other compilers is what would probably blow the size</span></div><div class="line" id="120956"><span class="nick" style="color:#6b8072"><a href="#120956" label="[12:09:56]">&lt;bauen1&gt;</a></span><span class="message">actually, hex0, hex1, hex2, m0, cc_amd64 all use very similiar routines, so maybe not impossible</span></div><div class="line" id="124553"><span class="nick" style="color:#6b8072"><a href="#124553" label="[12:45:53]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: i've noticed that a 64-bit mov `48C7C7 00000000 ; LOADI32_RDI %0  # All is well` is used in hex0 and hex1, but everything later just uses a sign-extending move `BF 00000000` ; perhaps a few bytes could be saved ?</span></div><div class="line" id="124557"><span class="nick" style="color:#6b8072"><a href="#124557" label="[12:45:57]">&lt;bauen1&gt;</a></span><span class="message">this is for amd64</span></div><div class="line" id="124737"><span class="nick" style="color:#6b8072"><a href="#124737" label="[12:47:37]">&lt;bauen1&gt;</a></span><span class="message">wait, BF is not a sign-extening move but just a simple move</span></div><div class="line" id="124742"><span class="nick" style="color:#6b8072"><a href="#124742" label="[12:47:42]">&lt;bauen1&gt;</a></span><span class="message">point still stands</span></div><div class="line" id="130147"><span class="nick">***</span><span class="message notice">ChanServ sets mode: +o rekado_</span></div><div class="line" id="130407"><span class="nick" style="color:#6b8072"><a href="#130407" label="[13:04:07]">&lt;bauen1&gt;</a></span><span class="message">also, am i right with the assumption that `fputc` from M0 or cc_amd64 is passed down to M2 ?</span></div><div class="line" id="134415"><span class="nick" style="color:#8dd3c7"><a href="#134415" label="[13:44:15]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: rekado is the one responsible for the website if I remember correctly</span></div><div class="line" id="134434"><span class="nick" style="color:#8dd3c7"><a href="#134434" label="[13:44:34]">&lt;OriansJ`&gt;</a></span><span class="message">rain1: yeah the middle part is the absolute worst</span></div><div class="line" id="134516"><span class="nick" style="color:#8dd3c7"><a href="#134516" label="[13:45:16]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: I've tried to think of ways which stage0 could be backdoor'd and then intentionally add things to make it harder.</span></div><div class="line" id="134528"><span class="nick" style="color:#6b8072"><a href="#134528" label="[13:45:28]">&lt;bauen1&gt;</a></span><span class="message">lol</span></div><div class="line" id="134632"><span class="nick" style="color:#8dd3c7"><a href="#134632" label="[13:46:32]">&lt;OriansJ`&gt;</a></span><span class="message">for example: <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/High_level_prototypes/sin.c">https://github.com/oriansj/stage0/blob/master/High_level_prototypes/sin.c</a> </span></div><div class="line" id="134647"><span class="nick" style="color:#8dd3c7"><a href="#134647" label="[13:46:47]">&lt;OriansJ`&gt;</a></span><span class="message">will instantly flag any and all unicode characters</span></div><div class="line" id="134713"><span class="nick" style="color:#6b8072"><a href="#134713" label="[13:47:13]">&lt;bauen1&gt;</a></span><span class="message">my current plan would be to hook the write and exit syscall, then do some byte counting in the write syscall to modify the ELF header to add additional space that is loaded into memory, then a bit of &quot;pattern matching&quot; to hook the syscalls, and finally at the exit hook write the additional backdoor code</span></div><div class="line" id="134730"><span class="nick" style="color:#8dd3c7"><a href="#134730" label="[13:47:30]">&lt;OriansJ`&gt;</a></span><span class="message">this will find all deviations in hex0 binaries: <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage1/dehex.hex0">https://github.com/oriansj/stage0/blob/master/stage1/dehex.hex0</a> </span></div><div class="line" id="134736"><span class="nick" style="color:#6b8072"><a href="#134736" label="[13:47:36]">&lt;bauen1&gt;</a></span><span class="message">having all the code hand coded makes things a bit annoying since adding or removing bytes will break things</span></div><div class="line" id="134807"><span class="nick" style="color:#8dd3c7"><a href="#134807" label="[13:48:07]">&lt;OriansJ`&gt;</a></span><span class="message">and stage0 itself can run on bare metal, so no kernel to hook either</span></div><div class="line" id="135004"><span class="nick" style="color:#8dd3c7"><a href="#135004" label="[13:50:04]">&lt;OriansJ`&gt;</a></span><span class="message">fputc and fgetc are actually implemented in M0 <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage3/M2-Planet_x86.c#L43">https://github.com/oriansj/stage0/blob/master/stage3/M2-Planet_x86.c#L43</a>  and just simply wrapped in inline assembly for M2-Planet</span></div><div class="line" id="135127"><span class="nick" style="color:#6b8072"><a href="#135127" label="[13:51:27]">&lt;bauen1&gt;</a></span><span class="message">i'm mostly looking at the amd64 implementation, but that is helpful</span></div><div class="line" id="135207"><span class="nick" style="color:#8dd3c7"><a href="#135207" label="[13:52:07]">&lt;OriansJ`&gt;</a></span><span class="message">THe only places you could hide the ELF tampering quietly is in M2-Planet but cc_x86 can build M2-Planet and should produce extremely similiar output (only using unsigned instead of signed integer instructions being the only difference)</span></div><div class="line" id="135347"><span class="nick" style="color:#8dd3c7"><a href="#135347" label="[13:53:47]">&lt;OriansJ`&gt;</a></span><span class="message">So one would have to either break the ability of cc_x86 to build M2-Planet (major issue for all of us) or compromise both cc_x86 and M2-Planet at the exact same time and hide the exact same backdoor in both C code and hand written (easy to audit) assembly</span></div><div class="line" id="135445"><span class="nick" style="color:#6b8072"><a href="#135445" label="[13:54:45]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: i'm fairly aware that you can discover the backdoor easily if you have a trusted compiler of some form</span></div><div class="line" id="135502"><span class="nick" style="color:#6b8072"><a href="#135502" label="[13:55:02]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: so i'm mostly trying to attack the inital binary hex0-seed</span></div><div class="line" id="135517"><span class="nick" style="color:#8dd3c7"><a href="#135517" label="[13:55:17]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: yep David A. Wheeler's DDC work</span></div><div class="line" id="135538"><span class="nick" style="color:#8dd3c7"><a href="#135538" label="[13:55:38]">&lt;OriansJ`&gt;</a></span><span class="message">250bytes doesn't leave much room to attack</span></div><div class="line" id="135610"><span class="nick" style="color:#6b8072"><a href="#135610" label="[13:56:10]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: as far as i understand the code, most (if not all) compilers up to mes use very similiar method of outputting the binary (a write syscall with a size of 1) and similiar exit methods (syscall exit without closing the fd)</span></div><div class="line" id="135628"><span class="nick" style="color:#8dd3c7"><a href="#135628" label="[13:56:28]">&lt;OriansJ`&gt;</a></span><span class="message">also the initial seed is expected to be visually inspected and hand toggled in; so much harder to hide things at that level</span></div><div class="line" id="135631"><span class="nick" style="color:#6b8072"><a href="#135631" label="[13:56:31]">&lt;bauen1&gt;</a></span><span class="message">true</span></div><div class="line" id="135659"><span class="nick" style="color:#6b8072"><a href="#135659" label="[13:56:59]">&lt;bauen1&gt;</a></span><span class="message">mostly a proof of concept for fun</span></div><div class="line" id="135728"><span class="nick" style="color:#8dd3c7"><a href="#135728" label="[13:57:28]">&lt;OriansJ`&gt;</a></span><span class="message">well there are certainly behaviors that a kernel could flag on</span></div><div class="line" id="135837"><span class="nick" style="color:#6b8072"><a href="#135837" label="[13:58:37]">&lt;bauen1&gt;</a></span><span class="message">depending on how similiar all compilers are it could be possible to implement a backdoor in hex0-seed with very a very small size (less than 1kb) that can still propagate all the way to M2-Planet (and whatever is after that)</span></div><div class="line" id="135845"><span class="nick" style="color:#8dd3c7"><a href="#135845" label="[13:58:45]">&lt;OriansJ`&gt;</a></span><span class="message">but you run into a risk of discovery as binary sizes and checksums are known at all times</span></div><div class="line" id="135900"><span class="nick" style="color:#6b8072"><a href="#135900" label="[13:59:00]">&lt;bauen1&gt;</a></span><span class="message">yeah, a backdoor in such a small binary is very obious</span></div><div class="line" id="135903"><span class="nick" style="color:#6b8072"><a href="#135903" label="[13:59:03]">&lt;bauen1&gt;</a></span><span class="message">*obvious</span></div><div class="line" id="135955"><span class="nick" style="color:#8dd3c7"><a href="#135955" label="[13:59:55]">&lt;OriansJ`&gt;</a></span><span class="message">and it has to avoid detection across multible independent platforms and operating systems</span></div><div class="line" id="140052"><span class="nick" style="color:#8dd3c7"><a href="#140052" label="[14:00:52]">&lt;OriansJ`&gt;</a></span><span class="message">as all architectures can bootstrap and cross-check every step of every binary of all other architectures</span></div><div class="line" id="140117"><span class="nick" style="color:#8dd3c7"><a href="#140117" label="[14:01:17]">&lt;OriansJ`&gt;</a></span><span class="message">*afk*</span></div><div class="line" id="140149"><span class="nick" style="color:#6b8072"><a href="#140149" label="[14:01:49]">&lt;bauen1&gt;</a></span><span class="message">it already has to implement byte pattern checking against 1 architecture, probably wouldn't be very complicated to add more</span></div><div class="line" id="140210"><span class="nick" style="color:#6b8072"><a href="#140210" label="[14:02:10]">&lt;bauen1&gt;</a></span><span class="message">but yes, introducing such a backdoor into a relatively trusted system would be extremely hard</span></div><div class="line" id="141754"><span class="nick" style="color:#6b8072"><a href="#141754" label="[14:17:54]">&lt;bauen1&gt;</a></span><span class="message">it does appear that the move instructions encoded as B0 - BF can be used to replace some multibyte opcodes in hex0 to reduce the size</span></div><div class="line" id="142001"><span class="nick" style="color:#6b8072"><a href="#142001" label="[14:20:01]">&lt;bauen1&gt;</a></span><span class="message">but not for r8-r15</span></div><div class="line" id="180557"><span class="nick">***</span><span class="message notice">terpri__ is now known as terpri</span></div><div class="line" id="182935"><span class="nick" style="color:#8dd3c7"><a href="#182935" label="[18:29:35]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: well mescc-tools and M2-Planet are platform neutral (eg produce identical output regardless of host); thus all architectures supported by them can cross-check each other and all bootstrap steps along the way as well.</span></div><div class="line" id="183109"><span class="nick" style="color:#8dd3c7"><a href="#183109" label="[18:31:09]">&lt;OriansJ`&gt;</a></span><span class="message">however I wish for stage0 binaries to be completely untrusted. eg everyone should make their own hex0 that they trust and use it to build the hex0.hex0 for their architecture; thus no single point of compromise could be possible as everything for all architectures become pure source.</span></div><div class="line" id="183322"><span class="nick" style="color:#8dd3c7"><a href="#183322" label="[18:33:22]">&lt;OriansJ`&gt;</a></span><span class="message">as for opcode encoding in M2-Planet and stage0; I intensionally selected inefficient encodings to encourage other people to contribute improvements; not to mention all the spelling and grammar errors.</span></div><div class="line" id="183414"><span class="nick" style="color:#8dd3c7"><a href="#183414" label="[18:34:14]">&lt;OriansJ`&gt;</a></span><span class="message">that way there are easy paths for people to choose to contribute to the various pieces and &quot;hopefully&quot; spot anything that I have done that isn't completely obvious or potentially malicious.</span></div><div class="line" id="183538"><span class="nick" style="color:#6b8072"><a href="#183538" label="[18:35:38]">&lt;bauen1&gt;</a></span><span class="message">nice</span></div><div class="line" id="183606"><span class="nick" style="color:#6b8072"><a href="#183606" label="[18:36:06]">&lt;bauen1&gt;</a></span><span class="message">just think of what i'm trying to do as a proof of concept of why even a 1-2kb binary seed should never be trusted</span></div><div class="line" id="183647"><span class="nick" style="color:#8dd3c7"><a href="#183647" label="[18:36:47]">&lt;OriansJ`&gt;</a></span><span class="message">well if one was truly clever, it would be possible to do hex0 in 64bytes</span></div><div class="line" id="183749"><span class="nick" style="color:#6b8072"><a href="#183749" label="[18:37:49]">&lt;bauen1&gt;</a></span><span class="message">true</span></div><div class="line" id="183802"><span class="nick" style="color:#8dd3c7"><a href="#183802" label="[18:38:02]">&lt;OriansJ`&gt;</a></span><span class="message">but that would be harder to reason about and understand how it works; thus I have opted for something absolutely stupidly simple to follow</span></div><div class="line" id="183910"><span class="nick" style="color:#6b8072"><a href="#183910" label="[18:39:10]">&lt;bauen1&gt;</a></span><span class="message">i could hack it down to maybe 128 bytes and make the backdoor non-obvious, but then the backdoored stage0 won't produce a matching binary when given an unmodified stage0 hex0 code</span></div><div class="line" id="184341"><span class="nick" style="color:#8dd3c7"><a href="#184341" label="[18:43:41]">&lt;OriansJ`&gt;</a></span><span class="message">the benefits of thinking like an attacker while designing defenses</span></div><div class="line" id="184454"><span class="nick" style="color:#8dd3c7"><a href="#184454" label="[18:44:54]">&lt;OriansJ`&gt;</a></span><span class="message">forced into 7bit ascii only input and state machines that cover every possible input in consistent ways</span></div><div class="line" id="184547"><span class="nick" style="color:#6b8072"><a href="#184547" label="[18:45:47]">&lt;bauen1&gt;</a></span><span class="message">yeah, it could be a lot simpler (just deal with [0-9A-F])</span></div><div class="line" id="184600"><span class="nick" style="color:#8dd3c7"><a href="#184600" label="[18:46:00]">&lt;OriansJ`&gt;</a></span><span class="message">no support for escapes of any kind until cc_x86</span></div><div class="line" id="184655"><span class="nick" style="color:#8dd3c7"><a href="#184655" label="[18:46:55]">&lt;OriansJ`&gt;</a></span><span class="message">only single use, non-recursive line macros in M1/M0</span></div><div class="line" id="184733"><span class="nick" style="color:#8dd3c7"><a href="#184733" label="[18:47:33]">&lt;OriansJ`&gt;</a></span><span class="message">Line comments and not block comments to prevent false comment attacks</span></div><div class="line" id="184834"><span class="nick" style="color:#8dd3c7"><a href="#184834" label="[18:48:34]">&lt;OriansJ`&gt;</a></span><span class="message">all non-hex characters are dropped (I could even add error catching in hex2 and M1 to flag them as outside of a comment field)</span></div><div class="line" id="185006"><span class="nick" style="color:#8dd3c7"><a href="#185006" label="[18:50:06]">&lt;OriansJ`&gt;</a></span><span class="message">which makes only 0-9, a-f, A-F, space, tab and newline characters the only valid inputs (with ; and # line comments allowing everything up to \n)</span></div><div class="line" id="185054"><span class="nick" style="color:#8dd3c7"><a href="#185054" label="[18:50:54]">&lt;OriansJ`&gt;</a></span><span class="message">we already catch duplicate labels in hex2</span></div><div class="line" id="185130"><span class="nick" style="color:#8dd3c7"><a href="#185130" label="[18:51:30]">&lt;OriansJ`&gt;</a></span><span class="message">and duplicate DEFINE definitions in M1</span></div><div class="line" id="185500"><span class="nick" style="color:#8dd3c7"><a href="#185500" label="[18:55:00]">&lt;OriansJ`&gt;</a></span><span class="message">The more potential attacks of hex0/hex1/hex2, M0/M1 and cc_x86/M2-Planet we know about; the better we can defend in the long term.</span></div><div class="line" id="185547"><span class="nick" style="color:#8dd3c7"><a href="#185547" label="[18:55:47]">&lt;OriansJ`&gt;</a></span><span class="message">Plus I want people to instantly catch any &quot;bugdoors&quot; I might introduce along the way</span></div><div class="line" id="185613"><span class="nick" style="color:#8dd3c7"><a href="#185613" label="[18:56:13]">&lt;OriansJ`&gt;</a></span><span class="message">Thus salting the ground against would be attackers</span></div><div class="line" id="190314"><span class="nick" style="color:#6b8072"><a href="#190314" label="[19:03:14]">&lt;bauen1&gt;</a></span><span class="message">i image type checking (and const verification to some extend) only comes at M2-Planet (if at all) ?</span></div><div class="line" id="190323"><span class="nick" style="color:#6b8072"><a href="#190323" label="[19:03:23]">&lt;bauen1&gt;</a></span><span class="message">not 100% sure how many &quot;features&quot; m2-planet has</span></div><br /></div></body></html>