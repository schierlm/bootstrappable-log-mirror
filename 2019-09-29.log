<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2019-09-29.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="015952"><span class="nick" style="color:#8dd3c7"><a href="#015952" label="[01:59:52]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: cool!  I'm reluctant to delete things from Wikis that I don't understand in many case</span></div><div class="line" id="020124"><span class="nick" style="color:#8dd3c7"><a href="#020124" label="[02:01:24]">&lt;xentrac&gt;</a></span><span class="message">because I worry that they might just be things I don't understand instead of things that are wrong</span></div><div class="line" id="141916"><span class="nick" style="color:#2e2a4a"><a href="#141916" label="[14:19:16]">&lt;OriansJ&gt;</a></span><span class="message"> xentrac: that is why wiki's have histories; as for why that article said one needed lazy evaluation for macros on eager evaluation lisps. Consider the following (if (not boom) (something important) (exit EXIT_FAILURE)) if if is not a primitive but a macro; an eager evaluation strategy will evaluate the exit even if you are not going to exit and the resulting side effect is the incorrect termination of the lisp program.</span></div><div class="line" id="151654"><span class="nick" style="color:#2e2a4a"><a href="#151654" label="[15:16:54]">&lt;OriansJ&gt;</a></span><span class="message">eval in an eager lisp is quite trivial: <a rel="nofollow" href="https://github.com/oriansj/Slow_Lisp/blob/master/lisp_eval.c#L168">https://github.com/oriansj/Slow_Lisp/blob/master/lisp_eval.c#L168</a>  ; even the ugly bits are also simple: <a rel="nofollow" href="https://github.com/oriansj/Slow_Lisp/blob/master/lisp_eval.c#L217">https://github.com/oriansj/Slow_Lisp/blob/master/lisp_eval.c#L217</a>  and when you look at the apply <a rel="nofollow" href="https://github.com/oriansj/Slow_Lisp/blob/master/lisp_eval.c#L114">https://github.com/oriansj/Slow_Lisp/blob/master/lisp_eval.c#L114</a>  it is easy to convince oneself that the all powerful lisp is easy to implement.</span></div><div class="line" id="152033"><span class="nick" style="color:#2e2a4a"><a href="#152033" label="[15:20:33]">&lt;OriansJ&gt;</a></span><span class="message">Then one gets to macros and the eager evaluation producing side effects starts showing up and then you have to choose how to solve the macro problem. You can either force your reader to deal with the macros; such that the eval will never know or you shoe-horn lazy evaluation into your eval process or you bite the bullet and implement lazy evaluation and the macros become just a simple lambda.</span></div><div class="line" id="153036"><span class="nick" style="color:#2e2a4a"><a href="#153036" label="[15:30:36]">&lt;OriansJ&gt;</a></span><span class="message">here is the complexity of a lisp-reader without support for macros: <a rel="nofollow" href="https://github.com/oriansj/Slow_Lisp/blob/master/lisp_read.c">https://github.com/oriansj/Slow_Lisp/blob/master/lisp_read.c</a>  nothing too bad in C but writing that in assembly while reading the source code was 10 hours of work <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage2/lisp.s#L124">https://github.com/oriansj/stage0/blob/master/stage2/lisp.s#L124</a>  and from that experience I now know why although the original kernel of lisp was done quickly; why it took months of brilliant minds hacking on</span></div><div class="line" id="153037"><span class="nick" style="color:#2e2a4a"><a href="#153037" label="[15:30:37]">&lt;OriansJ&gt;</a></span><span class="message">it before it hit a useful state.</span></div><div class="line" id="153333"><span class="nick" style="color:#2e2a4a"><a href="#153333" label="[15:33:33]">&lt;OriansJ&gt;</a></span><span class="message">contrast that with <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage2/cc_x86.s">https://github.com/oriansj/stage0/blob/master/stage2/cc_x86.s</a>  ; which was producing useful output within 4 hours of work and with each additional bit of functionality being a simple addition and test.</span></div><div class="line" id="153746"><span class="nick" style="color:#2e2a4a"><a href="#153746" label="[15:37:46]">&lt;OriansJ&gt;</a></span><span class="message">I thus from direct experience understand how C was hacked together in a weekend and why Lisp took months. The weakness in C was that the compiled binaries were slow and inefficient but adding optimization passes in C is rather trivial.</span></div><div class="line" id="154047"><span class="nick" style="color:#2e2a4a"><a href="#154047" label="[15:40:47]">&lt;OriansJ&gt;</a></span><span class="message">and having written a FORTH <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage2/forth.s">https://github.com/oriansj/stage0/blob/master/stage2/forth.s</a>  ; I must say the easiest language on the planet to bootstrap (after macro assembly of course) is actually a C subset (I call it M2-Planet). Even the advanced features like type tracking, structs, unions, inline assembly and gotos end up being rather trival to add.</span></div><div class="line" id="154512"><span class="nick" style="color:#2e2a4a"><a href="#154512" label="[15:45:12]">&lt;OriansJ&gt;</a></span><span class="message">However there is a possibility I missed something essential when I aborted M2-Moon. It might be possible that a compiled lisp might be easier than a compiled C to implement in assembly, especially since the reader would be far simpler and since it would be lazy (runtime) evaluation by default but it could use an eager (compile time) evaluation implementation.</span></div><div class="line" id="154917"><span class="nick" style="color:#2e2a4a"><a href="#154917" label="[15:49:17]">&lt;OriansJ&gt;</a></span><span class="message">If someone wanted to build such a thing (thus allowing us to skip the cc_* -&gt; M2-Planet -&gt; mes-m2 -&gt;  MesCC process and be thing -&gt; MesCC) say in simple C; I'd be willing to write it in assembly and thus be forced to admit lisp is a better to bootstrap language than C. [If any lisp zeolots want to have the fun of writing a lisp compiler]</span></div><div class="line" id="155039"><span class="nick" style="color:#2e2a4a"><a href="#155039" label="[15:50:39]">&lt;OriansJ&gt;</a></span><span class="message">(what can I say, I like being proven wrong and learning a better way)</span></div><div class="line" id="155337"><span class="nick" style="color:#6b8072"><a href="#155337" label="[15:53:37]">&lt;rain2&gt;</a></span><span class="message">jackhill: yes, would be great to build them from guile!</span></div><div class="line" id="181346"><span class="nick" style="color:#8dd3c7"><a href="#181346" label="[18:13:46]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: thanks for the reassurance :)</span></div><div class="line" id="181444"><span class="nick" style="color:#8dd3c7"><a href="#181444" label="[18:14:44]">&lt;xentrac&gt;</a></span><span class="message">it's true that macro evaluation is not eager.  the macro approach to implementing macros is to transform the code so that, as you say, the eval will never know</span></div><div class="line" id="181516"><span class="nick" style="color:#8dd3c7"><a href="#181516" label="[18:15:16]">&lt;xentrac&gt;</a></span><span class="message">shoehorning lazy evaluation into your eval process is called adding fexprs; fexprs are distinct from macros but you can use them to do the same thing</span></div><div class="line" id="181533"><span class="nick" style="color:#8dd3c7"><a href="#181533" label="[18:15:33]">&lt;xentrac&gt;</a></span><span class="message">and it's true that for macros like if, lazy evaluation replaces macros</span></div><div class="line" id="181543"><span class="nick" style="color:#8dd3c7"><a href="#181543" label="[18:15:43]">&lt;xentrac&gt;</a></span><span class="message">but not macros like let or defun</span></div><div class="line" id="181650"><span class="nick" style="color:#8dd3c7"><a href="#181650" label="[18:16:50]">&lt;xentrac&gt;</a></span><span class="message">as for bootstrapping C subsets, wouldn't it be even easier to bootstrap a semantically-C-subset language with Forth &quot;syntax&quot;?</span></div><div class="line" id="181744"><span class="nick" style="color:#8dd3c7"><a href="#181744" label="[18:17:44]">&lt;xentrac&gt;</a></span><span class="message">or for that matter Lisp syntax</span></div><div class="line" id="181814"><span class="nick" style="color:#8dd3c7"><a href="#181814" label="[18:18:14]">&lt;xentrac&gt;</a></span><span class="message">normally macro expansion happens in a separate stage after read and before compilation or evaluation</span></div><div class="line" id="181854"><span class="nick" style="color:#8dd3c7"><a href="#181854" label="[18:18:54]">&lt;xentrac&gt;</a></span><span class="message">that way, (quote (if a b c)) evaluates to a list of four things whose car is if, rather than, say, cond</span></div><div class="line" id="182515"><span class="nick" style="color:#8dd3c7"><a href="#182515" label="[18:25:15]">&lt;xentrac&gt;</a></span><span class="message">fexprs aren't just lazy evaluation either; like macros, they get the raw S-expression form of their arguments, so have to invoke eval if they want to treat them as code.  this makes for an uneasy mismatch with lexical scoping, which is, e.g., resolved in Tcl with &quot;uplevel&quot;</span></div><div class="line" id="182545"><span class="nick" style="color:#8dd3c7"><a href="#182545" label="[18:25:45]">&lt;xentrac&gt;</a></span><span class="message">but of course pre-Common-Lisp Lisps were mostly not lexically scoped, so eval would usually just do the right thing, except when it didn't</span></div><div class="line" id="182617"><span class="nick" style="color:#8dd3c7"><a href="#182617" label="[18:26:17]">&lt;xentrac&gt;</a></span><span class="message">I mean that the fexpr could (usually) get the right behavior by invoking eval</span></div><div class="line" id="182830"><span class="nick" style="color:#8dd3c7"><a href="#182830" label="[18:28:30]">&lt;xentrac&gt;</a></span><span class="message">the Wikipedia page on fexprs doesn't sufficiently call out the major difference between fexprs and macros, which is that fexprs run at runtime and macros run at compile time (which is the reason that the results of the macro are evaluated and the results of the fexpr aren't)</span></div><div class="line" id="183006"><span class="nick" style="color:#8dd3c7"><a href="#183006" label="[18:30:06]">&lt;xentrac&gt;</a></span><span class="message">you *can* implement let, defun, and setq as fexprs, even though you can't implement them with just lazy evaluation</span></div><div class="line" id="183011"><span class="nick" style="color:#8dd3c7"><a href="#183011" label="[18:30:11]">&lt;xentrac&gt;</a></span><span class="message">as ordinary functions</span></div><div class="line" id="184547"><span class="nick" style="color:#8dd3c7"><a href="#184547" label="[18:45:47]">&lt;xentrac&gt;</a></span><span class="message">(it does call out the difference eventually, just not in the introductory text where maybe it should)</span></div><div class="line" id="214020"><span class="nick" style="color:#2e2a4a"><a href="#214020" label="[21:40:20]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: very nicely said</span></div><div class="line" id="214149"><span class="nick" style="color:#8dd3c7"><a href="#214149" label="[21:41:49]">&lt;xentrac&gt;</a></span><span class="message">thanks</span></div><div class="line" id="215142"><span class="nick" style="color:#2e2a4a"><a href="#215142" label="[21:51:42]">&lt;OriansJ&gt;</a></span><span class="message">I guess the most import part is that macro functionality must be part of the implementation of the lisp from day zero; otherwise it isn't something you can really do on top of a lisp without it.</span></div><div class="line" id="215226"><span class="nick" style="color:#8dd3c7"><a href="#215226" label="[21:52:26]">&lt;xentrac&gt;</a></span><span class="message">You mean, without modifying the interpreter?</span></div><div class="line" id="215246"><span class="nick" style="color:#2e2a4a"><a href="#215246" label="[21:52:46]">&lt;OriansJ&gt;</a></span><span class="message">indeed at the implementation level</span></div><div class="line" id="215327"><span class="nick" style="color:#8dd3c7"><a href="#215327" label="[21:53:27]">&lt;xentrac&gt;</a></span><span class="message">You can add macros (or fexprs, or lazy evaluation) after day zero, but you do have to modify the implementation to add them</span></div><div class="line" id="215403"><span class="nick" style="color:#2e2a4a"><a href="#215403" label="[21:54:03]">&lt;OriansJ&gt;</a></span><span class="message">in serious ways; especially if the implementation is in assembly</span></div><div class="line" id="215426"><span class="nick" style="color:#8dd3c7"><a href="#215426" label="[21:54:26]">&lt;xentrac&gt;</a></span><span class="message">Macros can be added in a pretty straightforward way</span></div><div class="line" id="215452"><span class="nick" style="color:#8dd3c7"><a href="#215452" label="[21:54:52]">&lt;xentrac&gt;</a></span><span class="message">They just transform the S-expressions after read but before compilation or evaluation</span></div><div class="line" id="215522"><span class="nick" style="color:#2e2a4a"><a href="#215522" label="[21:55:22]">&lt;OriansJ&gt;</a></span><span class="message">correct</span></div><div class="line" id="215536"><span class="nick" style="color:#8dd3c7"><a href="#215536" label="[21:55:36]">&lt;xentrac&gt;</a></span><span class="message">Fexprs or lazy evaluation do require deeper surgery, and fexprs in particular can make a lot of optimizations impossible</span></div><div class="line" id="215558"><span class="nick" style="color:#2e2a4a"><a href="#215558" label="[21:55:58]">&lt;OriansJ&gt;</a></span><span class="message">which is why scheme lacks them if I remember correctly</span></div><div class="line" id="215606"><span class="nick" style="color:#8dd3c7"><a href="#215606" label="[21:56:06]">&lt;xentrac&gt;</a></span><span class="message">yeah. also common lisp</span></div><div class="line" id="215635"><span class="nick" style="color:#8dd3c7"><a href="#215635" label="[21:56:35]">&lt;xentrac&gt;</a></span><span class="message">but you can add a macro system to a compiler for any language as an afterthought, as long as you have an AST</span></div><div class="line" id="215705"><span class="nick" style="color:#2e2a4a"><a href="#215705" label="[21:57:05]">&lt;OriansJ&gt;</a></span><span class="message">to manipulate</span></div><div class="line" id="215710"><span class="nick" style="color:#8dd3c7"><a href="#215710" label="[21:57:10]">&lt;xentrac&gt;</a></span><span class="message">right</span></div><div class="line" id="215729"><span class="nick" style="color:#8dd3c7"><a href="#215729" label="[21:57:29]">&lt;xentrac&gt;</a></span><span class="message">a Crenshaw-style or TCC-style AST-less compiler makes it quite a bit more difficult</span></div><div class="line" id="215814"><span class="nick" style="color:#2e2a4a"><a href="#215814" label="[21:58:14]">&lt;OriansJ&gt;</a></span><span class="message">or functionally impossible</span></div><div class="line" id="215828"><span class="nick" style="color:#8dd3c7"><a href="#215828" label="[21:58:28]">&lt;xentrac&gt;</a></span><span class="message">I wouldn't go that far :D</span></div><div class="line" id="215858"><span class="nick" style="color:#8dd3c7"><a href="#215858" label="[21:58:58]">&lt;xentrac&gt;</a></span><span class="message">I mean both of us have already programmed things that most programmers would think impossible</span></div><div class="line" id="215921"><span class="nick" style="color:#2e2a4a"><a href="#215921" label="[21:59:21]">&lt;OriansJ&gt;</a></span><span class="message">true</span></div><div class="line" id="215949"><span class="nick" style="color:#2e2a4a"><a href="#215949" label="[21:59:49]">&lt;OriansJ&gt;</a></span><span class="message">and somethings are just the class of problems where solving them is entirely the wrong path</span></div><div class="line" id="220033"><span class="nick" style="color:#2e2a4a"><a href="#220033" label="[22:00:33]">&lt;OriansJ&gt;</a></span><span class="message">aka a flat list AST could get a macro but it probably ends up being more work than simply throwing it out and doing it the right way.</span></div><div class="line" id="220226"><span class="nick" style="color:#8dd3c7"><a href="#220226" label="[22:02:26]">&lt;xentrac&gt;</a></span><span class="message">heh</span></div><div class="line" id="220312"><span class="nick" style="color:#8dd3c7"><a href="#220312" label="[22:03:12]">&lt;xentrac&gt;</a></span><span class="message">I think there's a reasonable argument for compiling your set of macros into a streaming form so you don't have to reify the entire AST at once in memory</span></div><div class="line" id="220320"><span class="nick" style="color:#8dd3c7"><a href="#220320" label="[22:03:20]">&lt;xentrac&gt;</a></span><span class="message">but not for compiling them into that form by hand</span></div><div class="line" id="220447"><span class="nick" style="color:#2e2a4a"><a href="#220447" label="[22:04:47]">&lt;OriansJ&gt;</a></span><span class="message">hmmm</span></div><div class="line" id="220550"><span class="nick" style="color:#8dd3c7"><a href="#220550" label="[22:05:50]">&lt;xentrac&gt;</a></span><span class="message">especially if you can reuse the streaming pattern matching compilation tooling for other things, like backend optimization, database query optimization, or querying JSON documents</span></div><div class="line" id="220614"><span class="nick" style="color:#8dd3c7"><a href="#220614" label="[22:06:14]">&lt;xentrac&gt;</a></span><span class="message">but it's clearly in the realm of optimization rather than &quot;zero to one&quot;</span></div><div class="line" id="220715"><span class="nick" style="color:#2e2a4a"><a href="#220715" label="[22:07:15]">&lt;OriansJ&gt;</a></span><span class="message">it does have its place</span></div><div class="line" id="220845"><span class="nick" style="color:#2e2a4a"><a href="#220845" label="[22:08:45]">&lt;OriansJ&gt;</a></span><span class="message">but to be honest; regex pattern matching has never been my friend when solving problems</span></div><div class="line" id="220908"><span class="nick" style="color:#8dd3c7"><a href="#220908" label="[22:09:08]">&lt;xentrac&gt;</a></span><span class="message">yeah, regexes are not a good way to define Lisp macros :D</span></div><div class="line" id="220915"><span class="nick" style="color:#8dd3c7"><a href="#220915" label="[22:09:15]">&lt;xentrac&gt;</a></span><span class="message">in Ur-Scheme I didn't implement user-defined macros, but I did implement some special forms as built-in macros; look in <a rel="nofollow" href="http://canonical.org/~kragen/sw/urscheme/compiler.scm.html">http://canonical.org/~kragen/sw/urscheme/compiler.scm.html</a>  for &quot;(define macros&quot;</span></div><div class="line" id="220918"><span class="nick" style="color:#2e2a4a"><a href="#220918" label="[22:09:18]">&lt;OriansJ&gt;</a></span><span class="message">it usually results in me being too clever by half</span></div><div class="line" id="221045"><span class="nick" style="color:#8dd3c7"><a href="#221045" label="[22:10:45]">&lt;xentrac&gt;</a></span><span class="message">the code there is maybe a little bit painful because the macros are written without quasiquote!</span></div><div class="line" id="221137"><span class="nick" style="color:#8dd3c7"><a href="#221137" label="[22:11:37]">&lt;xentrac&gt;</a></span><span class="message">but for example Scheme's `define` is defined as a macro in terms of a primitive `%define` which doesn't understand the `(define (fn arg1 arg2) ...` syntax</span></div><div class="line" id="221202"><span class="nick" style="color:#8dd3c7"><a href="#221202" label="[22:12:02]">&lt;xentrac&gt;</a></span><span class="message">so with five lines of code there, all the function definitions get a lot easier to read</span></div><div class="line" id="221405"><span class="nick" style="color:#2e2a4a"><a href="#221405" label="[22:14:05]">&lt;OriansJ&gt;</a></span><span class="message">nicely done</span></div><div class="line" id="221407"><span class="nick" style="color:#8dd3c7"><a href="#221407" label="[22:14:07]">&lt;xentrac&gt;</a></span><span class="message">adding macro processing to the compilation amounted to factoring out a `compile-toplevel-expanded` function from the body of `compile-toplevel` and defining the latter as `(compile-toplevel-expanded (totally-macroexpand expr))`</span></div><div class="line" id="221424"><span class="nick" style="color:#8dd3c7"><a href="#221424" label="[22:14:24]">&lt;xentrac&gt;</a></span><span class="message">as I reconstruct it; I may not be remembering the actual development sequence correctly</span></div><div class="line" id="221619"><span class="nick" style="color:#8dd3c7"><a href="#221619" label="[22:16:19]">&lt;xentrac&gt;</a></span><span class="message">with quasiquote that definition of `define` would be</span></div><div class="line" id="221625"><span class="nick" style="color:#8dd3c7"><a href="#221625" label="[22:16:25]">&lt;xentrac&gt;</a></span><span class="message">(define-ur-macro 'cond</span></div><div class="line" id="221631"><span class="nick" style="color:#8dd3c7"><a href="#221631" label="[22:16:31]">&lt;xentrac&gt;</a></span><span class="message">  (lambda (args)</span></div><div class="line" id="221641"><span class="nick" style="color:#8dd3c7"><a href="#221641" label="[22:16:41]">&lt;xentrac&gt;</a></span><span class="message">    (cond ((null? args) #f)</span></div><div class="line" id="221717"><span class="nick" style="color:#8dd3c7"><a href="#221717" label="[22:17:17]">&lt;xentrac&gt;</a></span><span class="message">    ((eq? (caar args) 'else) `(begin ,(cdar args)))</span></div><div class="line" id="221744"><span class="nick" style="color:#2e2a4a"><a href="#221744" label="[22:17:44]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: the hardest leason about lisps seems to be it is all too temptingly easy to kinda implement them the way we like; without realizing alot of it isn't obvious to others. Which is why only a handful of lisps ever have more than 1 developer...</span></div><div class="line" id="221802"><span class="nick" style="color:#8dd3c7"><a href="#221802" label="[22:18:02]">&lt;xentrac&gt;</a></span><span class="message">    (else `(if ,(caar args) (begin . ,(cdar args))))</span></div><div class="line" id="221827"><span class="nick" style="color:#8dd3c7"><a href="#221827" label="[22:18:27]">&lt;xentrac&gt;</a></span><span class="message">oops, it's missing the trailing cond bit, and also that's the definition of define rather than cons</span></div><div class="line" id="221852"><span class="nick" style="color:#8dd3c7"><a href="#221852" label="[22:18:52]">&lt;xentrac&gt;</a></span><span class="message">but you get the idea</span></div><div class="line" id="221854"><span class="nick" style="color:#8dd3c7"><a href="#221854" label="[22:18:54]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: that's an interesting proposition</span></div><div class="line" id="221903"><span class="nick" style="color:#2e2a4a"><a href="#221903" label="[22:19:03]">&lt;OriansJ&gt;</a></span><span class="message">C compilers seem to be more like sand paintings</span></div><div class="line" id="221948"><span class="nick" style="color:#2e2a4a"><a href="#221948" label="[22:19:48]">&lt;OriansJ&gt;</a></span><span class="message">There hasn't been a C compiler I found that couldn't rather easily be picked up and worked on</span></div><div class="line" id="222118"><span class="nick" style="color:#2e2a4a"><a href="#222118" label="[22:21:18]">&lt;OriansJ&gt;</a></span><span class="message">Even deep magic ones like C500 or C4 tend to only require you to learn about which register is the accumulator and how the stack is built</span></div><div class="line" id="222135"><span class="nick" style="color:#2e2a4a"><a href="#222135" label="[22:21:35]">&lt;OriansJ&gt;</a></span><span class="message">the rest is plug in here to do X</span></div><div class="line" id="222205"><span class="nick" style="color:#8dd3c7"><a href="#222205" label="[22:22:05]">&lt;xentrac&gt;</a></span><span class="message">interesting</span></div><div class="line" id="222238"><span class="nick" style="color:#2e2a4a"><a href="#222238" label="[22:22:38]">&lt;OriansJ&gt;</a></span><span class="message">As much as I tried to avoid that with Slow_lisp; even I can see that 6months later</span></div><div class="line" id="222239"><span class="nick" style="color:#8dd3c7"><a href="#222239" label="[22:22:39]">&lt;xentrac&gt;</a></span><span class="message">what's your experience with Forth compilers?</span></div><div class="line" id="222334"><span class="nick" style="color:#2e2a4a"><a href="#222334" label="[22:23:34]">&lt;OriansJ&gt;</a></span><span class="message">Played with them written in FORTH but haven't tried writing one in anyother language</span></div><div class="line" id="222349"><span class="nick" style="color:#8dd3c7"><a href="#222349" label="[22:23:49]">&lt;xentrac&gt;</a></span><span class="message">I mean in terms of comprehensibility</span></div><div class="line" id="222409"><span class="nick" style="color:#8dd3c7"><a href="#222409" label="[22:24:09]">&lt;xentrac&gt;</a></span><span class="message">I've only looked at ones written in assembly; for the first few years they were pretty mysterious</span></div><div class="line" id="222417"><span class="nick" style="color:#8dd3c7"><a href="#222417" label="[22:24:17]">&lt;xentrac&gt;</a></span><span class="message">but probably because I'm just slow at things like that</span></div><div class="line" id="222456"><span class="nick" style="color:#2e2a4a"><a href="#222456" label="[22:24:56]">&lt;OriansJ&gt;</a></span><span class="message">If you want incomprehensibility look at APL interpreters/compilers written in APL</span></div><div class="line" id="222507"><span class="nick" style="color:#8dd3c7"><a href="#222507" label="[22:25:07]">&lt;xentrac&gt;</a></span><span class="message">I've never seen one; have you?</span></div><div class="line" id="222529"><span class="nick" style="color:#8dd3c7"><a href="#222529" label="[22:25:29]">&lt;xentrac&gt;</a></span><span class="message">I haven't looked much at Lisp compilers' source code, except maybe SIOD</span></div><div class="line" id="222546"><span class="nick" style="color:#2e2a4a"><a href="#222546" label="[22:25:46]">&lt;OriansJ&gt;</a></span><span class="message">I've seen 3 and even 2 hours and a sheet of paper don't let you get past the first line</span></div><div class="line" id="222636"><span class="nick" style="color:#8dd3c7"><a href="#222636" label="[22:26:36]">&lt;xentrac&gt;</a></span><span class="message">link?</span></div><div class="line" id="223043"><span class="nick" style="color:#8dd3c7"><a href="#223043" label="[22:30:43]">&lt;xentrac&gt;</a></span><span class="message">I wonder to what extent these things are familiarity effects</span></div><div class="line" id="223117"><span class="nick" style="color:#2e2a4a"><a href="#223117" label="[22:31:17]">&lt;OriansJ&gt;</a></span><span class="message">here is what APL programmers think clear and simple C code looks like: <a rel="nofollow" href="https://github.com/kevinlawler/kona/blob/master/src/k.c">https://github.com/kevinlawler/kona/blob/master/src/k.c</a> </span></div><div class="line" id="223125"><span class="nick" style="color:#8dd3c7"><a href="#223125" label="[22:31:25]">&lt;xentrac&gt;</a></span><span class="message">oh, yeah, I've seen that</span></div><div class="line" id="223142"><span class="nick" style="color:#8dd3c7"><a href="#223142" label="[22:31:42]">&lt;xentrac&gt;</a></span><span class="message">but you said in APL</span></div><div class="line" id="223231"><span class="nick" style="color:#2e2a4a"><a href="#223231" label="[22:32:31]">&lt;OriansJ&gt;</a></span><span class="message">(Trying to find it but it is hard to web-search for it)</span></div><div class="line" id="223235"><span class="nick" style="color:#8dd3c7"><a href="#223235" label="[22:32:35]">&lt;xentrac&gt;</a></span><span class="message">true</span></div><div class="line" id="223537"><span class="nick" style="color:#2e2a4a"><a href="#223537" label="[22:35:37]">&lt;OriansJ&gt;</a></span><span class="message">The one I remember the most was an optimizing APL compiler that was written in only 5 lines of APL</span></div><div class="line" id="223610"><span class="nick" style="color:#8dd3c7"><a href="#223610" label="[22:36:10]">&lt;xentrac&gt;</a></span><span class="message">I too would like to spend hours trying to reverse-engineer that!</span></div><div class="line" id="223611"><span class="nick" style="color:#2e2a4a"><a href="#223611" label="[22:36:11]">&lt;OriansJ&gt;</a></span><span class="message">So that first like was the reader, parser and tokenizer all in one</span></div><div class="line" id="223901"><span class="nick" style="color:#2e2a4a"><a href="#223901" label="[22:39:01]">&lt;OriansJ&gt;</a></span><span class="message">for example in GNU APL there is a simple APL function: <a rel="nofollow" href="https://svn.savannah.gnu.org/svn/apl/trunk/src/testcases/Lambda.tc">https://svn.savannah.gnu.org/svn/apl/trunk/src/testcases/Lambda.tc</a> </span></div><div class="line" id="224600"><span class="nick" style="color:#2e2a4a"><a href="#224600" label="[22:46:00]">&lt;OriansJ&gt;</a></span><span class="message">found one: <a rel="nofollow" href="https://github.com/Co-dfns/Co-dfns">https://github.com/Co-dfns/Co-dfns</a> </span></div><div class="line" id="224659"><span class="nick" style="color:#8dd3c7"><a href="#224659" label="[22:46:59]">&lt;xentrac&gt;</a></span><span class="message">cool!</span></div><div class="line" id="224705"><span class="nick" style="color:#2e2a4a"><a href="#224705" label="[22:47:05]">&lt;OriansJ&gt;</a></span><span class="message">I just look at this <a rel="nofollow" href="https://github.com/Co-dfns/Co-dfns/blob/master/codfns.dyalog">https://github.com/Co-dfns/Co-dfns/blob/master/codfns.dyalog</a> </span></div><div class="line" id="224710"><span class="nick" style="color:#2e2a4a"><a href="#224710" label="[22:47:10]">&lt;OriansJ&gt;</a></span><span class="message">and think; nope</span></div><div class="line" id="224713"><span class="nick" style="color:#8dd3c7"><a href="#224713" label="[22:47:13]">&lt;xentrac&gt;</a></span><span class="message">haha</span></div><div class="line" id="224730"><span class="nick" style="color:#8dd3c7"><a href="#224730" label="[22:47:30]">&lt;xentrac&gt;</a></span><span class="message">yeah, a lot of people have that reaction to calculus classes too</span></div><div class="line" id="224807"><span class="nick" style="color:#2e2a4a"><a href="#224807" label="[22:48:07]">&lt;OriansJ&gt;</a></span><span class="message">never had that problem in math classes</span></div><div class="line" id="224850"><span class="nick" style="color:#8dd3c7"><a href="#224850" label="[22:48:50]">&lt;xentrac&gt;</a></span><span class="message">I have to say this looks like a bit more than 5 lines</span></div><div class="line" id="224915"><span class="nick" style="color:#2e2a4a"><a href="#224915" label="[22:49:15]">&lt;OriansJ&gt;</a></span><span class="message">yep; it was just 750 lines previously</span></div><div class="line" id="224920"><span class="nick" style="color:#2e2a4a"><a href="#224920" label="[22:49:20]">&lt;OriansJ&gt;</a></span><span class="message"> <a rel="nofollow" href="https://news.ycombinator.com/item?id=13797797">https://news.ycombinator.com/item?id=13797797</a> </span></div><div class="line" id="225002"><span class="nick" style="color:#2e2a4a"><a href="#225002" label="[22:50:02]">&lt;OriansJ&gt;</a></span><span class="message">I mean; honestly why write ⊖⍕⊃⊂|⌊-*+○⌈×÷!⌽⍉⌹~⍴⍋⍒,⍟?⍳0 when you just mean 42?</span></div><div class="line" id="225130"><span class="nick" style="color:#2e2a4a"><a href="#225130" label="[22:51:30]">&lt;OriansJ&gt;</a></span><span class="message">The entire APL family is based on the belief; you need to learn the way we do things, otherwise no hope for you.</span></div><div class="line" id="225214"><span class="nick" style="color:#2e2a4a"><a href="#225214" label="[22:52:14]">&lt;OriansJ&gt;</a></span><span class="message">and I am certain it results in extremely compressed understanding of things</span></div><div class="line" id="225339"><span class="nick" style="color:#2e2a4a"><a href="#225339" label="[22:53:39]">&lt;OriansJ&gt;</a></span><span class="message">But that is the thing; is programming about making optimal use of the machine or about making the optimal use of the people.</span></div><div class="line" id="225339"><span class="nick" style="color:#8dd3c7"><a href="#225339" label="[22:53:39]">&lt;xentrac&gt;</a></span><span class="message">APL is based on the plausible idea that compressed notation enables compressed thinking</span></div><div class="line" id="225352"><span class="nick" style="color:#8dd3c7"><a href="#225352" label="[22:53:52]">&lt;xentrac&gt;</a></span><span class="message">that is, making optimal use of the people</span></div><div class="line" id="225424"><span class="nick" style="color:#8dd3c7"><a href="#225424" label="[22:54:24]">&lt;xentrac&gt;</a></span><span class="message">this is plausible because in fact it is true in math, where we constantly do algebraic manipulation that would be very slow and error-prone to do in words</span></div><div class="line" id="225438"><span class="nick" style="color:#8dd3c7"><a href="#225438" label="[22:54:38]">&lt;xentrac&gt;</a></span><span class="message">but I am not convinced that APL succeeds at it</span></div><div class="line" id="225448"><span class="nick" style="color:#2e2a4a"><a href="#225448" label="[22:54:48]">&lt;OriansJ&gt;</a></span><span class="message">and I know enough K (APL relative) to solve the problem sets in the environments where it is used.</span></div><div class="line" id="225541"><span class="nick" style="color:#2e2a4a"><a href="#225541" label="[22:55:41]">&lt;OriansJ&gt;</a></span><span class="message">but words have the great advantage of infinite number and the ability to leverage language to learn more on the fly</span></div><div class="line" id="225545"><span class="nick" style="color:#8dd3c7"><a href="#225545" label="[22:55:45]">&lt;xentrac&gt;</a></span><span class="message">K is an APL for the purpose of this discussion</span></div><div class="line" id="225602"><span class="nick" style="color:#8dd3c7"><a href="#225602" label="[22:56:02]">&lt;xentrac&gt;</a></span><span class="message">sure</span></div><div class="line" id="225607"><span class="nick" style="color:#2e2a4a"><a href="#225607" label="[22:56:07]">&lt;OriansJ&gt;</a></span><span class="message">(APL for finance people honestly)</span></div><div class="line" id="225622"><span class="nick" style="color:#8dd3c7"><a href="#225622" label="[22:56:22]">&lt;xentrac&gt;</a></span><span class="message">and I think you can reasonably do algebraic manipulation of expressions where the variables are multiple letters long :D</span></div><div class="line" id="225626"><span class="nick" style="color:#8dd3c7"><a href="#225626" label="[22:56:26]">&lt;xentrac&gt;</a></span><span class="message">just not with a pencil</span></div><div class="line" id="225657"><span class="nick" style="color:#8dd3c7"><a href="#225657" label="[22:56:57]">&lt;xentrac&gt;</a></span><span class="message">but the objective of APL was to formulate a language where the operators had a formal structure that makes them amenable to formal manipulation</span></div><div class="line" id="225657"><span class="nick" style="color:#2e2a4a"><a href="#225657" label="[22:56:57]">&lt;OriansJ&gt;</a></span><span class="message">well there is rigidity in the minds of people who use APL too much</span></div><div class="line" id="225708"><span class="nick" style="color:#8dd3c7"><a href="#225708" label="[22:57:08]">&lt;xentrac&gt;</a></span><span class="message">I think Scheme and Haskell have done a better job of this</span></div><div class="line" id="225715"><span class="nick" style="color:#2e2a4a"><a href="#225715" label="[22:57:15]">&lt;OriansJ&gt;</a></span><span class="message">absolutely agree</span></div><div class="line" id="225746"><span class="nick" style="color:#8dd3c7"><a href="#225746" label="[22:57:46]">&lt;xentrac&gt;</a></span><span class="message">still, there are things that are easier to do in APL (or, say, Numpy or Octave) than in Scheme or Haskell</span></div><div class="line" id="225753"><span class="nick" style="color:#8dd3c7"><a href="#225753" label="[22:57:53]">&lt;xentrac&gt;</a></span><span class="message">I don't have a good enough understanding of why that is</span></div><div class="line" id="225758"><span class="nick" style="color:#2e2a4a"><a href="#225758" label="[22:57:58]">&lt;OriansJ&gt;</a></span><span class="message">but I can't help but wonder how much the language we use color the thoughts we are able to have</span></div><div class="line" id="225825"><span class="nick" style="color:#2e2a4a"><a href="#225825" label="[22:58:25]">&lt;OriansJ&gt;</a></span><span class="message">for example; why did NIX come from the Haskell community and no where else?</span></div><div class="line" id="225843"><span class="nick" style="color:#8dd3c7"><a href="#225843" label="[22:58:43]">&lt;xentrac&gt;</a></span><span class="message">for sure.  there are definitely times where solving something first in OCaml or Python makes it easy to solve in C</span></div><div class="line" id="225846"><span class="nick" style="color:#2e2a4a"><a href="#225846" label="[22:58:46]">&lt;OriansJ&gt;</a></span><span class="message">Why were all of the advances over NIX done in the Lisp community?</span></div><div class="line" id="225959"><span class="nick" style="color:#2e2a4a"><a href="#225959" label="[22:59:59]">&lt;OriansJ&gt;</a></span><span class="message">Why didn't any of the bootstrappers come from the demo or similiar communities?</span></div><div class="line" id="230025"><span class="nick" style="color:#2e2a4a"><a href="#230025" label="[23:00:25]">&lt;OriansJ&gt;</a></span><span class="message">but everyone here is familiar with lisp</span></div><div class="line" id="230121"><span class="nick" style="color:#2e2a4a"><a href="#230121" label="[23:01:21]">&lt;OriansJ&gt;</a></span><span class="message">Why did major GUI design ideas come from the smalltalk communties?</span></div><div class="line" id="230204"><span class="nick" style="color:#2e2a4a"><a href="#230204" label="[23:02:04]">&lt;OriansJ&gt;</a></span><span class="message">it is almost the learning of a language deletes ideas you can have; allowing you to come to ideas that you previously couldn't reach</span></div><div class="line" id="230246"><span class="nick" style="color:#2e2a4a"><a href="#230246" label="[23:02:46]">&lt;OriansJ&gt;</a></span><span class="message">but learning multiple languages expands that set to include ideas that were previously removed.</span></div><div class="line" id="230251"><span class="nick" style="color:#8dd3c7"><a href="#230251" label="[23:02:51]">&lt;xentrac&gt;</a></span><span class="message">yeah</span></div><div class="line" id="230701"><span class="nick" style="color:#2e2a4a"><a href="#230701" label="[23:07:01]">&lt;OriansJ&gt;</a></span><span class="message">It makes me deeply wonder what other ideas, beliefs, fears or dreams we all have in common.</span></div><div class="line" id="230755"><span class="nick" style="color:#8dd3c7"><a href="#230755" label="[23:07:55]">&lt;xentrac&gt;</a></span><span class="message">it's hard to explore the boundaries because we can only explore incrementally</span></div><div class="line" id="230813"><span class="nick" style="color:#8dd3c7"><a href="#230813" label="[23:08:13]">&lt;xentrac&gt;</a></span><span class="message">did you look at Dercuano?</span></div><div class="line" id="231003"><span class="nick" style="color:#2e2a4a"><a href="#231003" label="[23:10:03]">&lt;OriansJ&gt;</a></span><span class="message">a subset of it but not all</span></div><div class="line" id="231038"><span class="nick" style="color:#8dd3c7"><a href="#231038" label="[23:10:38]">&lt;xentrac&gt;</a></span><span class="message">there are some things in there about that</span></div><div class="line" id="231043"><span class="nick" style="color:#2e2a4a"><a href="#231043" label="[23:10:43]">&lt;OriansJ&gt;</a></span><span class="message">I've also cloned it</span></div><div class="line" id="231046"><span class="nick" style="color:#8dd3c7"><a href="#231046" label="[23:10:46]">&lt;xentrac&gt;</a></span><span class="message">that's good</span></div><div class="line" id="231053"><span class="nick" style="color:#8dd3c7"><a href="#231053" label="[23:10:53]">&lt;xentrac&gt;</a></span><span class="message">hopefully it will survive after I'm dead</span></div><div class="line" id="231540"><span class="nick" style="color:#2e2a4a"><a href="#231540" label="[23:15:40]">&lt;OriansJ&gt;</a></span><span class="message">once something is useful for others, it tends to survive until it stops being so</span></div><div class="line" id="231657"><span class="nick" style="color:#8dd3c7"><a href="#231657" label="[23:16:57]">&lt;xentrac&gt;</a></span><span class="message">not convinced Dercuano is useful for others yet</span></div><div class="line" id="231718"><span class="nick" style="color:#8dd3c7"><a href="#231718" label="[23:17:18]">&lt;xentrac&gt;</a></span><span class="message">I mean so far I've only gotten like two corrections</span></div><div class="line" id="231806"><span class="nick" style="color:#2e2a4a"><a href="#231806" label="[23:18:06]">&lt;OriansJ&gt;</a></span><span class="message">well if it makes you feel any better it will be part of my offline archive</span></div><div class="line" id="231838"><span class="nick" style="color:#2e2a4a"><a href="#231838" label="[23:18:38]">&lt;OriansJ&gt;</a></span><span class="message">which is designed to last for the rest of my life and hopefully the life of my kid(s)</span></div><div class="line" id="232254"><span class="nick" style="color:#8dd3c7"><a href="#232254" label="[23:22:54]">&lt;xentrac&gt;</a></span><span class="message">also I can perhaps improve it</span></div><div class="line" id="232525"><span class="nick" style="color:#2e2a4a"><a href="#232525" label="[23:25:25]">&lt;OriansJ&gt;</a></span><span class="message">my perspective is Wernher von Braun nearly has been forgotten</span></div><div class="line" id="232559"><span class="nick" style="color:#2e2a4a"><a href="#232559" label="[23:25:59]">&lt;OriansJ&gt;</a></span><span class="message">and there is a strong possibility he might be entirely forgotten in the next 100 years</span></div><div class="line" id="232610"><span class="nick" style="color:#2e2a4a"><a href="#232610" label="[23:26:10]">&lt;OriansJ&gt;</a></span><span class="message">and he put a man on the freaking moon</span></div><div class="line" id="232657"><span class="nick" style="color:#2e2a4a"><a href="#232657" label="[23:26:57]">&lt;OriansJ&gt;</a></span><span class="message">The only people who might remember me in 100 years is family and friends.</span></div><div class="line" id="232817"><span class="nick" style="color:#8dd3c7"><a href="#232817" label="[23:28:17]">&lt;xentrac&gt;</a></span><span class="message">well, hopefully I'll remember you</span></div><div class="line" id="232830"><span class="nick" style="color:#8dd3c7"><a href="#232830" label="[23:28:30]">&lt;xentrac&gt;</a></span><span class="message">but I need a better vehicle than this body</span></div><div class="line" id="232942"><span class="nick" style="color:#2e2a4a"><a href="#232942" label="[23:29:42]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: are you more hoping for digital upload of your mind or cyborg body upgrades?</span></div><div class="line" id="233021"><span class="nick" style="color:#8dd3c7"><a href="#233021" label="[23:30:21]">&lt;xentrac&gt;</a></span><span class="message">probably the second one first, later the first</span></div><div class="line" id="233205"><span class="nick" style="color:#2e2a4a"><a href="#233205" label="[23:32:05]">&lt;OriansJ&gt;</a></span><span class="message">well then you have got good odds</span></div><div class="line" id="233329"><span class="nick" style="color:#8dd3c7"><a href="#233329" label="[23:33:29]">&lt;xentrac&gt;</a></span><span class="message">I'd say around 20%; not so good</span></div><div class="line" id="233749"><span class="nick" style="color:#2e2a4a"><a href="#233749" label="[23:37:49]">&lt;OriansJ&gt;</a></span><span class="message">20% is very good odds when looking at 100+ years</span></div><br /></div></body></html>