<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2021-07-30.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="005134"><span class="nick" style="color:#8dd3c7"><a href="#005134" label="[00:51:34]">&lt;stikonas&gt;</a></span><span class="message">hmm, almost done with assembly version of kaem-minimal for riscv64 but now can't find syscall number for fork, strange...</span></div><div class="line" id="010055"><span class="nick" style="color:#8dd3c7"><a href="#010055" label="[01:00:55]">&lt;stikonas&gt;</a></span><span class="message">oh, there is no fork on risc-v</span></div><div class="line" id="010106"><span class="nick" style="color:#8dd3c7"><a href="#010106" label="[01:01:06]">&lt;stikonas&gt;</a></span><span class="message">hmm, there must be something else to use...</span></div><div class="line" id="010416"><span class="nick" style="color:#8dd3c7"><a href="#010416" label="[01:04:16]">&lt;stikonas&gt;</a></span><span class="message">ok, there is clone</span></div><div class="line" id="012903"><span class="nick" style="color:#2e2a4a"><a href="#012903" label="[01:29:03]">&lt;oriansj&gt;</a></span><span class="message">A call to fork() is equivalent to a call to clone(2) specifying flags as just</span></div><div class="line" id="012905"><span class="nick" style="color:#2e2a4a"><a href="#012905" label="[01:29:05]">&lt;oriansj&gt;</a></span><span class="message">       SIGCHLD.</span></div><div class="line" id="013207"><span class="nick" style="color:#8dd3c7"><a href="#013207" label="[01:32:07]">&lt;stikonas&gt;</a></span><span class="message">yeah, it seems there are more syscalls that are missing</span></div><div class="line" id="013216"><span class="nick" style="color:#8dd3c7"><a href="#013216" label="[01:32:16]">&lt;stikonas&gt;</a></span><span class="message">I guess all &quot;obsolete&quot; ones are not added</span></div><div class="line" id="013311"><span class="nick" style="color:#8dd3c7"><a href="#013311" label="[01:33:11]">&lt;stikonas&gt;</a></span><span class="message">it makes sense for new software... But might be a bit painful during bootstrap for older software (depending on what libc does)</span></div><div class="line" id="020924"><span class="nick" style="color:#2e2a4a"><a href="#020924" label="[02:09:24]">&lt;oriansj&gt;</a></span><span class="message">I guess one could say RISC-V doesn't care about bootstrapping or legacy software or assembly writers or compiler writers</span></div><div class="line" id="021158"><span class="nick" style="color:#6b8072"><a href="#021158" label="[02:11:58]">&lt;xentrac&gt;</a></span><span class="message">one could say that, but one could say anything</span></div><div class="line" id="021308"><span class="nick" style="color:#2e2a4a"><a href="#021308" label="[02:13:08]">&lt;oriansj&gt;</a></span><span class="message">xentrac: fair</span></div><div class="line" id="021426"><span class="nick" style="color:#6b8072"><a href="#021426" label="[02:14:26]">&lt;xentrac&gt;</a></span><span class="message">much as one could say that Russia is in my teacup, or that molten sealing-wax is the best gift for winning the hearts of foreign potentates</span></div><div class="line" id="021635"><span class="nick" style="color:#2e2a4a"><a href="#021635" label="[02:16:35]">&lt;oriansj&gt;</a></span><span class="message">well Russian Map Teacups are a thing and I can't make claims about the hearts of foreign potentates but RISC-V is less bootstrap friendly than AArch64 which is less bootstrap friendly than ARMv7l</span></div><div class="line" id="021806"><span class="nick" style="color:#2e2a4a"><a href="#021806" label="[02:18:06]">&lt;oriansj&gt;</a></span><span class="message">For all of the design sins of x86, bootstrapping it is not one of them.</span></div><div class="line" id="021902"><span class="nick" style="color:#6b8072"><a href="#021902" label="[02:19:02]">&lt;xentrac&gt;</a></span><span class="message">Indeed!</span></div><div class="line" id="022249"><span class="nick" style="color:#6b8072"><a href="#022249" label="[02:22:49]">&lt;xentrac&gt;</a></span><span class="message">but I think writing an assembler for RISC-V is something like 2% of the effort of writing an assembler for amd64</span></div><div class="line" id="025120"><span class="nick" style="color:#2e2a4a"><a href="#025120" label="[02:51:20]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well depends entirely on what you mean by an assembler. For example M0+hex2 function like an assembler and linker and it appears the task of writing those for RISC-V is more than triple the effort needed for AMD64</span></div><div class="line" id="050622"><span class="nick" style="color:#80b1d3"><a href="#050622" label="[05:06:22]">&lt;fossy&gt;</a></span><span class="message">oriansj: i think that risc-v cares about being simple. which means less syscalls and not implementing legacy stuff</span></div><div class="line" id="050628"><span class="nick" style="color:#80b1d3"><a href="#050628" label="[05:06:28]">&lt;fossy&gt;</a></span><span class="message">which I 100% think is not a bad thing</span></div><div class="line" id="050645"><span class="nick" style="color:#80b1d3"><a href="#050645" label="[05:06:45]">&lt;fossy&gt;</a></span><span class="message">it does make bootstrapping harder, but almost everything easier, lol</span></div><div class="line" id="050711"><span class="nick" style="color:#80b1d3"><a href="#050711" label="[05:07:11]">&lt;fossy&gt;</a></span><span class="message">simple hardware ~= hard software :P</span></div><div class="line" id="051308"><span class="nick" style="color:#2e2a4a"><a href="#051308" label="[05:13:08]">&lt;oriansj&gt;</a></span><span class="message">fossy: simple for hardware implementation, you are absolutely right. Which is probably something they cared about. The Funky immediate formats and the like do reflect those sorts of engineering choices. Bootstrapping just was not something they selected for.</span></div><div class="line" id="073806"><span class="nick" style="color:#6d2462"><a href="#073806" label="[07:38:06]">&lt;siraben&gt;</a></span><span class="message">What version of GCC does live-bootstrap go up to? 4.0.4?</span></div><div class="line" id="100739"><span class="nick" style="color:#234e69"><a href="#100739" label="[10:07:39]">&lt;stikonas[m]&gt;</a></span><span class="message">siraben: 4.7.4</span></div><div class="line" id="100808"><span class="nick" style="color:#234e69"><a href="#100808" label="[10:08:08]">&lt;stikonas[m]&gt;</a></span><span class="message">There isn't much problem going further</span></div><div class="line" id="100831"><span class="nick" style="color:#234e69"><a href="#100831" label="[10:08:31]">&lt;stikonas[m]&gt;</a></span><span class="message">Prob just build latest binutils first</span></div><div class="line" id="101724"><span class="nick" style="color:#6d2462"><a href="#101724" label="[10:17:24]">&lt;siraben&gt;</a></span><span class="message">huh looks like Nix already has busybox sh built in, so we won't need to bootstrap the shell</span></div><div class="line" id="101742"><span class="nick" style="color:#6d2462"><a href="#101742" label="[10:17:42]">&lt;siraben&gt;</a></span><span class="message">nevertheless I found the place where the bootstrap tarball is generated</span></div><div class="line" id="152635"><span class="nick">***</span><span class="message notice">Server sets mode: +cnt </span></div><div class="line" id="164721"><span class="nick">***</span><span class="message notice">ChanServ sets mode: +o oriansj</span></div><div class="line" id="165542"><span class="nick" style="color:#2e2a4a"><a href="#165542" label="[16:55:42]">&lt;oriansj&gt;</a></span><span class="message">well atleast at this point the upstream blynn-compiler is buildable by live-bootstrap so once it gets to the stage able to bootstrap GHC, we can leverage it without changes.</span></div><div class="line" id="170429"><span class="nick" style="color:#6d2462"><a href="#170429" label="[17:04:29]">&lt;siraben&gt;</a></span><span class="message">oriansj: ah, did you test blynn-compiler with that GCC already?</span></div><div class="line" id="170500"><span class="nick" style="color:#6d2462"><a href="#170500" label="[17:05:00]">&lt;siraben&gt;</a></span><span class="message">Ok, so we don't need to necessarily make it work from M2-Planet</span></div><div class="line" id="172923"><span class="nick">***</span><span class="message notice">Noisytoot_ is now known as Noisytoot</span></div><div class="line" id="175739"><span class="nick" style="color:#6d2462"><a href="#175739" label="[17:57:39]">&lt;siraben&gt;</a></span><span class="message">Why do things like kaem use int instead of size_t when indexing into arrays and such?</span></div><div class="line" id="175743"><span class="nick" style="color:#6d2462"><a href="#175743" label="[17:57:43]">&lt;siraben&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/oriansj/kaem/blob/master/functions/match.c">https://github.com/oriansj/kaem/blob/master/functions/match.c</a> </span></div><div class="line" id="175744"><span class="nick" style="color:#6d2462"><a href="#175744" label="[17:57:44]">&lt;siraben&gt;</a></span><span class="message">isn't that undefined behavior?</span></div><div class="line" id="175949"><span class="nick" style="color:#8dd3c7"><a href="#175949" label="[17:59:49]">&lt;stikonas&gt;</a></span><span class="message">leftover from before M2-Planet supported size_t?</span></div><div class="line" id="180020"><span class="nick" style="color:#6c3d55"><a href="#180020" label="[18:00:20]">&lt;GeDaMo&gt;</a></span><span class="message">size_t is unsigned</span></div><div class="line" id="180139"><span class="nick" style="color:#8dd3c7"><a href="#180139" label="[18:01:39]">&lt;stikonas&gt;</a></span><span class="message">well, as long as you use just positive int's it will work with int too</span></div><div class="line" id="180210"><span class="nick" style="color:#6c3d55"><a href="#180210" label="[18:02:10]">&lt;GeDaMo&gt;</a></span><span class="message">I'm just pointing that out because the snippet that siraben linked sets i to -1</span></div><div class="line" id="180255"><span class="nick" style="color:#2e2a4a"><a href="#180255" label="[18:02:55]">&lt;oriansj&gt;</a></span><span class="message">siraben: very short version: is when we first wrote kaem we were sticking to cc_x86 types <a rel="nofollow" href="https://github.com/oriansj/stage0-posix/blob/master/x86/cc_x86.M1#L4757">https://github.com/oriansj/stage0-posix/blob/master/x86/cc_x86.M1#L4757</a>  which as you can see don't include size_t</span></div><div class="line" id="180334"><span class="nick" style="color:#6d2462"><a href="#180334" label="[18:03:34]">&lt;siraben&gt;</a></span><span class="message">I mention this because I've been attempting to formally verify some of the functions (good exercises) but the indexing is tripping me up all the time</span></div><div class="line" id="180348"><span class="nick" style="color:#6d2462"><a href="#180348" label="[18:03:48]">&lt;siraben&gt;</a></span><span class="message">or at least according to the encoding of the C spec used in the proof assistant</span></div><div class="line" id="180439"><span class="nick" style="color:#6c3d55"><a href="#180439" label="[18:04:39]">&lt;GeDaMo&gt;</a></span><span class="message">Should that match function check if a or b are NULL?</span></div><div class="line" id="180508"><span class="nick" style="color:#6d2462"><a href="#180508" label="[18:05:08]">&lt;siraben&gt;</a></span><span class="message">well assume they are not null and it's fine (stronger precondition)</span></div><div class="line" id="180721"><span class="nick" style="color:#6d2462"><a href="#180721" label="[18:07:21]">&lt;siraben&gt;</a></span><span class="message">what's the spec say on overflow behavior of unsigned, it truncates, right?</span></div><div class="line" id="180730"><span class="nick" style="color:#2e2a4a"><a href="#180730" label="[18:07:30]">&lt;oriansj&gt;</a></span><span class="message">siraben: we can always make the C pieces more formally correct without much effort.</span></div><div class="line" id="180830"><span class="nick" style="color:#6d2462"><a href="#180830" label="[18:08:30]">&lt;siraben&gt;</a></span><span class="message">this is just a minor side effort because I've been trying to find some more &quot;realistic&quot; C programs to verify for practice</span></div><div class="line" id="180838"><span class="nick" style="color:#6d2462"><a href="#180838" label="[18:08:38]">&lt;siraben&gt;</a></span><span class="message">it's definitely overkill for bootstrappable</span></div><div class="line" id="180848"><span class="nick" style="color:#2e2a4a"><a href="#180848" label="[18:08:48]">&lt;oriansj&gt;</a></span><span class="message">GeDaMo: would you want to dereference a null pointer in a compare?</span></div><div class="line" id="180906"><span class="nick" style="color:#6c3d55"><a href="#180906" label="[18:09:06]">&lt;GeDaMo&gt;</a></span><span class="message">&quot;Unsigned integer arithmetic is always performed modulo 2n where n is the number of bits in that particular integer. E.g. for unsigned int, adding one to UINT_MAX gives ​0​, and subtracting one from ​0​ gives UINT_MAX.&quot; <a rel="nofollow" href="https://en.cppreference.com/w/c/language/operator_arithmetic">https://en.cppreference.com/w/c/language/operator_arithmetic</a> </span></div><div class="line" id="180919"><span class="nick" style="color:#6c3d55"><a href="#180919" label="[18:09:19]">&lt;GeDaMo&gt;</a></span><span class="message">oriansj: I would not :P</span></div><div class="line" id="180923"><span class="nick" style="color:#6d2462"><a href="#180923" label="[18:09:23]">&lt;siraben&gt;</a></span><span class="message">GeDaMo: right, that is extremely useful</span></div><div class="line" id="181020"><span class="nick" style="color:#6d2462"><a href="#181020" label="[18:10:20]">&lt;siraben&gt;</a></span><span class="message">otherwise the use of int means I have to assert that i is always less than Int.max_signed, which may not always be true</span></div><div class="line" id="181027"><span class="nick" style="color:#6d2462"><a href="#181027" label="[18:10:27]">&lt;siraben&gt;</a></span><span class="message">as the website says signed overflow is undefined</span></div><div class="line" id="181216"><span class="nick" style="color:#8dd3c7"><a href="#181216" label="[18:12:16]">&lt;stikonas&gt;</a></span><span class="message">well, I guess because for signed integers it depends on how sign is encoded</span></div><div class="line" id="181316"><span class="nick" style="color:#8dd3c7"><a href="#181316" label="[18:13:16]">&lt;stikonas&gt;</a></span><span class="message">siraben: but here it's not as important whether spec says it's defined or not</span></div><div class="line" id="181327"><span class="nick" style="color:#8dd3c7"><a href="#181327" label="[18:13:27]">&lt;stikonas&gt;</a></span><span class="message">cause M2-Planet can define it if it wants</span></div><div class="line" id="181340"><span class="nick" style="color:#8dd3c7"><a href="#181340" label="[18:13:40]">&lt;stikonas&gt;</a></span><span class="message">(not sure how it deals with overflows)</span></div><div class="line" id="181412"><span class="nick" style="color:#2e2a4a"><a href="#181412" label="[18:14:12]">&lt;oriansj&gt;</a></span><span class="message">siraben: well the behavior given an array of length less than 2^(n-1) will behave the same as an int as an unsigned (size_t)</span></div><div class="line" id="181539"><span class="nick" style="color:#6d2462"><a href="#181539" label="[18:15:39]">&lt;siraben&gt;</a></span><span class="message">that's true, I can just add those preconditions to my formal spec</span></div><div class="line" id="181552"><span class="nick" style="color:#2e2a4a"><a href="#181552" label="[18:15:52]">&lt;oriansj&gt;</a></span><span class="message">So assuming int32 and array of say 4K elements overflow should never be reached and negative numbers could be used to detect underflow. (or using unsigned underflow would be detected asn overflow)</span></div><div class="line" id="181837"><span class="nick" style="color:#2e2a4a"><a href="#181837" label="[18:18:37]">&lt;oriansj&gt;</a></span><span class="message">stikonas: The short version of how M2-Planet deals with under and overflow is simply what the hardware behavior is by default.</span></div><div class="line" id="181914"><span class="nick" style="color:#6d2462"><a href="#181914" label="[18:19:14]">&lt;siraben&gt;</a></span><span class="message">could M2-Planet be adjusted to have size_t?</span></div><div class="line" id="181927"><span class="nick" style="color:#8dd3c7"><a href="#181927" label="[18:19:27]">&lt;stikonas&gt;</a></span><span class="message">siraben: M2-Planet has size_t</span></div><div class="line" id="181932"><span class="nick" style="color:#8dd3c7"><a href="#181932" label="[18:19:32]">&lt;stikonas&gt;</a></span><span class="message">it didn't have before</span></div><div class="line" id="181946"><span class="nick" style="color:#6d2462"><a href="#181946" label="[18:19:46]">&lt;siraben&gt;</a></span><span class="message">Oh, so kaem could be using size_t there instead?</span></div><div class="line" id="181957"><span class="nick" style="color:#8dd3c7"><a href="#181957" label="[18:19:57]">&lt;stikonas&gt;</a></span><span class="message">yes, but nobody updated that piece of code</span></div><div class="line" id="182027"><span class="nick" style="color:#2e2a4a"><a href="#182027" label="[18:20:27]">&lt;oriansj&gt;</a></span><span class="message">siraben: <a rel="nofollow" href="https://github.com/oriansj/M2-Planet/blob/master/cc_types.c#L111">https://github.com/oriansj/M2-Planet/blob/master/cc_types.c#L111</a> </span></div><div class="line" id="182040"><span class="nick" style="color:#6d2462"><a href="#182040" label="[18:20:40]">&lt;siraben&gt;</a></span><span class="message">between do..while and while..do, which one is compiled more efficiently?</span></div><div class="line" id="182040"><span class="nick" style="color:#8dd3c7"><a href="#182040" label="[18:20:40]">&lt;stikonas&gt;</a></span><span class="message">I guess most compilers leave signed integer overflow to hardware default, hence it is &quot;undefined&quot; as different hardware might have difference conventions</span></div><div class="line" id="182048"><span class="nick" style="color:#6d2462"><a href="#182048" label="[18:20:48]">&lt;siraben&gt;</a></span><span class="message">compiled by M2-Planet*</span></div><div class="line" id="182132"><span class="nick" style="color:#8dd3c7"><a href="#182132" label="[18:21:32]">&lt;stikonas&gt;</a></span><span class="message">even if it's not efficient, that wouldn't matter too much, kaem is not the bottleneck</span></div><div class="line" id="182201"><span class="nick" style="color:#6d2462"><a href="#182201" label="[18:22:01]">&lt;siraben&gt;</a></span><span class="message">Also, what's the command used to automatically format C code in the bootstrap files?</span></div><div class="line" id="182229"><span class="nick" style="color:#6d2462"><a href="#182229" label="[18:22:29]">&lt;siraben&gt;</a></span><span class="message">stikonas: yeah, but just out of curiosity, because I wonder why it's written a bit more awkwardly with do while</span></div><div class="line" id="182402"><span class="nick" style="color:#2e2a4a"><a href="#182402" label="[18:24:02]">&lt;oriansj&gt;</a></span><span class="message">siraben: astyle -A1tSxejz2fpUxV file.c</span></div><div class="line" id="182457"><span class="nick" style="color:#6d2462"><a href="#182457" label="[18:24:57]">&lt;siraben&gt;</a></span><span class="message">oriansj: thanks</span></div><div class="line" id="182632"><span class="nick" style="color:#2e2a4a"><a href="#182632" label="[18:26:32]">&lt;oriansj&gt;</a></span><span class="message">there are no such things as while .. do loops in C but there are while loops and do while loops and for loops. Of which do while loops are at most 2 instructions shorter.</span></div><div class="line" id="182710"><span class="nick" style="color:#6d2462"><a href="#182710" label="[18:27:10]">&lt;siraben&gt;</a></span><span class="message">sorry not while..do, but do..while vs. just while</span></div><div class="line" id="182726"><span class="nick" style="color:#2e2a4a"><a href="#182726" label="[18:27:26]">&lt;oriansj&gt;</a></span><span class="message">as it just outputs a label and a conditional jump at the end</span></div><div class="line" id="182839"><span class="nick" style="color:#2e2a4a"><a href="#182839" label="[18:28:39]">&lt;oriansj&gt;</a></span><span class="message">while loops have a label, conditional jump, the code block, an unconditional jump and a label</span></div><div class="line" id="182904"><span class="nick" style="color:#6d2462"><a href="#182904" label="[18:29:04]">&lt;siraben&gt;</a></span><span class="message">Right.</span></div><div class="line" id="183039"><span class="nick" style="color:#2e2a4a"><a href="#183039" label="[18:30:39]">&lt;oriansj&gt;</a></span><span class="message">So in terms of efficiency it is best to use the one that best matches the work rather than trying to shave off a single jump</span></div><div class="line" id="183345"><span class="nick" style="color:#2e2a4a"><a href="#183345" label="[18:33:45]">&lt;oriansj&gt;</a></span><span class="message">for loops are the most inefficient and I know why C dropped the loop {} primitive despite it being trivial to implement. (a unconditional jump at the end and 2 labels)</span></div><div class="line" id="201946"><span class="nick" style="color:#6b8072"><a href="#201946" label="[20:19:46]">&lt;xentrac&gt;</a></span><span class="message">indexing into arrays with ints is not undefined behavior :)</span></div><div class="line" id="201958"><span class="nick" style="color:#6b8072"><a href="#201958" label="[20:19:58]">&lt;xentrac&gt;</a></span><span class="message">I mean, it depends on which int, but not in general</span></div><div class="line" id="202208"><span class="nick" style="color:#6d2462"><a href="#202208" label="[20:22:08]">&lt;siraben&gt;</a></span><span class="message">xentrac: misspoke then, it turns out the obligation to assert that the int does not overflow makes verification harder</span></div><div class="line" id="202238"><span class="nick" style="color:#6d2462"><a href="#202238" label="[20:22:38]">&lt;siraben&gt;</a></span><span class="message">especially if it comes from traversing an unbounded amount of bytes from an input pointer</span></div><div class="line" id="202328"><span class="nick" style="color:#6d2462"><a href="#202328" label="[20:23:28]">&lt;siraben&gt;</a></span><span class="message">sample programs: <a rel="nofollow" href="https://github.com/PrincetonUniversity/VST/tree/master/progs64">https://github.com/PrincetonUniversity/VST/tree/master/progs64</a> </span></div><div class="line" id="202348"><span class="nick" style="color:#6d2462"><a href="#202348" label="[20:23:48]">&lt;siraben&gt;</a></span><span class="message">which I think are pretty realistic and comparable to files we have</span></div><div class="line" id="202356"><span class="nick" style="color:#6b8072"><a href="#202356" label="[20:23:56]">&lt;xentrac&gt;</a></span><span class="message">you can compile while(a) b; as jmp end\@; start\@: K(b); end\@: K(a); jnz start\@</span></div><div class="line" id="202408"><span class="nick" style="color:#6b8072"><a href="#202408" label="[20:24:08]">&lt;xentrac&gt;</a></span><span class="message">this is only one more instruction than a do-while loop rather than 2</span></div><div class="line" id="202557"><span class="nick" style="color:#6b8072"><a href="#202557" label="[20:25:57]">&lt;xentrac&gt;</a></span><span class="message">usually I think you need to prove bounds on your loop counter anyway if you want to verify the loop?</span></div><div class="line" id="202639"><span class="nick" style="color:#6b8072"><a href="#202639" label="[20:26:39]">&lt;xentrac&gt;</a></span><span class="message">I mean if you do things inside the loop like array indexing or arithmetic?</span></div><div class="line" id="202741"><span class="nick" style="color:#6d2462"><a href="#202741" label="[20:27:41]">&lt;siraben&gt;</a></span><span class="message">yeah I have to show in particular an invariant holds on the loop</span></div><div class="line" id="202744"><span class="nick" style="color:#6b8072"><a href="#202744" label="[20:27:44]">&lt;xentrac&gt;</a></span><span class="message">oriansj: M0+hex2 don't know most of the amd64 mnemonics</span></div><div class="line" id="202800"><span class="nick" style="color:#6d2462"><a href="#202800" label="[20:28:00]">&lt;siraben&gt;</a></span><span class="message">and that this invariant holds on loop entry and on the ith iteration</span></div><div class="line" id="202812"><span class="nick" style="color:#6d2462"><a href="#202812" label="[20:28:12]">&lt;siraben&gt;</a></span><span class="message">and all array accesses must be in bounds</span></div><div class="line" id="203037"><span class="nick" style="color:#6d2462"><a href="#203037" label="[20:30:37]">&lt;siraben&gt;</a></span><span class="message">but anyway, i'm still relatively new to applying verification to C and the level of detail is a bit annoying (but necessary) compared to idealized imperative languages given for learning purposes</span></div><div class="line" id="203531"><span class="nick" style="color:#6b8072"><a href="#203531" label="[20:35:31]">&lt;xentrac&gt;</a></span><span class="message">you're way ahead of me tho</span></div><div class="line" id="203610"><span class="nick" style="color:#6b8072"><a href="#203610" label="[20:36:10]">&lt;xentrac&gt;</a></span><span class="message">we could, you know, use an idealized imperative language if we want to rewrite stuff in it</span></div><div class="line" id="204013"><span class="nick" style="color:#6d2462"><a href="#204013" label="[20:40:13]">&lt;siraben&gt;</a></span><span class="message">xentrac: it's a lot of effort to do that, instead, the C spec has already been cleaned up and formalized and a compiler targeting x86, ARM, RISC-V has been verified to respect the semantics</span></div><div class="line" id="204053"><span class="nick" style="color:#6d2462"><a href="#204053" label="[20:40:53]">&lt;siraben&gt;</a></span><span class="message">I used this book <a rel="nofollow" href="https://softwarefoundations.cis.upenn.edu/vc-current/toc.html">https://softwarefoundations.cis.upenn.edu/vc-current/toc.html</a> </span></div><div class="line" id="204106"><span class="nick" style="color:#6b8072"><a href="#204106" label="[20:41:06]">&lt;xentrac&gt;</a></span><span class="message">well, a lot of effort will be required in any case</span></div><div class="line" id="204138"><span class="nick" style="color:#6b8072"><a href="#204138" label="[20:41:38]">&lt;xentrac&gt;</a></span><span class="message">also do you mean CompCert?  CompCert may be verified but it isn't free software</span></div><div class="line" id="204155"><span class="nick" style="color:#6d2462"><a href="#204155" label="[20:41:55]">&lt;siraben&gt;</a></span><span class="message">I realize :(</span></div><div class="line" id="204218"><span class="nick" style="color:#6d2462"><a href="#204218" label="[20:42:18]">&lt;siraben&gt;</a></span><span class="message">Well non-commercial use is allowed, right?</span></div><div class="line" id="204230"><span class="nick" style="color:#6b8072"><a href="#204230" label="[20:42:30]">&lt;xentrac&gt;</a></span><span class="message">I mean, neither was seL4 for the first several years, but we may not get so lucky this time around</span></div><div class="line" id="204239"><span class="nick" style="color:#6b8072"><a href="#204239" label="[20:42:39]">&lt;xentrac&gt;</a></span><span class="message">that's my understanding, yes</span></div><div class="line" id="204402"><span class="nick" style="color:#6b8072"><a href="#204402" label="[20:44:02]">&lt;xentrac&gt;</a></span><span class="message">(and CompCert is already older than seL4)</span></div><div class="line" id="204508"><span class="nick" style="color:#6b8072"><a href="#204508" label="[20:45:08]">&lt;xentrac&gt;</a></span><span class="message">there were a lot of programs I used pretty often in the early days of Linux that have pretty much died because of being for non-commercial use only</span></div><div class="line" id="204522"><span class="nick" style="color:#6d2462"><a href="#204522" label="[20:45:22]">&lt;siraben&gt;</a></span><span class="message">I'd wager it's possible to create a language suitable for bootstrapping while having a small and cleab semantics</span></div><div class="line" id="204522"><span class="nick" style="color:#6b8072"><a href="#204522" label="[20:45:22]">&lt;xentrac&gt;</a></span><span class="message">the Seyon terminal emulator, xv, ncftp</span></div><div class="line" id="204522"><span class="nick" style="color:#6d2462"><a href="#204522" label="[20:45:22]">&lt;siraben&gt;</a></span><span class="message">clean*</span></div><div class="line" id="204523"><span class="nick" style="color:#6d2462"><a href="#204523" label="[20:45:23]">&lt;siraben&gt;</a></span><span class="message">I see</span></div><div class="line" id="204611"><span class="nick" style="color:#6b8072"><a href="#204611" label="[20:46:11]">&lt;xentrac&gt;</a></span><span class="message">admittedly there is less need nowadays for interacting with dialup modems or ftp sites</span></div><div class="line" id="204721"><span class="nick" style="color:#6d2462"><a href="#204721" label="[20:47:21]">&lt;siraben&gt;</a></span><span class="message">bbl, night all</span></div><div class="line" id="204728"><span class="nick" style="color:#6b8072"><a href="#204728" label="[20:47:28]">&lt;xentrac&gt;</a></span><span class="message">night!</span></div><div class="line" id="225045"><span class="nick" style="color:#2e2a4a"><a href="#225045" label="[22:50:45]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well you are partially right but not entirely. As M0+hex2 knows 0% of AMD64's mnemonics. But that is why we use DEFINE statements and that is more than enough to bootstrap everything. RISC-V needs considerably more than that.</span></div><div class="line" id="225534"><span class="nick" style="color:#6b8072"><a href="#225534" label="[22:55:34]">&lt;xentrac&gt;</a></span><span class="message">yeah, it needs the bits to be shuffled like some perverted card trick</span></div><div class="line" id="225643"><span class="nick" style="color:#2e2a4a"><a href="#225643" label="[22:56:43]">&lt;oriansj&gt;</a></span><span class="message">we just leverage the fact that Immediates are byte aligned, contiguous and a fixed number of bytes in size. RISC-V however gets complicated because the documentation like ARMv7 is wrong AND has a messy bit ordering.</span></div><div class="line" id="225731"><span class="nick" style="color:#6b8072"><a href="#225731" label="[22:57:31]">&lt;xentrac&gt;</a></span><span class="message">oh interesting, what documentation problems have you run into?</span></div><div class="line" id="225833"><span class="nick" style="color:#2e2a4a"><a href="#225833" label="[22:58:33]">&lt;oriansj&gt;</a></span><span class="message">xentrac: little endian instructions but big endian left to right in docs</span></div><div class="line" id="225959"><span class="nick" style="color:#2e2a4a"><a href="#225959" label="[22:59:59]">&lt;oriansj&gt;</a></span><span class="message">so docs show [ab][cd][ef][01] but reality is [01][ef]cd][ab]</span></div><div class="line" id="230053"><span class="nick" style="color:#8dd3c7"><a href="#230053" label="[23:00:53]">&lt;stikonas&gt;</a></span><span class="message">kaem-minimal  for riscv64 GAS prototype  is getting closer, need to fix some minor (it segfaults when executable is not found) issues but almost works</span></div><div class="line" id="230156"><span class="nick" style="color:#2e2a4a"><a href="#230156" label="[23:01:56]">&lt;oriansj&gt;</a></span><span class="message">stikonas: nice, keep up the good work ^_^</span></div><div class="line" id="230232"><span class="nick" style="color:#8dd3c7"><a href="#230232" label="[23:02:32]">&lt;stikonas&gt;</a></span><span class="message">most of the problems were where I assumed things instead of reading manpages...</span></div><div class="line" id="230405"><span class="nick" style="color:#6b8072"><a href="#230405" label="[23:04:05]">&lt;xentrac&gt;</a></span><span class="message">oriansj: that's explained on p. 9 of §1.5 in &quot;RISC-V Unprivileged ISA V20191213&quot;, subsection &quot;Expanded Instruction-Length Encoding&quot;</span></div><div class="line" id="230532"><span class="nick" style="color:#6b8072"><a href="#230532" label="[23:05:32]">&lt;xentrac&gt;</a></span><span class="message">&gt; Instructions are stored in memory as a sequence of 16-bit little-endian parcels regardless of memory system endianness.  Parcels forming one instruction are stored at increasing halfword addresses, with the lowest-addressed parcel holding the lowest-numbered bits in the instruction specification.</span></div><div class="line" id="230554"><span class="nick" style="color:#6b8072"><a href="#230554" label="[23:05:54]">&lt;xentrac&gt;</a></span><span class="message">(p.27/238)</span></div><div class="line" id="230652"><span class="nick" style="color:#6b8072"><a href="#230652" label="[23:06:52]">&lt;xentrac&gt;</a></span><span class="message">&gt; We have to fix the order in which instruction parcels are stored in memory, independent of memory system endianness, to ensure that the length-encoding bits always appear first in halfword address order.  This allows the length of a variable-length instruction to be quickly determined by the instruction-fetch unit by examining only the first few bits of the first 16-bit instruction parcel.</span></div><div class="line" id="230738"><span class="nick" style="color:#6b8072"><a href="#230738" label="[23:07:38]">&lt;xentrac&gt;</a></span><span class="message">&gt; We further make the parcels little-endian to decouple the instruction encoding from the memory system endianness altogether.</span></div><div class="line" id="230855"><span class="nick" style="color:#6b8072"><a href="#230855" label="[23:08:55]">&lt;xentrac&gt;</a></span><span class="message">&gt; Once we had decided to fix on a little-endian instruction encoding, this naturally led to placing the length-encoding bits in the LSB positions of the instruction format to avoid breaking up opcode fields.</span></div><div class="line" id="231012"><span class="nick" style="color:#6b8072"><a href="#231012" label="[23:10:12]">&lt;xentrac&gt;</a></span><span class="message">I thought that was pretty clear!</span></div><div class="line" id="231438"><span class="nick" style="color:#2e2a4a"><a href="#231438" label="[23:14:38]">&lt;oriansj&gt;</a></span><span class="message">xentrac: yes the words are clear with context but the pictures of the instruction formats do not match the words.</span></div><div class="line" id="231512"><span class="nick" style="color:#6b8072"><a href="#231512" label="[23:15:12]">&lt;xentrac&gt;</a></span><span class="message">they seem to match to me; the length-encoding bits are in the LSB positions</span></div><div class="line" id="231615"><span class="nick" style="color:#6b8072"><a href="#231615" label="[23:16:15]">&lt;xentrac&gt;</a></span><span class="message">and the bits are numbered with (for the 32-bit format) bit 31 at the left, which clearly can't be a length-encoding bit, and bit 0 at the right, which is part of the opcode field</span></div><div class="line" id="231634"><span class="nick" style="color:#6b8072"><a href="#231634" label="[23:16:34]">&lt;xentrac&gt;</a></span><span class="message">I don't see any inconsistency at all</span></div><div class="line" id="232214"><span class="nick" style="color:#2e2a4a"><a href="#232214" label="[23:22:14]">&lt;oriansj&gt;</a></span><span class="message">[func7 7][]rs2 5][rs1 5][funct3 3][rd 5][opcode 7] is what R format looks like in the diagrams. [rd 1][opcode 7], [rs1 1][funct3 3][rd 4],[rs2 4][rs1 4], [funct7 7][rs2 1] look very different to me</span></div><div class="line" id="232641"><span class="nick" style="color:#6b8072"><a href="#232641" label="[23:26:41]">&lt;xentrac&gt;</a></span><span class="message">well sure, if you read it as four bytes you have to put them in the right byte order to get the right 32-bit word</span></div><div class="line" id="232707"><span class="nick" style="color:#6b8072"><a href="#232707" label="[23:27:07]">&lt;xentrac&gt;</a></span><span class="message">there you've put them in big-endian order, but the right byte order is little-endian order, which gives you</span></div><div class="line" id="232801"><span class="nick" style="color:#6b8072"><a href="#232801" label="[23:28:01]">&lt;xentrac&gt;</a></span><span class="message">[funct7 7][rs2 1], [rs2 4][rs1 4], [rs1 1][funct3 3][rd 4], [rd 1][opcode 7]</span></div><div class="line" id="232814"><span class="nick" style="color:#6b8072"><a href="#232814" label="[23:28:14]">&lt;xentrac&gt;</a></span><span class="message">which is the same</span></div><div class="line" id="232836"><span class="nick" style="color:#6b8072"><a href="#232836" label="[23:28:36]">&lt;xentrac&gt;</a></span><span class="message">I mean it's the same problem you have with a 32-bit integer in memory on i386 or amd64</span></div><div class="line" id="232943"><span class="nick" style="color:#6b8072"><a href="#232943" label="[23:29:43]">&lt;xentrac&gt;</a></span><span class="message">0x804800 is represented as the sequence of bytes 0x00, 0x48, 0x80, 0x00</span></div><div class="line" id="233721"><span class="nick" style="color:#2e2a4a"><a href="#233721" label="[23:37:21]">&lt;oriansj&gt;</a></span><span class="message">xentrac: hex2 and M? are big endian languages that optionally output pointers and immediates in little endian order.</span></div><div class="line" id="233742"><span class="nick" style="color:#2e2a4a"><a href="#233742" label="[23:37:42]">&lt;oriansj&gt;</a></span><span class="message">they read a byte and output that byte</span></div><div class="line" id="233834"><span class="nick" style="color:#2e2a4a"><a href="#233834" label="[23:38:34]">&lt;oriansj&gt;</a></span><span class="message">So DEFINE foo aabb will write the byte aa and then the byte bb</span></div><div class="line" id="233913"><span class="nick" style="color:#2e2a4a"><a href="#233913" label="[23:39:13]">&lt;oriansj&gt;</a></span><span class="message">we are not writing out words but individual bytes</span></div><div class="line" id="234326"><span class="nick" style="color:#2e2a4a"><a href="#234326" label="[23:43:26]">&lt;oriansj&gt;</a></span><span class="message">which is why for i386 and AMD64, we just did DEFINE ADDI8_to_RAX 4883C0 and ADDI8_to_RAX !-1 and it just works</span></div><div class="line" id="234353"><span class="nick" style="color:#80b1d3"><a href="#234353" label="[23:43:53]">&lt;fossy&gt;</a></span><span class="message">urgh the linux kernel minimum requirements docs are wrong</span></div><div class="line" id="234400"><span class="nick" style="color:#2e2a4a"><a href="#234400" label="[23:44:00]">&lt;oriansj&gt;</a></span><span class="message">or DEFINE CALLI32 E8 and CALLI32 %foo and it worked</span></div><div class="line" id="234526"><span class="nick" style="color:#80b1d3"><a href="#234526" label="[23:45:26]">&lt;fossy&gt;</a></span><span class="message">our version binutils is meant to work but it most def dosent</span></div><div class="line" id="234530"><span class="nick" style="color:#2e2a4a"><a href="#234530" label="[23:45:30]">&lt;oriansj&gt;</a></span><span class="message">fossy: nice find</span></div><div class="line" id="234558"><span class="nick" style="color:#6b8072"><a href="#234558" label="[23:45:58]">&lt;xentrac&gt;</a></span><span class="message">oriansj: yeah, makes sense.  not sure that necessarily means risc-v is harder to bootstrap, but it's definitely different from the byte orientation of the Datapoint 2200</span></div><div class="line" id="234605"><span class="nick" style="color:#80b1d3"><a href="#234605" label="[23:46:05]">&lt;fossy&gt;</a></span><span class="message">im wondering if its cause its an LTS (4.9.x series) but it changed and noone updated it</span></div><div class="line" id="234611"><span class="nick" style="color:#80b1d3"><a href="#234611" label="[23:46:11]">&lt;fossy&gt;</a></span><span class="message">so im testing older of that</span></div><div class="line" id="234618"><span class="nick" style="color:#80b1d3"><a href="#234618" label="[23:46:18]">&lt;fossy&gt;</a></span><span class="message">if that dosent work ill move to 4.4.x</span></div><div class="line" id="234718"><span class="nick" style="color:#6b8072"><a href="#234718" label="[23:47:18]">&lt;xentrac&gt;</a></span><span class="message">so tools that work well for bootstrapping one may not work well for bootstrapping the other</span></div><div class="line" id="234725"><span class="nick" style="color:#2e2a4a"><a href="#234725" label="[23:47:25]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well the word orientation means we might not be able to do a reasonable hex1 and might have to skip to doing a full hex2 in hex0 (that is going to really suck)</span></div><div class="line" id="234826"><span class="nick" style="color:#2e2a4a"><a href="#234826" label="[23:48:26]">&lt;oriansj&gt;</a></span><span class="message">xentrac: these tools worked fine for 5 other architectures</span></div><div class="line" id="234936"><span class="nick" style="color:#6b8072"><a href="#234936" label="[23:49:36]">&lt;xentrac&gt;</a></span><span class="message">I wonder if there's a simpler way to do RISC-V</span></div><div class="line" id="235008"><span class="nick" style="color:#2e2a4a"><a href="#235008" label="[23:50:08]">&lt;oriansj&gt;</a></span><span class="message">but you are right, there *MIGHT* be a more optimal bootstrapping path for RISC-V but thus far no one has figured it out yet.</span></div><div class="line" id="235241"><span class="nick" style="color:#2e2a4a"><a href="#235241" label="[23:52:41]">&lt;oriansj&gt;</a></span><span class="message">I'm certain stikonas would love it if someone else saved them the work of having to hand convert RISC-V instructions into hex</span></div><div class="line" id="235634"><span class="nick" style="color:#2e2a4a"><a href="#235634" label="[23:56:34]">&lt;oriansj&gt;</a></span><span class="message">hence why when there was a working solution for improving RISC-V's hex2, I incorporated it in a way that would be as easy as possible to implement in assembly.</span></div><br /></div></body></html>