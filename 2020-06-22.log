<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2020-06-22.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000006"><span class="nick" style="color:#389600"><a href="#000006" label="[00:00:06]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: well Wirth's designs are generally quite balanced in terms of performance to minimalism</span></div><div class="line" id="000153"><span class="nick" style="color:#8dd3c7"><a href="#000153" label="[00:01:53]">&lt;xentrac&gt;</a></span><span class="message">yeah, although he typically goes perhaps a bit far in the minimalism direction</span></div><div class="line" id="000351"><span class="nick" style="color:#8dd3c7"><a href="#000351" label="[00:03:51]">&lt;xentrac&gt;</a></span><span class="message">I don't remember how many logic blocks Wirth's RISC takes up on a Xilinx FPGA</span></div><div class="line" id="000357"><span class="nick" style="color:#389600"><a href="#000357" label="[00:03:57]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: I find his hardware design makes much more sense if you imagine it never running hand written assembly</span></div><div class="line" id="000412"><span class="nick" style="color:#8dd3c7"><a href="#000412" label="[00:04:12]">&lt;xentrac&gt;</a></span><span class="message">which aspects of the hardware design?</span></div><div class="line" id="001124"><span class="nick" style="color:#389600"><a href="#001124" label="[00:11:24]">&lt;OriansJ`&gt;</a></span><span class="message">assuming we are discussing: <a rel="nofollow" href="https://people.inf.ethz.ch/wirth/FPGA-relatedWork/RISC-Arch.pdf">https://people.inf.ethz.ch/wirth/FPGA-relatedWork/RISC-Arch.pdf</a> </span></div><div class="line" id="001145"><span class="nick" style="color:#389600"><a href="#001145" label="[00:11:45]">&lt;OriansJ`&gt;</a></span><span class="message">no add-carry, no subtract-borrow in hardware</span></div><div class="line" id="001214"><span class="nick" style="color:#389600"><a href="#001214" label="[00:12:14]">&lt;OriansJ`&gt;</a></span><span class="message">No Multiply high or modulus or remainder</span></div><div class="line" id="001251"><span class="nick" style="color:#389600"><a href="#001251" label="[00:12:51]">&lt;OriansJ`&gt;</a></span><span class="message">no add immediate or subtract immediate forms</span></div><div class="line" id="001528"><span class="nick" style="color:#389600"><a href="#001528" label="[00:15:28]">&lt;OriansJ`&gt;</a></span><span class="message">no call register nor jump register instructions</span></div><div class="line" id="001928"><span class="nick" style="color:#389600"><a href="#001928" label="[00:19:28]">&lt;OriansJ`&gt;</a></span><span class="message">oops read the paragrah wrong</span></div><div class="line" id="002137"><span class="nick" style="color:#389600"><a href="#002137" label="[00:21:37]">&lt;OriansJ`&gt;</a></span><span class="message">load/stores are either 32bit or 8bit and nothing else</span></div><div class="line" id="002218"><span class="nick" style="color:#6b8072"><a href="#002218" label="[00:22:18]">&lt;darius&gt;</a></span><span class="message">xentrac, really 4 memory instructions</span></div><div class="line" id="002227"><span class="nick" style="color:#6b8072"><a href="#002227" label="[00:22:27]">&lt;darius&gt;</a></span><span class="message">load/store word/byte</span></div><div class="line" id="002618"><span class="nick" style="color:#389600"><a href="#002618" label="[00:26:18]">&lt;OriansJ`&gt;</a></span><span class="message">ironically with ~label being 24bit offset and @immediate being 16bit immediates, it maps nearly perfectly to M1 and hex2</span></div><div class="line" id="002655"><span class="nick" style="color:#389600"><a href="#002655" label="[00:26:55]">&lt;OriansJ`&gt;</a></span><span class="message">I could probably port hex0-&gt;M2-Planet to it in less than a month</span></div><div class="line" id="002826"><span class="nick" style="color:#389600"><a href="#002826" label="[00:28:26]">&lt;OriansJ`&gt;</a></span><span class="message">So if we wanted, it certainly could very easily become another root port for stage0</span></div><div class="line" id="002940"><span class="nick" style="color:#389600"><a href="#002940" label="[00:29:40]">&lt;OriansJ`&gt;</a></span><span class="message">just need a guix package for its simulator and a solid excuse to work on it</span></div><div class="line" id="003020"><span class="nick" style="color:#389600"><a href="#003020" label="[00:30:20]">&lt;OriansJ`&gt;</a></span><span class="message">(such as someone doing it in TTL who would later share the schematic under an FSF approved license)</span></div><div class="line" id="003134"><span class="nick" style="color:#6b8072"><a href="#003134" label="[00:31:34]">&lt;darius&gt;</a></span><span class="message">OriansJ`, wirth's pdf lists for the ISA add/sub all of those except for call through register and the multiply/divide instructions you mentioned. i haven't looked at his implementation.</span></div><div class="line" id="003315"><span class="nick" style="color:#389600"><a href="#003315" label="[00:33:15]">&lt;OriansJ`&gt;</a></span><span class="message">darius: you might be correct as I did a quick rush through read/issue search</span></div><div class="line" id="003401"><span class="nick" style="color:#8dd3c7"><a href="#003401" label="[00:34:01]">&lt;xentrac&gt;</a></span><span class="message">yeah, true, 4</span></div><div class="line" id="003404"><span class="nick" style="color:#389600"><a href="#003404" label="[00:34:04]">&lt;OriansJ`&gt;</a></span><span class="message">although I might think the 110v branch instructions might actually use a register value</span></div><div class="line" id="003423"><span class="nick" style="color:#8dd3c7"><a href="#003423" label="[00:34:23]">&lt;xentrac&gt;</a></span><span class="message">it does actually have add-carry and subtract-borrow in hardware; that's add' and sub'</span></div><div class="line" id="003501"><span class="nick" style="color:#8dd3c7"><a href="#003501" label="[00:35:01]">&lt;xentrac&gt;</a></span><span class="message">multiply high and modulo do seem like serious omissions (if you're going to have multiply and divide anyway)</span></div><div class="line" id="003607"><span class="nick" style="color:#6b8072"><a href="#003607" label="[00:36:07]">&lt;darius&gt;</a></span><span class="message">OriansJ`, oh right</span></div><div class="line" id="003714"><span class="nick" style="color:#389600"><a href="#003714" label="[00:37:14]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: only if one is writing in assembly</span></div><div class="line" id="003737"><span class="nick" style="color:#389600"><a href="#003737" label="[00:37:37]">&lt;OriansJ`&gt;</a></span><span class="message">they are not serious omissions if you are writing everything in pascal or C</span></div><div class="line" id="004301"><span class="nick" style="color:#389600"><a href="#004301" label="[00:43:01]">&lt;OriansJ`&gt;</a></span><span class="message">also it does not specify if bit or little endian for either bits nor bytes</span></div><div class="line" id="004328"><span class="nick" style="color:#389600"><a href="#004328" label="[00:43:28]">&lt;OriansJ`&gt;</a></span><span class="message">^bit^big^ endian</span></div><div class="line" id="004626"><span class="nick" style="color:#389600"><a href="#004626" label="[00:46:26]">&lt;OriansJ`&gt;</a></span><span class="message">of course it is a big change from the NS32000, that Wirth previously used.</span></div><div class="line" id="004721"><span class="nick" style="color:#389600"><a href="#004721" label="[00:47:21]">&lt;OriansJ`&gt;</a></span><span class="message">which easily was a $200K design if it was in TTL, rather than the $500 CMOS chip it initially retailed as</span></div><div class="line" id="004723"><span class="nick" style="color:#8dd3c7"><a href="#004723" label="[00:47:23]">&lt;xentrac&gt;</a></span><span class="message">oh, I see what you mean</span></div><div class="line" id="004816"><span class="nick" style="color:#8dd3c7"><a href="#004816" label="[00:48:16]">&lt;xentrac&gt;</a></span><span class="message">although Pascal and C have mod and % operators</span></div><div class="line" id="004858"><span class="nick" style="color:#8dd3c7"><a href="#004858" label="[00:48:58]">&lt;xentrac&gt;</a></span><span class="message">also, multiply high is pretty important for long long support in C</span></div><div class="line" id="004910"><span class="nick" style="color:#8dd3c7"><a href="#004910" label="[00:49:10]">&lt;xentrac&gt;</a></span><span class="message">but that's a GCC extension</span></div><div class="line" id="005126"><span class="nick" style="color:#389600"><a href="#005126" label="[00:51:26]">&lt;OriansJ`&gt;</a></span><span class="message">you can get the same value by bitshifting and other fun; which &quot;might&quot; end up being faster depending upon your basis of hardware implementation (FPGA vs custom asic)</span></div><div class="line" id="005434"><span class="nick" style="color:#389600"><a href="#005434" label="[00:54:34]">&lt;OriansJ`&gt;</a></span><span class="message">if one would to do custom asic, hardware multiply high would certainly be the superior choice. Although Wirth consumed all 256 Potential encodings for the first opcode byte</span></div><div class="line" id="005734"><span class="nick" style="color:#8dd3c7"><a href="#005734" label="[00:57:34]">&lt;xentrac&gt;</a></span><span class="message">probably nowadays yeah</span></div><div class="line" id="005747"><span class="nick" style="color:#389600"><a href="#005747" label="[00:57:47]">&lt;OriansJ`&gt;</a></span><span class="message">which means one would have to do something funky in 00v0 to squeeze it in the 12bits of wasted space</span></div><div class="line" id="005755"><span class="nick" style="color:#6b8072"><a href="#005755" label="[00:57:55]">&lt;darius&gt;</a></span><span class="message">fwiw wirth's longer document says &quot;The DIV instruction deposits the remainder in an auxiliary register H.&quot; but seems to mention it nowhere else.</span></div><div class="line" id="005829"><span class="nick" style="color:#6b8072"><a href="#005829" label="[00:58:29]">&lt;darius&gt;</a></span><span class="message">might be a similar story wrt multiply high</span></div><div class="line" id="005833"><span class="nick" style="color:#389600"><a href="#005833" label="[00:58:33]">&lt;OriansJ`&gt;</a></span><span class="message">darius: perhaps a MIPS idea steal that he later realized was a very bad idea</span></div><div class="line" id="005834"><span class="nick" style="color:#8dd3c7"><a href="#005834" label="[00:58:34]">&lt;xentrac&gt;</a></span><span class="message">you could do the same thing with multiply, as the 8086 does</span></div><div class="line" id="005843"><span class="nick" style="color:#8dd3c7"><a href="#005843" label="[00:58:43]">&lt;xentrac&gt;</a></span><span class="message">jinx</span></div><div class="line" id="005851"><span class="nick" style="color:#6b8072"><a href="#005851" label="[00:58:51]">&lt;darius&gt;</a></span><span class="message">it goes back long before mips</span></div><div class="line" id="005918"><span class="nick" style="color:#8dd3c7"><a href="#005918" label="[00:59:18]">&lt;xentrac&gt;</a></span><span class="message">weren't we seeing that the PDP-8 EEA did that in the late 1960s?</span></div><div class="line" id="005921"><span class="nick" style="color:#8dd3c7"><a href="#005921" label="[00:59:21]">&lt;xentrac&gt;</a></span><span class="message">with the MQ register</span></div><div class="line" id="005927"><span class="nick" style="color:#8dd3c7"><a href="#005927" label="[00:59:27]">&lt;xentrac&gt;</a></span><span class="message">yesterday</span></div><div class="line" id="005936"><span class="nick" style="color:#389600"><a href="#005936" label="[00:59:36]">&lt;OriansJ`&gt;</a></span><span class="message">darius: MIPS had a famous performance bottle neck cased by a specialized register for division/multiplication</span></div><div class="line" id="005940"><span class="nick" style="color:#6b8072"><a href="#005940" label="[00:59:40]">&lt;darius&gt;</a></span><span class="message">i didn't review pdp8 but i've seen mq in very old designs</span></div><div class="line" id="010003"><span class="nick" style="color:#6b8072"><a href="#010003" label="[01:00:03]">&lt;darius&gt;</a></span><span class="message">mm hm</span></div><div class="line" id="010033"><span class="nick" style="color:#389600"><a href="#010033" label="[01:00:33]">&lt;OriansJ`&gt;</a></span><span class="message">but then again the Only architecture that did Multiplication right out of the gate was DEC alpha</span></div><div class="line" id="010049"><span class="nick" style="color:#389600"><a href="#010049" label="[01:00:49]">&lt;OriansJ`&gt;</a></span><span class="message">but they completely did byte instructions wrong</span></div><div class="line" id="010118"><span class="nick" style="color:#389600"><a href="#010118" label="[01:01:18]">&lt;OriansJ`&gt;</a></span><span class="message">so bad they had to add &quot;The byte extension&quot;</span></div><div class="line" id="010145"><span class="nick" style="color:#389600"><a href="#010145" label="[01:01:45]">&lt;OriansJ`&gt;</a></span><span class="message">as Alpha originally only loaded 64bit values and you had to do masking and bit shifting to get anything smaller</span></div><div class="line" id="010157"><span class="nick" style="color:#389600"><a href="#010157" label="[01:01:57]">&lt;OriansJ`&gt;</a></span><span class="message">if I remember correctly</span></div><div class="line" id="010258"><span class="nick" style="color:#8dd3c7"><a href="#010258" label="[01:02:58]">&lt;xentrac&gt;</a></span><span class="message">sounds legit</span></div><div class="line" id="010300"><span class="nick" style="color:#389600"><a href="#010300" label="[01:03:00]">&lt;OriansJ`&gt;</a></span><span class="message">*correction only 32 and 64bit values*</span></div><div class="line" id="010332"><span class="nick" style="color:#8dd3c7"><a href="#010332" label="[01:03:32]">&lt;xentrac&gt;</a></span><span class="message">how did their multiply work?</span></div><div class="line" id="010447"><span class="nick" style="color:#389600"><a href="#010447" label="[01:04:47]">&lt;OriansJ`&gt;</a></span><span class="message">They had 3op multiply and 3op multiply high</span></div><div class="line" id="010523"><span class="nick" style="color:#8dd3c7"><a href="#010523" label="[01:05:23]">&lt;xentrac&gt;</a></span><span class="message">three-operand?</span></div><div class="line" id="010554"><span class="nick" style="color:#389600"><a href="#010554" label="[01:05:54]">&lt;OriansJ`&gt;</a></span><span class="message">Rc := Ra op Rb; eg R0 = R0 x R1</span></div><div class="line" id="010606"><span class="nick" style="color:#8dd3c7"><a href="#010606" label="[01:06:06]">&lt;xentrac&gt;</a></span><span class="message">three-operation?</span></div><div class="line" id="010609"><span class="nick" style="color:#389600"><a href="#010609" label="[01:06:09]">&lt;OriansJ`&gt;</a></span><span class="message">or R11 = R2 - R4</span></div><div class="line" id="010611"><span class="nick" style="color:#389600"><a href="#010611" label="[01:06:11]">&lt;OriansJ`&gt;</a></span><span class="message">yes</span></div><div class="line" id="010623"><span class="nick" style="color:#389600"><a href="#010623" label="[01:06:23]">&lt;OriansJ`&gt;</a></span><span class="message">err operands</span></div><div class="line" id="010642"><span class="nick" style="color:#389600"><a href="#010642" label="[01:06:42]">&lt;OriansJ`&gt;</a></span><span class="message">So 3 different registers were explicitly specified</span></div><div class="line" id="010654"><span class="nick" style="color:#389600"><a href="#010654" label="[01:06:54]">&lt;OriansJ`&gt;</a></span><span class="message">2 source and 1 destination</span></div><div class="line" id="010708"><span class="nick" style="color:#8dd3c7"><a href="#010708" label="[01:07:08]">&lt;xentrac&gt;</a></span><span class="message">makes sense</span></div><div class="line" id="010717"><span class="nick" style="color:#389600"><a href="#010717" label="[01:07:17]">&lt;OriansJ`&gt;</a></span><span class="message">so mul would just give you the bottom half and mulh would give you the top half</span></div><div class="line" id="010735"><span class="nick" style="color:#8dd3c7"><a href="#010735" label="[01:07:35]">&lt;xentrac&gt;</a></span><span class="message">sounds convenient but inefficient</span></div><div class="line" id="010738"><span class="nick" style="color:#389600"><a href="#010738" label="[01:07:38]">&lt;OriansJ`&gt;</a></span><span class="message">with a single clock delay because multiplication was pipelined</span></div><div class="line" id="010751"><span class="nick" style="color:#8dd3c7"><a href="#010751" label="[01:07:51]">&lt;xentrac&gt;</a></span><span class="message">I bet you hate the x18's multiply :)</span></div><div class="line" id="010802"><span class="nick" style="color:#389600"><a href="#010802" label="[01:08:02]">&lt;OriansJ`&gt;</a></span><span class="message">So 3 clocks for MUL but 4 clocks for bot MUL and MULH</span></div><div class="line" id="010843"><span class="nick" style="color:#389600"><a href="#010843" label="[01:08:43]">&lt;OriansJ`&gt;</a></span><span class="message">I do dislike how x86 does multiplication and division; which AMD64 never fixed</span></div><div class="line" id="011956"><span class="nick" style="color:#389600"><a href="#011956" label="[01:19:56]">&lt;OriansJ`&gt;</a></span><span class="message">if AMD just reallocated a single 1byte opcdoe from x86 for 3op instructions; they could have had a 4byte encoding with support for 2^12 instructions</span></div><div class="line" id="012025"><span class="nick" style="color:#8dd3c7"><a href="#012025" label="[01:20:25]">&lt;xentrac&gt;</a></span><span class="message">until FMA there weren't any 3-operand instructions at all, were there?</span></div><div class="line" id="012445"><span class="nick" style="color:#389600"><a href="#012445" label="[01:24:45]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: hope</span></div><div class="line" id="012453"><span class="nick" style="color:#389600"><a href="#012453" label="[01:24:53]">&lt;OriansJ`&gt;</a></span><span class="message">^nope^</span></div><div class="line" id="012543"><span class="nick" style="color:#389600"><a href="#012543" label="[01:25:43]">&lt;OriansJ`&gt;</a></span><span class="message">and if they allocated the first 4bits as specifiers, then the next 8bits of the XOP could be used for 256 instructions.</span></div><div class="line" id="012633"><span class="nick" style="color:#389600"><a href="#012633" label="[01:26:33]">&lt;OriansJ`&gt;</a></span><span class="message">Say 0000 for integer, 0001 for floating point and 0010 for SIMD integer and 0011 for SIMD floating point</span></div><div class="line" id="013038"><span class="nick" style="color:#389600"><a href="#013038" label="[01:30:38]">&lt;OriansJ`&gt;</a></span><span class="message">which would have actually ended up making AMD64 more dense then x86</span></div><div class="line" id="013105"><span class="nick" style="color:#8dd3c7"><a href="#013105" label="[01:31:05]">&lt;xentrac&gt;</a></span><span class="message">its bloated immediates count heavily against it</span></div><div class="line" id="013112"><span class="nick" style="color:#8dd3c7"><a href="#013112" label="[01:31:12]">&lt;xentrac&gt;</a></span><span class="message">if you're going for density</span></div><div class="line" id="013127"><span class="nick" style="color:#389600"><a href="#013127" label="[01:31:27]">&lt;OriansJ`&gt;</a></span><span class="message">but they probably tried to minimize the differences to enable minimal engineering efforts on the software side</span></div><div class="line" id="013814"><span class="nick" style="color:#389600"><a href="#013814" label="[01:38:14]">&lt;OriansJ`&gt;</a></span><span class="message">also they could have enables 8, 16 and 32bit immediates for all instructions that supported immediates</span></div><div class="line" id="014016"><span class="nick" style="color:#389600"><a href="#014016" label="[01:40:16]">&lt;OriansJ`&gt;</a></span><span class="message">Toss in flexiable register push/pop and now you could designate R15 for your argument stack pointer and RSP simply becomes argument stack only; throw a poison page inbetween and stack overflows become impossible</span></div><div class="line" id="014241"><span class="nick" style="color:#389600"><a href="#014241" label="[01:42:41]">&lt;OriansJ`&gt;</a></span><span class="message">^Return stack for RSP^</span></div><div class="line" id="014451"><span class="nick" style="color:#8dd3c7"><a href="#014451" label="[01:44:51]">&lt;xentrac&gt;</a></span><span class="message">yeah, they weren't very strongly influenced by Forth chips, though, I think</span></div><div class="line" id="014546"><span class="nick" style="color:#389600"><a href="#014546" label="[01:45:46]">&lt;OriansJ`&gt;</a></span><span class="message">I think it was AMD's lack of programmers which ultimately handicapped AMD64</span></div><div class="line" id="014707"><span class="nick" style="color:#8dd3c7"><a href="#014707" label="[01:47:07]">&lt;xentrac&gt;</a></span><span class="message">really? I don't think AMD's lack of programmers is the reason my cellphone is aarch64</span></div><div class="line" id="014806"><span class="nick" style="color:#389600"><a href="#014806" label="[01:48:06]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: well that has more to do with who has AMD64 licenses</span></div><div class="line" id="014853"><span class="nick" style="color:#8dd3c7"><a href="#014853" label="[01:48:53]">&lt;xentrac&gt;</a></span><span class="message">that's certainly a factor, yeah</span></div><div class="line" id="014917"><span class="nick" style="color:#8dd3c7"><a href="#014917" label="[01:49:17]">&lt;xentrac&gt;</a></span><span class="message">but I think power consumption probably mattered more</span></div><div class="line" id="014933"><span class="nick" style="color:#8dd3c7"><a href="#014933" label="[01:49:33]">&lt;xentrac&gt;</a></span><span class="message">(not entirely disconnected...)</span></div><div class="line" id="014954"><span class="nick" style="color:#389600"><a href="#014954" label="[01:49:54]">&lt;OriansJ`&gt;</a></span><span class="message">as PowerPC has shown with P.A. Semi's PA6T</span></div><div class="line" id="015313"><span class="nick" style="color:#389600"><a href="#015313" label="[01:53:13]">&lt;OriansJ`&gt;</a></span><span class="message">once we got past 130nm Architecture stopped being the deciding factor for Performance/Watt</span></div><div class="line" id="015406"><span class="nick" style="color:#8dd3c7"><a href="#015406" label="[01:54:06]">&lt;xentrac&gt;</a></span><span class="message">not sure about that; there's a big, power-hungry micro-op decoding area on amd64 (and modern i386) chips that's just absent on ARMs</span></div><div class="line" id="015413"><span class="nick" style="color:#8dd3c7"><a href="#015413" label="[01:54:13]">&lt;xentrac&gt;</a></span><span class="message">aarch64 even dropped Thumb!</span></div><div class="line" id="015557"><span class="nick" style="color:#389600"><a href="#015557" label="[01:55:57]">&lt;OriansJ`&gt;</a></span><span class="message">and a Pentium Pro done in 40nm would consume less power than any commercially available Aarch64 chip but its performance would also be worse</span></div><div class="line" id="015614"><span class="nick" style="color:#8dd3c7"><a href="#015614" label="[01:56:14]">&lt;xentrac&gt;</a></span><span class="message">Intel tried for a while to promote Android on amd64, but I think they finally gve up on that</span></div><div class="line" id="015614"><span class="nick" style="color:#389600"><a href="#015614" label="[01:56:14]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: margins were too low</span></div><div class="line" id="015711"><span class="nick" style="color:#8dd3c7"><a href="#015711" label="[01:57:11]">&lt;xentrac&gt;</a></span><span class="message">I mean you could argue that Intel's designers aren't the sharpest hammers in the bag; certainly that was the opinion of their Itanic co-designers at HP</span></div><div class="line" id="015712"><span class="nick" style="color:#389600"><a href="#015712" label="[01:57:12]">&lt;OriansJ`&gt;</a></span><span class="message">Intel is too used to big fat margins on chips sold; phones are heading towards razor thin margins</span></div><div class="line" id="015803"><span class="nick" style="color:#8dd3c7"><a href="#015803" label="[01:58:03]">&lt;xentrac&gt;</a></span><span class="message">Intel has been competing in some low-margin markets since the 80s, though not CPUs; you'd think they'd have some of that in their DNA still</span></div><div class="line" id="015810"><span class="nick" style="color:#8dd3c7"><a href="#015810" label="[01:58:10]">&lt;xentrac&gt;</a></span><span class="message">but mabye not</span></div><div class="line" id="015940"><span class="nick" style="color:#389600"><a href="#015940" label="[01:59:40]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: if it was, they would have followed AMD and ditched their FAB to the highest bidder back when it would have made them bank</span></div><div class="line" id="020017"><span class="nick" style="color:#389600"><a href="#020017" label="[02:00:17]">&lt;OriansJ`&gt;</a></span><span class="message">But the margin on paper of running off their own fab looked too good for them to give up</span></div><div class="line" id="020225"><span class="nick" style="color:#8dd3c7"><a href="#020225" label="[02:02:25]">&lt;xentrac&gt;</a></span><span class="message">you're suggesting they should have gone fabless?  I think it's far from settled that vertical integration is an across-the-board lose</span></div><div class="line" id="020348"><span class="nick" style="color:#8dd3c7"><a href="#020348" label="[02:03:48]">&lt;xentrac&gt;</a></span><span class="message">certainly there are possible future scenarios where AMD can no longer compete with Intel precisely because Intel is vertically integrated</span></div><div class="line" id="020402"><span class="nick" style="color:#389600"><a href="#020402" label="[02:04:02]">&lt;OriansJ`&gt;</a></span><span class="message">yes as it would have forced an industry wide arms race on process and design; allowing much more competition to explode and benefit us all</span></div><div class="line" id="020422"><span class="nick" style="color:#8dd3c7"><a href="#020422" label="[02:04:22]">&lt;xentrac&gt;</a></span><span class="message">do you mean, like, decades ago?</span></div><div class="line" id="020452"><span class="nick" style="color:#389600"><a href="#020452" label="[02:04:52]">&lt;OriansJ`&gt;</a></span><span class="message">yes</span></div><div class="line" id="020527"><span class="nick" style="color:#389600"><a href="#020527" label="[02:05:27]">&lt;OriansJ`&gt;</a></span><span class="message">although that would probably result in another design becoming super dominate and the cycle end up repeating</span></div><div class="line" id="020548"><span class="nick" style="color:#8dd3c7"><a href="#020548" label="[02:05:48]">&lt;xentrac&gt;</a></span><span class="message">right now Intel is still in the running to make it to 5nm</span></div><div class="line" id="020605"><span class="nick" style="color:#8dd3c7"><a href="#020605" label="[02:06:05]">&lt;xentrac&gt;</a></span><span class="message">though pretty far behind ;)</span></div><div class="line" id="020636"><span class="nick" style="color:#389600"><a href="#020636" label="[02:06:36]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: 5nm is now just marketing for density not transistor size</span></div><div class="line" id="020657"><span class="nick" style="color:#8dd3c7"><a href="#020657" label="[02:06:57]">&lt;xentrac&gt;</a></span><span class="message">it wouldn't be surprising if Intel made it to 3nm and TSMC didn't</span></div><div class="line" id="020702"><span class="nick" style="color:#389600"><a href="#020702" label="[02:07:02]">&lt;OriansJ`&gt;</a></span><span class="message">it has been that way since 22nm</span></div><div class="line" id="020721"><span class="nick" style="color:#8dd3c7"><a href="#020721" label="[02:07:21]">&lt;xentrac&gt;</a></span><span class="message">what do you mean?</span></div><div class="line" id="020756"><span class="nick" style="color:#389600"><a href="#020756" label="[02:07:56]">&lt;OriansJ`&gt;</a></span><span class="message">as Intel's 10nm transistors are the same size as their 22nm transistors</span></div><div class="line" id="020823"><span class="nick" style="color:#389600"><a href="#020823" label="[02:08:23]">&lt;OriansJ`&gt;</a></span><span class="message">but they are beter at packing them in</span></div><div class="line" id="020838"><span class="nick" style="color:#8dd3c7"><a href="#020838" label="[02:08:38]">&lt;xentrac&gt;</a></span><span class="message">higher resolution will do that</span></div><div class="line" id="022159"><span class="nick" style="color:#389600"><a href="#022159" label="[02:21:59]">&lt;OriansJ`&gt;</a></span><span class="message">or simply more gate layers</span></div><div class="line" id="023359"><span class="nick" style="color:#389600"><a href="#023359" label="[02:33:59]">&lt;OriansJ`&gt;</a></span><span class="message">or rotate the transistors to shingle them</span></div><div class="line" id="030105"><span class="nick" style="color:#389600"><a href="#030105" label="[03:01:05]">&lt;OriansJ`&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/10_nm_process">https://en.wikipedia.org/wiki/10_nm_process</a>  for reference</span></div><div class="line" id="033744"><span class="nick">***</span><span class="message notice">terpri__ is now known as terpri</span></div><div class="line" id="040345"><span class="nick" style="color:#80b1d3"><a href="#040345" label="[04:03:45]">*</a></span><span class="message">xentrac rotates his transistors</span></div><div class="line" id="064124"><span class="nick">***</span><span class="message notice">terpri__ is now known as terpri</span></div><div class="line" id="084657"><span class="nick">***</span><span class="message notice">nikita_ is now known as nikita`</span></div><div class="line" id="100025"><span class="nick">***</span><span class="message notice">ChanServ sets mode: +o rekado_</span></div><div class="line" id="100025"><span class="nick">***</span><span class="message notice">rekado_ is now known as rekado</span></div><div class="line" id="130907"><span class="nick" style="color:#389600"><a href="#130907" label="[13:09:07]">&lt;OriansJ`&gt;</a></span><span class="message">xentrac: well that is a rather hard engineering problem</span></div><div class="line" id="183357"><span class="nick">***</span><span class="message notice">terpri__ is now known as terpri</span></div><br /></div></body></html>