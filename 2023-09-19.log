<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2023-09-19.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000101"><span class="nick" style="color:#389600"><a href="#000101" label="[00:01:01]">&lt;muurkha&gt;</a></span><span class="message">but if I'm not mistaken it wasn't until the ARM7 (ARMv3) that they had halfword instructions: <a rel="nofollow" href="https://3dodev.com/_media/documentation/hardware/arm60_datasheet_-_gec_plessey_semiconductors.pdf">https://3dodev.com/_media/documentation/hardware/arm60_datasheet_-_gec_plessey_semiconductors.pdf</a> </span></div><div class="line" id="000139"><span class="nick" style="color:#389600"><a href="#000139" label="[00:01:39]">&lt;muurkha&gt;</a></span><span class="message">the ARM6 didn't</span></div><div class="line" id="000156"><span class="nick" style="color:#8dd3c7"><a href="#000156" label="[00:01:56]">&lt;oriansj&gt;</a></span><span class="message">muurkha: you are probably right, 16bit values tend to be more legacy than absolutely needed to anything interesting.</span></div><div class="line" id="000206"><span class="nick" style="color:#389600"><a href="#000206" label="[00:02:06]">&lt;muurkha&gt;</a></span><span class="message">it didn't have signed byte loads either</span></div><div class="line" id="000230"><span class="nick" style="color:#8dd3c7"><a href="#000230" label="[00:02:30]">&lt;oriansj&gt;</a></span><span class="message">well if you treat only chars as bytes, then you can get away with that</span></div><div class="line" id="000301"><span class="nick" style="color:#389600"><a href="#000301" label="[00:03:01]">&lt;muurkha&gt;</a></span><span class="message">I don't understand</span></div><div class="line" id="000305"><span class="nick" style="color:#389600"><a href="#000305" label="[00:03:05]">&lt;muurkha&gt;</a></span><span class="message">what do you mean by &quot;chars&quot;?</span></div><div class="line" id="000323"><span class="nick" style="color:#8dd3c7"><a href="#000323" label="[00:03:23]">&lt;oriansj&gt;</a></span><span class="message">char in the C sense</span></div><div class="line" id="000533"><span class="nick" style="color:#389600"><a href="#000533" label="[00:05:33]">&lt;muurkha&gt;</a></span><span class="message">it would be pretty inconvenient to implement a compliant C on the ARM where C char wasn't a byte</span></div><div class="line" id="000605"><span class="nick" style="color:#389600"><a href="#000605" label="[00:06:05]">&lt;muurkha&gt;</a></span><span class="message">because C defines char to be the basic unit of sizeof and some other things</span></div><div class="line" id="000724"><span class="nick" style="color:#389600"><a href="#000724" label="[00:07:24]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/Transistor_count">https://en.wikipedia.org/wiki/Transistor_count</a>  says the ARM700 shipped in 01994, so until that point no ARM had 16-bit instructions or signed byte loads</span></div><div class="line" id="000921"><span class="nick" style="color:#389600"><a href="#000921" label="[00:09:21]">&lt;muurkha&gt;</a></span><span class="message">so the Newton, the Acorn RiscPCs, the original StrongARM, were all without 16-bit loads and stores, and without signed byte loads</span></div><div class="line" id="000957"><span class="nick" style="color:#8dd3c7"><a href="#000957" label="[00:09:57]">&lt;oriansj&gt;</a></span><span class="message">well zero extension can be achieved with AND 0x0000FFFF and sign extension can be achieved with signed bit shifts</span></div><div class="line" id="001013"><span class="nick" style="color:#389600"><a href="#001013" label="[00:10:13]">&lt;muurkha&gt;</a></span><span class="message">multiply, by contrast, was added in the very first ARM chip to ship to customers, ARM2, because you can do multiply a *lot* faster in hardware than in software</span></div><div class="line" id="001108"><span class="nick" style="color:#8dd3c7"><a href="#001108" label="[00:11:08]">&lt;oriansj&gt;</a></span><span class="message">well yes a multiply loop takes a good bit more than 3-6 clock cycles</span></div><div class="line" id="001159"><span class="nick" style="color:#389600"><a href="#001159" label="[00:11:59]">&lt;muurkha&gt;</a></span><span class="message">I don't think they ever shipped a divide instruction, did they?</span></div><div class="line" id="001209"><span class="nick" style="color:#389600"><a href="#001209" label="[00:12:09]">&lt;muurkha&gt;</a></span><span class="message">for integers</span></div><div class="line" id="001211"><span class="nick" style="color:#8dd3c7"><a href="#001211" label="[00:12:11]">&lt;oriansj&gt;</a></span><span class="message">not until armv8</span></div><div class="line" id="001224"><span class="nick" style="color:#389600"><a href="#001224" label="[00:12:24]">&lt;muurkha&gt;</a></span><span class="message">so in no 32-bit ARM ever?</span></div><div class="line" id="001242"><span class="nick" style="color:#8dd3c7"><a href="#001242" label="[00:12:42]">&lt;oriansj&gt;</a></span><span class="message">correct, only 64bit ARM ever got divide</span></div><div class="line" id="001401"><span class="nick" style="color:#8dd3c7"><a href="#001401" label="[00:14:01]">&lt;oriansj&gt;</a></span><span class="message">it is why you see in M2libc/armv7l/libc-core.M1 :divide, :divides, :modulus and :moduluss</span></div><div class="line" id="001402"><span class="nick" style="color:#389600"><a href="#001402" label="[00:14:02]">&lt;muurkha&gt;</a></span><span class="message">in a lot of cases if you're doing 16-bit operations you don't need to AND 0xffff, you can just compute with 16 extra garbage bits</span></div><div class="line" id="001513"><span class="nick" style="color:#389600"><a href="#001513" label="[00:15:13]">&lt;muurkha&gt;</a></span><span class="message">I was noodling on minimalistic bootstrapping instruction sets last night</span></div><div class="line" id="001526"><span class="nick" style="color:#8dd3c7"><a href="#001526" label="[00:15:26]">&lt;oriansj&gt;</a></span><span class="message">true that is a valid optimization for those cases (especially if your compiler can predict that those bits are lost or cleared before they are looked at)</span></div><div class="line" id="001606"><span class="nick" style="color:#8dd3c7"><a href="#001606" label="[00:16:06]">&lt;oriansj&gt;</a></span><span class="message">(as they may impact if the register is zero program states)</span></div><div class="line" id="001618"><span class="nick" style="color:#389600"><a href="#001618" label="[00:16:18]">&lt;muurkha&gt;</a></span><span class="message">I came up with a 3-address code with 16 instructions, 32 32-bit general-purpose registers, and one addressing mode, with pc, sp, and lr in GPRs</span></div><div class="line" id="001719"><span class="nick" style="color:#389600"><a href="#001719" label="[00:17:19]">&lt;muurkha&gt;</a></span><span class="message">li16, addi, srli, load32, store32, load8, store8, bne, bgeu, jalr, add, sub, bic, mul, mulhu, and jal</span></div><div class="line" id="001725"><span class="nick" style="color:#389600"><a href="#001725" label="[00:17:25]">&lt;muurkha&gt;</a></span><span class="message">32-bit instructions</span></div><div class="line" id="001755"><span class="nick" style="color:#389600"><a href="#001755" label="[00:17:55]">&lt;muurkha&gt;</a></span><span class="message">thinking it might be worthwhile to split li16 into movt and movw</span></div><div class="line" id="001839"><span class="nick" style="color:#389600"><a href="#001839" label="[00:18:39]">&lt;muurkha&gt;</a></span><span class="message">it feels like something you can implement in C in an afternoon, though I haven't tried yet</span></div><div class="line" id="001900"><span class="nick" style="color:#389600"><a href="#001900" label="[00:19:00]">&lt;muurkha&gt;</a></span><span class="message">and get sort of reasonable performance</span></div><div class="line" id="002007"><span class="nick" style="color:#389600"><a href="#002007" label="[00:20:07]">&lt;muurkha&gt;</a></span><span class="message">if you want to compile it to native code you probably want an ifence instruction, and for most architectures the compiler will have to compile pc-destination instructions separately</span></div><div class="line" id="002203"><span class="nick" style="color:#389600"><a href="#002203" label="[00:22:03]">&lt;muurkha&gt;</a></span><span class="message">occurs to me that it might be worthwhile to replace srli with rori</span></div><div class="line" id="002207"><span class="nick" style="color:#389600"><a href="#002207" label="[00:22:07]">&lt;muurkha&gt;</a></span><span class="message">what do you think?</span></div><div class="line" id="002915"><span class="nick" style="color:#8dd3c7"><a href="#002915" label="[00:29:15]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I'd truncate to 16 registers (as it maps better to hex)</span></div><div class="line" id="003042"><span class="nick" style="color:#389600"><a href="#003042" label="[00:30:42]">&lt;muurkha&gt;</a></span><span class="message">using an entire byte of the instruction encoding to specify each register operand</span></div><div class="line" id="003115"><span class="nick" style="color:#8dd3c7"><a href="#003115" label="[00:31:15]">&lt;oriansj&gt;</a></span><span class="message">(so 256 registers like MMIX ?)</span></div><div class="line" id="003403"><span class="nick" style="color:#8dd3c7"><a href="#003403" label="[00:34:03]">&lt;oriansj&gt;</a></span><span class="message">but yeah that instruction set has everything one would need in bootstrapping but a syscall instruction. and Memory Mapped I/O would definitely add complexity relative to a simple lookup table for the syscalls</span></div><div class="line" id="003839"><span class="nick" style="color:#389600"><a href="#003839" label="[00:38:39]">&lt;muurkha&gt;</a></span><span class="message">just 32 registers; I don't want to make context switches unreasonably slow</span></div><div class="line" id="003956"><span class="nick" style="color:#8dd3c7"><a href="#003956" label="[00:39:56]">&lt;oriansj&gt;</a></span><span class="message">I only need 6 registers (if PC, stack and LR are in the general register set) [or just 3 if not counting those]</span></div><div class="line" id="004019"><span class="nick" style="color:#389600"><a href="#004019" label="[00:40:19]">&lt;muurkha&gt;</a></span><span class="message">yeah, and 16 are enough for most things, but occasionally a bit cramped</span></div><div class="line" id="004031"><span class="nick" style="color:#389600"><a href="#004031" label="[00:40:31]">&lt;muurkha&gt;</a></span><span class="message">yeah, for system calls it needs an ecall instruction, a kernel-mode bit, a way for kernel-mode code to set up trap handlers to invoke the desired kernel-mode code, a watchdog timer that traps to kernel mode when the timer expires, and some kind of memory protection</span></div><div class="line" id="004108"><span class="nick" style="color:#8dd3c7"><a href="#004108" label="[00:41:08]">&lt;oriansj&gt;</a></span><span class="message">muurkha: in a physical machine yes but in a bytecode VM, nope</span></div><div class="line" id="004111"><span class="nick" style="color:#389600"><a href="#004111" label="[00:41:11]">&lt;muurkha&gt;</a></span><span class="message">the absolute minimum reasonable memory protection would be base+bounds registers</span></div><div class="line" id="004145"><span class="nick" style="color:#389600"><a href="#004145" label="[00:41:45]">&lt;muurkha&gt;</a></span><span class="message">sure, if the VM only has to support user code, you can eliminate all the stuff that's invisible in user mode</span></div><div class="line" id="004152"><span class="nick" style="color:#8dd3c7"><a href="#004152" label="[00:41:52]">&lt;oriansj&gt;</a></span><span class="message">indeed</span></div><div class="line" id="004324"><span class="nick" style="color:#389600"><a href="#004324" label="[00:43:24]">&lt;muurkha&gt;</a></span><span class="message">there are a couple of rationales for including the protection mechanisms though</span></div><div class="line" id="004345"><span class="nick" style="color:#389600"><a href="#004345" label="[00:43:45]">&lt;muurkha&gt;</a></span><span class="message">1. you need them if you want to run it on an FPGA or something</span></div><div class="line" id="004414"><span class="nick" style="color:#389600"><a href="#004414" label="[00:44:14]">&lt;muurkha&gt;</a></span><span class="message">2. if they're designed to be properly virtualizable (unlike i386 or ARM!) user-mode code can use them recursively to confine untrusted code of its own</span></div><div class="line" id="004559"><span class="nick" style="color:#389600"><a href="#004559" label="[00:45:59]">&lt;muurkha&gt;</a></span><span class="message">at a very modest additional cost; it makes your kernel-mode code responsible for emulating the hardware protection facilities in software when the user-mode code tries to examine or twiddle kernel-mode state</span></div><div class="line" id="004645"><span class="nick" style="color:#389600"><a href="#004645" label="[00:46:45]">&lt;muurkha&gt;</a></span><span class="message">(trap vectors, watchdog state, the kernel-mode bit, and the base+bounds registers)</span></div><div class="line" id="005756"><span class="nick" style="color:#8dd3c7"><a href="#005756" label="[00:57:56]">&lt;oriansj&gt;</a></span><span class="message">true but if the goal is a sweet-16 like architecture for making bootstrapping easier on low memory hardware; then no it wouldn't provide much value</span></div><div class="line" id="005953"><span class="nick" style="color:#389600"><a href="#005953" label="[00:59:53]">&lt;muurkha&gt;</a></span><span class="message">what do you mean by &quot;low memory&quot;?</span></div><div class="line" id="010013"><span class="nick" style="color:#8dd3c7"><a href="#010013" label="[01:00:13]">&lt;oriansj&gt;</a></span><span class="message">say 16KB of RAM</span></div><div class="line" id="010022"><span class="nick" style="color:#389600"><a href="#010022" label="[01:00:22]">&lt;muurkha&gt;</a></span><span class="message">that sounds like something where you want virtual memory, which I haven't proposed; base+bounds isn't a powerful enough memory protection mechanism for that</span></div><div class="line" id="010101"><span class="nick" style="color:#389600"><a href="#010101" label="[01:01:01]">&lt;muurkha&gt;</a></span><span class="message">although if you have an ecall instruction you could certainly add system calls for something like Forth's BLOCK and UPDATE</span></div><div class="line" id="010112"><span class="nick" style="color:#8dd3c7"><a href="#010112" label="[01:01:12]">&lt;oriansj&gt;</a></span><span class="message">I was planning on adding in-page logic to every load/store instruction so we can leverage the block loading idea you shared earlier</span></div><div class="line" id="010235"><span class="nick" style="color:#389600"><a href="#010235" label="[01:02:35]">&lt;muurkha&gt;</a></span><span class="message">well, the idea of the block loading idea is that you can avoid adding in-page logic to every load/store instruction</span></div><div class="line" id="010240"><span class="nick" style="color:#8dd3c7"><a href="#010240" label="[01:02:40]">&lt;oriansj&gt;</a></span><span class="message">it'll be slow but then we wouldn't need a hardware MMU and it would be transparent to the running code</span></div><div class="line" id="010307"><span class="nick" style="color:#389600"><a href="#010307" label="[01:03:07]">&lt;muurkha&gt;</a></span><span class="message">because they're &quot;bank-switching&quot; existing blocks of a larger virtual memory into &quot;windows&quot; or &quot;buffers&quot; in the small physical memory</span></div><div class="line" id="010324"><span class="nick" style="color:#389600"><a href="#010324" label="[01:03:24]">&lt;muurkha&gt;</a></span><span class="message">well.  &quot;physical&quot;, heh.</span></div><div class="line" id="010418"><span class="nick" style="color:#389600"><a href="#010418" label="[01:04:18]">&lt;muurkha&gt;</a></span><span class="message">I think that if you're doing something on a 16KiB machine you probably want to use a compact variable-length bytecode instead of a fixed-size 32-bit instruction set</span></div><div class="line" id="010442"><span class="nick" style="color:#389600"><a href="#010442" label="[01:04:42]">&lt;muurkha&gt;</a></span><span class="message">maybe not for your inner loops but for most of your logic</span></div><div class="line" id="010539"><span class="nick" style="color:#389600"><a href="#010539" label="[01:05:39]">&lt;muurkha&gt;</a></span><span class="message">I was thinking of this for machines that are 1-5 orders of magnitude bigger than that</span></div><div class="line" id="010642"><span class="nick" style="color:#8dd3c7"><a href="#010642" label="[01:06:42]">&lt;oriansj&gt;</a></span><span class="message">even with 4-6byte instructions one  would only have 16,386bytes of coded needed to get to M2-Planet</span></div><div class="line" id="010717"><span class="nick" style="color:#8dd3c7"><a href="#010717" label="[01:07:17]">&lt;oriansj&gt;</a></span><span class="message">but yes the Pineapple RISC-V EEPROM machine does have 512KB</span></div><div class="line" id="010751"><span class="nick" style="color:#8dd3c7"><a href="#010751" label="[01:07:51]">&lt;oriansj&gt;</a></span><span class="message">^coded^machine instructions^</span></div><div class="line" id="010805"><span class="nick" style="color:#389600"><a href="#010805" label="[01:08:05]">&lt;muurkha&gt;</a></span><span class="message">yeah.  more generally something like the ARM6 is about 10,000 gates</span></div><div class="line" id="010828"><span class="nick" style="color:#389600"><a href="#010828" label="[01:08:28]">&lt;muurkha&gt;</a></span><span class="message">so I think it's useful to have a way to program such small machines</span></div><div class="line" id="010852"><span class="nick" style="color:#389600"><a href="#010852" label="[01:08:52]">&lt;muurkha&gt;</a></span><span class="message">hooking up a 10,000-gate machine to 10,000 bits of SRAM should be a reasonable thing to do, but that's only 2.5 KiB</span></div><div class="line" id="011032"><span class="nick" style="color:#8dd3c7"><a href="#011032" label="[01:10:32]">&lt;oriansj&gt;</a></span><span class="message">well not if the external storage has 4KB block size</span></div><div class="line" id="011036"><span class="nick" style="color:#389600"><a href="#011036" label="[01:10:36]">&lt;muurkha&gt;</a></span><span class="message">an interesting question is what it would look like if our chosen switching technology happened to be much faster, or slower</span></div><div class="line" id="011040"><span class="nick" style="color:#2e2a4a"><a href="#011040" label="[01:10:40]">&lt;stikonas&gt;</a></span><span class="message">2.5 KiB might be enough to run hex1-&gt;hex2 step</span></div><div class="line" id="011120"><span class="nick" style="color:#8dd3c7"><a href="#011120" label="[01:11:20]">&lt;oriansj&gt;</a></span><span class="message">it is enough for M0-compact (1696 bytes)</span></div><div class="line" id="011159"><span class="nick" style="color:#389600"><a href="#011159" label="[01:11:59]">&lt;muurkha&gt;</a></span><span class="message">you can access an external storage with 4KB blocks with less RAM than that</span></div><div class="line" id="015024"><span class="nick" style="color:#8dd3c7"><a href="#015024" label="[01:50:24]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well either the top 3KB of each block is wasted or your block device has configurable block load sizes.</span></div><div class="line" id="023716"><span class="nick" style="color:#389600"><a href="#023716" label="[02:37:16]">&lt;muurkha&gt;</a></span><span class="message">you can reload the same block multiple times, ignoring different parts each time.  like subscribing to a stock ticker or Ethernet</span></div><div class="line" id="023904"><span class="nick" style="color:#6b8072"><a href="#023904" label="[02:39:04]">&lt;theruran&gt;</a></span><span class="message">the Pineapple-ONE looks really nice. might have to be geared more toward bootstrapping though</span></div><div class="line" id="044216"><span class="nick" style="color:#8dd3c7"><a href="#044216" label="[04:42:16]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well yes but that is the configurable block load sizes bit</span></div><div class="line" id="044321"><span class="nick" style="color:#8dd3c7"><a href="#044321" label="[04:43:21]">&lt;oriansj&gt;</a></span><span class="message">as you would be giving the logical block address, the target memory address, the amount to load/store and the offset inside of the block.</span></div><div class="line" id="052532"><span class="nick" style="color:#389600"><a href="#052532" label="[05:25:32]">&lt;muurkha&gt;</a></span><span class="message">oriansj: that mechanism is largely the Unix approach; it is both more complex to implement and more difficult to use than the FORTH approach</span></div><div class="line" id="052939"><span class="nick" style="color:#389600"><a href="#052939" label="[05:29:39]">&lt;muurkha&gt;</a></span><span class="message">if you had 2.5 KiB of RAM you'd probably want to use a smaller block size than the traditional 1024 bytes.  when Chuck Moore got old and started losing his vision, he switched to 256-byte blocks</span></div><div class="line" id="052947"><span class="nick" style="color:#389600"><a href="#052947" label="[05:29:47]">&lt;muurkha&gt;</a></span><span class="message">16 lines by 16 columns</span></div><div class="line" id="131446"><span class="nick" style="color:#8dd3c7"><a href="#131446" label="[13:14:46]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I was thinking more on the hardware level. in the SCSI protocol the TRANSFER LENGTH field in the READ(6) command only covers the number of blocks read (starting at the specified LBA and counting up) and the drive capacity has the field BLOCK LENGTH IN BYTES which on some drives is fixed to 4096 or 512 bytes respectively. In the 4KB case, the drive would only read whole 4KB blocks into memory and on a 2.5KB memory system, most</span></div><div class="line" id="131446"><span class="nick" style="color:#8dd3c7"><a href="#131446" label="[13:14:46]">&lt;oriansj&gt;</a></span><span class="message">of that is going to be written into null space. But yes on drives that allow the setting of that parameter, setting it to 256 or 512 bytes is definitely viable for paging in and out data in the basic read/write this block at this block of memory the contents of this Logical block address on disk.</span></div><div class="line" id="182251"><span class="nick" style="color:#389600"><a href="#182251" label="[18:22:51]">&lt;muurkha&gt;</a></span><span class="message">oriansj: oh, that makes sense.  typically at the level of SDRAM or Flash you send a series of commands to the device, and some of those commands result in it asserting words on the data bus</span></div><div class="line" id="182829"><span class="nick" style="color:#389600"><a href="#182829" label="[18:28:29]">&lt;muurkha&gt;</a></span><span class="message">in both DRAM and Flash, reads normally work by transferring a whole row of the memory matrix to an SRAM buffer, followed by muxing some of that buffer onto the data bus</span></div><div class="line" id="182933"><span class="nick" style="color:#8dd3c7"><a href="#182933" label="[18:29:33]">&lt;oriansj&gt;</a></span><span class="message">usually done by an 8051 if I remember correctly (with ARM M0 cores becoming more popular)</span></div><div class="line" id="183039"><span class="nick" style="color:#389600"><a href="#183039" label="[18:30:39]">&lt;muurkha&gt;</a></span><span class="message">I think it is usually done by hardwired logic</span></div><div class="line" id="183505"><span class="nick" style="color:#8dd3c7"><a href="#183505" label="[18:35:05]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://www.bunniestudios.com/blog/?p=918">https://www.bunniestudios.com/blog/?p=918</a>  perhaps depends if there is an internal controller</span></div><div class="line" id="183530"><span class="nick" style="color:#8dd3c7"><a href="#183530" label="[18:35:30]">&lt;oriansj&gt;</a></span><span class="message">or external drive controller</span></div><div class="line" id="184500"><span class="nick" style="color:#8dd3c7"><a href="#184500" label="[18:45:00]">&lt;oriansj&gt;</a></span><span class="message">this one goes a little deeper: <a rel="nofollow" href="https://www.bunniestudios.com/blog/?p=898">https://www.bunniestudios.com/blog/?p=898</a> </span></div><div class="line" id="190120"><span class="nick" style="color:#8dd3c7"><a href="#190120" label="[19:01:20]">&lt;oriansj&gt;</a></span><span class="message">reading the K9GAG08B0M datasheet; it appears that they only read 4Kb pages and write 4Kb pages</span></div><div class="line" id="190837"><span class="nick" style="color:#389600"><a href="#190837" label="[19:08:37]">&lt;muurkha&gt;</a></span><span class="message">I'm not talking about SD cards, which do indeed need an internal controller; I'm talking about Flash memory chips</span></div><div class="line" id="191119"><span class="nick" style="color:#389600"><a href="#191119" label="[19:11:19]">&lt;muurkha&gt;</a></span><span class="message">yes, like the K9GAG08B0M</span></div><div class="line" id="191204"><span class="nick" style="color:#389600"><a href="#191204" label="[19:12:04]">&lt;muurkha&gt;</a></span><span class="message">I haven't actually implemented this yet</span></div><div class="line" id="191249"><span class="nick" style="color:#389600"><a href="#191249" label="[19:12:49]">&lt;muurkha&gt;</a></span><span class="message">but note that it has a timing diagram for &quot;two-plane page read operation with two-plane random data out&quot;</span></div><div class="line" id="191441"><span class="nick" style="color:#389600"><a href="#191441" label="[19:14:41]">&lt;muurkha&gt;</a></span><span class="message">to me this means that once you've read the page into the internal SRAM buffer you can read random words from the SRAM buffer, but I'm not 100% confident in my understanding</span></div><div class="line" id="191528"><span class="nick" style="color:#389600"><a href="#191528" label="[19:15:28]">&lt;muurkha&gt;</a></span><span class="message">I'm pretty sure you can also read the entire page one byte after another from the SRAM buffer without any intervening commands</span></div><br /></div></body></html>