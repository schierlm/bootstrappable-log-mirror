<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2023-05-15.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000341"><span class="nick" style="color:#389600"><a href="#000341" label="[00:03:41]">&lt;emilytrau[m]&gt;</a></span><span class="message">&lt;ericson2314&gt; &quot;what branch/repo should I target...&quot; &lt;- nixpkgs targets the mes-0.24 branch üëç</span></div><div class="line" id="000430"><span class="nick" style="color:#8dd3c7"><a href="#000430" label="[00:04:30]">&lt;ericson2314&gt;</a></span><span class="message">emilytrau: saw that. Yeah I guess my question was more does stuff from non-mes branches still get incorporated</span></div><div class="line" id="000435"><span class="nick" style="color:#8dd3c7"><a href="#000435" label="[00:04:35]">&lt;ericson2314&gt;</a></span><span class="message">or is that pretty much inactive</span></div><div class="line" id="000441"><span class="nick" style="color:#8dd3c7"><a href="#000441" label="[00:04:41]">&lt;ericson2314&gt;</a></span><span class="message">since that this feature isn't about bootstrapping/mes per-se</span></div><div class="line" id="000834"><span class="nick" style="color:#8dd3c7"><a href="#000834" label="[00:08:34]">&lt;ericson2314&gt;</a></span><span class="message">another thing is that tcc seem, like gcc and clang, confused on whether -B should point to something with a lib/ subdir</span></div><div class="line" id="000938"><span class="nick" style="color:#2e2a4a"><a href="#000938" label="[00:09:38]">&lt;janus&gt;</a></span><span class="message">Not sure if this is widely known , but I just saw a comment by Lennart Augustsson explaining how GHC was bootstrapped: <a rel="nofollow" href="https://www.reddit.com/r/haskell/comments/o0t96c/elm_language_and_haskell/h1y4wev/">https://www.reddit.com/r/haskell/comments/o0t96c/elm_language_and_haskell/h1y4wev/</a> </span></div><div class="line" id="001002"><span class="nick" style="color:#2e2a4a"><a href="#001002" label="[00:10:02]">&lt;janus&gt;</a></span><span class="message">I like how he even explains how LML itself was bootstrapped</span></div><div class="line" id="001132"><span class="nick" style="color:#8dd3c7"><a href="#001132" label="[00:11:32]">&lt;ericson2314&gt;</a></span><span class="message">oh I guess -B is only supposed to have lib subdir for PE</span></div><div class="line" id="001137"><span class="nick" style="color:#8dd3c7"><a href="#001137" label="[00:11:37]">&lt;ericson2314&gt;</a></span><span class="message">with TCC</span></div><div class="line" id="001138"><span class="nick" style="color:#8dd3c7"><a href="#001138" label="[00:11:38]">&lt;ericson2314&gt;</a></span><span class="message">huh OK</span></div><div class="line" id="001146"><span class="nick" style="color:#2e2a4a"><a href="#001146" label="[00:11:46]">&lt;janus&gt;</a></span><span class="message">It's interesting to me because everyone who is trying bootstrapping nowadays seems to be trying real hard to avoid LML</span></div><div class="line" id="002137"><span class="nick" style="color:#6b8072"><a href="#002137" label="[00:21:37]">&lt;stikonas&gt;</a></span><span class="message">janneke: thanks again,  I think lists do work</span></div><div class="line" id="002152"><span class="nick" style="color:#6b8072"><a href="#002152" label="[00:21:52]">&lt;stikonas&gt;</a></span><span class="message">I just tried it for a few minutes and managed it to print the first bit correctly</span></div><div class="line" id="002159"><span class="nick" style="color:#6b8072"><a href="#002159" label="[00:21:59]">&lt;stikonas&gt;</a></span><span class="message">you probably saved me a fair amount of time</span></div><div class="line" id="002501"><span class="nick" style="color:#80b1d3"><a href="#002501" label="[00:25:01]">&lt;stikonas[m]&gt;</a></span><span class="message">janus: LML path seems to be lost...</span></div><div class="line" id="002515"><span class="nick" style="color:#80b1d3"><a href="#002515" label="[00:25:15]">&lt;stikonas[m]&gt;</a></span><span class="message">We would have to bootstrap it first</span></div><div class="line" id="002545"><span class="nick" style="color:#80b1d3"><a href="#002545" label="[00:25:45]">&lt;stikonas[m]&gt;</a></span><span class="message">Somebody already looked at it, maybe rekado...</span></div><div class="line" id="002648"><span class="nick" style="color:#2e2a4a"><a href="#002648" label="[00:26:48]">&lt;janus&gt;</a></span><span class="message">Bootstrapping to me always sounds like you're making a compiler. But strictly speaking, you'd only need to interpret HBC, right?</span></div><div class="line" id="002717"><span class="nick" style="color:#2e2a4a"><a href="#002717" label="[00:27:17]">&lt;janus&gt;</a></span><span class="message">I am not saying it is the most viable option, I just thought it was interesting that we have a claim that this is what was *actually* done</span></div><div class="line" id="002814"><span class="nick" style="color:#2e2a4a"><a href="#002814" label="[00:28:14]">&lt;janus&gt;</a></span><span class="message">It is good news for me working on the ghc-0.96 sources, because I had gotten the impression that the HBC specific code was a bit more extensive</span></div><div class="line" id="002841"><span class="nick" style="color:#2e2a4a"><a href="#002841" label="[00:28:41]">&lt;janus&gt;</a></span><span class="message">So I have been using that as a reference, which is good, because that is the code that was actually working, according to Augustsson</span></div><div class="line" id="002908"><span class="nick" style="color:#2e2a4a"><a href="#002908" label="[00:29:08]">&lt;janus&gt;</a></span><span class="message">So even though we don't have an LML interpreter, it still is a valuable tidbit for anybody looking at the ghc-0.96 sources</span></div><div class="line" id="004133"><span class="nick" style="color:#80b1d3"><a href="#004133" label="[00:41:33]">&lt;stikonas[m]&gt;</a></span><span class="message">Yeah, interpreters are fine too</span></div><div class="line" id="004216"><span class="nick" style="color:#80b1d3"><a href="#004216" label="[00:42:16]">&lt;stikonas[m]&gt;</a></span><span class="message">E.g. mes is interpreter too that is useful in bootstrapping tcc</span></div><div class="line" id="004407"><span class="nick" style="color:#8dd3c7"><a href="#004407" label="[00:44:07]">&lt;ericson2314&gt;</a></span><span class="message">I would try to write a Core comipiler</span></div><div class="line" id="004410"><span class="nick" style="color:#8dd3c7"><a href="#004410" label="[00:44:10]">&lt;ericson2314&gt;</a></span><span class="message">s/comipiler/interpreter/</span></div><div class="line" id="004416"><span class="nick" style="color:#8dd3c7"><a href="#004416" label="[00:44:16]">&lt;ericson2314&gt;</a></span><span class="message">and compile GHC to core</span></div><div class="line" id="004424"><span class="nick" style="color:#8dd3c7"><a href="#004424" label="[00:44:24]">&lt;ericson2314&gt;</a></span><span class="message">and rip out as much FFI as possible</span></div><div class="line" id="004436"><span class="nick" style="color:#8dd3c7"><a href="#004436" label="[00:44:36]">&lt;ericson2314&gt;</a></span><span class="message">* much FFI-ish, *  stuff as possible</span></div><div class="line" id="004506"><span class="nick" style="color:#8dd3c7"><a href="#004506" label="[00:45:06]">&lt;ericson2314&gt;</a></span><span class="message">it is good for GHC to abstract its own IO better anyways</span></div><div class="line" id="004513"><span class="nick" style="color:#8dd3c7"><a href="#004513" label="[00:45:13]">&lt;ericson2314&gt;</a></span><span class="message">and that is also good for this, win-win</span></div><div class="line" id="004526"><span class="nick" style="color:#8dd3c7"><a href="#004526" label="[00:45:26]">&lt;ericson2314&gt;</a></span><span class="message">emilytrau: one cannot go from m2 straight to tinycc, no?</span></div><div class="line" id="004537"><span class="nick" style="color:#8dd3c7"><a href="#004537" label="[00:45:37]">&lt;ericson2314&gt;</a></span><span class="message">mes building tcc is so slow :(</span></div><div class="line" id="005037"><span class="nick" style="color:#389600"><a href="#005037" label="[00:50:37]">&lt;emilytrau[m]&gt;</a></span><span class="message">John Ericson: slow is the way :(</span></div><div class="line" id="005103"><span class="nick" style="color:#8dd3c7"><a href="#005103" label="[00:51:03]">&lt;ericson2314&gt;</a></span><span class="message">the m2 C compiler seems...surprisingly powerful?</span></div><div class="line" id="005127"><span class="nick" style="color:#2e2a4a"><a href="#005127" label="[00:51:27]">&lt;janus&gt;</a></span><span class="message">ericson2314: So you're saying, first patch GHC master to abstract out it's own I/O? And then use that new GHC to compile the oldest possible GHC to Core? And then run that with the new interpreter?</span></div><div class="line" id="005154"><span class="nick" style="color:#8dd3c7"><a href="#005154" label="[00:51:54]">&lt;ericson2314&gt;</a></span><span class="message">I wouldn't even bother with old GHC</span></div><div class="line" id="005210"><span class="nick" style="color:#8dd3c7"><a href="#005210" label="[00:52:10]">&lt;ericson2314&gt;</a></span><span class="message">janus: it is not the past of least resistance for bootstrapping probably, but it brings a bunch of benefits</span></div><div class="line" id="005233"><span class="nick" style="color:#8dd3c7"><a href="#005233" label="[00:52:33]">&lt;ericson2314&gt;</a></span><span class="message">IMO there is an interesting distinction between &quot;history reply&quot; and non-&quot;history reply&quot; bootstrapping</span></div><div class="line" id="005237"><span class="nick" style="color:#2e2a4a"><a href="#005237" label="[00:52:37]">&lt;janus&gt;</a></span><span class="message">Right ok. It's an interesting proposal because I think many are discouraged when they hear that they have to use gcc-2.96 and such...</span></div><div class="line" id="005244"><span class="nick" style="color:#8dd3c7"><a href="#005244" label="[00:52:44]">&lt;ericson2314&gt;</a></span><span class="message">for garbage fires like C++, history reply is the only way</span></div><div class="line" id="005256"><span class="nick" style="color:#8dd3c7"><a href="#005256" label="[00:52:56]">&lt;ericson2314&gt;</a></span><span class="message">but for a &quot;nice&quot; language, it really ought to be possible to do better</span></div><div class="line" id="005307"><span class="nick" style="color:#8dd3c7"><a href="#005307" label="[00:53:07]">&lt;ericson2314&gt;</a></span><span class="message">and if one cannot do better, well then you should loose your &quot;nice language&quot; status</span></div><div class="line" id="005323"><span class="nick" style="color:#8dd3c7"><a href="#005323" label="[00:53:23]">&lt;ericson2314&gt;</a></span><span class="message">s/reply/replay/</span></div><div class="line" id="005400"><span class="nick" style="color:#2e2a4a"><a href="#005400" label="[00:54:00]">&lt;janus&gt;</a></span><span class="message">ericson2314: It also has the advantage that you get to know the current GHC codebase, which is a more marketable skill than knowing the 0.96 codebase :P</span></div><div class="line" id="005442"><span class="nick" style="color:#2e2a4a"><a href="#005442" label="[00:54:42]">&lt;janus&gt;</a></span><span class="message">So it's interesting that you say it is not the path of least resistence, because it kinda seems to me that it might be, when you consider the big picture of somebody deciding to spend X amount of days working on this</span></div><div class="line" id="005644"><span class="nick" style="color:#8dd3c7"><a href="#005644" label="[00:56:44]">&lt;ericson2314&gt;</a></span><span class="message">I would love to be wrong!</span></div><div class="line" id="005652"><span class="nick" style="color:#8dd3c7"><a href="#005652" label="[00:56:52]">&lt;ericson2314&gt;</a></span><span class="message">I have worked on GHC a bunch</span></div><div class="line" id="005705"><span class="nick" style="color:#8dd3c7"><a href="#005705" label="[00:57:05]">&lt;ericson2314&gt;</a></span><span class="message">there is some....cultural friction about what constitutes good software engineering</span></div><div class="line" id="005708"><span class="nick" style="color:#8dd3c7"><a href="#005708" label="[00:57:08]">&lt;ericson2314&gt;</a></span><span class="message">hopefully it is surmounted</span></div><div class="line" id="005723"><span class="nick" style="color:#8dd3c7"><a href="#005723" label="[00:57:23]">&lt;ericson2314&gt;</a></span><span class="message">I will be at Zurihac in a few weeks, hope to keep the discussion going then</span></div><div class="line" id="005852"><span class="nick" style="color:#2e2a4a"><a href="#005852" label="[00:58:52]">&lt;janus&gt;</a></span><span class="message">Sadly I can't come this year... But I like your proposal. Did you ever talk to Joachim Breitner about it?</span></div><div class="line" id="010034"><span class="nick" style="color:#80b1d3"><a href="#010034" label="[01:00:34]">&lt;stikonas[m]&gt;</a></span><span class="message">John Ericson: no, M2-Planet can't build tcc</span></div><div class="line" id="010048"><span class="nick" style="color:#80b1d3"><a href="#010048" label="[01:00:48]">&lt;stikonas[m]&gt;</a></span><span class="message">We are still missing quite a few features</span></div><div class="line" id="010057"><span class="nick" style="color:#2e2a4a"><a href="#010057" label="[01:00:57]">&lt;janus&gt;</a></span><span class="message">I suppose in a way Breitner's proposal might align with what you're proposing, since he'd also have to use only the simplest of IO if Hugs' runtime system is to be compatible?</span></div><div class="line" id="010059"><span class="nick" style="color:#8dd3c7"><a href="#010059" label="[01:00:59]">&lt;ericson2314&gt;</a></span><span class="message">janus: hopefully I can then :)</span></div><div class="line" id="010104"><span class="nick" style="color:#80b1d3"><a href="#010104" label="[01:01:04]">&lt;stikonas[m]&gt;</a></span><span class="message">And it's hard to further extend M2</span></div><div class="line" id="010129"><span class="nick" style="color:#80b1d3"><a href="#010129" label="[01:01:29]">&lt;stikonas[m]&gt;</a></span><span class="message">We added some features recently (e.g. structs on stack)</span></div><div class="line" id="010137"><span class="nick" style="color:#8dd3c7"><a href="#010137" label="[01:01:37]">&lt;ericson2314&gt;</a></span><span class="message">It sort of seems there is a little scheme vs unix rivalry in the bootstrap :)</span></div><div class="line" id="010203"><span class="nick" style="color:#80b1d3"><a href="#010203" label="[01:02:03]">&lt;stikonas[m]&gt;</a></span><span class="message">But it's hard to do further additions</span></div><div class="line" id="010219"><span class="nick" style="color:#80b1d3"><a href="#010219" label="[01:02:19]">&lt;stikonas[m]&gt;</a></span><span class="message">c parser in M2-Planet is very simple</span></div><div class="line" id="010229"><span class="nick" style="color:#8dd3c7"><a href="#010229" label="[01:02:29]">&lt;ericson2314&gt;</a></span><span class="message">janus: I've been involved with a &quot;split-base&quot; thing, to try do separate implementation agnostic vs specific stuff in the standard library</span></div><div class="line" id="010241"><span class="nick" style="color:#8dd3c7"><a href="#010241" label="[01:02:41]">&lt;ericson2314&gt;</a></span><span class="message">this also has Joachim work precendent</span></div><div class="line" id="010243"><span class="nick" style="color:#80b1d3"><a href="#010243" label="[01:02:43]">&lt;stikonas[m]&gt;</a></span><span class="message">But we indeed achieved surprisingly a lot with M2</span></div><div class="line" id="010247"><span class="nick" style="color:#8dd3c7"><a href="#010247" label="[01:02:47]">&lt;ericson2314&gt;</a></span><span class="message">and should dovetail nicely</span></div><div class="line" id="010343"><span class="nick" style="color:#8dd3c7"><a href="#010343" label="[01:03:43]">&lt;ericson2314&gt;</a></span><span class="message">maybe a s-expression C would be a good intermediate step :)</span></div><div class="line" id="010358"><span class="nick" style="color:#8dd3c7"><a href="#010358" label="[01:03:58]">&lt;ericson2314&gt;</a></span><span class="message">get something fast but avoid parsing nonsense</span></div><div class="line" id="010450"><span class="nick" style="color:#80b1d3"><a href="#010450" label="[01:04:50]">&lt;stikonas[m]&gt;</a></span><span class="message">One could also port mescc from scheme to M2 but it's non trivial work with little benefit</span></div><div class="line" id="010516"><span class="nick" style="color:#80b1d3"><a href="#010516" label="[01:05:16]">&lt;stikonas[m]&gt;</a></span><span class="message">mes might be slow to build itself, but GCC 12 is slower</span></div><div class="line" id="013118"><span class="nick" style="color:#8dd3c7"><a href="#013118" label="[01:31:18]">&lt;ericson2314&gt;</a></span><span class="message">fair</span></div><div class="line" id="030623"><span class="nick" style="color:#6d2462"><a href="#030623" label="[03:06:23]">&lt;oriansj&gt;</a></span><span class="message">ericson2314: well the problem with M2-Planet is that it supports enough of the C lambda core to do anything one needs to do but it lacks enough of the extra C features that people generally choose to use to do more advanced things. And there is a minor hobby project of mine which is effectively S-expression M2-planet but it doesn't bring much benefit as I doubt one would tweak mescc to run in that subset.</span></div><div class="line" id="040529"><span class="nick" style="color:#234e69"><a href="#040529" label="[04:05:29]">&lt;muurkha&gt;</a></span><span class="message">janus: what is LML?</span></div><div class="line" id="040553"><span class="nick" style="color:#234e69"><a href="#040553" label="[04:05:53]">&lt;muurkha&gt;</a></span><span class="message">maybe <a rel="nofollow" href="https://old.reddit.com/r/haskell/comments/o0t96c/elm_language_and_haskell/h1y4wev/">https://old.reddit.com/r/haskell/comments/o0t96c/elm_language_and_haskell/h1y4wev/</a>  explains?</span></div><div class="line" id="040619"><span class="nick" style="color:#6c3d55"><a href="#040619" label="[04:06:19]">&lt;probie&gt;</a></span><span class="message">Possibly Lazy ML?</span></div><div class="line" id="040626"><span class="nick" style="color:#234e69"><a href="#040626" label="[04:06:26]">&lt;muurkha&gt;</a></span><span class="message">it doesn't really explain, no</span></div><div class="line" id="040651"><span class="nick" style="color:#234e69"><a href="#040651" label="[04:06:51]">&lt;muurkha&gt;</a></span><span class="message">I don't think rekado's writeup mentioned LML or HBC?</span></div><div class="line" id="040841"><span class="nick" style="color:#234e69"><a href="#040841" label="[04:08:41]">&lt;muurkha&gt;</a></span><span class="message">unbootstrapping with an interpreter is a pretty reasonable thing to do.  That's how I got StoneKnifeForth to bootstrapping itself: <a rel="nofollow" href="https://github.com/kragen/stoneknifeforth/blob/master/tinyboot.py">https://github.com/kragen/stoneknifeforth/blob/master/tinyboot.py</a> </span></div><div class="line" id="041029"><span class="nick" style="color:#234e69"><a href="#041029" label="[04:10:29]">&lt;muurkha&gt;</a></span><span class="message">&quot;Lazy ML&quot; sounds plausible; is that a thing that exists?</span></div><div class="line" id="041549"><span class="nick" style="color:#6c3d55"><a href="#041549" label="[04:15:49]">&lt;probie&gt;</a></span><span class="message">muurkha: yes - it's a thing Augustsson wrote and was probably the first compiled (as opposed to interpreted) lazy functional language (<a rel="nofollow" href="https://dl.acm.org/doi/pdf/10.1145/800055.802038">https://dl.acm.org/doi/pdf/10.1145/800055.802038</a>  is the paper talking about it)</span></div><div class="line" id="041702"><span class="nick" style="color:#234e69"><a href="#041702" label="[04:17:02]">&lt;muurkha&gt;</a></span><span class="message">oh awesome, thanks</span></div><div class="line" id="055540"><span class="nick" style="color:#234e69"><a href="#055540" label="[05:55:40]">&lt;muurkha&gt;</a></span><span class="message">I'm guessing the LML version of GHC doesn't survive?</span></div><div class="line" id="064438"><span class="nick" style="color:#6c3d55"><a href="#064438" label="[06:44:38]">&lt;probie&gt;</a></span><span class="message">LML wasn't used to build GHC, it was used to build HBC (and HBC was used to build GHC)</span></div><div class="line" id="070600"><span class="nick" style="color:#234e69"><a href="#070600" label="[07:06:00]">&lt;muurkha&gt;</a></span><span class="message">oh, thanks for the correction. does HBC survive?</span></div><div class="line" id="072220"><span class="nick" style="color:#6c3d55"><a href="#072220" label="[07:22:20]">&lt;probie&gt;</a></span><span class="message">I think so. I've just been playing around trying to get it build. I think it might actually be buildable (and I've got a version of ghc which thinks it can be compiled by hbc)</span></div><div class="line" id="072231"><span class="nick" style="color:#6c3d55"><a href="#072231" label="[07:22:31]">&lt;probie&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/haskell-implementations/hbc">https://github.com/haskell-implementations/hbc</a> </span></div><div class="line" id="072425"><span class="nick" style="color:#6c3d55"><a href="#072425" label="[07:24:25]">&lt;probie&gt;</a></span><span class="message">I think it includes an lml compiler written in C under src/syntax</span></div><div class="line" id="073102"><span class="nick" style="color:#6c3d55"><a href="#073102" label="[07:31:02]">&lt;probie&gt;</a></span><span class="message">it might actually be possible to bootstrap GHC via getting hbc to build and then working your way up through a dozen or so versions of GHC</span></div><div class="line" id="082100"><span class="nick" style="color:#6c3d55"><a href="#082100" label="[08:21:00]">&lt;probie&gt;</a></span><span class="message">nevermind, it does actually depend on an installed lmlc</span></div><div class="line" id="082542"><span class="nick" style="color:#6c3d55"><a href="#082542" label="[08:25:42]">&lt;probie&gt;</a></span><span class="message">that said, it looks like you could bootstrap ghc via hbc if one wrote an lml compiler in C (or another bootstrappable language)</span></div><div class="line" id="082855"><span class="nick" style="color:#d9d9d9"><a href="#082855" label="[08:28:55]">&lt;[exa]&gt;</a></span><span class="message">probie: the possibility is wildly theoretical given the insane amount of spacetime ghc actually needs for compiling and the complexity of build tools all around</span></div><div class="line" id="083050"><span class="nick" style="color:#d9d9d9"><a href="#083050" label="[08:30:50]">&lt;[exa]&gt;</a></span><span class="message">there's some push even in hs community to provide a better bootstrap for ghc than &quot;the last blob from the chain of blobs&quot; but it's going slowly</span></div><div class="line" id="083154"><span class="nick" style="color:#234e69"><a href="#083154" label="[08:31:54]">&lt;muurkha&gt;</a></span><span class="message">Augustsson's paper seems clear enough about LML, especially with all of SPJ's later fine work elaborating on the G-machine model</span></div><div class="line" id="083225"><span class="nick" style="color:#d9d9d9"><a href="#083225" label="[08:32:25]">&lt;[exa]&gt;</a></span><span class="message">imo if the purpose of haskell here is to provide a strong tool for compiling stuff, I'd go for just reimplementing LML because it's going to do the same job for like 1% of the price</span></div><div class="line" id="084209"><span class="nick" style="color:#6c3d55"><a href="#084209" label="[08:42:09]">&lt;probie&gt;</a></span><span class="message">As a user of GHC, I'd like a path to build it that doesn't require trusting some binary that someone generated 20 years ago</span></div><div class="line" id="084439"><span class="nick" style="color:#bc80bd"><a href="#084439" label="[08:44:39]">&lt;janneke&gt;</a></span><span class="message">&quot;&lt;ericson2314&gt; emilytrau: saw that. Yeah I guess my question was more does stuff from non-mes branches still get incorporated&quot;</span></div><div class="line" id="084611"><span class="nick" style="color:#bc80bd"><a href="#084611" label="[08:46:11]">&lt;janneke&gt;</a></span><span class="message">it would be nice if the bootstrappable patches could be ported to a newer tcc, there have been several attempts the past years but they did not lead to a runnable tcc yet</span></div><div class="line" id="145056"><span class="nick" style="color:#80b1d3"><a href="#145056" label="[14:50:56]">&lt;stikonas[m]&gt;</a></span><span class="message">The other option is to improve mescc...</span></div><div class="line" id="193221"><span class="nick" style="color:#3c5b35"><a href="#193221" label="[19:32:21]">&lt;theruran&gt;</a></span><span class="message">Irvise_: I just read your messages above about targeting an old GCC/GNAT would be problematic because it would require so many compiles in the path; and maybe it would be easier to write a separate compiler that targets a current GNAT or the GCC 4.7 (?) that is targeted by mescc</span></div><div class="line" id="193228"><span class="nick" style="color:#3c5b35"><a href="#193228" label="[19:32:28]">&lt;theruran&gt;</a></span><span class="message">did I understand that right?</span></div><div class="line" id="193441"><span class="nick" style="color:#3c5b35"><a href="#193441" label="[19:34:41]">&lt;theruran&gt;</a></span><span class="message">as an aside, I am interested in writing a formally-verified Kernel LISP using Vale/FStar then translating the assembly into the stage0-posix path. probably no time for that tho! ;(((</span></div><div class="line" id="193839"><span class="nick" style="color:#3c5b35"><a href="#193839" label="[19:38:39]">&lt;theruran&gt;</a></span><span class="message">because having LISP pre-C in the bootstrap path is very appealing to me, and could be used to write an Ada compiler</span></div><div class="line" id="194326"><span class="nick" style="color:#6b8072"><a href="#194326" label="[19:43:26]">&lt;stikonas&gt;</a></span><span class="message">wouldn't it be simpler to keep these as separate goals? I would expect that it isbe simpler to write ada compiler by using far more powerful tools (C/C++, Guile, etc) rather than be limitted to stage0-posix stuff</span></div><div class="line" id="194657"><span class="nick" style="color:#3c5b35"><a href="#194657" label="[19:46:57]">&lt;theruran&gt;</a></span><span class="message">yeah, well Kernel would need some things like pattern matching, a parser combinator library, and some binary file manipulation probably for the linker (gnatlink). and while those could be translated from Scheme it probably wouldn't be the most straightforward thing</span></div><div class="line" id="195001"><span class="nick" style="color:#3c5b35"><a href="#195001" label="[19:50:01]">&lt;theruran&gt;</a></span><span class="message">Irvise_ and I talked about it before. getting GNAT to compile and building an full Ada compiler seemed like separate goals. and using an existing small Scheme, and writing one to be pre-C in the bootstrap path also seemed like separate goals</span></div><div class="line" id="200607"><span class="nick" style="color:#af8d2f"><a href="#200607" label="[20:06:07]">&lt;Irvise_&gt;</a></span><span class="message">theruran: yes, you understood it correctly :)</span></div><div class="line" id="200633"><span class="nick" style="color:#af8d2f"><a href="#200633" label="[20:06:33]">&lt;Irvise_&gt;</a></span><span class="message">I think jumping directly to GCC 4.7 is the best we can do.</span></div><div class="line" id="200830"><span class="nick" style="color:#af8d2f"><a href="#200830" label="[20:08:30]">&lt;Irvise_&gt;</a></span><span class="message">Regarding jumping the C dependency: that is why I wanted to take a look a look at using Mes instead of TR7.</span></div><div class="line" id="203457"><span class="nick" style="color:#3c5b35"><a href="#203457" label="[20:34:57]">&lt;theruran&gt;</a></span><span class="message">ü§î so jumping to 4.7 doesn't seem like a big scope change from GNAT 3.1 or whatever</span></div><div class="line" id="203517"><span class="nick" style="color:#3c5b35"><a href="#203517" label="[20:35:17]">&lt;theruran&gt;</a></span><span class="message">I was thinking we don't even need to write a type checker if we're just bootstrapping GNAT, right?</span></div><div class="line" id="203618"><span class="nick" style="color:#3c5b35"><a href="#203618" label="[20:36:18]">&lt;theruran&gt;</a></span><span class="message">because like, the goal is not to verify the GNAT implementation of the Ada spec. it's just to get a bit-for-bit executable. right?</span></div><div class="line" id="204259"><span class="nick" style="color:#3c5b35"><a href="#204259" label="[20:42:59]">&lt;theruran&gt;</a></span><span class="message">Irvise_: well Mes is written in C but at least it is a C subset. I'll have to give it a good run on the latest version, because last I was told it is missing some things.. debugger? useful error messages? maybe it's not a big deal anyway</span></div><div class="line" id="204439"><span class="nick" style="color:#234e69"><a href="#204439" label="[20:44:39]">&lt;muurkha&gt;</a></span><span class="message">I think you need a type checker to compile Ada; for one thing, it has generics</span></div><div class="line" id="204526"><span class="nick" style="color:#234e69"><a href="#204526" label="[20:45:26]">&lt;muurkha&gt;</a></span><span class="message">for another, it has value types.  in fact, it's mostly value types</span></div><div class="line" id="204548"><span class="nick" style="color:#234e69"><a href="#204548" label="[20:45:48]">&lt;muurkha&gt;</a></span><span class="message">to put an object of a user-defined value type in .bss or a stack frame you need to know what size it is, which depends on its type</span></div><div class="line" id="204612"><span class="nick" style="color:#234e69"><a href="#204612" label="[20:46:12]">&lt;muurkha&gt;</a></span><span class="message">also, I think the different records have their fields in different namespaces, as in C except before about 01978</span></div><div class="line" id="204651"><span class="nick" style="color:#234e69"><a href="#204651" label="[20:46:51]">&lt;muurkha&gt;</a></span><span class="message">in C &quot;x-&gt;head&quot; might compile to different offsets from where x points depending on the static type of x</span></div><div class="line" id="204743"><span class="nick" style="color:#234e69"><a href="#204743" label="[20:47:43]">&lt;muurkha&gt;</a></span><span class="message">but maybe you can do all of that &quot;interpretively&quot;; Ada being stricter than C might mean Ada programs don't care about things like what gets copied when you memcpy a struct</span></div><div class="line" id="204859"><span class="nick" style="color:#234e69"><a href="#204859" label="[20:48:59]">&lt;muurkha&gt;</a></span><span class="message">then the value-type semantics just comes down to [possibly unnecessarily] cloning objects in the heap to prevent aliasing</span></div><div class="line" id="210434"><span class="nick" style="color:#af8d2f"><a href="#210434" label="[21:04:34]">&lt;Irvise_&gt;</a></span><span class="message">Indeed. Luckily for us, the GNAT compiler does not tend to use some of the more advance features, so a reduced Ada subset may actually work. But of course, we are still in the very early stages of work.</span></div><div class="line" id="210452"><span class="nick" style="color:#af8d2f"><a href="#210452" label="[21:04:52]">&lt;Irvise_&gt;</a></span><span class="message">I still have not ordered my copies of books to properly learn Scheme.</span></div><div class="line" id="210523"><span class="nick" style="color:#3c5b35"><a href="#210523" label="[21:05:23]">&lt;theruran&gt;</a></span><span class="message">Irvise_: lol. see if you can do SICP with Mes :P</span></div><div class="line" id="210731"><span class="nick" style="color:#af8d2f"><a href="#210731" label="[21:07:31]">&lt;Irvise_&gt;</a></span><span class="message">That would actually be a nice challenge &gt;:D</span></div><div class="line" id="214424"><span class="nick" style="color:#af8d2f"><a href="#214424" label="[21:44:24]">&lt;Irvise_&gt;</a></span><span class="message">theruran: however, before I start with the bootstrap, which, once again, is going to take me a long while to begin with; I want to at least get an Ada compiler into Guix.</span></div><div class="line" id="214442"><span class="nick" style="color:#af8d2f"><a href="#214442" label="[21:44:42]">&lt;Irvise_&gt;</a></span><span class="message">There are people waiting for it to get Coreboot/Libreboot graphics support.</span></div><div class="line" id="214500"><span class="nick" style="color:#af8d2f"><a href="#214500" label="[21:45:00]">&lt;Irvise_&gt;</a></span><span class="message">And a binary is still allowed for non-bootstrapped languages so...</span></div><div class="line" id="214511"><span class="nick" style="color:#3c5b35"><a href="#214511" label="[21:45:11]">&lt;theruran&gt;</a></span><span class="message">Irvise_: sounds good. we both know that getting the supporting tools built together is a major PITA and having a Guix-reproducible build recipe would help a lot</span></div><div class="line" id="214543"><span class="nick" style="color:#3c5b35"><a href="#214543" label="[21:45:43]">&lt;theruran&gt;</a></span><span class="message">I see re: Coreboot</span></div><div class="line" id="214543"><span class="nick" style="color:#af8d2f"><a href="#214543" label="[21:45:43]">&lt;Irvise_&gt;</a></span><span class="message">And we do have a plan to get it bootstrapped. I hope the Guix people will allow a temporary fix to get some Ada packages and Ada support into Guix (GHDL also comes to mind).</span></div><div class="line" id="214602"><span class="nick" style="color:#3c5b35"><a href="#214602" label="[21:46:02]">&lt;theruran&gt;</a></span><span class="message">GHDL is also nice</span></div><div class="line" id="214723"><span class="nick" style="color:#3c5b35"><a href="#214723" label="[21:47:23]">&lt;theruran&gt;</a></span><span class="message">I am also annoyed by AdaCore's packaging discipline w.r.t. gnatprove. there are no tags in the spark2014 repo and I *guess* we are meant to just point at fsf branch HEAD (wtf)</span></div><div class="line" id="214728"><span class="nick" style="color:#af8d2f"><a href="#214728" label="[21:47:28]">&lt;Irvise_&gt;</a></span><span class="message">I will focus on that from now on. Though, just like always, it is going to be a slow process... Maybe it is not that difficult and we can have an initial binary seed in a couple of moths...</span></div><div class="line" id="214813"><span class="nick" style="color:#3c5b35"><a href="#214813" label="[21:48:13]">&lt;theruran&gt;</a></span><span class="message">muurkha: those are some great points. I don't think I'll be able to approach an answer on that without getting knee-deep into it.</span></div><div class="line" id="215017"><span class="nick" style="color:#234e69"><a href="#215017" label="[21:50:17]">&lt;muurkha&gt;</a></span><span class="message">yeah, I'm pretty ignorant about Ada, so I might have fundamental things wrong</span></div><div class="line" id="215207"><span class="nick" style="color:#af8d2f"><a href="#215207" label="[21:52:07]">&lt;Irvise_&gt;</a></span><span class="message">I would use the ones used in Alire...</span></div><div class="line" id="215208"><span class="nick" style="color:#af8d2f"><a href="#215208" label="[21:52:08]">&lt;Irvise_&gt;</a></span><span class="message">I know, it is a very poor practice and a bad practice w.r.t AdaCore, but that is what we have...</span></div><div class="line" id="215209"><span class="nick" style="color:#af8d2f"><a href="#215209" label="[21:52:09]">&lt;Irvise_&gt;</a></span><span class="message">Also, they are a bit behind GCC releases. So the official support for GCC 13 from GNATProve is not there yet...</span></div><div class="line" id="215238"><span class="nick" style="color:#af8d2f"><a href="#215238" label="[21:52:38]">&lt;Irvise_&gt;</a></span><span class="message">(I would use the same tags as in Alire)</span></div><div class="line" id="215257"><span class="nick" style="color:#af8d2f"><a href="#215257" label="[21:52:57]">&lt;Irvise_&gt;</a></span><span class="message">Good night :)</span></div><div class="line" id="215609"><span class="nick" style="color:#3c5b35"><a href="#215609" label="[21:56:09]">&lt;theruran&gt;</a></span><span class="message">Irvise_: I cannot use the gnatprove from Alire on a musl-libc system. cool huh?!</span></div><div class="line" id="222729"><span class="nick" style="color:#389600"><a href="#222729" label="[22:27:29]">&lt;sam_&gt;</a></span><span class="message">I think it changed in gcc 11 or 12</span></div><div class="line" id="222744"><span class="nick" style="color:#389600"><a href="#222744" label="[22:27:44]">&lt;sam_&gt;</a></span><span class="message">i.e. there's no more gnat-gpl releases as of &gt;= 11</span></div><div class="line" id="225153"><span class="nick" style="color:#3c5b35"><a href="#225153" label="[22:51:53]">&lt;theruran&gt;</a></span><span class="message">well at least you can point to the GCC version of the GNAT FSF in Alire. but gnatprove in Alire does not point to any version, tag, or commit hash of the AdaCore/spark2014 repo. so it's not clear what version it is, and if intermediate commits on HEAD are actually stable enough for packaging</span></div><br /></div></body></html>