<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-08-23.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="004724"><span class="nick" style="color:#389600"><a href="#004724" label="[00:47:24]">&lt;mala&gt;</a></span><span class="message">So dumb question -- but how hard would it be to use sectorlisp or similar as an alternative bootstrap into mes (on intel, obvs)? (Sorry if I've asked this before)</span></div><div class="line" id="005402"><span class="nick" style="color:#8dd3c7"><a href="#005402" label="[00:54:02]">&lt;muurkha&gt;</a></span><span class="message">hi mala!  kragen here.  it's an interesting question</span></div><div class="line" id="005402"><span class="nick" style="color:#2e2a4a"><a href="#005402" label="[00:54:02]">&lt;stikonas&gt;</a></span><span class="message">mala: I guess fairly hard</span></div><div class="line" id="005425"><span class="nick" style="color:#2e2a4a"><a href="#005425" label="[00:54:25]">&lt;stikonas&gt;</a></span><span class="message">at least people here did not manage to write much in sectorlisp, but maybe we haven't tried</span></div><div class="line" id="005453"><span class="nick" style="color:#8dd3c7"><a href="#005453" label="[00:54:53]">&lt;muurkha&gt;</a></span><span class="message">I haven't tried programming in sectorlisp in part because I want to stay as far away from Justine Tunney as humanly possible</span></div><div class="line" id="005506"><span class="nick" style="color:#2e2a4a"><a href="#005506" label="[00:55:06]">&lt;stikonas&gt;</a></span><span class="message">so M0-&gt;cc_*-&gt;M2-Planet-&gt;mes  is the only way to bootstrap mes right now</span></div><div class="line" id="005607"><span class="nick" style="color:#2e2a4a"><a href="#005607" label="[00:56:07]">&lt;stikonas&gt;</a></span><span class="message">mala: you can try if you enjoy lisp but otherwise main effort here is assembly-&gt;C pathway</span></div><div class="line" id="005617"><span class="nick" style="color:#8dd3c7"><a href="#005617" label="[00:56:17]">&lt;muurkha&gt;</a></span><span class="message">just yesterday she was crowing about how sooner or later the Library Genesis folks will be rotting in jail</span></div><div class="line" id="005655"><span class="nick" style="color:#8dd3c7"><a href="#005655" label="[00:56:55]">&lt;muurkha&gt;</a></span><span class="message">(ref: <a rel="nofollow" href="https://news.ycombinator.com/item?id=32541595">https://news.ycombinator.com/item?id=32541595</a>) </span></div><div class="line" id="005742"><span class="nick" style="color:#8dd3c7"><a href="#005742" label="[00:57:42]">&lt;muurkha&gt;</a></span><span class="message">my own attempt at packing a high-level programming environment into 512 bytes is definitely not going to make it to 512 but might make it to 1024: <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/qfitzah.s">http://canonical.org/~kragen/sw/dev3/qfitzah.s</a> </span></div><div class="line" id="005819"><span class="nick" style="color:#8dd3c7"><a href="#005819" label="[00:58:19]">&lt;muurkha&gt;</a></span><span class="message">Qfitzah uses S-expressions but it isn't a Lisp; it's more like Mathematica or Q (not q, Q)</span></div><div class="line" id="005836"><span class="nick" style="color:#2e2a4a"><a href="#005836" label="[00:58:36]">&lt;stikonas&gt;</a></span><span class="message">well, we have rickmasters builder-hex0 (bootstrap stage) which also fits into 512 bytes</span></div><div class="line" id="005910"><span class="nick" style="color:#2e2a4a"><a href="#005910" label="[00:59:10]">&lt;stikonas&gt;</a></span><span class="message">and there is this new uefi stuff although it doesn't go all the way to mes yet</span></div><div class="line" id="005929"><span class="nick" style="color:#2e2a4a"><a href="#005929" label="[00:59:29]">&lt;stikonas&gt;</a></span><span class="message">but are getting more and more baremetal options</span></div><div class="line" id="010006"><span class="nick" style="color:#8dd3c7"><a href="#010006" label="[01:00:06]">&lt;muurkha&gt;</a></span><span class="message">the appeal of Qfitzah is that maybe you can avoid programming in hex0/hex1/etc. and leap instantly straight to high-level stuff</span></div><div class="line" id="010111"><span class="nick" style="color:#8dd3c7"><a href="#010111" label="[01:01:11]">&lt;muurkha&gt;</a></span><span class="message">Qfitzah also mentions that Strachey's GPM was 250 machine instructions, which I think was also about 1024 bytes</span></div><div class="line" id="010133"><span class="nick" style="color:#2e2a4a"><a href="#010133" label="[01:01:33]">&lt;stikonas&gt;</a></span><span class="message">yeah, hex0 stuff is somewhat annoying to write in</span></div><div class="line" id="010139"><span class="nick" style="color:#2e2a4a"><a href="#010139" label="[01:01:39]">&lt;stikonas&gt;</a></span><span class="message">but hex1 is much better</span></div><div class="line" id="010205"><span class="nick" style="color:#8dd3c7"><a href="#010205" label="[01:02:05]">&lt;muurkha&gt;</a></span><span class="message">my real concern is not how hard it is to write but how hard it is to find bugs in</span></div><div class="line" id="010213"><span class="nick" style="color:#8dd3c7"><a href="#010213" label="[01:02:13]">&lt;muurkha&gt;</a></span><span class="message">(whether accidental or not)</span></div><div class="line" id="010237"><span class="nick" style="color:#2e2a4a"><a href="#010237" label="[01:02:37]">&lt;stikonas&gt;</a></span><span class="message">that often depends on the debugging tools that you can use</span></div><div class="line" id="010252"><span class="nick" style="color:#2e2a4a"><a href="#010252" label="[01:02:52]">&lt;stikonas&gt;</a></span><span class="message">if it runs in gdb, finding bugs is not too hard</span></div><div class="line" id="010257"><span class="nick" style="color:#8dd3c7"><a href="#010257" label="[01:02:57]">&lt;muurkha&gt;</a></span><span class="message">I don't know how much help gdb is in finding backdoors</span></div><div class="line" id="010310"><span class="nick" style="color:#8dd3c7"><a href="#010310" label="[01:03:10]">&lt;muurkha&gt;</a></span><span class="message">GPM is pretty pessimal from that point of view.  not sure if term rewriting is better; it might be</span></div><div class="line" id="014712"><span class="nick" style="color:#2e2a4a"><a href="#014712" label="[01:47:12]">&lt;stikonas&gt;</a></span><span class="message">this hex2 warning is now slightly too strong &quot;If you are not generating a ROM image this binary will likely not work&quot; (if --base-address is omitted)</span></div><div class="line" id="014739"><span class="nick" style="color:#2e2a4a"><a href="#014739" label="[01:47:39]">&lt;stikonas&gt;</a></span><span class="message">it works fine with pic</span></div><div class="line" id="014820"><span class="nick" style="color:#8dd3c7"><a href="#014820" label="[01:48:20]">&lt;muurkha&gt;</a></span><span class="message">yay</span></div><div class="line" id="014822"><span class="nick" style="color:#8dd3c7"><a href="#014822" label="[01:48:22]">&lt;muurkha&gt;</a></span><span class="message">congratulations!</span></div><div class="line" id="014827"><span class="nick" style="color:#2e2a4a"><a href="#014827" label="[01:48:27]">&lt;stikonas&gt;</a></span><span class="message">well, but that's expected</span></div><div class="line" id="014918"><span class="nick" style="color:#80b1d3"><a href="#014918" label="[01:49:18]">&lt;oriansj&gt;</a></span><span class="message">muurkha: every instruction set that support PC relative addressing AND absolute addressing uses syntax to distinguish which the programmer in intends be it special instructions LOADR32 R0, LABEL or referencing the PC explicitly MOV RAX, [RIP+LABEL]</span></div><div class="line" id="015126"><span class="nick" style="color:#2e2a4a"><a href="#015126" label="[01:51:26]">&lt;stikonas&gt;</a></span><span class="message">or some other syntax, I think nasm had mov rax, [rel label]</span></div><div class="line" id="015139"><span class="nick" style="color:#80b1d3"><a href="#015139" label="[01:51:39]">&lt;oriansj&gt;</a></span><span class="message">mala: to the question of using sectorlisp for bootstrapping. The answer is you have no ability to directly write any data to disk nor to memory nor jump to an address in memory.</span></div><div class="line" id="015141"><span class="nick" style="color:#2e2a4a"><a href="#015141" label="[01:51:41]">&lt;stikonas&gt;</a></span><span class="message">but still explicit</span></div><div class="line" id="015209"><span class="nick" style="color:#80b1d3"><a href="#015209" label="[01:52:09]">&lt;oriansj&gt;</a></span><span class="message">stikonas: indeed and thank you</span></div><div class="line" id="015235"><span class="nick" style="color:#2e2a4a"><a href="#015235" label="[01:52:35]">&lt;stikonas&gt;</a></span><span class="message">no need to thank me :), didn't realy do anything now</span></div><div class="line" id="015318"><span class="nick" style="color:#2e2a4a"><a href="#015318" label="[01:53:18]">&lt;stikonas&gt;</a></span><span class="message">anyway, today I cleaned up catm in stage0-uefi, now will have to go down to hex0 and kaem-minimal and cleanup rest of the stuff I've written</span></div><div class="line" id="015330"><span class="nick" style="color:#2e2a4a"><a href="#015330" label="[01:53:30]">&lt;stikonas&gt;</a></span><span class="message">possibly increasing size of binaries a bit</span></div><div class="line" id="015344"><span class="nick" style="color:#2e2a4a"><a href="#015344" label="[01:53:44]">&lt;stikonas&gt;</a></span><span class="message">but I think it's better to keep to the spec and close allocated resources</span></div><div class="line" id="015457"><span class="nick" style="color:#80b1d3"><a href="#015457" label="[01:54:57]">&lt;oriansj&gt;</a></span><span class="message">so to make sectorlisp useful, you'll have to figure out a method for getting sectorlisp to segfault in a useful fashion which would result in either the execution of a program (like hex0 or more complex) after setting up that program in a very hard to control fashion in memory and do so within the very limited amount of memory they setup. Oh and for extra fun that data you can put in memory is in a different segment, so you'll have to</span></div><div class="line" id="015458"><span class="nick" style="color:#80b1d3"><a href="#015458" label="[01:54:58]">&lt;oriansj&gt;</a></span><span class="message">change the segment register without writing any code into memory.</span></div><div class="line" id="015607"><span class="nick" style="color:#2e2a4a"><a href="#015607" label="[01:56:07]">&lt;stikonas&gt;</a></span><span class="message">that sounds like lots of hacks...</span></div><div class="line" id="015618"><span class="nick" style="color:#2e2a4a"><a href="#015618" label="[01:56:18]">&lt;stikonas&gt;</a></span><span class="message">which is probably not what we want in bootstrapping</span></div><div class="line" id="015657"><span class="nick" style="color:#80b1d3"><a href="#015657" label="[01:56:57]">&lt;oriansj&gt;</a></span><span class="message">writing hex0 will look trivial and be an order of magnitude easier to audit.</span></div><div class="line" id="015722"><span class="nick" style="color:#80b1d3"><a href="#015722" label="[01:57:22]">&lt;oriansj&gt;</a></span><span class="message">that being said mala sectorFORTH however is MUCH MUCH more promising as a root</span></div><div class="line" id="015826"><span class="nick" style="color:#80b1d3"><a href="#015826" label="[01:58:26]">&lt;oriansj&gt;</a></span><span class="message">although that would require you to type about 1-4KB of input before it'll be really useful.</span></div><div class="line" id="020202"><span class="nick" style="color:#80b1d3"><a href="#020202" label="[02:02:02]">&lt;oriansj&gt;</a></span><span class="message">and to be completely honest, there is no better bootstrap seed for x86 than Oscar Toledo G's bootOS <a rel="nofollow" href="https://github.com/nanochess/bootOS">https://github.com/nanochess/bootOS</a>  which not only has a filesystem, the ability to create files and to execute programs from that filesystem.</span></div><div class="line" id="020302"><span class="nick" style="color:#389600"><a href="#020302" label="[02:03:02]">&lt;mala&gt;</a></span><span class="message">oriansj, et all -- that is all really informative. Thank you!</span></div><div class="line" id="020919"><span class="nick" style="color:#80b1d3"><a href="#020919" label="[02:09:19]">&lt;oriansj&gt;</a></span><span class="message">I really should port SET to bootOS and finish defining/implementing GFK filesystem</span></div><div class="line" id="030216"><span class="nick" style="color:#8dd3c7"><a href="#030216" label="[03:02:16]">&lt;muurkha&gt;</a></span><span class="message">that'd be great!</span></div><div class="line" id="030314"><span class="nick" style="color:#8dd3c7"><a href="#030314" label="[03:03:14]">&lt;muurkha&gt;</a></span><span class="message">oriansj: yeah, but lots of instruction sets don't support absolute addressing for lots of instructions</span></div><div class="line" id="030355"><span class="nick" style="color:#8dd3c7"><a href="#030355" label="[03:03:55]">&lt;muurkha&gt;</a></span><span class="message">like, for conditional jumps</span></div><div class="line" id="030432"><span class="nick" style="color:#8dd3c7"><a href="#030432" label="[03:04:32]">&lt;muurkha&gt;</a></span><span class="message">RISC-V at its most basic level has separate LUI and AUIPC instructions for loading (the high 20 bits of) absolute and PC-relative base addresses into registers</span></div><div class="line" id="030510"><span class="nick" style="color:#8dd3c7"><a href="#030510" label="[03:05:10]">&lt;muurkha&gt;</a></span><span class="message">and most RISC-V assemblers support LI and LA pseudo-instructions which assemble to respectively LUI;ADDI and AUIPC;ADDI</span></div><div class="line" id="030710"><span class="nick" style="color:#8dd3c7"><a href="#030710" label="[03:07:10]">&lt;muurkha&gt;</a></span><span class="message">(but the register jump instruction also has a 12-bit offset field, so a jump to a 32-bit absolute address is just LUI;JR rather than LUI;ADDI;JR</span></div><div class="line" id="030720"><span class="nick" style="color:#8dd3c7"><a href="#030720" label="[03:07:20]">&lt;muurkha&gt;</a></span><span class="message">and similarly for relative addresses with AUIPC;JR)</span></div><div class="line" id="030915"><span class="nick" style="color:#8dd3c7"><a href="#030915" label="[03:09:15]">&lt;muurkha&gt;</a></span><span class="message">for 64-bit constants your best bet is loading constants from a constant pool using a PC-relative address.  sadly, unlike ARM, RISC-V does not support directly indexing off the PC in a load instruction</span></div><div class="line" id="032508"><span class="nick" style="color:#80b1d3"><a href="#032508" label="[03:25:08]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well all instruction sets I have seen support absolute addressing</span></div><div class="line" id="032603"><span class="nick" style="color:#80b1d3"><a href="#032603" label="[03:26:03]">&lt;oriansj&gt;</a></span><span class="message">The only way to not support absolute addressing is if the only way to address memory was PC relative</span></div><div class="line" id="032645"><span class="nick" style="color:#80b1d3"><a href="#032645" label="[03:26:45]">&lt;oriansj&gt;</a></span><span class="message">because if I can load/store memory from a value in a register or from the stack, I can find a way to shove an absolute address in there.</span></div><div class="line" id="032952"><span class="nick" style="color:#8dd3c7"><a href="#032952" label="[03:29:52]">&lt;muurkha&gt;</a></span><span class="message">there's a lot of fuzziness there, but yes, being able to stick an absolute address in a register does allow you to load and store at absolute addresses in many instruction sets which don't directly support absolute addressing</span></div><div class="line" id="033138"><span class="nick" style="color:#8dd3c7"><a href="#033138" label="[03:31:38]">&lt;muurkha&gt;</a></span><span class="message">we were talking about assembly language syntax here, and there are lots of assembly languages that don't have a syntax for putting an absolute address into your instruction because the underlying instruction set doesn't have one</span></div><div class="line" id="033146"><span class="nick" style="color:#80b1d3"><a href="#033146" label="[03:31:46]">&lt;oriansj&gt;</a></span><span class="message">and you are right that absolute addressing for jumps/calls is generally only done via loading that address into a register first.</span></div><div class="line" id="033150"><span class="nick" style="color:#8dd3c7"><a href="#033150" label="[03:31:50]">&lt;muurkha&gt;</a></span><span class="message">most RISC machines (not just RISC-V) fall in this category I think?</span></div><div class="line" id="033244"><span class="nick" style="color:#80b1d3"><a href="#033244" label="[03:32:44]">&lt;oriansj&gt;</a></span><span class="message">muurkha: most RISC machines just use loading of immediates to populate an absolute addres into a register for use.</span></div><div class="line" id="033254"><span class="nick" style="color:#8dd3c7"><a href="#033254" label="[03:32:54]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="033311"><span class="nick" style="color:#8dd3c7"><a href="#033311" label="[03:33:11]">&lt;muurkha&gt;</a></span><span class="message">there are also a lot of machines that use some sort of segmented addressing where the base address of a segment is implicitly added to all your memory addresses, like the PDP-11, and you may or may not have a way to load the base address register as an unprivileged user</span></div><div class="line" id="033314"><span class="nick" style="color:#80b1d3"><a href="#033314" label="[03:33:14]">&lt;oriansj&gt;</a></span><span class="message">and some like RISC-V include pseudo instructions to make that easy.</span></div><div class="line" id="033335"><span class="nick" style="color:#8dd3c7"><a href="#033335" label="[03:33:35]">&lt;muurkha&gt;</a></span><span class="message">but segmentation wasn't really what we were talking about either</span></div><div class="line" id="033419"><span class="nick" style="color:#80b1d3"><a href="#033419" label="[03:34:19]">&lt;oriansj&gt;</a></span><span class="message">well segmentation only really was popular for 8/16bit processors</span></div><div class="line" id="033457"><span class="nick" style="color:#80b1d3"><a href="#033457" label="[03:34:57]">&lt;oriansj&gt;</a></span><span class="message">as once you have 24 or 32bits, you just didn't need such tricks to make real programs</span></div><div class="line" id="033550"><span class="nick" style="color:#8dd3c7"><a href="#033550" label="[03:35:50]">&lt;muurkha&gt;</a></span><span class="message">that's not the only thing segmentation was good for!</span></div><div class="line" id="033602"><span class="nick" style="color:#8dd3c7"><a href="#033602" label="[03:36:02]">&lt;muurkha&gt;</a></span><span class="message">on the PDP-11 it was primarily a memory protection mechanism</span></div><div class="line" id="033648"><span class="nick" style="color:#8dd3c7"><a href="#033648" label="[03:36:48]">&lt;muurkha&gt;</a></span><span class="message">a lot simpler in hardware than an MMU</span></div><div class="line" id="033726"><span class="nick" style="color:#8dd3c7"><a href="#033726" label="[03:37:26]">&lt;muurkha&gt;</a></span><span class="message">on the Burroughs B5000 line every array was in its own segment, and again the main purpose of this was memory protection</span></div><div class="line" id="033735"><span class="nick" style="color:#80b1d3"><a href="#033735" label="[03:37:35]">&lt;oriansj&gt;</a></span><span class="message">having looked at memory overlays for the PDP-11; I can't agree with that view</span></div><div class="line" id="033741"><span class="nick" style="color:#8dd3c7"><a href="#033741" label="[03:37:41]">&lt;muurkha&gt;</a></span><span class="message">oh?</span></div><div class="line" id="033743"><span class="nick" style="color:#8dd3c7"><a href="#033743" label="[03:37:43]">&lt;muurkha&gt;</a></span><span class="message">I forget the word size of the B5000</span></div><div class="line" id="033813"><span class="nick" style="color:#8dd3c7"><a href="#033813" label="[03:38:13]">&lt;muurkha&gt;</a></span><span class="message">36 bits or something?</span></div><div class="line" id="033838"><span class="nick" style="color:#8dd3c7"><a href="#033838" label="[03:38:38]">&lt;muurkha&gt;</a></span><span class="message">I don't know of any 8-bit processors that had segmentation</span></div><div class="line" id="033918"><span class="nick" style="color:#80b1d3"><a href="#033918" label="[03:39:18]">&lt;oriansj&gt;</a></span><span class="message">6502</span></div><div class="line" id="033955"><span class="nick" style="color:#80b1d3"><a href="#033955" label="[03:39:55]">&lt;oriansj&gt;</a></span><span class="message">they just didn't call them segments</span></div><div class="line" id="034039"><span class="nick" style="color:#8dd3c7"><a href="#034039" label="[03:40:39]">&lt;muurkha&gt;</a></span><span class="message">in what sense did the 6502 have segments?</span></div><div class="line" id="034050"><span class="nick" style="color:#8dd3c7"><a href="#034050" label="[03:40:50]">&lt;muurkha&gt;</a></span><span class="message">the 65816, sure</span></div><div class="line" id="034119"><span class="nick" style="color:#8dd3c7"><a href="#034119" label="[03:41:19]">&lt;muurkha&gt;</a></span><span class="message">because you could relocate the zero page and stack page on the 65816.  but the 6502?</span></div><div class="line" id="034329"><span class="nick" style="color:#80b1d3"><a href="#034329" label="[03:43:29]">&lt;oriansj&gt;</a></span><span class="message">The 6502 divides itâ€™s 64KB of memory up into 256 byte pages which were swappable</span></div><div class="line" id="034338"><span class="nick" style="color:#8dd3c7"><a href="#034338" label="[03:43:38]">&lt;muurkha&gt;</a></span><span class="message">swappable?</span></div><div class="line" id="034410"><span class="nick" style="color:#80b1d3"><a href="#034410" label="[03:44:10]">&lt;oriansj&gt;</a></span><span class="message">Bank_switching is what they called it</span></div><div class="line" id="034422"><span class="nick" style="color:#8dd3c7"><a href="#034422" label="[03:44:22]">&lt;muurkha&gt;</a></span><span class="message">oh, bank switching is something different</span></div><div class="line" id="034433"><span class="nick" style="color:#8dd3c7"><a href="#034433" label="[03:44:33]">&lt;muurkha&gt;</a></span><span class="message">and it's not part of the CPU, it's part of the memory subsystem</span></div><div class="line" id="034439"><span class="nick" style="color:#8dd3c7"><a href="#034439" label="[03:44:39]">&lt;muurkha&gt;</a></span><span class="message">you can have it or not</span></div><div class="line" id="034503"><span class="nick" style="color:#8dd3c7"><a href="#034503" label="[03:45:03]">&lt;muurkha&gt;</a></span><span class="message">lots of 8-bit micros used bank switching in order to be able to handle more than 64K.  In fact the IBM PC ended up using bank switching a lot in the form of LIM EMS</span></div><div class="line" id="034516"><span class="nick" style="color:#8dd3c7"><a href="#034516" label="[03:45:16]">&lt;muurkha&gt;</a></span><span class="message">what do you mean about PDP-11 overlays?</span></div><div class="line" id="034659"><span class="nick" style="color:#80b1d3"><a href="#034659" label="[03:46:59]">&lt;oriansj&gt;</a></span><span class="message">overlays were a way to manually page in and out code/data from/to memory/disk in a block way</span></div><div class="line" id="034705"><span class="nick" style="color:#8dd3c7"><a href="#034705" label="[03:47:05]">&lt;muurkha&gt;</a></span><span class="message">I know what overlays are :)</span></div><div class="line" id="034712"><span class="nick" style="color:#8dd3c7"><a href="#034712" label="[03:47:12]">&lt;muurkha&gt;</a></span><span class="message">not usually in a block way though!</span></div><div class="line" id="034749"><span class="nick" style="color:#8dd3c7"><a href="#034749" label="[03:47:49]">&lt;muurkha&gt;</a></span><span class="message">but you said that because of overlays you couldn't agree with that view.  which view did you mean, and what did you disagree with about it?</span></div><div class="line" id="034756"><span class="nick" style="color:#80b1d3"><a href="#034756" label="[03:47:56]">&lt;oriansj&gt;</a></span><span class="message">well when you are short on RAM, block overlays take less code</span></div><div class="line" id="034847"><span class="nick" style="color:#80b1d3"><a href="#034847" label="[03:48:47]">&lt;oriansj&gt;</a></span><span class="message">as segments didn't provide protection as any process could violate all segment protections</span></div><div class="line" id="035014"><span class="nick" style="color:#8dd3c7"><a href="#035014" label="[03:50:14]">&lt;muurkha&gt;</a></span><span class="message">PDP-11 segments are not loadable by user processes, so they do provide protection.  also true of 80286 and 80386 segments, though they weren't used much</span></div><div class="line" id="035050"><span class="nick" style="color:#8dd3c7"><a href="#035050" label="[03:50:50]">&lt;muurkha&gt;</a></span><span class="message">I mean that's how Unix worked</span></div><div class="line" id="035308"><span class="nick" style="color:#8dd3c7"><a href="#035308" label="[03:53:08]">&lt;muurkha&gt;</a></span><span class="message">also true of B5000 segments, though in a different way; on the B5000 you can load all the segments you want at user level, but you can only load them with valid segment descriptors.  you can't convert absolute addresses into segment descriptors that grant you access to that memory (unless, presumably, you're the MCP, but I haven't been able to find any documentation of that)</span></div><div class="line" id="035309"><span class="nick" style="color:#80b1d3"><a href="#035309" label="[03:53:09]">&lt;oriansj&gt;</a></span><span class="message">The 11/20 lacks any kind of memory protection hardware unless retrofitted with a KS-11 memory mapping add-on. (Aka an actual MMU)</span></div><div class="line" id="035415"><span class="nick" style="color:#8dd3c7"><a href="#035415" label="[03:54:15]">&lt;muurkha&gt;</a></span><span class="message">no, it was not an actual MMU: <a rel="nofollow" href="https://www.bell-labs.com/usr/dmr/www/odd.html">https://www.bell-labs.com/usr/dmr/www/odd.html</a> </span></div><div class="line" id="035430"><span class="nick" style="color:#8dd3c7"><a href="#035430" label="[03:54:30]">&lt;muurkha&gt;</a></span><span class="message">&quot;We knew the PDP-11/45, which did support memory mapping and protection for the kernel and other processes, was coming, but not instantly; in anticipation, we arranged with Digital Special Systems to buy a PDP-11/20 with KS-11 add-on. This was an extra system unit bolted to the processor that made it distinguish kernel from user mode, and provided a classical PDP-10 style &quot;hi-seg&quot; &quot;low-seg&quot; memory</span></div><div class="line" id="035436"><span class="nick" style="color:#8dd3c7"><a href="#035436" label="[03:54:36]">&lt;muurkha&gt;</a></span><span class="message">mapping unit. I seem to recall that maybe 6 of these had been made when we ordered it.&quot;</span></div><div class="line" id="035450"><span class="nick" style="color:#8dd3c7"><a href="#035450" label="[03:54:50]">&lt;muurkha&gt;</a></span><span class="message">I mean, not an MMU in the sense of paging.  they did call it a memory mapping unit!</span></div><div class="line" id="035546"><span class="nick" style="color:#8dd3c7"><a href="#035546" label="[03:55:46]">&lt;muurkha&gt;</a></span><span class="message">it just had a high and low address for each segment (a base and limit)</span></div><div class="line" id="035645"><span class="nick" style="color:#80b1d3"><a href="#035645" label="[03:56:45]">&lt;oriansj&gt;</a></span><span class="message">The Burroughs B5000 might not have had a traditional MMU but it did provide the two functions of an MMU - virtual memory addresses and memory protection (abeit in a different architectual way)</span></div><div class="line" id="035723"><span class="nick" style="color:#8dd3c7"><a href="#035723" label="[03:57:23]">&lt;muurkha&gt;</a></span><span class="message">more details at <a rel="nofollow" href="https://www.bell-labs.com/usr/dmr/www/odd.html">https://www.bell-labs.com/usr/dmr/www/odd.html</a> </span></div><div class="line" id="035726"><span class="nick" style="color:#80b1d3"><a href="#035726" label="[03:57:26]">&lt;oriansj&gt;</a></span><span class="message">the 286 had only a segment only MMU</span></div><div class="line" id="035727"><span class="nick" style="color:#8dd3c7"><a href="#035727" label="[03:57:27]">&lt;muurkha&gt;</a></span><span class="message">oops</span></div><div class="line" id="035803"><span class="nick" style="color:#8dd3c7"><a href="#035803" label="[03:58:03]">&lt;muurkha&gt;</a></span><span class="message">I meant <a rel="nofollow" href="http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-11-HGKTCB-D%20PDP-1145%20Memory%20Management%20Reference%20Manual.pdf">http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-11-HGKTCB-D%20PDP-1145%20Memory%20Management%20Reference%20Manual.pdf</a> </span></div><div class="line" id="035837"><span class="nick" style="color:#8dd3c7"><a href="#035837" label="[03:58:37]">&lt;muurkha&gt;</a></span><span class="message">yeah, the base/limit scheme on the PDP-11 also made memory addresses virtual and provided memory protection</span></div><div class="line" id="035843"><span class="nick" style="color:#8dd3c7"><a href="#035843" label="[03:58:43]">&lt;muurkha&gt;</a></span><span class="message">just at a larger granularity</span></div><div class="line" id="035929"><span class="nick" style="color:#80b1d3"><a href="#035929" label="[03:59:29]">&lt;oriansj&gt;</a></span><span class="message">So again segments aren't protection unless there is effective MMU kernel/user separation which is enforced by hardware</span></div><div class="line" id="040234"><span class="nick" style="color:#80b1d3"><a href="#040234" label="[04:02:34]">&lt;oriansj&gt;</a></span><span class="message">otherwise the running code can just change what the segment is pointing to at anytime for any reason</span></div><div class="line" id="040329"><span class="nick" style="color:#8dd3c7"><a href="#040329" label="[04:03:29]">&lt;muurkha&gt;</a></span><span class="message">well, the segmentation mechanism is effective MMU kernel/user separation which is enforced by hardware</span></div><div class="line" id="040337"><span class="nick" style="color:#8dd3c7"><a href="#040337" label="[04:03:37]">&lt;muurkha&gt;</a></span><span class="message">only the kernel can change what the segment is pointing to</span></div><div class="line" id="040754"><span class="nick" style="color:#8dd3c7"><a href="#040754" label="[04:07:54]">&lt;muurkha&gt;</a></span><span class="message">(the manual above calls the segments &quot;pages&quot; but it's clearly talking about what we call segments nowadays, not fixed-size pages)</span></div><div class="line" id="040826"><span class="nick" style="color:#8dd3c7"><a href="#040826" label="[04:08:26]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://gunkies.org/wiki/PDP-11_Memory_Management">https://gunkies.org/wiki/PDP-11_Memory_Management</a>  goes into more detail</span></div><div class="line" id="042333"><span class="nick" style="color:#80b1d3"><a href="#042333" label="[04:23:33]">&lt;oriansj&gt;</a></span><span class="message">muurkha: my point is you can have segmentation mechanism without the separation like you see in x86</span></div><div class="line" id="082240"><span class="nick">***</span><span class="message notice">Guest8836 is now known as roptat</span></div><div class="line" id="114458"><span class="nick" style="color:#8dd3c7"><a href="#114458" label="[11:44:58]">&lt;muurkha&gt;</a></span><span class="message">oriansj: oh, sure, the 8088 had &quot;segmentation&quot; without memory protection</span></div><div class="line" id="134503"><span class="nick" style="color:#6d2462"><a href="#134503" label="[13:45:03]">&lt;theruran&gt;</a></span><span class="message">oriansj: looking at Jitawa and I don't think it would be convenient or maybe even possible to use it for bootstrapping since it doesn't support mutation. that's interesting what you said about sectorLISP though</span></div><div class="line" id="184811"><span class="nick">***</span><span class="message notice">Andrew is now known as WaxCPU</span></div><br /></div></body></html>