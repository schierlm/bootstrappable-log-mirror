<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2021-05-15.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000141"><span class="nick" style="color:#8dd3c7"><a href="#000141" label="[00:01:41]">&lt;fossy&gt;</a></span><span class="message">exams over!!</span></div><div class="line" id="000408"><span class="nick" style="color:#2e2a4a"><a href="#000408" label="[00:04:08]">&lt;xentrac&gt;</a></span><span class="message">yay fossy!</span></div><div class="line" id="001237"><span class="nick" style="color:#6b8072"><a href="#001237" label="[00:12:37]">&lt;stikonas&gt;</a></span><span class="message">fossy: congrats</span></div><div class="line" id="010341"><span class="nick" style="color:#80b1d3"><a href="#010341" label="[01:03:41]">&lt;melg8&gt;</a></span><span class="message">@fossy congratulations!</span></div><div class="line" id="012917"><span class="nick" style="color:#80b1d3"><a href="#012917" label="[01:29:17]">&lt;melg8&gt;</a></span><span class="message">why catm is build with hex0 instead of hex1? <a rel="nofollow" href="https://github.com/oriansj/stage0-posix/blob/cb1c9d585690f6ead54a22caaa508ccd86cb863d/x86/mescc-tools-mini-kaem.kaem#L39">https://github.com/oriansj/stage0-posix/blob/cb1c9d585690f6ead54a22caaa508ccd86cb863d/x86/mescc-tools-mini-kaem.kaem#L39</a> </span></div><div class="line" id="020058"><span class="nick" style="color:#6b8072"><a href="#020058" label="[02:00:58]">&lt;stikonas&gt;</a></span><span class="message">melg8: I guess because it's simple enough and does not require anything labels</span></div><div class="line" id="020217"><span class="nick" style="color:#6b8072"><a href="#020217" label="[02:02:17]">&lt;stikonas&gt;</a></span><span class="message">in principle we don't need it until hex2</span></div><div class="line" id="020224"><span class="nick" style="color:#6b8072"><a href="#020224" label="[02:02:24]">&lt;stikonas&gt;</a></span><span class="message">so it can even be written in hex2</span></div><div class="line" id="020253"><span class="nick" style="color:#6b8072"><a href="#020253" label="[02:02:53]">&lt;stikonas&gt;</a></span><span class="message">only M0 starts using it...</span></div><div class="line" id="020322"><span class="nick" style="color:#6b8072"><a href="#020322" label="[02:03:22]">&lt;stikonas&gt;</a></span><span class="message">alternatively, I guess one can detach elf header from hex2.. and use cat to reattach it...</span></div><div class="line" id="020340"><span class="nick" style="color:#6b8072"><a href="#020340" label="[02:03:40]">&lt;stikonas&gt;</a></span><span class="message">OriansJ: any reason why we are not doing that for hex2 but are doing it for M0?</span></div><div class="line" id="023439"><span class="nick" style="color:#6d2462"><a href="#023439" label="[02:34:39]">&lt;OriansJ&gt;</a></span><span class="message">stikonas: because it is one of those easy jobs that got left on the floor for anyonne who wanted to improve stage0-posix</span></div><div class="line" id="023608"><span class="nick" style="color:#6d2462"><a href="#023608" label="[02:36:08]">&lt;OriansJ&gt;</a></span><span class="message">because if all that remains is hard tasks, it becomes difficult to start contributing to stage0 and feel empowered to make it better.</span></div><div class="line" id="023641"><span class="nick" style="color:#6d2462"><a href="#023641" label="[02:36:41]">&lt;OriansJ&gt;</a></span><span class="message">That is why I work on the annoying/hard tasks and leave the simpler and easier work for other people.</span></div><div class="line" id="023647"><span class="nick" style="color:#6b8072"><a href="#023647" label="[02:36:47]">&lt;stikonas&gt;</a></span><span class="message">ok, I guess that's good, although, maybe there should be some easy task list, so that people would know...</span></div><div class="line" id="023716"><span class="nick" style="color:#6d2462"><a href="#023716" label="[02:37:16]">&lt;OriansJ&gt;</a></span><span class="message">stikonas: fair but writing that list unfortunately landed in my easy pile...</span></div><div class="line" id="023810"><span class="nick" style="color:#6d2462"><a href="#023810" label="[02:38:10]">&lt;OriansJ&gt;</a></span><span class="message">So knowing if spotting those things would be hard is a bit of a meta problem for me.</span></div><div class="line" id="023903"><span class="nick" style="color:#6d2462"><a href="#023903" label="[02:39:03]">&lt;OriansJ&gt;</a></span><span class="message">as they all look obvious</span></div><div class="line" id="024359"><span class="nick" style="color:#6d2462"><a href="#024359" label="[02:43:59]">&lt;OriansJ&gt;</a></span><span class="message">little tweak here, little bug there, spelling mistakes all over the place</span></div><div class="line" id="125750"><span class="nick" style="color:#80b1d3"><a href="#125750" label="[12:57:50]">&lt;melg8&gt;</a></span><span class="message">Hi, in Release_1.7.0 of M2-Planet - there were folder functions. but i dont see it in master, where it is now?</span></div><div class="line" id="155013"><span class="nick" style="color:#6d2462"><a href="#155013" label="[15:50:13]">&lt;OriansJ&gt;</a></span><span class="message">melg8: all library functions have been moved into M2libc</span></div><div class="line" id="155113"><span class="nick" style="color:#6d2462"><a href="#155113" label="[15:51:13]">&lt;OriansJ&gt;</a></span><span class="message">(to reduce duplication and simplify the task of updating the library of functions neeeded by multiple programs)</span></div><div class="line" id="155323"><span class="nick" style="color:#6d2462"><a href="#155323" label="[15:53:23]">&lt;OriansJ&gt;</a></span><span class="message">also instead of using M2-Planet function names, M2libc is the start of using standard C functions instead of intensionally different functions; in effort to simplify porting efforts to M2-Planet</span></div><div class="line" id="173049"><span class="nick" style="color:#234e69"><a href="#173049" label="[17:30:49]">&lt;gforce_d11977&gt;</a></span><span class="message">melg8: here the date-calls: <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/invoked_date_binary.txt">http://intercity-vpn.de/bootstrap/invoked_date_binary.txt</a> </span></div><div class="line" id="173158"><span class="nick" style="color:#80b1d3"><a href="#173158" label="[17:31:58]">&lt;melg8&gt;</a></span><span class="message">gforce_d11977 really nice!</span></div><div class="line" id="173221"><span class="nick" style="color:#234e69"><a href="#173221" label="[17:32:21]">&lt;gforce_d11977&gt;</a></span><span class="message">melg8: but patching date is crap, we should patch the underlying functions (output monotonic raising values) starting at e.g. 01-01-2000</span></div><div class="line" id="173815"><span class="nick" style="color:#6c3d55"><a href="#173815" label="[17:38:15]">&lt;stikonas[m]&gt;</a></span><span class="message">And date binary might not be the only source of date... You can just call libc functions that date uses</span></div><div class="line" id="181548"><span class="nick" style="color:#80b1d3"><a href="#181548" label="[18:15:48]">&lt;melg8&gt;</a></span><span class="message">OriansJ if i build kaem with hex2 vs catm of ELF-i386-debug and than hex2-0 should it differ? and if yes - why?</span></div><div class="line" id="182032"><span class="nick" style="color:#6d2462"><a href="#182032" label="[18:20:32]">&lt;OriansJ&gt;</a></span><span class="message">melg8: there should not be a difference if you -f $file1 -f $file2 .. -f $fileN or catm hold $file1 $file2 .. $fileN and pass them to hex2. now there might be a difference between hex2 written in hex1 and hex2 written in C</span></div><div class="line" id="182127"><span class="nick" style="color:#6d2462"><a href="#182127" label="[18:21:27]">&lt;OriansJ&gt;</a></span><span class="message">also hex1 doesn't support %label&gt;label calculations</span></div><div class="line" id="182156"><span class="nick" style="color:#6d2462"><a href="#182156" label="[18:21:56]">&lt;OriansJ&gt;</a></span><span class="message">nor &amp;label (that is only included in hex2)</span></div><div class="line" id="182246"><span class="nick" style="color:#80b1d3"><a href="#182246" label="[18:22:46]">&lt;melg8&gt;</a></span><span class="message">Thanks! another question: how hard would be to add to kaem functionality of creation directory? i need that so i can copy not just single executable out of whole build, but whole /bin/ dir ?</span></div><div class="line" id="182427"><span class="nick" style="color:#6d2462"><a href="#182427" label="[18:24:27]">&lt;OriansJ&gt;</a></span><span class="message">well if the sys_mkdir is in M2libc (which it is in $arch/Linux/sys/stat.h) you need only include it in your build and call the function with the correct arguments.</span></div><div class="line" id="182905"><span class="nick" style="color:#80b1d3"><a href="#182905" label="[18:29:05]">&lt;melg8&gt;</a></span><span class="message">that's nice, thanks! inside of guix - copy-file &quot;M2-Planet/test/common_x86/x86_defs.M1&quot; &quot;x86/x86_defs.M1&quot; - this is some external tool used to copy stuff around?</span></div><div class="line" id="183018"><span class="nick" style="color:#6d2462"><a href="#183018" label="[18:30:18]">&lt;OriansJ&gt;</a></span><span class="message">melg8: guix leverages gash-utils if I remember correctly. Which is basically core-utils written in scheme and run on guile which is orcastrating the build.</span></div><div class="line" id="183103"><span class="nick" style="color:#80b1d3"><a href="#183103" label="[18:31:03]">&lt;melg8&gt;</a></span><span class="message">but guile is not build from source as part of bootstrap but just &quot;is&quot; in system from binary?</span></div><div class="line" id="183157"><span class="nick" style="color:#6d2462"><a href="#183157" label="[18:31:57]">&lt;OriansJ&gt;</a></span><span class="message">melg8: that is one of the issues with the current guix bootstrap that will be addressed by live-bootstrap when it builds the guix bootstrap seed.</span></div><div class="line" id="183414"><span class="nick" style="color:#80b1d3"><a href="#183414" label="[18:34:14]">&lt;melg8&gt;</a></span><span class="message">don't you know is nix and guix .drv format differ? i've read about guix implementing some kind of interpreter for it's derivations, so it can manage build from &quot;inside&quot; of bootstrapping process?</span></div><div class="line" id="183545"><span class="nick" style="color:#6d2462"><a href="#183545" label="[18:35:45]">&lt;OriansJ&gt;</a></span><span class="message">melg8: well I can't speak to the inner details of guix itself as I don't hack on that but there are certainly people here who do (like civodul and janneke) who probably would be able to answer that question or point you towards people who would know.</span></div><div class="line" id="183624"><span class="nick" style="color:#6d2462"><a href="#183624" label="[18:36:24]">&lt;OriansJ&gt;</a></span><span class="message">just like the POSIX kernel in live-bootstrap is another seed issue that will later need to be addressed.</span></div><div class="line" id="183725"><span class="nick" style="color:#6d2462"><a href="#183725" label="[18:37:25]">&lt;OriansJ&gt;</a></span><span class="message">basically there will be &quot;hand holds&quot; of shrinking sizes as we approach an absolute bootstrap from &quot;nothing&quot;</span></div><div class="line" id="183744"><span class="nick" style="color:#80b1d3"><a href="#183744" label="[18:37:44]">&lt;melg8&gt;</a></span><span class="message">hand holds?</span></div><div class="line" id="183822"><span class="nick" style="color:#6d2462"><a href="#183822" label="[18:38:22]">&lt;OriansJ&gt;</a></span><span class="message">guix was guile+linux+bios+microcode; live-bootstrap is posix+bios+microcode and what comes next will probably be bios+microcode and then solving those as well.</span></div><div class="line" id="183930"><span class="nick" style="color:#6d2462"><a href="#183930" label="[18:39:30]">&lt;OriansJ&gt;</a></span><span class="message">melg8: binary blobs that are used to make the work easier while working down the bootstrap. Like in rock climbing.</span></div><div class="line" id="184003"><span class="nick" style="color:#6d2462"><a href="#184003" label="[18:40:03]">&lt;OriansJ&gt;</a></span><span class="message">Linux+guile made the guix work far easier and enabled a great deal of progress in simplifying the bootstrap.</span></div><div class="line" id="184047"><span class="nick" style="color:#6d2462"><a href="#184047" label="[18:40:47]">&lt;OriansJ&gt;</a></span><span class="message">Now just Linux is being used to keep the bootstrapping work simple as we work to eliminate the need for the guile blob in the bootstrap to guix.</span></div><div class="line" id="184117"><span class="nick" style="color:#6d2462"><a href="#184117" label="[18:41:17]">&lt;OriansJ&gt;</a></span><span class="message">Then we will let go of the POSIX blob when we are able to take the next step down the rockface of bootstrapping to zero.</span></div><div class="line" id="184156"><span class="nick" style="color:#6d2462"><a href="#184156" label="[18:41:56]">&lt;OriansJ&gt;</a></span><span class="message">it is a very iterative process with some duplicated effort but that is the cost of addressing various people's baseline of trust.</span></div><div class="line" id="184334"><span class="nick" style="color:#80b1d3"><a href="#184334" label="[18:43:34]">&lt;melg8&gt;</a></span><span class="message">again, at what stage posix strikes? when build stops be &quot;kernel free&quot;? (if we talking not about stage0-posix, but about stage0 at least)?</span></div><div class="line" id="184431"><span class="nick" style="color:#6d2462"><a href="#184431" label="[18:44:31]">&lt;OriansJ&gt;</a></span><span class="message">melg8: yes stage0 is bare metal only and stage0-posix was created for those people who trust their POSIX kernel (be it Linux, BSD*, etc) but wanted to bootstrap everything else.</span></div><div class="line" id="184502"><span class="nick" style="color:#6d2462"><a href="#184502" label="[18:45:02]">&lt;OriansJ&gt;</a></span><span class="message">just like there will be a stage0-CPM or stage0-DOS should someone need that sort of trust foundation.</span></div><div class="line" id="184504"><span class="nick" style="color:#80b1d3"><a href="#184504" label="[18:45:04]">&lt;melg8&gt;</a></span><span class="message">what about M2-planet?</span></div><div class="line" id="184521"><span class="nick" style="color:#6d2462"><a href="#184521" label="[18:45:21]">&lt;OriansJ&gt;</a></span><span class="message">it runs on bare metal</span></div><div class="line" id="184535"><span class="nick" style="color:#80b1d3"><a href="#184535" label="[18:45:35]">&lt;melg8&gt;</a></span><span class="message">soo its about tcc?</span></div><div class="line" id="184813"><span class="nick" style="color:#80b1d3"><a href="#184813" label="[18:48:13]">&lt;melg8&gt;</a></span><span class="message">i'm between two different directions of personal interest) paranoia tells me do work on developing baremetal, and love for nix build system tells to at least reproduce guix advances for nix) even though i would try live-bootstrap path to it, not requiring nix to use guile for it</span></div><div class="line" id="185321"><span class="nick" style="color:#6d2462"><a href="#185321" label="[18:53:21]">&lt;OriansJ&gt;</a></span><span class="message">melg8: well tcc is a bottle neck for bootstrapping GCC and we need a kernel for it to run. but a POSIX kernel written in the M2-Planet subset would solve that problem entirely (bauen1 is the kernel person if I remember correctly)</span></div><div class="line" id="185336"><span class="nick" style="color:#6d2462"><a href="#185336" label="[18:53:36]">&lt;OriansJ&gt;</a></span><span class="message">but you should work on what feels the most fun so you don't get burned out.</span></div><div class="line" id="185635"><span class="nick" style="color:#80b1d3"><a href="#185635" label="[18:56:35]">&lt;melg8&gt;</a></span><span class="message">do kaem work on baremetal?</span></div><div class="line" id="185834"><span class="nick" style="color:#6d2462"><a href="#185834" label="[18:58:34]">&lt;OriansJ&gt;</a></span><span class="message">melg8: not unless I turn it into a kernel</span></div><div class="line" id="185857"><span class="nick" style="color:#6d2462"><a href="#185857" label="[18:58:57]">&lt;OriansJ&gt;</a></span><span class="message">So all of the steps would have to be manual until you get to after a kernel being built.</span></div><div class="line" id="185937"><span class="nick" style="color:#80b1d3"><a href="#185937" label="[18:59:37]">&lt;melg8&gt;</a></span><span class="message">manual? can't they be encoded inside of c code at least?</span></div><div class="line" id="190002"><span class="nick" style="color:#6d2462"><a href="#190002" label="[19:00:02]">&lt;OriansJ&gt;</a></span><span class="message">melg8: think insert floppy disk and boot computer that doesn't have an operating system installed.</span></div><div class="line" id="190031"><span class="nick" style="color:#6d2462"><a href="#190031" label="[19:00:31]">&lt;OriansJ&gt;</a></span><span class="message">one could automate the qemu bootsteps but that wouldn't actually be on bare metal now would it?</span></div><div class="line" id="190154"><span class="nick" style="color:#80b1d3"><a href="#190154" label="[19:01:54]">&lt;melg8&gt;</a></span><span class="message">yea, but for development that would be nicer, than.. you know, ci running robotic arm with floppy disk each time - to air gaped machine from 90-s</span></div><div class="line" id="190702"><span class="nick" style="color:#6d2462"><a href="#190702" label="[19:07:02]">&lt;OriansJ&gt;</a></span><span class="message">melg8: well the development is going to be rather limited as only the read/write/init functions need any change.</span></div><div class="line" id="190734"><span class="nick" style="color:#6d2462"><a href="#190734" label="[19:07:34]">&lt;OriansJ&gt;</a></span><span class="message">init simply sets what is written to and read from (and any memory setup required)</span></div><div class="line" id="190750"><span class="nick" style="color:#80b1d3"><a href="#190750" label="[19:07:50]">&lt;melg8&gt;</a></span><span class="message">i mean until this kernel stuff is done - it would be nice if it tested not by hands</span></div><div class="line" id="190754"><span class="nick" style="color:#6d2462"><a href="#190754" label="[19:07:54]">&lt;OriansJ&gt;</a></span><span class="message">read just simply reads 1 byte from the input source (be it file, serial port, etc)</span></div><div class="line" id="190818"><span class="nick" style="color:#6d2462"><a href="#190818" label="[19:08:18]">&lt;OriansJ&gt;</a></span><span class="message">write just writes 1 byte to the output destination (be it file, serial oort, etc)</span></div><div class="line" id="190846"><span class="nick" style="color:#6d2462"><a href="#190846" label="[19:08:46]">&lt;OriansJ&gt;</a></span><span class="message">melg8: probably, that is why the CPM/DOS port will probably be the easiest half-step</span></div><div class="line" id="190952"><span class="nick" style="color:#6d2462"><a href="#190952" label="[19:09:52]">&lt;OriansJ&gt;</a></span><span class="message">and anyone is free to do that work if they so desire. the blueprints and standards are readily available.</span></div><div class="line" id="191100"><span class="nick" style="color:#80b1d3"><a href="#191100" label="[19:11:00]">&lt;melg8&gt;</a></span><span class="message">it would require alot of guidance for me, just to get started) never developed kernel stuff and very little c++ baremetal</span></div><div class="line" id="191115"><span class="nick" style="color:#6d2462"><a href="#191115" label="[19:11:15]">&lt;OriansJ&gt;</a></span><span class="message">as hex0, hex1, hex2, M0, M1, cc_* and M2-Planet behaviors are all universal be it on bare-metal, CPM/DOS, POSIX/Linux/*BSD, Windows, VMS, etc</span></div><div class="line" id="191143"><span class="nick" style="color:#6d2462"><a href="#191143" label="[19:11:43]">&lt;OriansJ&gt;</a></span><span class="message">melg8: I am more than happy to guide someone through the work if they desire to do so</span></div><div class="line" id="191255"><span class="nick" style="color:#80b1d3"><a href="#191255" label="[19:12:55]">&lt;melg8&gt;</a></span><span class="message">okay, if i fail with nix attempt, will know that i have plan B what to do)</span></div><div class="line" id="191326"><span class="nick" style="color:#6d2462"><a href="#191326" label="[19:13:26]">&lt;OriansJ&gt;</a></span><span class="message">melg8: if you are failing with nix, it means I didn't give you the help you needed to better understand the pieces.</span></div><div class="line" id="191422"><span class="nick" style="color:#6d2462"><a href="#191422" label="[19:14:22]">&lt;OriansJ&gt;</a></span><span class="message">or I needed to add something to stage0-posix to address those problems</span></div><div class="line" id="191436"><span class="nick" style="color:#6d2462"><a href="#191436" label="[19:14:36]">&lt;OriansJ&gt;</a></span><span class="message">both of which are something that I will do</span></div><div class="line" id="191554"><span class="nick" style="color:#80b1d3"><a href="#191554" label="[19:15:54]">&lt;melg8&gt;</a></span><span class="message">i mean, now it looks like it can be done, and even maybe by me (even with my limited knowledge of nix) but there is alot of nuance stuff, like - build system, people seems don't like large rebuilds, than live-bootstrap which i take as base for this - now not adapted for all arches which nix supports. If i want it to not just be home project for me</span></div><div class="line" id="191555"><span class="nick" style="color:#80b1d3"><a href="#191555" label="[19:15:55]">&lt;melg8&gt;</a></span><span class="message">in nix, but push to nixpkgs - that can be alot more challenging</span></div><div class="line" id="191559"><span class="nick" style="color:#6d2462"><a href="#191559" label="[19:15:59]">&lt;OriansJ&gt;</a></span><span class="message">as there shouldn't be anything magical needed to get nix to build stage0-posix (if you can run a shell stage0-posix will build)</span></div><div class="line" id="191735"><span class="nick" style="color:#80b1d3"><a href="#191735" label="[19:17:35]">&lt;melg8&gt;</a></span><span class="message">i'm starting with kaem. and go from there. i've managed to build 1 package with c-kaem. Now only missing useful part is kaem to be able to make dirs, so i don't need to rerun same process 5 times to get 5 binaries out of it.</span></div><div class="line" id="191803"><span class="nick" style="color:#6d2462"><a href="#191803" label="[19:18:03]">&lt;OriansJ&gt;</a></span><span class="message">well it'll be simple to add mkdir to kaem</span></div><div class="line" id="191944"><span class="nick" style="color:#80b1d3"><a href="#191944" label="[19:19:44]">&lt;melg8&gt;</a></span><span class="message">1 thing i've encountered is - that nix builds stuff in /build directory... and all bits of sources are in /nix/store/ and... default runner (kaem in this case) can't (or can it?) just copy everything from this /store paths to set it in single unified directory. So i rewrote whole build script to use evaluated expressions from nix, so it builds</span></div><div class="line" id="191945"><span class="nick" style="color:#80b1d3"><a href="#191945" label="[19:19:45]">&lt;melg8&gt;</a></span><span class="message">using /store paths instead of relative</span></div><div class="line" id="192005"><span class="nick" style="color:#80b1d3"><a href="#192005" label="[19:20:05]">&lt;melg8&gt;</a></span><span class="message">looks like this</span></div><div class="line" id="192007"><span class="nick" style="color:#80b1d3"><a href="#192007" label="[19:20:07]">&lt;melg8&gt;</a></span><span class="message"> +&gt; /nix/store/v00nmlmnj0qsdc6nprm68hxq4p6hfygp-bootstrap-seeds/POSIX/x86/hex0-seed /nix/store/v00nmlmnj0qsdc6nprm68hxq4p6hfygp-bootstrap-seeds/POSIX/x86/hex0_x86.hex0 hex0</span></div><div class="line" id="192007"><span class="nick" style="color:#80b1d3"><a href="#192007" label="[19:20:07]">&lt;melg8&gt;</a></span><span class="message"> +&gt; hex0 /nix/store/v00nmlmnj0qsdc6nprm68hxq4p6hfygp-bootstrap-seeds/POSIX/x86/kaem-minimal.hex0 kaem-0</span></div><div class="line" id="192008"><span class="nick" style="color:#80b1d3"><a href="#192008" label="[19:20:08]">&lt;melg8&gt;</a></span><span class="message"> +&gt; hex0 /nix/store/6y3ys70mn4sf5a8snyl8bis1ivzvj7bb-source/x86/hex1_x86.hex0 hex1</span></div><div class="line" id="192008"><span class="nick" style="color:#80b1d3"><a href="#192008" label="[19:20:08]">&lt;melg8&gt;</a></span><span class="message"> +&gt; hex0 /nix/store/6y3ys70mn4sf5a8snyl8bis1ivzvj7bb-source/x86/catm_x86.hex0 catm</span></div><div class="line" id="192009"><span class="nick" style="color:#80b1d3"><a href="#192009" label="[19:20:09]">&lt;melg8&gt;</a></span><span class="message"> +&gt; hex1 /nix/store/6y3ys70mn4sf5a8snyl8bis1ivzvj7bb-source/x86/hex2_x86.hex1 hex2-0</span></div><div class="line" id="192009"><span class="nick" style="color:#80b1d3"><a href="#192009" label="[19:20:09]">&lt;melg8&gt;</a></span><span class="message"> +&gt; catm hold /nix/store/6y3ys70mn4sf5a8snyl8bis1ivzvj7bb-source/x86/ELF-i386.hex2 /nix/store/6y3ys70mn4sf5a8snyl8bis1ivzvj7bb-source/x86/M0_x86.hex2</span></div><div class="line" id="192107"><span class="nick" style="color:#80b1d3"><a href="#192107" label="[19:21:07]">&lt;melg8&gt;</a></span><span class="message">but maybe that just my lack of knowledge - and it can be done with nix and kaem to prepare single directory</span></div><div class="line" id="192130"><span class="nick" style="color:#80b1d3"><a href="#192130" label="[19:21:30]">&lt;melg8&gt;</a></span><span class="message">i'll show script to nix guys so they maybe guide me</span></div><div class="line" id="192222"><span class="nick" style="color:#80b1d3"><a href="#192222" label="[19:22:22]">&lt;melg8&gt;</a></span><span class="message">and ... for the record - sha256sums are same as in live-bootstrap</span></div><div class="line" id="192550"><span class="nick" style="color:#80b1d3"><a href="#192550" label="[19:25:50]">&lt;melg8&gt;</a></span><span class="message">and now i'm using catm to copy stuff out of build</span></div><div class="line" id="193036"><span class="nick" style="color:#234e69"><a href="#193036" label="[19:30:36]">&lt;gforce_d11977&gt;</a></span><span class="message">another run, another problem 8-))) tar-1.34 checksum is wrong, here the logs and the graph:</span></div><div class="line" id="193040"><span class="nick" style="color:#234e69"><a href="#193040" label="[19:30:40]">&lt;gforce_d11977&gt;</a></span><span class="message"> <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/memplot-memhack26-1999M.png">http://intercity-vpn.de/bootstrap/memplot-memhack26-1999M.png</a> </span></div><div class="line" id="193056"><span class="nick" style="color:#234e69"><a href="#193056" label="[19:30:56]">&lt;gforce_d11977&gt;</a></span><span class="message"> <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/memplot-memhack26-1999M.txt">http://intercity-vpn.de/bootstrap/memplot-memhack26-1999M.txt</a> </span></div><div class="line" id="193108"><span class="nick" style="color:#234e69"><a href="#193108" label="[19:31:08]">&lt;gforce_d11977&gt;</a></span><span class="message"> <a rel="nofollow" href="http://intercity-vpn.de/bootstrap/memplot-memhack26-1999M-log.txt">http://intercity-vpn.de/bootstrap/memplot-memhack26-1999M-log.txt</a> </span></div><div class="line" id="193541"><span class="nick" style="color:#6d2462"><a href="#193541" label="[19:35:41]">&lt;OriansJ&gt;</a></span><span class="message">melg8: bootstrap-seeds doesn't require a build, they are just taken as built and done.</span></div><div class="line" id="193716"><span class="nick" style="color:#80b1d3"><a href="#193716" label="[19:37:16]">&lt;melg8&gt;</a></span><span class="message">yes, so when i had gcc + coreutils in client side of things - that was 1 download, and if now it is from kaem to coreutis through live-bootstrap - it's like n-times longer</span></div><div class="line" id="193719"><span class="nick" style="color:#6d2462"><a href="#193719" label="[19:37:19]">&lt;OriansJ&gt;</a></span><span class="message">and stage0-posix doesn't use an external bootstrap-seeds but leverages a git submodule to grab a specific version and everything is done via relative paths, so if you just cd to the target directory in nix prior to the build starting, everything will be done in there</span></div><div class="line" id="195340"><span class="nick" style="color:#6d2462"><a href="#195340" label="[19:53:40]">&lt;OriansJ&gt;</a></span><span class="message">welcome to bootstrappable admas. You probably would like stage0-posix and live-bootstrap as things to look at: <a rel="nofollow" href="https://github.com/oriansj/stage0-posix">https://github.com/oriansj/stage0-posix</a>  <a rel="nofollow" href="https://github.com/fosslinux/live-bootstrap">https://github.com/fosslinux/live-bootstrap</a>  and some notes to help one get their mind around it all: <a rel="nofollow" href="https://github.com/oriansj/talk-notes">https://github.com/oriansj/talk-notes</a> </span></div><div class="line" id="195522"><span class="nick" style="color:#6d2462"><a href="#195522" label="[19:55:22]">&lt;OriansJ&gt;</a></span><span class="message">and yes stage0-posix is multi-arch and builds from hex to a minimal cross-platform C compiler and live-bootstrap goes from their to bison and GCC</span></div><div class="line" id="201657"><span class="nick" style="color:#234e69"><a href="#201657" label="[20:16:57]">&lt;gforce_d11977&gt;</a></span><span class="message">dont know, if I have already posted this minimal-single-board-computer for bootstrapping 8-) <a rel="nofollow" href="https://hackaday.com/2018/01/28/the-tiniest-working-68k-system/">https://hackaday.com/2018/01/28/the-tiniest-working-68k-system/</a> </span></div><div class="line" id="201756"><span class="nick" style="color:#234e69"><a href="#201756" label="[20:17:56]">&lt;gforce_d11977&gt;</a></span><span class="message">(&quot;a minimal computer: just a CPU with a serial link and a crystal&quot;)</span></div><div class="line" id="202026"><span class="nick" style="color:#6d2462"><a href="#202026" label="[20:20:26]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: I don't think it'll work that good for bootstrapping. one would want 1 input and 1 output as it is simpler than dealing with 1 input/output. (and require less memory too)</span></div><div class="line" id="202102"><span class="nick" style="color:#234e69"><a href="#202102" label="[20:21:02]">&lt;gforce_d11977&gt;</a></span><span class="message">OriansJ: input/output is done using serial console?!</span></div><div class="line" id="202136"><span class="nick" style="color:#6d2462"><a href="#202136" label="[20:21:36]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: well serial ports or usb or etc</span></div><div class="line" id="202227"><span class="nick" style="color:#6d2462"><a href="#202227" label="[20:22:27]">&lt;OriansJ&gt;</a></span><span class="message">basically one would want a single device to write the output to and a seperate device for reading of input so that everything could be done in as little memory as possible</span></div><div class="line" id="202258"><span class="nick" style="color:#6d2462"><a href="#202258" label="[20:22:58]">&lt;OriansJ&gt;</a></span><span class="message">less transistors and room for potential lithography compromise attacks to alter the output.</span></div><div class="line" id="202350"><span class="nick" style="color:#234e69"><a href="#202350" label="[20:23:50]">&lt;gforce_d11977&gt;</a></span><span class="message">ofcourse you are right, this &quot;tiny m68k system&quot; was just sooo cute. taking this more serious - and hopefully some university will bring it up - would need a lot if thinkering....</span></div><div class="line" id="202353"><span class="nick" style="color:#6d2462"><a href="#202353" label="[20:23:53]">&lt;OriansJ&gt;</a></span><span class="message">also the 68K is far from a simple CPU in comparision to the RISC-II done at Berkley</span></div><div class="line" id="202440"><span class="nick" style="color:#6d2462"><a href="#202440" label="[20:24:40]">&lt;OriansJ&gt;</a></span><span class="message">it certainly is &quot;cute&quot; but not entirely practical in its current form.</span></div><div class="line" id="202442"><span class="nick" style="color:#234e69"><a href="#202442" label="[20:24:42]">&lt;gforce_d11977&gt;</a></span><span class="message">you are right, this beast already has a monitor-implementation onchip</span></div><div class="line" id="202456"><span class="nick" style="color:#234e69"><a href="#202456" label="[20:24:56]">&lt;gforce_d11977&gt;</a></span><span class="message">(untrushted code 8-))</span></div><div class="line" id="202532"><span class="nick" style="color:#6d2462"><a href="#202532" label="[20:25:32]">&lt;OriansJ&gt;</a></span><span class="message">also we would want a system where we could replace individual chips with a trace of individual gates that implement the same functionality. a la Monster 6502</span></div><div class="line" id="202606"><span class="nick" style="color:#234e69"><a href="#202606" label="[20:26:06]">&lt;gforce_d11977&gt;</a></span><span class="message">yeah...</span></div><div class="line" id="202641"><span class="nick" style="color:#6d2462"><a href="#202641" label="[20:26:41]">&lt;OriansJ&gt;</a></span><span class="message">which would work for a simpler CPU architecture with far less microcode requirements.</span></div><div class="line" id="202659"><span class="nick" style="color:#6d2462"><a href="#202659" label="[20:26:59]">&lt;OriansJ&gt;</a></span><span class="message">a 68K cold-fire subset certainly would be possible.</span></div><div class="line" id="202837"><span class="nick" style="color:#6d2462"><a href="#202837" label="[20:28:37]">&lt;OriansJ&gt;</a></span><span class="message">of course this is the sort of technical bit that would only be really solved by someone actually doing the work to prove it one way or the other.</span></div><div class="line" id="202838"><span class="nick" style="color:#234e69"><a href="#202838" label="[20:28:38]">&lt;gforce_d11977&gt;</a></span><span class="message">there was this project where a guy implemented on an 8bit-microcontroller an 32bit ARM-emulator and run Linux on it: this works when you just have enough RAM, so sticking RAM an a monster 6502 and give it a year or 2 to run a live bootstrap would be a nice ARTWORK, e.g. as an museum installation 8-)))</span></div><div class="line" id="202921"><span class="nick" style="color:#234e69"><a href="#202921" label="[20:29:21]">&lt;gforce_d11977&gt;</a></span><span class="message"> <a rel="nofollow" href="https://dmitry.gr/?r=05.Projects&amp;proj=07.%20Linux%20on%208bit">https://dmitry.gr/?r=05.Projects&amp;proj=07.%20Linux%20on%208bit</a> </span></div><div class="line" id="202934"><span class="nick" style="color:#6d2462"><a href="#202934" label="[20:29:34]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: well an 8 bit processor with a 16bit address space couldn't really properly emulate a 32bit CPU</span></div><div class="line" id="203006"><span class="nick" style="color:#6d2462"><a href="#203006" label="[20:30:06]">&lt;OriansJ&gt;</a></span><span class="message">not to mention the 256byte stack limit...</span></div><div class="line" id="203007"><span class="nick" style="color:#234e69"><a href="#203007" label="[20:30:07]">&lt;gforce_d11977&gt;</a></span><span class="message">OriansJ: ofcourse it can. if you have enough time for emulating it.</span></div><div class="line" id="203026"><span class="nick" style="color:#234e69"><a href="#203026" label="[20:30:26]">&lt;gforce_d11977&gt;</a></span><span class="message">dont try to optimize it. it will work.</span></div><div class="line" id="203134"><span class="nick" style="color:#6d2462"><a href="#203134" label="[20:31:34]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: well one would have to create a 32bit state machine which supported writing to a 4+GB disk on a system that couldn't even with GEOS access past 20MB</span></div><div class="line" id="203138"><span class="nick" style="color:#234e69"><a href="#203138" label="[20:31:38]">&lt;gforce_d11977&gt;</a></span><span class="message">&quot;everything which cannot be done in assembler have to be soldered&quot; (or similar)</span></div><div class="line" id="203222"><span class="nick" style="color:#6d2462"><a href="#203222" label="[20:32:22]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: soldering on more memory chips doesn't solve the problem that they can't actually be addressed with the address pins on the address bus.</span></div><div class="line" id="203241"><span class="nick" style="color:#234e69"><a href="#203241" label="[20:32:41]">&lt;gforce_d11977&gt;</a></span><span class="message">OriansJ: easy-peasy-bank-switching 8-)</span></div><div class="line" id="203347"><span class="nick" style="color:#234e69"><a href="#203347" label="[20:33:47]">&lt;gforce_d11977&gt;</a></span><span class="message">just read the posted link, dmitry has done it (and some other guys worked on similar stuff)</span></div><div class="line" id="204116"><span class="nick" style="color:#6d2462"><a href="#204116" label="[20:41:16]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: dmintry did a 32bit arm emulator on AVR which had a 22-bit program counter and 64 banks to switch to. While the 6502 only support 16bit Program counter and 4 banks to switch to (16 if one uses the 6509)</span></div><div class="line" id="204251"><span class="nick" style="color:#6d2462"><a href="#204251" label="[20:42:51]">&lt;OriansJ&gt;</a></span><span class="message">so 28bits of address space is plenty to simulate a sub 256MB process</span></div><div class="line" id="204819"><span class="nick" style="color:#6d2462"><a href="#204819" label="[20:48:19]">&lt;OriansJ&gt;</a></span><span class="message">but let us just assume that is enough memory. You'd need a disk controller for the 6502 that supports a 32bit address space.</span></div><div class="line" id="205314"><span class="nick" style="color:#234e69"><a href="#205314" label="[20:53:14]">&lt;gforce_d11977&gt;</a></span><span class="message">OriansJ: you are thinking too low level. just emulate a program counter with more bits. An reading from/writing to a e.g. 1TB-SD-card (which itself includes untrushted code) can ofcourse be done with 8bits. you &quot;just&quot; have to write a wrapper. again: do not try to optimize that, it is slow anyway...</span></div><div class="line" id="205847"><span class="nick" style="color:#6d2462"><a href="#205847" label="[20:58:47]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: I don't know of any SD-card interfaces for 6502 systems nor any disk systems for 6502 systems that support for than 24bits of address space.</span></div><div class="line" id="210009"><span class="nick" style="color:#6d2462"><a href="#210009" label="[21:00:09]">&lt;OriansJ&gt;</a></span><span class="message">so it would have to be a custom built disk controller and you'll be limited to 1 32KB page of memory at at time (assuming you can squeeze all that functionality into 32KB)</span></div><div class="line" id="210116"><span class="nick" style="color:#6d2462"><a href="#210116" label="[21:01:16]">&lt;OriansJ&gt;</a></span><span class="message">as the data you banked in would be in the same address block you would be executing.</span></div><div class="line" id="210234"><span class="nick" style="color:#6d2462"><a href="#210234" label="[21:02:34]">&lt;OriansJ&gt;</a></span><span class="message">also the 256byte stack limit for the 6502 means you would have to not use the stack for your emulator either; which makes for even more complex of a coding problem.</span></div><div class="line" id="210623"><span class="nick" style="color:#234e69"><a href="#210623" label="[21:06:23]">&lt;gforce_d11977&gt;</a></span><span class="message">it just makes everything slower, but not a show stopper</span></div><div class="line" id="210806"><span class="nick" style="color:#6d2462"><a href="#210806" label="[21:08:06]">&lt;OriansJ&gt;</a></span><span class="message">So assuming you had a custom 32bit (or bigger) hard drive interface; a 6509 with 1MB of RAM and had the time&amp;&amp;skill required to implement an emulator in under 60KB (which also includes its entire stack space, 1KB needed for just holding the register values of the emulator and all state tracking)</span></div><div class="line" id="210847"><span class="nick" style="color:#6d2462"><a href="#210847" label="[21:08:47]">&lt;OriansJ&gt;</a></span><span class="message">and assuming that disk controller could write to the pages that are not banked in.</span></div><div class="line" id="211008"><span class="nick" style="color:#6d2462"><a href="#211008" label="[21:10:08]">&lt;OriansJ&gt;</a></span><span class="message">and all the mapping between the instructions and the opcodes</span></div><div class="line" id="211111"><span class="nick" style="color:#6d2462"><a href="#211111" label="[21:11:11]">&lt;OriansJ&gt;</a></span><span class="message">unless you used seperate pages for the various opcodes and their implementations that you had to bank in and out for every single instruction.</span></div><div class="line" id="211311"><span class="nick" style="color:#6d2462"><a href="#211311" label="[21:13:11]">&lt;OriansJ&gt;</a></span><span class="message">but all of this depends on a Disk drive that doesn't exist yet and has a bunch of unique properties.</span></div><div class="line" id="211650"><span class="nick" style="color:#6d2462"><a href="#211650" label="[21:16:50]">&lt;OriansJ&gt;</a></span><span class="message">or what would be far simpler is just take the monster 6502, expand the PC and stack to 32bits and then this entire bit would be trivial</span></div><div class="line" id="211800"><span class="nick" style="color:#6d2462"><a href="#211800" label="[21:18:00]">&lt;OriansJ&gt;</a></span><span class="message">or do a monster-risc-II</span></div><div class="line" id="211903"><span class="nick" style="color:#6d2462"><a href="#211903" label="[21:19:03]">&lt;OriansJ&gt;</a></span><span class="message">drop the number of registers down to 16 and it might end up taking less gates than the monster6502</span></div><div class="line" id="212300"><span class="nick" style="color:#6d2462"><a href="#212300" label="[21:23:00]">&lt;OriansJ&gt;</a></span><span class="message">the Turing limitation is always about the size of the addressable memory space. If you have infinite amount of RAM anything is possible but if you only have 4bits of address space, you can't simulate shit.</span></div><div class="line" id="213242"><span class="nick" style="color:#6d2462"><a href="#213242" label="[21:32:42]">&lt;OriansJ&gt;</a></span><span class="message">So shoe-horning in a 32bit disk drive would give you enough address bits if you are clever enough to simulate what you wanted but with any standard 6502 disk drive, it is impossible without a human playing floppy disk pager for the simulator.</span></div><div class="line" id="220145"><span class="nick" style="color:#d9d9d9"><a href="#220145" label="[22:01:45]">&lt;civodul&gt;</a></span><span class="message">melg8: Guix uses pretty much the same .drv format as Nix (yet they're not interchangeable in practice)</span></div><div class="line" id="220219"><span class="nick" style="color:#80b1d3"><a href="#220219" label="[22:02:19]">&lt;melg8&gt;</a></span><span class="message">but... whyy...</span></div><div class="line" id="220236"><span class="nick" style="color:#d9d9d9"><a href="#220236" label="[22:02:36]">&lt;civodul&gt;</a></span><span class="message">melg8: regarding the impact of the kernel in bootstrapping, there are thoughts on how to bootstrap from very little on GNU/Hurd: <a rel="nofollow" href="https://guix.gnu.org/en/blog/2020/childhurds-and-substitutes/">https://guix.gnu.org/en/blog/2020/childhurds-and-substitutes/</a>  (see &quot;Isolated build environments&quot;)</span></div><div class="line" id="220351"><span class="nick" style="color:#d9d9d9"><a href="#220351" label="[22:03:51]">&lt;civodul&gt;</a></span><span class="message">there's also been an experiment to bootstrap on Linux + bare metal (without guix-daemon): <a rel="nofollow" href="https://guix.gnu.org/en/blog/2019/reproducible-builds-summit-5th-edition/">https://guix.gnu.org/en/blog/2019/reproducible-builds-summit-5th-edition/</a> </span></div><div class="line" id="220500"><span class="nick" style="color:#80b1d3"><a href="#220500" label="[22:05:00]">&lt;melg8&gt;</a></span><span class="message">btw, who is  David (Nix), - and where is source for nix?)</span></div><div class="line" id="220506"><span class="nick" style="color:#80b1d3"><a href="#220506" label="[22:05:06]">&lt;melg8&gt;</a></span><span class="message">from that article</span></div><div class="line" id="220524"><span class="nick" style="color:#bc80bd"><a href="#220524" label="[22:05:24]">&lt;vagrantc&gt;</a></span><span class="message">i love it when people take my wild crazy ideas made in jest and actually implement them :)</span></div><div class="line" id="220608"><span class="nick" style="color:#bc80bd"><a href="#220608" label="[22:06:08]">&lt;vagrantc&gt;</a></span><span class="message">xwvvvvwx: i think you are being asked about ... haven't heard from you in a while ...</span></div><div class="line" id="220614"><span class="nick" style="color:#3c5b35"><a href="#220614" label="[22:06:14]">*</a></span><span class="message">vagrantc waves to xwvvvvwx </span></div><div class="line" id="221001"><span class="nick" style="color:#234e69"><a href="#221001" label="[22:10:01]">&lt;gforce_d11977&gt;</a></span><span class="message">OriansJ: i have to think about it. implementing the emulator in 60k is indeed needed...</span></div><div class="line" id="223604"><span class="nick" style="color:#6d2462"><a href="#223604" label="[22:36:04]">&lt;OriansJ&gt;</a></span><span class="message">gforce_d11977: well sweet-16 fits in 300bytes because thankfully 6502 does have a 16bit PC and one doesn't need to simulate via disk paging and 1byte opcodes only and 32 zero page addresses for the 16 registers (R0-R15)</span></div><div class="line" id="223805"><span class="nick" style="color:#6d2462"><a href="#223805" label="[22:38:05]">&lt;OriansJ&gt;</a></span><span class="message">So only 16 opcodes to implement</span></div><div class="line" id="223809"><span class="nick" style="color:#6d2462"><a href="#223809" label="[22:38:09]">&lt;OriansJ&gt;</a></span><span class="message"> <a rel="nofollow" href="http://www.6502.org/source/interpreters/sweet16.htm">http://www.6502.org/source/interpreters/sweet16.htm</a> </span></div><div class="line" id="224502"><span class="nick" style="color:#6d2462"><a href="#224502" label="[22:45:02]">&lt;OriansJ&gt;</a></span><span class="message">but to support the 1KB required to support arm, x86 or AMD64 registers +scratch registers; you wouldn't be able to leverage the zero-page instructions like woz did</span></div><div class="line" id="224811"><span class="nick" style="color:#6d2462"><a href="#224811" label="[22:48:11]">&lt;OriansJ&gt;</a></span><span class="message">so limited to indexed absolute instructions (3 bytes) per</span></div><div class="line" id="225408"><span class="nick" style="color:#6d2462"><a href="#225408" label="[22:54:08]">&lt;OriansJ&gt;</a></span><span class="message">and assuming only 5 instructions per primitive operation (and zero bytes spent on decoding). (4 single byte writes and a jump instruction to return.) to implement the over 4000 unique ARM opcodes; you already blew your 60KB budget and you didn't even add the complex state bits required for paging out to disk</span></div><div class="line" id="225550"><span class="nick" style="color:#6d2462"><a href="#225550" label="[22:55:50]">&lt;OriansJ&gt;</a></span><span class="message">So you are either going to have to do an arm subset or do a programming paging implementation for the various instructions you wish to implement.</span></div><div class="line" id="225654"><span class="nick" style="color:#6d2462"><a href="#225654" label="[22:56:54]">&lt;OriansJ&gt;</a></span><span class="message">so lets assume you figure all that out (entirely possible given enough effort)</span></div><div class="line" id="225923"><span class="nick" style="color:#6d2462"><a href="#225923" label="[22:59:23]">&lt;OriansJ&gt;</a></span><span class="message">and go with the 6509 to get the ability to use a sweet 1MB of RAM if you use 64KB pages but then you'll have duplicate the registers between the pages which requires scratch writes out to disk or you could use 32KB register banks but be limited to 512KB</span></div><div class="line" id="230019"><span class="nick" style="color:#6d2462"><a href="#230019" label="[23:00:19]">&lt;OriansJ&gt;</a></span><span class="message">and you'll have to allocate 1 of them for the RAM of the virtual machine you'll be paging out to disk.</span></div><div class="line" id="230425"><span class="nick" style="color:#6d2462"><a href="#230425" label="[23:04:25]">&lt;OriansJ&gt;</a></span><span class="message">But the biggest 6502 floppy drive only had 800 KB of storage capacity to work with and the biggest 6502 hard drive only had 32MB of capacity.</span></div><div class="line" id="230536"><span class="nick" style="color:#6d2462"><a href="#230536" label="[23:05:36]">&lt;OriansJ&gt;</a></span><span class="message">so you'll need 1310 floppy disks that you would have to be visually alerted to insert and remove</span></div><div class="line" id="230646"><span class="nick" style="color:#6d2462"><a href="#230646" label="[23:06:46]">&lt;OriansJ&gt;</a></span><span class="message">or an external robot to handle the swapping of floppies and all the control routines required.</span></div><div class="line" id="230917"><span class="nick" style="color:#6d2462"><a href="#230917" label="[23:09:17]">&lt;OriansJ&gt;</a></span><span class="message">So it is possible to do gforce_d11977 (assuming external user floppy paging or robotic floppy paging) and some extremely clever and tight code implementing only an essential subset of ARM or x86 or AMD64</span></div><div class="line" id="231248"><span class="nick" style="color:#6d2462"><a href="#231248" label="[23:12:48]">&lt;OriansJ&gt;</a></span><span class="message">So anyone who manages given all of that will have achieved something seriously difficult and impressive even if the emulator takes up 480KB in RAM</span></div><div class="line" id="231843"><span class="nick" style="color:#6d2462"><a href="#231843" label="[23:18:43]">&lt;OriansJ&gt;</a></span><span class="message">with bank switching potentially every 10 simulated instructions (10 millisecond delay) but leveraging a blazing fast 20Mhz 6502 core; you are looking at best case of a 2Khz simulated CPU speed. (floppy disk I/O latency will be a major factor)</span></div><div class="line" id="232202"><span class="nick" style="color:#6d2462"><a href="#232202" label="[23:22:02]">&lt;OriansJ&gt;</a></span><span class="message">So 347.22-ish days boot time to linux</span></div><div class="line" id="232252"><span class="nick" style="color:#6d2462"><a href="#232252" label="[23:22:52]">&lt;OriansJ&gt;</a></span><span class="message">assuming zero bit flips or data integrity errors occuring in that time period.</span></div><div class="line" id="232500"><span class="nick" style="color:#2e2a4a"><a href="#232500" label="[23:25:00]">&lt;xentrac&gt;</a></span><span class="message">hmm, why would an emulator take up 480KB?</span></div><div class="line" id="232512"><span class="nick" style="color:#6d2462"><a href="#232512" label="[23:25:12]">&lt;OriansJ&gt;</a></span><span class="message">with half of your 16 banks being used just to store your 256KB instruction lookup table according to the dmitry.gr link you provided.</span></div><div class="line" id="232615"><span class="nick" style="color:#6d2462"><a href="#232615" label="[23:26:15]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: ARM is far from a simple state machine with over 4K unique instructions</span></div><div class="line" id="232658"><span class="nick" style="color:#2e2a4a"><a href="#232658" label="[23:26:58]">&lt;xentrac&gt;</a></span><span class="message">oh, because you're implementing all the opcodes</span></div><div class="line" id="232716"><span class="nick" style="color:#6d2462"><a href="#232716" label="[23:27:16]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: using only 8bit instructions</span></div><div class="line" id="232730"><span class="nick" style="color:#2e2a4a"><a href="#232730" label="[23:27:30]">&lt;xentrac&gt;</a></span><span class="message">the usual i386 registers are 4-byte EIP ESP EBP ESI EDI EAX EBX ECX EDX, right?  36 bytes on the zero page?  I think that will fit in 1K</span></div><div class="line" id="232833"><span class="nick" style="color:#2e2a4a"><a href="#232833" label="[23:28:33]">&lt;xentrac&gt;</a></span><span class="message">I feel like 99% of i386 instructions executed are probably covered by about 30 opcodes and 5 addressing modes</span></div><div class="line" id="232847"><span class="nick" style="color:#2e2a4a"><a href="#232847" label="[23:28:47]">&lt;xentrac&gt;</a></span><span class="message">of course if the other 1% requires you to swap a floppy disk that's ... still not okay</span></div><div class="line" id="233018"><span class="nick" style="color:#af8d2f"><a href="#233018" label="[23:30:18]">&lt;gef&gt;</a></span><span class="message">oriansj: &quot;only an essential subset of ARM or x86 or AMD64&quot; - after some tried experimentation of mine, my conclusion is that the essential subset is the SBN4 int32 architecture. This would be enough to arrive up to M2-planet without big hurdles. Getting a posix kernel working though, is a different game. Also, banking isn't such a big deal. Amstrad's CPC series had its ROMs overlapping all the RAM banks. If you program consciously around it, the</span></div><div class="line" id="233018"><span class="nick" style="color:#af8d2f"><a href="#233018" label="[23:30:18]">&lt;gef&gt;</a></span><span class="message">overheads aren't excessive.</span></div><div class="line" id="233029"><span class="nick" style="color:#6d2462"><a href="#233029" label="[23:30:29]">&lt;OriansJ&gt;</a></span><span class="message">don't forget scratch registers for immediates, address to bank register mapping, etc</span></div><div class="line" id="233053"><span class="nick" style="color:#2e2a4a"><a href="#233053" label="[23:30:53]">&lt;xentrac&gt;</a></span><span class="message">if you're on a von Neumann machine you can JIT-compile each basic block into a JIT cache, which would probably give you more like a 20× slowdown (20 6502 instructions per i386 instruction) than a 10000× slowdown</span></div><div class="line" id="233059"><span class="nick" style="color:#2e2a4a"><a href="#233059" label="[23:30:59]">&lt;xentrac&gt;</a></span><span class="message">SBN4?</span></div><div class="line" id="233148"><span class="nick" style="color:#6d2462"><a href="#233148" label="[23:31:48]">&lt;OriansJ&gt;</a></span><span class="message">gef: so you want to emulate a 64bit architecture to run the emulation of a 32bit architecture?</span></div><div class="line" id="233242"><span class="nick" style="color:#af8d2f"><a href="#233242" label="[23:32:42]">&lt;gef&gt;</a></span><span class="message">* essential subset -&gt; I mean the essential subset across _all_ hardware (architectures) and software (languages. Yes, I mean that sbn4  (<a rel="nofollow" href="https://en.wikipedia.org/wiki/One-instruction_set_computer#subneg4">https://en.wikipedia.org/wiki/One-instruction_set_computer#subneg4</a>)  is the minimal layer to even bootstrap from within a *computer language*. It's emulation is a triviality - for most languages it is just an oneliner.</span></div><div class="line" id="233305"><span class="nick" style="color:#2e2a4a"><a href="#233305" label="[23:33:05]">&lt;xentrac&gt;</a></span><span class="message">JIT is less doable on an AVR where erasing a block of NAND takes milliseconds</span></div><div class="line" id="233318"><span class="nick" style="color:#2e2a4a"><a href="#233318" label="[23:33:18]">&lt;xentrac&gt;</a></span><span class="message">oh, oisc subneg4</span></div><div class="line" id="233322"><span class="nick" style="color:#af8d2f"><a href="#233322" label="[23:33:22]">&lt;gef&gt;</a></span><span class="message">32bit should be the right model, since it can be emulated efficiently from architectures from the 80s onwards (and some before, z80 wouldn't be to bad due to efficient 16 bit register arithmetic)</span></div><div class="line" id="233341"><span class="nick" style="color:#af8d2f"><a href="#233341" label="[23:33:41]">&lt;gef&gt;</a></span><span class="message">*to -&gt; too</span></div><div class="line" id="233436"><span class="nick" style="color:#2e2a4a"><a href="#233436" label="[23:34:36]">&lt;xentrac&gt;</a></span><span class="message">oisc is fun but I suspect you can do better with a misc-like approach or Wirth's RISC (or MIPSter's RISC-U)</span></div><div class="line" id="233608"><span class="nick" style="color:#80b1d3"><a href="#233608" label="[23:36:08]">&lt;melg8&gt;</a></span><span class="message">@OriansJ when we build kaem from sources for the fist time, where &lt;stdio&gt; header comes from? i dont se it in M2 call</span></div><div class="line" id="234423"><span class="nick" style="color:#6d2462"><a href="#234423" label="[23:44:23]">&lt;OriansJ&gt;</a></span><span class="message">melg8: #include ... is a null op in M2-Planet because it is meaningless in bare metal</span></div><div class="line" id="234503"><span class="nick" style="color:#6d2462"><a href="#234503" label="[23:45:03]">&lt;OriansJ&gt;</a></span><span class="message">So asking where stdio isn't the question but the stdio functions that are used; which always must be in the -f $files listed in the build</span></div><div class="line" id="235027"><span class="nick" style="color:#6d2462"><a href="#235027" label="[23:50:27]">&lt;OriansJ&gt;</a></span><span class="message">gef: in an absolute turing sense yes that might be true. In the oh god imagine having trying to an ARM emulator in OISC instructions; I am not gonna touch that.</span></div><div class="line" id="235052"><span class="nick" style="color:#80b1d3"><a href="#235052" label="[23:50:52]">&lt;melg8&gt;</a></span><span class="message">OriansJ okay, than if i have implementation of function in header, what should i do to use it in kaem build with M2? (<a rel="nofollow" href="https://github.com/oriansj/M2libc/blob/main/x86/Linux/sys/stat.h">https://github.com/oriansj/M2libc/blob/main/x86/Linux/sys/stat.h</a>) </span></div><div class="line" id="235202"><span class="nick" style="color:#6d2462"><a href="#235202" label="[23:52:02]">&lt;OriansJ&gt;</a></span><span class="message">melg8: -f M2libc/x86/Linux/sys/stat.h probably</span></div><div class="line" id="235222"><span class="nick" style="color:#80b1d3"><a href="#235222" label="[23:52:22]">&lt;melg8&gt;</a></span><span class="message">does order matter?</span></div><div class="line" id="235233"><span class="nick" style="color:#80b1d3"><a href="#235233" label="[23:52:33]">&lt;melg8&gt;</a></span><span class="message">order of -f calls</span></div><div class="line" id="235244"><span class="nick" style="color:#6d2462"><a href="#235244" label="[23:52:44]">&lt;OriansJ&gt;</a></span><span class="message">melg8: yes, unless C prototypes are used in the files.</span></div><div class="line" id="235331"><span class="nick" style="color:#80b1d3"><a href="#235331" label="[23:53:31]">&lt;melg8&gt;</a></span><span class="message">and what are the rules for order? i should add this file before file where i want to use it?</span></div><div class="line" id="235817"><span class="nick" style="color:#6d2462"><a href="#235817" label="[23:58:17]">&lt;OriansJ&gt;</a></span><span class="message">melg8: left to right like if you used cat. So imagine cat $file1 $file2 .. $fileN &gt; $input and you passed only that code to the C compiler</span></div><div class="line" id="235824"><span class="nick" style="color:#80b1d3"><a href="#235824" label="[23:58:24]">&lt;melg8&gt;</a></span><span class="message">why mescc-tools/stage0-posix/m2-planet - all have master, and m2-libc - main?)</span></div><div class="line" id="235846"><span class="nick" style="color:#6d2462"><a href="#235846" label="[23:58:46]">&lt;OriansJ&gt;</a></span><span class="message">melg8: github changed the default from master to main</span></div><div class="line" id="235906"><span class="nick" style="color:#6d2462"><a href="#235906" label="[23:59:06]">&lt;OriansJ&gt;</a></span><span class="message">and it wasn't a detail that mattered to me</span></div><div class="line" id="235913"><span class="nick" style="color:#80b1d3"><a href="#235913" label="[23:59:13]">&lt;melg8&gt;</a></span><span class="message">now i cant make universal download function))</span></div><div class="line" id="235955"><span class="nick" style="color:#6d2462"><a href="#235955" label="[23:59:55]">&lt;OriansJ&gt;</a></span><span class="message">if you make a master branch for M2libc, I'll merge it and then you'll have it</span></div><br /></div></body></html>