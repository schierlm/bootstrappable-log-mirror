<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2020-08-19.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="020159"><span class="nick">***</span><span class="message notice">nckx is now known as PotentialUser-93</span></div><div class="line" id="020203"><span class="nick">***</span><span class="message notice">PotentialUser-93 is now known as nckx</span></div><div class="line" id="033231"><span class="nick" style="color:#8dd3c7"><a href="#033231" label="[03:32:31]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: you are correct in that it isn't until cc_x86 and M2-Planet are there types (int, char, pointers, array, struct and union) [basically everything one would need to write a Compiler or interpreter) with M2-Planet supporting const (and promptly discarding it) and different operations for signed/unsigned integers</span></div><div class="line" id="033737"><span class="nick" style="color:#8dd3c7"><a href="#033737" label="[03:37:37]">&lt;OriansJ`&gt;</a></span><span class="message">Other features of cc_x86 and M2-Planet are: functions, globals, locals, conditionals (if/else), iterators (do/while/for), flow control (continue/break/goto/labels), array reference (a[x] = 1; i = b[3];), struct reference (a-&gt;next-&gt;next = NULL; i = a-&gt;value;), custom types with sizeof support and inline assembly</span></div><div class="line" id="034402"><span class="nick" style="color:#8dd3c7"><a href="#034402" label="[03:44:02]">&lt;OriansJ`&gt;</a></span><span class="message">if you wish for an example of a program that uses a good set of C features used: <a rel="nofollow" href="https://github.com/oriansj/mes-m2">https://github.com/oriansj/mes-m2</a> </span></div><div class="line" id="034933"><span class="nick" style="color:#8dd3c7"><a href="#034933" label="[03:49:33]">&lt;OriansJ`&gt;</a></span><span class="message">and because C's Macro system is stupid for auditability/clarity I made # line comments in M2-Planet/cc_x86 and // as ignored tokens; so one can do //CONSTANT foo 4 and #define foo 4 and get the same behavior or //CONSTANT cell_size sizeof(struct cell) and #define cell_size 1 to compensate for the fact 1 + pointer in M2-Planet/cc_x86 is the next byte and in C could mean 700+ bytes later depending upon the pointer type</span></div><div class="line" id="035105"><span class="nick" style="color:#8dd3c7"><a href="#035105" label="[03:51:05]">&lt;OriansJ`&gt;</a></span><span class="message">Other than that; M2-Planet/cc_x86 are a pure C core subset capable of anything you would need</span></div><div class="line" id="035709"><span class="nick" style="color:#8dd3c7"><a href="#035709" label="[03:57:09]">&lt;OriansJ`&gt;</a></span><span class="message">The next step is getting MesCC to work on guile (to simplify the task of mes-m2 incrementially becoming compatible)</span></div><div class="line" id="040801"><span class="nick">***</span><span class="message notice">V is now known as Guest7215</span></div><div class="line" id="041910"><span class="nick">***</span><span class="message notice">V_ is now known as V</span></div><div class="line" id="145100"><span class="nick" style="color:#2e2a4a"><a href="#145100" label="[14:51:00]">&lt;bauen1&gt;</a></span><span class="message">so my backdoor poc for hex0-seed can now check for outputs that are elf headers like itself and then modifies the p_filesz/p_memsz to make room for itself and hijacks the entry vector</span></div><div class="line" id="145136"><span class="nick" style="color:#2e2a4a"><a href="#145136" label="[14:51:36]">&lt;bauen1&gt;</a></span><span class="message">it's now also ~1kb big, but the code is still very straight forward and unoptimised</span></div><div class="line" id="145250"><span class="nick" style="color:#6b8072"><a href="#145250" label="[14:52:50]">*</a></span><span class="message">janneke can imagine the news headlines</span></div><div class="line" id="145306"><span class="nick" style="color:#2e2a4a"><a href="#145306" label="[14:53:06]">&lt;bauen1&gt;</a></span><span class="message">i could change the way the write and exit syscalls are invoked across all compilers to be simpler and more uniform to make my life easier</span></div><div class="line" id="145319"><span class="nick" style="color:#2e2a4a"><a href="#145319" label="[14:53:19]">&lt;bauen1&gt;</a></span><span class="message">janneke: you can still find the backdoor very easily</span></div><div class="line" id="145341"><span class="nick" style="color:#80b1d3"><a href="#145341" label="[14:53:41]">&lt;janneke&gt;</a></span><span class="message">bauen1: yeah, but who reads the rest of the article nowadays?</span></div><div class="line" id="145345"><span class="nick" style="color:#80b1d3"><a href="#145345" label="[14:53:45]">&lt;janneke&gt;</a></span><span class="message">;)</span></div><div class="line" id="145359"><span class="nick" style="color:#2e2a4a"><a href="#145359" label="[14:53:59]">&lt;bauen1&gt;</a></span><span class="message">lol</span></div><div class="line" id="145500"><span class="nick" style="color:#80b1d3"><a href="#145500" label="[14:55:00]">&lt;janneke&gt;</a></span><span class="message">most secure so-called &quot;full source bootstrap&quot; compromised</span></div><div class="line" id="153415"><span class="nick" style="color:#8dd3c7"><a href="#153415" label="[15:34:15]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: except for one small problem, not all hex0 are ELF or COM but some are just pure binary. no entry vector, just execute the first byte of the file</span></div><div class="line" id="153655"><span class="nick" style="color:#2e2a4a"><a href="#153655" label="[15:36:55]">&lt;bauen1&gt;</a></span><span class="message">true</span></div><div class="line" id="153708"><span class="nick" style="color:#2e2a4a"><a href="#153708" label="[15:37:08]">&lt;bauen1&gt;</a></span><span class="message">but that would be even easier to plant a backdoor in</span></div><div class="line" id="153722"><span class="nick" style="color:#2e2a4a"><a href="#153722" label="[15:37:22]">&lt;bauen1&gt;</a></span><span class="message">at the same time also easier to detect</span></div><div class="line" id="153746"><span class="nick" style="color:#2e2a4a"><a href="#153746" label="[15:37:46]">&lt;bauen1&gt;</a></span><span class="message">just put the bootstrap code up front and the payload at the end (figuring out where the payload is could be a bit complicated)</span></div><div class="line" id="153822"><span class="nick" style="color:#8dd3c7"><a href="#153822" label="[15:38:22]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: except the first instruction would have to be a jump or call and thus the payload would be the very first thing inspected</span></div><div class="line" id="154000"><span class="nick" style="color:#8dd3c7"><a href="#154000" label="[15:40:00]">&lt;OriansJ`&gt;</a></span><span class="message">as hex0 does not buffer input or output; so you would have to write your setup before the main program could write a byte or have to shift the entire contents of the file</span></div><div class="line" id="154009"><span class="nick" style="color:#8dd3c7"><a href="#154009" label="[15:40:09]">&lt;OriansJ`&gt;</a></span><span class="message">after the fact</span></div><div class="line" id="154107"><span class="nick" style="color:#2e2a4a"><a href="#154107" label="[15:41:07]">&lt;bauen1&gt;</a></span><span class="message">i just write my own start code (bootstrap0 a few bytes ) that jumps to the bigger payload (aka. bootstrap1) that just copies the original start code where it should be and jumps to it as if nothing happened</span></div><div class="line" id="154125"><span class="nick" style="color:#2e2a4a"><a href="#154125" label="[15:41:25]">&lt;bauen1&gt;</a></span><span class="message">it works quite well for amd64 elf</span></div><div class="line" id="154228"><span class="nick" style="color:#8dd3c7"><a href="#154228" label="[15:42:28]">&lt;OriansJ`&gt;</a></span><span class="message">and you also have no idea about output size until after you read all of the input</span></div><div class="line" id="154229"><span class="nick" style="color:#2e2a4a"><a href="#154229" label="[15:42:29]">&lt;bauen1&gt;</a></span><span class="message">but all of the backdoor is really dependent on the ABI and what tools are exposed by assembly</span></div><div class="line" id="154254"><span class="nick" style="color:#2e2a4a"><a href="#154254" label="[15:42:54]">&lt;bauen1&gt;</a></span><span class="message">which is why i load the memsz from the elf header in my backdoor to figure it out</span></div><div class="line" id="154303"><span class="nick" style="color:#2e2a4a"><a href="#154303" label="[15:43:03]">&lt;bauen1&gt;</a></span><span class="message">but you could also do a pattern search and hope for the best</span></div><div class="line" id="154334"><span class="nick" style="color:#8dd3c7"><a href="#154334" label="[15:43:34]">&lt;OriansJ`&gt;</a></span><span class="message">but raw binaries could be anything, including indirect hex binaries</span></div><div class="line" id="154348"><span class="nick" style="color:#2e2a4a"><a href="#154348" label="[15:43:48]">&lt;bauen1&gt;</a></span><span class="message">oh i see what you're getting at</span></div><div class="line" id="154359"><span class="nick" style="color:#2e2a4a"><a href="#154359" label="[15:43:59]">&lt;bauen1&gt;</a></span><span class="message">yes that would be a very big issue</span></div><div class="line" id="154405"><span class="nick" style="color:#8dd3c7"><a href="#154405" label="[15:44:05]">&lt;OriansJ`&gt;</a></span><span class="message">eg input could be hex with the output being the source code we know is good</span></div><div class="line" id="154430"><span class="nick" style="color:#8dd3c7"><a href="#154430" label="[15:44:30]">&lt;OriansJ`&gt;</a></span><span class="message">really easy to catch additions or subtractions or modifications</span></div><div class="line" id="154612"><span class="nick" style="color:#8dd3c7"><a href="#154612" label="[15:46:12]">&lt;OriansJ`&gt;</a></span><span class="message">also we could do a self-checking sha256sum program; which just outputs its own memory's sha256sum.</span></div><div class="line" id="154654"><span class="nick" style="color:#2e2a4a"><a href="#154654" label="[15:46:54]">&lt;bauen1&gt;</a></span><span class="message">but everything that has a common binary header (or start e.g. push rax push rbx push rdx) can be easily detected</span></div><div class="line" id="154727"><span class="nick" style="color:#2e2a4a"><a href="#154727" label="[15:47:27]">&lt;bauen1&gt;</a></span><span class="message">yeah that would catch this (assuming you know the correct output)</span></div><div class="line" id="154814"><span class="nick" style="color:#8dd3c7"><a href="#154814" label="[15:48:14]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: only if one uses the turbo pascal standard for function calls; M2-Planet doesn't</span></div><div class="line" id="154851"><span class="nick" style="color:#8dd3c7"><a href="#154851" label="[15:48:51]">&lt;OriansJ`&gt;</a></span><span class="message">push can be just a mov rax [rbx]; add rbx, 8</span></div><div class="line" id="154922"><span class="nick" style="color:#8dd3c7"><a href="#154922" label="[15:49:22]">&lt;OriansJ`&gt;</a></span><span class="message">or sub rbx, 8 if you want the stack to grow in the proper direction (up)</span></div><div class="line" id="155038"><span class="nick" style="color:#8dd3c7"><a href="#155038" label="[15:50:38]">&lt;OriansJ`&gt;</a></span><span class="message">as there is pass via register, pass via stack or pass via both (common in optimizing compilers)</span></div><div class="line" id="155109"><span class="nick" style="color:#2e2a4a"><a href="#155109" label="[15:51:09]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: but the platform that runs the binaries (in almost all cases) has some form of ABI defined</span></div><div class="line" id="155129"><span class="nick" style="color:#8dd3c7"><a href="#155129" label="[15:51:29]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: only for system calls such as read and write</span></div><div class="line" id="155133"><span class="nick" style="color:#2e2a4a"><a href="#155133" label="[15:51:33]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: for linux-x86_64 it would be the elf header or that certain registeres can be / are clobbered by the kernel</span></div><div class="line" id="155139"><span class="nick" style="color:#8dd3c7"><a href="#155139" label="[15:51:39]">&lt;OriansJ`&gt;</a></span><span class="message">everything else we can do arbitrary shit with</span></div><div class="line" id="155216"><span class="nick" style="color:#2e2a4a"><a href="#155216" label="[15:52:16]">&lt;bauen1&gt;</a></span><span class="message">also the backdoor could buffer the output in memory until it has enough information (currently done to calculate the correct p_filesz / p_memsz)</span></div><div class="line" id="155229"><span class="nick" style="color:#8dd3c7"><a href="#155229" label="[15:52:29]">&lt;OriansJ`&gt;</a></span><span class="message">handwritten assembly uses pass via registers with the callee pushing to save registers from modification (as it is simpler to reason about) but pass via the stack is easier for a state machine (like M2-Planet)</span></div><div class="line" id="155417"><span class="nick" style="color:#8dd3c7"><a href="#155417" label="[15:54:17]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: except elf files have to specify memory required for allocation from the kernel (which is usually rounded up to the next page) and writing past that memory address without a sys_brk to allocate more is a page fault</span></div><div class="line" id="155446"><span class="nick" style="color:#8dd3c7"><a href="#155446" label="[15:54:46]">&lt;OriansJ`&gt;</a></span><span class="message">if the program is never supposed to call sys_brk; we have something to flag on in kernel space</span></div><div class="line" id="155506"><span class="nick" style="color:#2e2a4a"><a href="#155506" label="[15:55:06]">&lt;bauen1&gt;</a></span><span class="message">OriansJ`: true, but the entire ELF header is loaded into memory and i never really need more than i can stuff there</span></div><div class="line" id="155557"><span class="nick" style="color:#2e2a4a"><a href="#155557" label="[15:55:57]">&lt;bauen1&gt;</a></span><span class="message">which would be catched by the sha256sum program</span></div><div class="line" id="155605"><span class="nick" style="color:#8dd3c7"><a href="#155605" label="[15:56:05]">&lt;OriansJ`&gt;</a></span><span class="message">So we pass 100MB of input (say a valid ELF program) but no malloc can occur in hex0 and there is no way hex0 will allocate 100MB on load</span></div><div class="line" id="155641"><span class="nick" style="color:#2e2a4a"><a href="#155641" label="[15:56:41]">&lt;bauen1&gt;</a></span><span class="message">it is detectable</span></div><div class="line" id="155706"><span class="nick" style="color:#8dd3c7"><a href="#155706" label="[15:57:06]">&lt;OriansJ`&gt;</a></span><span class="message">So either the payload will page fault hard (easy to detect) or it must do a sys_brk, which is also something easy to detect</span></div><div class="line" id="155723"><span class="nick" style="color:#2e2a4a"><a href="#155723" label="[15:57:23]">&lt;bauen1&gt;</a></span><span class="message">but i don't necessariyl need to hold the entire output to gather the information i need to modify the output before it is written</span></div><div class="line" id="155754"><span class="nick" style="color:#8dd3c7"><a href="#155754" label="[15:57:54]">&lt;OriansJ`&gt;</a></span><span class="message">bauen1: true valid ELF files do make that easy</span></div><div class="line" id="155808"><span class="nick" style="color:#8dd3c7"><a href="#155808" label="[15:58:08]">&lt;OriansJ`&gt;</a></span><span class="message">raw binaries are another story though</span></div><div class="line" id="155811"><span class="nick" style="color:#2e2a4a"><a href="#155811" label="[15:58:11]">&lt;bauen1&gt;</a></span><span class="message">so of course it is detectable, but not to the casual user who runs hex0-seed without double checking the size</span></div><div class="line" id="155826"><span class="nick" style="color:#2e2a4a"><a href="#155826" label="[15:58:26]">&lt;bauen1&gt;</a></span><span class="message">(or verifying the assembly)</span></div><div class="line" id="155847"><span class="nick" style="color:#8dd3c7"><a href="#155847" label="[15:58:47]">&lt;OriansJ`&gt;</a></span><span class="message">absolutely, there is no protect against users who don't properly check</span></div><div class="line" id="155939"><span class="nick" style="color:#2e2a4a"><a href="#155939" label="[15:59:39]">&lt;bauen1&gt;</a></span><span class="message">making a completely undetectable backdoor is impossible, making one that is hard to detect (actively obfuscate the input and check the output) is hard, making a simple one that can adapt to &quot;normal&quot; source code is easy</span></div><div class="line" id="155940"><span class="nick" style="color:#8dd3c7"><a href="#155940" label="[15:59:40]">&lt;OriansJ`&gt;</a></span><span class="message">now guix's build merkle tree could spot an alternate root binary rather easily</span></div><div class="line" id="160121"><span class="nick" style="color:#8dd3c7"><a href="#160121" label="[16:01:21]">&lt;OriansJ`&gt;</a></span><span class="message">yep, our goal isn't to make backdoors impossible but rather easy to catch and publicly shame</span></div><div class="line" id="160225"><span class="nick" style="color:#8dd3c7"><a href="#160225" label="[16:02:25]">&lt;OriansJ`&gt;</a></span><span class="message">blood-elf would probably be the optimal place to put a backdoor as it is used to generate the dwarf stubs for M2-Planet outputs</span></div><div class="line" id="160404"><span class="nick" style="color:#8dd3c7"><a href="#160404" label="[16:04:04]">&lt;OriansJ`&gt;</a></span><span class="message">However its output is 100% M1-macro architecture neutral data segments (with a small requirement of --64 for 64bit architectures)</span></div><div class="line" id="160449"><span class="nick" style="color:#8dd3c7"><a href="#160449" label="[16:04:49]">&lt;OriansJ`&gt;</a></span><span class="message">So you would have to hide it in the M1 output and only output when processing a C compiler or blood-elf</span></div><div class="line" id="200635"><span class="nick" style="color:#2e2a4a"><a href="#200635" label="[20:06:35]">&lt;bauen1&gt;</a></span><span class="message">so i now have an unoptimised backdoor for hex0-seed that will produce itself when given the hex0-seed hex0 code</span></div><div class="line" id="200642"><span class="nick" style="color:#2e2a4a"><a href="#200642" label="[20:06:42]">&lt;bauen1&gt;</a></span><span class="message">only 1264 bytes</span></div><div class="line" id="200706"><span class="nick" style="color:#2e2a4a"><a href="#200706" label="[20:07:06]">&lt;bauen1&gt;</a></span><span class="message">*1230 bytes</span></div><div class="line" id="200726"><span class="nick" style="color:#2e2a4a"><a href="#200726" label="[20:07:26]">&lt;bauen1&gt;</a></span><span class="message">it requires a small modification to hex0-seed to make finding the syscalls easier</span></div><div class="line" id="201342"><span class="nick" style="color:#6d2462"><a href="#201342" label="[20:13:42]">&lt;xentrac&gt;</a></span><span class="message">wow!</span></div><div class="line" id="201702"><span class="nick">***</span><span class="message notice">nckx is now known as facebook</span></div><div class="line" id="201727"><span class="nick">***</span><span class="message notice">facebook is now known as nckx</span></div><div class="line" id="204909"><span class="nick">***</span><span class="message notice">Server sets mode: +cnt </span></div><div class="line" id="210114"><span class="nick" style="color:#234e69"><a href="#210114" label="[21:01:14]">&lt;Hagfish&gt;</a></span><span class="message">impressive</span></div><div class="line" id="210128"><span class="nick" style="color:#234e69"><a href="#210128" label="[21:01:28]">&lt;Hagfish&gt;</a></span><span class="message">will it just propagate itself, or does it have like a payload of some sort?</span></div><div class="line" id="225827"><span class="nick" style="color:#2e2a4a"><a href="#225827" label="[22:58:27]">&lt;bauen1&gt;</a></span><span class="message">Hagfish: it propagates itself</span></div><div class="line" id="225841"><span class="nick" style="color:#2e2a4a"><a href="#225841" label="[22:58:41]">&lt;bauen1&gt;</a></span><span class="message">Hagfish: it hooks into certain patterns that are write and exit syscalls</span></div><div class="line" id="225931"><span class="nick" style="color:#2e2a4a"><a href="#225931" label="[22:59:31]">&lt;bauen1&gt;</a></span><span class="message">Hagfish: in the write syscall it checks if an ELF header is written, if it finds one it modifies it slightly to add space in the final binarie, then overwrites the entry and writes calls where write and exit syscalls would be</span></div><div class="line" id="230713"><span class="nick" style="color:#2e2a4a"><a href="#230713" label="[23:07:13]">&lt;bauen1&gt;</a></span><span class="message">technically it can also propagate itself up to mes but i might need to adjust the syscalls to write / exit to match `mov rax, &lt;syscall_num&gt; \n syscall`</span></div><div class="line" id="231117"><span class="nick" style="color:#2e2a4a"><a href="#231117" label="[23:11:17]">&lt;bauen1&gt;</a></span><span class="message">perhaphs not yet to binaries generated by mescc</span></div><div class="line" id="231551"><span class="nick" style="color:#2e2a4a"><a href="#231551" label="[23:15:51]">&lt;bauen1&gt;</a></span><span class="message">yeah, since mescc seems to differentiate between text and code it won't work &quot;out of the box&quot;</span></div><div class="line" id="231639"><span class="nick" style="color:#2e2a4a"><a href="#231639" label="[23:16:39]">&lt;bauen1&gt;</a></span><span class="message">perhaps also changing the elf header flags to map .text as rw could work</span></div><div class="line" id="233129"><span class="nick" style="color:#8dd3c7"><a href="#233129" label="[23:31:29]">&lt;OriansJ`&gt;</a></span><span class="message">.text is already rwx</span></div><div class="line" id="233314"><span class="nick" style="color:#8dd3c7"><a href="#233314" label="[23:33:14]">&lt;OriansJ`&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/oriansj/mescc-tools-seed/blob/master/x86/hex0_x86.hex0#L63">https://github.com/oriansj/mescc-tools-seed/blob/master/x86/hex0_x86.hex0#L63</a> </span></div><div class="line" id="233554"><span class="nick" style="color:#8dd3c7"><a href="#233554" label="[23:35:54]">&lt;OriansJ`&gt;</a></span><span class="message">as one would manually need to roll seperate segments but you would need padding to align to page sizes to actually get the segments with different permission flags</span></div><div class="line" id="233631"><span class="nick" style="color:#8dd3c7"><a href="#233631" label="[23:36:31]">&lt;OriansJ`&gt;</a></span><span class="message">as hex2 doesn't support after this; starts at address xyz</span></div><br /></div></body></html>