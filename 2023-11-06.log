<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2023-11-06.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="001007"><span class="nick" style="color:#389600"><a href="#001007" label="[00:10:07]">&lt;artemist&gt;</a></span><span class="message">I'm working on getting mescc running for aarch64 target and my big problem is how to generate instructions with registers that are not nibble aligned. I could use an accumulator register or just output hex from as.scm</span></div><div class="line" id="001113"><span class="nick" style="color:#389600"><a href="#001113" label="[00:11:13]">&lt;artemist&gt;</a></span><span class="message">I'm not sure what people would prefer, neither seems great</span></div><div class="line" id="001555"><span class="nick" style="color:#389600"><a href="#001555" label="[00:15:55]">&lt;artemist&gt;</a></span><span class="message">It may also be possible to modify M1 to make it possible to e.g. or words together, but that sounds annoying</span></div><div class="line" id="002037"><span class="nick" style="color:#8dd3c7"><a href="#002037" label="[00:20:37]">&lt;stikonas&gt;</a></span><span class="message">artemist: we already have that in M1 for riscv</span></div><div class="line" id="002109"><span class="nick" style="color:#8dd3c7"><a href="#002109" label="[00:21:09]">&lt;stikonas&gt;</a></span><span class="message">and oriansj and I discussed it at some point that it would be nice to convert aarch64 to be word based</span></div><div class="line" id="002125"><span class="nick" style="color:#8dd3c7"><a href="#002125" label="[00:21:25]">&lt;stikonas&gt;</a></span><span class="message">so I think people would prefer that</span></div><div class="line" id="002153"><span class="nick" style="color:#8dd3c7"><a href="#002153" label="[00:21:53]">&lt;stikonas&gt;</a></span><span class="message">now the problem is how to do it in backwards compatible way if you don't want to rework stage0-posix-aarch64</span></div><div class="line" id="002159"><span class="nick" style="color:#8dd3c7"><a href="#002159" label="[00:21:59]">&lt;stikonas&gt;</a></span><span class="message">possibly need an option to specify which mode to use</span></div><div class="line" id="002218"><span class="nick" style="color:#8dd3c7"><a href="#002218" label="[00:22:18]">&lt;stikonas&gt;</a></span><span class="message">actually it's hex2, not M1</span></div><div class="line" id="002248"><span class="nick" style="color:#8dd3c7"><a href="#002248" label="[00:22:48]">&lt;stikonas&gt;</a></span><span class="message">see e.g. here <a rel="nofollow" href="https://github.com/oriansj/mescc-tools/blob/master/hex2_word.c#L39">https://github.com/oriansj/mescc-tools/blob/master/hex2_word.c#L39</a> </span></div><div class="line" id="002304"><span class="nick" style="color:#8dd3c7"><a href="#002304" label="[00:23:04]">&lt;stikonas&gt;</a></span><span class="message">though right now that file is very risc-v'ish</span></div><div class="line" id="002412"><span class="nick" style="color:#8dd3c7"><a href="#002412" label="[00:24:12]">&lt;stikonas&gt;</a></span><span class="message">word based stuff is far easier to maintain</span></div><div class="line" id="002427"><span class="nick" style="color:#8dd3c7"><a href="#002427" label="[00:24:27]">&lt;stikonas&gt;</a></span><span class="message">you basically create a fairly short M1 define list (100 lines or so)</span></div><div class="line" id="002445"><span class="nick" style="color:#8dd3c7"><a href="#002445" label="[00:24:45]">&lt;stikonas&gt;</a></span><span class="message">and then you can construct any assembly expression ever...</span></div><div class="line" id="002451"><span class="nick" style="color:#8dd3c7"><a href="#002451" label="[00:24:51]">&lt;stikonas&gt;</a></span><span class="message">oh, actually, it's both hex2 and M1</span></div><div class="line" id="002504"><span class="nick" style="color:#8dd3c7"><a href="#002504" label="[00:25:04]">&lt;stikonas&gt;</a></span><span class="message">M1 needs some support to be able to output word based immediate constants</span></div><div class="line" id="003219"><span class="nick" style="color:#389600"><a href="#003219" label="[00:32:19]">&lt;artemist&gt;</a></span><span class="message">That wouls be convenient, I'll look at it</span></div><div class="line" id="004605"><span class="nick" style="color:#8dd3c7"><a href="#004605" label="[00:46:05]">&lt;stikonas&gt;</a></span><span class="message">artemist: have you seen how mescc deals with riscv64?</span></div><div class="line" id="004626"><span class="nick" style="color:#8dd3c7"><a href="#004626" label="[00:46:26]">&lt;stikonas&gt;</a></span><span class="message">i.e. how macros look like</span></div><div class="line" id="004628"><span class="nick" style="color:#8dd3c7"><a href="#004628" label="[00:46:28]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://gitlab.com/janneke/mes/-/blob/wip-riscv/module/mescc/riscv64/as.scm">https://gitlab.com/janneke/mes/-/blob/wip-riscv/module/mescc/riscv64/as.scm</a> </span></div><div class="line" id="004648"><span class="nick" style="color:#8dd3c7"><a href="#004648" label="[00:46:48]">&lt;stikonas&gt;</a></span><span class="message">because of the way or'ing is implemented, opcode is always the last</span></div><div class="line" id="004653"><span class="nick" style="color:#8dd3c7"><a href="#004653" label="[00:46:53]">&lt;stikonas&gt;</a></span><span class="message">but other than that it's quite readable</span></div><div class="line" id="004940"><span class="nick" style="color:#389600"><a href="#004940" label="[00:49:40]">&lt;artemist&gt;</a></span><span class="message">I saw this file though I assumed stuff was nibble aligned like it is in aarch32</span></div><div class="line" id="005003"><span class="nick" style="color:#8dd3c7"><a href="#005003" label="[00:50:03]">&lt;stikonas&gt;</a></span><span class="message">nope, riscv is far worse</span></div><div class="line" id="005019"><span class="nick" style="color:#8dd3c7"><a href="#005019" label="[00:50:19]">&lt;stikonas&gt;</a></span><span class="message">it's immediates and instructions are not just misaligned</span></div><div class="line" id="005029"><span class="nick" style="color:#8dd3c7"><a href="#005029" label="[00:50:29]">&lt;stikonas&gt;</a></span><span class="message">but they are also mangled in complicated ways</span></div><div class="line" id="005147"><span class="nick" style="color:#8dd3c7"><a href="#005147" label="[00:51:47]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://i.stack.imgur.com/MUKIE.png">https://i.stack.imgur.com/MUKIE.png</a> </span></div><div class="line" id="005205"><span class="nick" style="color:#8dd3c7"><a href="#005205" label="[00:52:05]">&lt;stikonas&gt;</a></span><span class="message">e.g. various bits are not in order</span></div><div class="line" id="005221"><span class="nick" style="color:#389600"><a href="#005221" label="[00:52:21]">&lt;artemist&gt;</a></span><span class="message">This feels like something you come up with so your engineering undergrads can feel clever</span></div><div class="line" id="005222"><span class="nick" style="color:#8dd3c7"><a href="#005222" label="[00:52:22]">&lt;stikonas&gt;</a></span><span class="message">you can have bit 20, then bits 10 to 1 then bit 11, etc...</span></div><div class="line" id="005323"><span class="nick" style="color:#8dd3c7"><a href="#005323" label="[00:53:23]">&lt;stikonas&gt;</a></span><span class="message">it might be that somehow this makes instruction decoding in HW simpler</span></div><div class="line" id="005329"><span class="nick" style="color:#8dd3c7"><a href="#005329" label="[00:53:29]">&lt;stikonas&gt;</a></span><span class="message">e.g. registers are always in the same place...</span></div><div class="line" id="005340"><span class="nick" style="color:#8dd3c7"><a href="#005340" label="[00:53:40]">&lt;stikonas&gt;</a></span><span class="message">and you can often check sign of immediate earlier</span></div><div class="line" id="014217"><span class="nick" style="color:#389600"><a href="#014217" label="[01:42:17]">&lt;artemist&gt;</a></span><span class="message">Is there a reference for how the or works? I can't see it in the hex2 high level prototype</span></div><div class="line" id="014244"><span class="nick" style="color:#8dd3c7"><a href="#014244" label="[01:42:44]">&lt;stikonas&gt;</a></span><span class="message">well, mescc-tools is a C reference...</span></div><div class="line" id="014251"><span class="nick" style="color:#8dd3c7"><a href="#014251" label="[01:42:51]">&lt;stikonas&gt;</a></span><span class="message">there is hex2_word.c there</span></div><div class="line" id="014318"><span class="nick" style="color:#389600"><a href="#014318" label="[01:43:18]">&lt;artemist&gt;</a></span><span class="message">Oh, I was looking in stage0-posix, oops</span></div><div class="line" id="014326"><span class="nick" style="color:#8dd3c7"><a href="#014326" label="[01:43:26]">&lt;stikonas&gt;</a></span><span class="message">basically for riscv we contstruct 32-bit words as</span></div><div class="line" id="014359"><span class="nick" style="color:#8dd3c7"><a href="#014359" label="[01:43:59]">&lt;stikonas&gt;</a></span><span class="message">.01000000 .00020000 .00000300 00000004</span></div><div class="line" id="014413"><span class="nick" style="color:#8dd3c7"><a href="#014413" label="[01:44:13]">&lt;stikonas&gt;</a></span><span class="message">which is gets or'ed into</span></div><div class="line" id="014417"><span class="nick" style="color:#8dd3c7"><a href="#014417" label="[01:44:17]">&lt;stikonas&gt;</a></span><span class="message">01020304</span></div><div class="line" id="014432"><span class="nick" style="color:#8dd3c7"><a href="#014432" label="[01:44:32]">&lt;stikonas&gt;</a></span><span class="message">so everything that starts with . gets merged into the next thing</span></div><div class="line" id="014456"><span class="nick" style="color:#389600"><a href="#014456" label="[01:44:56]">&lt;artemist&gt;</a></span><span class="message">Is stuff swapped again for endianness reasons?</span></div><div class="line" id="014458"><span class="nick" style="color:#8dd3c7"><a href="#014458" label="[01:44:58]">&lt;stikonas&gt;</a></span><span class="message">plus for riscv we also redefined % &amp; $...</span></div><div class="line" id="014521"><span class="nick" style="color:#8dd3c7"><a href="#014521" label="[01:45:21]">&lt;stikonas&gt;</a></span><span class="message">hmm, I think it is swapped, but not again</span></div><div class="line" id="014555"><span class="nick" style="color:#389600"><a href="#014555" label="[01:45:55]">&lt;artemist&gt;</a></span><span class="message">Oh, sorry, I meant would .01000000 .00020000 .00000300 00000004 turn into 04030201</span></div><div class="line" id="014608"><span class="nick" style="color:#389600"><a href="#014608" label="[01:46:08]">&lt;artemist&gt;</a></span><span class="message">Not sure where I got &quot;again&quot; from</span></div><div class="line" id="014608"><span class="nick" style="color:#8dd3c7"><a href="#014608" label="[01:46:08]">&lt;stikonas&gt;</a></span><span class="message">no, I don't think so</span></div><div class="line" id="014640"><span class="nick" style="color:#8dd3c7"><a href="#014640" label="[01:46:40]">&lt;stikonas&gt;</a></span><span class="message">the final 01020304 is swapped in memory</span></div><div class="line" id="014650"><span class="nick" style="color:#8dd3c7"><a href="#014650" label="[01:46:50]">&lt;stikonas&gt;</a></span><span class="message">but that's the same for x86</span></div><div class="line" id="014716"><span class="nick" style="color:#8dd3c7"><a href="#014716" label="[01:47:16]">&lt;stikonas&gt;</a></span><span class="message">anyway, take a look at mescc_tools/hex2_word</span></div><div class="line" id="014734"><span class="nick" style="color:#8dd3c7"><a href="#014734" label="[01:47:34]">&lt;stikonas&gt;</a></span><span class="message">probably ignore those % &amp; $... things</span></div><div class="line" id="014740"><span class="nick" style="color:#8dd3c7"><a href="#014740" label="[01:47:40]">&lt;stikonas&gt;</a></span><span class="message">and only look at . for now</span></div><div class="line" id="014805"><span class="nick" style="color:#8dd3c7"><a href="#014805" label="[01:48:05]">&lt;stikonas&gt;</a></span><span class="message">in risc-v those other thigns implement instruction mangling (those formats I showed you in that picture)</span></div><div class="line" id="014852"><span class="nick" style="color:#8dd3c7"><a href="#014852" label="[01:48:52]">&lt;stikonas&gt;</a></span><span class="message">and then the 2nd part is here <a rel="nofollow" href="https://github.com/oriansj/mescc-tools/blob/master/M1-macro.c#L614">https://github.com/oriansj/mescc-tools/blob/master/M1-macro.c#L614</a> </span></div><div class="line" id="015430"><span class="nick" style="color:#389600"><a href="#015430" label="[01:54:30]">&lt;artemist&gt;</a></span><span class="message">Thanks! I'll figure out how to port this</span></div><div class="line" id="015946"><span class="nick" style="color:#389600"><a href="#015946" label="[01:59:46]">&lt;artemist&gt;</a></span><span class="message">hm... It's xor not or, that makes sense</span></div><div class="line" id="020056"><span class="nick" style="color:#8dd3c7"><a href="#020056" label="[02:00:56]">&lt;stikonas&gt;</a></span><span class="message">oh yes, it's xor...</span></div><div class="line" id="020120"><span class="nick" style="color:#8dd3c7"><a href="#020120" label="[02:01:20]">&lt;stikonas&gt;</a></span><span class="message">in practive for risc-v it doesn't matter</span></div><div class="line" id="020139"><span class="nick" style="color:#8dd3c7"><a href="#020139" label="[02:01:39]">&lt;stikonas&gt;</a></span><span class="message">as none of the bits should ever be set in more than one operand</span></div><div class="line" id="020531"><span class="nick" style="color:#389600"><a href="#020531" label="[02:05:31]">&lt;artemist&gt;</a></span><span class="message">Mostly just if it's convenient to e.g. default to 64 bit then have a way to switch back to 32 bit, which could work in aarch64</span></div><div class="line" id="020549"><span class="nick" style="color:#389600"><a href="#020549" label="[02:05:49]">&lt;artemist&gt;</a></span><span class="message">(general purpose registers)</span></div><div class="line" id="020849"><span class="nick" style="color:#8dd3c7"><a href="#020849" label="[02:08:49]">&lt;stikonas&gt;</a></span><span class="message">aarch64 also has 32-bit words, doesn't it?</span></div><div class="line" id="021234"><span class="nick" style="color:#389600"><a href="#021234" label="[02:12:34]">&lt;artemist&gt;</a></span><span class="message">Yes, I was thinking of whether you use the 64-bit or 32-bit general purpose registers, as a lot of instructions support either</span></div><div class="line" id="021345"><span class="nick" style="color:#8dd3c7"><a href="#021345" label="[02:13:45]">&lt;stikonas&gt;</a></span><span class="message">hmm, it's probably different for risc-v</span></div><div class="line" id="021358"><span class="nick" style="color:#8dd3c7"><a href="#021358" label="[02:13:58]">&lt;stikonas&gt;</a></span><span class="message">well, risc-v has some of that</span></div><div class="line" id="021417"><span class="nick" style="color:#8dd3c7"><a href="#021417" label="[02:14:17]">&lt;stikonas&gt;</a></span><span class="message">e.g. LD, LW, LH and LB loads different sizes...</span></div><div class="line" id="021445"><span class="nick" style="color:#8dd3c7"><a href="#021445" label="[02:14:45]">&lt;stikonas&gt;</a></span><span class="message">but generally most opcodes have no concept of 64 vs 32-bit</span></div><div class="line" id="021503"><span class="nick" style="color:#8dd3c7"><a href="#021503" label="[02:15:03]">&lt;stikonas&gt;</a></span><span class="message">they just work on all 64-bits</span></div><div class="line" id="021534"><span class="nick" style="color:#8dd3c7"><a href="#021534" label="[02:15:34]">&lt;stikonas&gt;</a></span><span class="message">e.g. &quot;addi, reg1, reg2, imm1&quot; works on 64-bit registers in riscv64 but on 32-bit registers in riscv32</span></div><div class="line" id="021635"><span class="nick" style="color:#389600"><a href="#021635" label="[02:16:35]">&lt;artemist&gt;</a></span><span class="message">in aarch64 &quot;add x0, x1, x2&quot; would be the full 64 bits but &quot;add w0, w1, w2&quot; would truncate the result to 32 bits</span></div><div class="line" id="021718"><span class="nick" style="color:#389600"><a href="#021718" label="[02:17:18]">&lt;artemist&gt;</a></span><span class="message">Same registers, it's just &quot;ignore the top half&quot;</span></div><div class="line" id="021728"><span class="nick" style="color:#8dd3c7"><a href="#021728" label="[02:17:28]">&lt;stikonas&gt;</a></span><span class="message">yeah, that's different</span></div><div class="line" id="021744"><span class="nick" style="color:#8dd3c7"><a href="#021744" label="[02:17:44]">&lt;stikonas&gt;</a></span><span class="message">riscv64 has none of that...</span></div><div class="line" id="021803"><span class="nick" style="color:#8dd3c7"><a href="#021803" label="[02:18:03]">&lt;stikonas&gt;</a></span><span class="message">there are some new opcodes though</span></div><div class="line" id="021831"><span class="nick" style="color:#8dd3c7"><a href="#021831" label="[02:18:31]">&lt;stikonas&gt;</a></span><span class="message">so there is addiw reg1, reg2, imm1 that works with 32-bit values</span></div><div class="line" id="021918"><span class="nick" style="color:#8dd3c7"><a href="#021918" label="[02:19:18]">&lt;stikonas&gt;</a></span><span class="message">but the result is sign extended and writen to 64-bit register</span></div><div class="line" id="021925"><span class="nick" style="color:#389600"><a href="#021925" label="[02:19:25]">&lt;artemist&gt;</a></span><span class="message">that difference might be pretty similar on aarch64, it's just a single bit at the top of the instruction that specifies</span></div><div class="line" id="021945"><span class="nick" style="color:#8dd3c7"><a href="#021945" label="[02:19:45]">&lt;stikonas&gt;</a></span><span class="message">hmm, could be</span></div><div class="line" id="021950"><span class="nick" style="color:#8dd3c7"><a href="#021950" label="[02:19:50]">&lt;stikonas&gt;</a></span><span class="message">then it's not so different</span></div><div class="line" id="021957"><span class="nick" style="color:#8dd3c7"><a href="#021957" label="[02:19:57]">&lt;stikonas&gt;</a></span><span class="message">but assemblers make it less apparent</span></div><div class="line" id="022108"><span class="nick" style="color:#389600"><a href="#022108" label="[02:21:08]">&lt;artemist&gt;</a></span><span class="message">Yeah, assemblers being high level has been annoying</span></div><div class="line" id="022126"><span class="nick" style="color:#389600"><a href="#022126" label="[02:21:26]">&lt;artemist&gt;</a></span><span class="message">aarch64 assembly really doesn't like exposing the existance of pc-relative instructions</span></div><div class="line" id="022257"><span class="nick" style="color:#8dd3c7"><a href="#022257" label="[02:22:57]">&lt;stikonas&gt;</a></span><span class="message">well, on riscv it's not a problem</span></div><div class="line" id="022311"><span class="nick" style="color:#8dd3c7"><a href="#022311" label="[02:23:11]">&lt;stikonas&gt;</a></span><span class="message">there is lui for absolute loads and auipc for relative loads</span></div><div class="line" id="022324"><span class="nick" style="color:#8dd3c7"><a href="#022324" label="[02:23:24]">&lt;stikonas&gt;</a></span><span class="message">well you actually need 2 instructions</span></div><div class="line" id="022332"><span class="nick" style="color:#8dd3c7"><a href="#022332" label="[02:23:32]">&lt;stikonas&gt;</a></span><span class="message">lui/addiw or auipc/addiw</span></div><div class="line" id="022409"><span class="nick" style="color:#8dd3c7"><a href="#022409" label="[02:24:09]">&lt;stikonas&gt;</a></span><span class="message">but low level stuff (e.g. hex0) is really pain to write for riscv</span></div><div class="line" id="022433"><span class="nick" style="color:#8dd3c7"><a href="#022433" label="[02:24:33]">&lt;stikonas&gt;</a></span><span class="message">well, actually only once you reach M0, it becomes nice</span></div><div class="line" id="022438"><span class="nick" style="color:#8dd3c7"><a href="#022438" label="[02:24:38]">&lt;stikonas&gt;</a></span><span class="message">even nicer than x86</span></div><div class="line" id="022650"><span class="nick" style="color:#389600"><a href="#022650" label="[02:26:50]">&lt;artemist&gt;</a></span><span class="message">The instructions exist but the assembler really wants you do something like &quot;ldr x0, label&quot;</span></div><div class="line" id="022658"><span class="nick" style="color:#389600"><a href="#022658" label="[02:26:58]">&lt;artemist&gt;</a></span><span class="message">or &quot;mov x0, label</span></div><div class="line" id="022717"><span class="nick" style="color:#389600"><a href="#022717" label="[02:27:17]">&lt;artemist&gt;</a></span><span class="message">mov on aarch64 means so many different actual opcodes</span></div><div class="line" id="022835"><span class="nick" style="color:#8dd3c7"><a href="#022835" label="[02:28:35]">&lt;stikonas&gt;</a></span><span class="message">yeah, just like x86...</span></div><div class="line" id="022843"><span class="nick" style="color:#8dd3c7"><a href="#022843" label="[02:28:43]">&lt;stikonas&gt;</a></span><span class="message">risc-v is simpler in that regard</span></div><div class="line" id="022906"><span class="nick" style="color:#8dd3c7"><a href="#022906" label="[02:29:06]">&lt;stikonas&gt;</a></span><span class="message">mv is actually the same opcode as addi just with zero immediate</span></div><div class="line" id="022921"><span class="nick" style="color:#8dd3c7"><a href="#022921" label="[02:29:21]">&lt;stikonas&gt;</a></span><span class="message">but you can't mov x0, label</span></div><div class="line" id="022928"><span class="nick" style="color:#8dd3c7"><a href="#022928" label="[02:29:28]">&lt;stikonas&gt;</a></span><span class="message">you have to load it using auipc/addiw</span></div><div class="line" id="043524"><span class="nick" style="color:#2e2a4a"><a href="#043524" label="[04:35:24]">&lt;muurkha&gt;</a></span><span class="message">cedb: you will learn Forth eventually if this kind of thing interests you, probably</span></div><div class="line" id="043620"><span class="nick" style="color:#2e2a4a"><a href="#043620" label="[04:36:20]">&lt;muurkha&gt;</a></span><span class="message">janneke: congratulations on new stage0 release push!</span></div><div class="line" id="043738"><span class="nick" style="color:#2e2a4a"><a href="#043738" label="[04:37:38]">&lt;muurkha&gt;</a></span><span class="message">23:52 &lt; artemist&gt; This feels like something you come up with so your engineering undergrads can</span></div><div class="line" id="043741"><span class="nick" style="color:#2e2a4a"><a href="#043741" label="[04:37:41]">&lt;muurkha&gt;</a></span><span class="message">                  feel clever</span></div><div class="line" id="043915"><span class="nick" style="color:#2e2a4a"><a href="#043915" label="[04:39:15]">&lt;muurkha&gt;</a></span><span class="message">that was what I thought about the RISC-V instruction format at first too, but when I went to look at where immediate bits come from, I changed my mind; I think it's actually a significant advantage for tiny, low-gate-count RISC-V cores</span></div><div class="line" id="044015"><span class="nick" style="color:#2e2a4a"><a href="#044015" label="[04:40:15]">&lt;muurkha&gt;</a></span><span class="message">I think there's probably a significant class of designs where this gives you a significantly higher maximum clock speed</span></div><div class="line" id="044224"><span class="nick" style="color:#2e2a4a"><a href="#044224" label="[04:42:24]">&lt;muurkha&gt;</a></span><span class="message">wrt auipc/addiw or auipc/addi, there's a standard `la` pseudoinstruction that traditional RISC-V assemblers assemble to that instruction pair</span></div><div class="line" id="050243"><span class="nick" style="color:#389600"><a href="#050243" label="[05:02:43]">&lt;artemist&gt;</a></span><span class="message">Yeah, true. I guess if the sign bit is always in the same place it's fewer gates to sign extend</span></div><div class="line" id="050448"><span class="nick" style="color:#389600"><a href="#050448" label="[05:04:48]">&lt;artemist&gt;</a></span><span class="message">Low gate count is an interesting use case I don't think about a ton, especially since I keep seeing bigger and bigger rv64 socs for linux</span></div><div class="line" id="050726"><span class="nick" style="color:#2e2a4a"><a href="#050726" label="[05:07:26]">&lt;muurkha&gt;</a></span><span class="message">low gate count is where RISC-V is wildly successful</span></div><div class="line" id="050900"><span class="nick" style="color:#2e2a4a"><a href="#050900" label="[05:09:00]">&lt;muurkha&gt;</a></span><span class="message">Linux-capable RISC-V is so far kind of an enthusiast niche</span></div><div class="line" id="051139"><span class="nick" style="color:#2e2a4a"><a href="#051139" label="[05:11:39]">&lt;muurkha&gt;</a></span><span class="message">but in the microcontroller market RISC-V is kicking the shit out of Tensilica and in some cases even ARM</span></div><div class="line" id="051345"><span class="nick" style="color:#2e2a4a"><a href="#051345" label="[05:13:45]">&lt;muurkha&gt;</a></span><span class="message">also, MIPS.  to the point that MIPS the company has totally just thrown in the towel and switched to RISC-V</span></div><div class="line" id="051411"><span class="nick" style="color:#2e2a4a"><a href="#051411" label="[05:14:11]">&lt;muurkha&gt;</a></span><span class="message">Xilinx announced yesterday that they're ditching MicroBlaze in the same way</span></div><div class="line" id="052101"><span class="nick" style="color:#2e2a4a"><a href="#052101" label="[05:21:01]">&lt;muurkha&gt;</a></span><span class="message">I think likely Loongson or someone will ship a really compelling Linux-capable RISC-V at some point, but so far they're all a bit anemic</span></div><div class="line" id="071403"><span class="nick" style="color:#389600"><a href="#071403" label="[07:14:03]">&lt;artemist&gt;</a></span><span class="message">MIPS seemed on their last legs because of ARM before riscv</span></div><div class="line" id="080405"><span class="nick" style="color:#6b8072"><a href="#080405" label="[08:04:05]">&lt;jcowan&gt;</a></span><span class="message">risc-v is very close to mips, but is opne source</span></div><div class="line" id="080426"><span class="nick" style="color:#6b8072"><a href="#080426" label="[08:04:26]">&lt;jcowan&gt;</a></span><span class="message">and the mips company (Wave) has discontinued mips and is using risc-v anyway</span></div><div class="line" id="081408"><span class="nick" style="color:#80b1d3"><a href="#081408" label="[08:14:08]">&lt;pabs3&gt;</a></span><span class="message">and Loongson is moving on to LoongArch, their evolution of MIPS</span></div><div class="line" id="081436"><span class="nick" style="color:#80b1d3"><a href="#081436" label="[08:14:36]">&lt;pabs3&gt;</a></span><span class="message">don't think I have seen them mention any RISC-V stuff</span></div><div class="line" id="125616"><span class="nick" style="color:#6d2462"><a href="#125616" label="[12:56:16]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;emilytrau&gt; @stikonas artemist fyi if you're hacking on it mescc-tools is currently broken out of the box on aarch64. for the nix packages we apply an extra patch to m2libc <a rel="nofollow" href="https://github.com/NixOS/nixpkgs/blob/85f1ba3e51676fa8cc604a3d863d729026a6b8eb/pkgs/by-name/m2/m2libc/package.nix#L21">https://github.com/NixOS/nixpkgs/blob/85f1ba3e51676fa8cc604a3d863d729026a6b8eb/pkgs/by-name/m2/m2libc/package.nix#L21</a> </span></div><div class="line" id="130447"><span class="nick" style="color:#6d2462"><a href="#130447" label="[13:04:47]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;Andrius Štikonas&gt; Yeah, I know that pr</span></div><div class="line" id="130526"><span class="nick" style="color:#6d2462"><a href="#130526" label="[13:05:26]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;Andrius Štikonas&gt; The author hasn't finished it though, somebody should test and merge it</span></div><div class="line" id="130619"><span class="nick" style="color:#6d2462"><a href="#130619" label="[13:06:19]">&lt;matrix_bridge&gt;</a></span><span class="message">&lt;Andrius Štikonas&gt; I think it has 3 changes and mknod was untested</span></div><br /></div></body></html>