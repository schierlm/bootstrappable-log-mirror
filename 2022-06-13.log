<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-06-13.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000225"><span class="nick" style="color:#8dd3c7"><a href="#000225" label="[00:02:25]">&lt;oriansj&gt;</a></span><span class="message">little endian word, opcode is the last 6bits; which when written to memory is in the first 8bits</span></div><div class="line" id="000249"><span class="nick" style="color:#8dd3c7"><a href="#000249" label="[00:02:49]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://danielmangum.com/static/risc_v_inst_intro_1.png">https://danielmangum.com/static/risc_v_inst_intro_1.png</a> </span></div><div class="line" id="001023"><span class="nick" style="color:#2e2a4a"><a href="#001023" label="[00:10:23]">&lt;muurkha&gt;</a></span><span class="message">it's not the last 6 bits, it's the low-order 6 bits, which makes it 6 bits of the first byte, yes</span></div><div class="line" id="001046"><span class="nick" style="color:#2e2a4a"><a href="#001046" label="[00:10:46]">&lt;muurkha&gt;</a></span><span class="message">the least significant byte</span></div><div class="line" id="001910"><span class="nick" style="color:#8dd3c7"><a href="#001910" label="[00:19:10]">&lt;oriansj&gt;</a></span><span class="message">muurkha: forgive my lack of clarification. when I say the last 6bits, I am speaking in reference to the word from the perspective of big endian bit ordering. Which does map directly to what you have expressed in regards to low-order bits and on little-endian architectures would map to the high byte of the word in memory (or first byte in big endian perspective)</span></div><div class="line" id="002622"><span class="nick" style="color:#2e2a4a"><a href="#002622" label="[00:26:22]">&lt;muurkha&gt;</a></span><span class="message">yes, I agree that it would be 6 bits of the last byte in a big-endian encoding, but RISC-V is defined to be little-endian.  if you wanted to do the same thing with a big-endian instruction encoding you'd have to put the instruction length data in the high byte (or syllable or whatever)</span></div><div class="line" id="002701"><span class="nick" style="color:#2e2a4a"><a href="#002701" label="[00:27:01]">&lt;muurkha&gt;</a></span><span class="message">otherwise you'd have to guess where to find it :)</span></div><div class="line" id="002722"><span class="nick" style="color:#8dd3c7"><a href="#002722" label="[00:27:22]">&lt;oriansj&gt;</a></span><span class="message">indeed</span></div><div class="line" id="002823"><span class="nick" style="color:#2e2a4a"><a href="#002823" label="[00:28:23]">&lt;muurkha&gt;</a></span><span class="message">one of the things that makes the PDP-8 (and, say, the original ARM and the Berkeley RISC) so simple is that they don't have variable-length instructions</span></div><div class="line" id="002950"><span class="nick" style="color:#2e2a4a"><a href="#002950" label="[00:29:50]">&lt;muurkha&gt;</a></span><span class="message">the approach used in Chuck Moore's MISC cores is interesting: he packs multiple 5-bit instructions into an instruction word (20 bits on the MuP21 and F21, 18 bits on the F18A processors in the GA144)</span></div><div class="line" id="003007"><span class="nick" style="color:#8dd3c7"><a href="#003007" label="[00:30:07]">&lt;oriansj&gt;</a></span><span class="message">well there definitely is decode logic savings there but RISC-II showed one could support multiple encoding sizes efficiently</span></div><div class="line" id="003026"><span class="nick" style="color:#2e2a4a"><a href="#003026" label="[00:30:26]">&lt;muurkha&gt;</a></span><span class="message">one of the instructions is &quot;literal&quot;, which prevents the rest of the word from being decoded as instructions, instead pushing it on the stack</span></div><div class="line" id="003041"><span class="nick" style="color:#2e2a4a"><a href="#003041" label="[00:30:41]">&lt;muurkha&gt;</a></span><span class="message">I've never looked at the RISC-II, maybe I should</span></div><div class="line" id="003055"><span class="nick" style="color:#8dd3c7"><a href="#003055" label="[00:30:55]">&lt;oriansj&gt;</a></span><span class="message">it supported both 16bit and 32bit instructions</span></div><div class="line" id="003108"><span class="nick" style="color:#8dd3c7"><a href="#003108" label="[00:31:08]">&lt;oriansj&gt;</a></span><span class="message">but internally expanded all 16bit instructions to 32bits</span></div><div class="line" id="003111"><span class="nick" style="color:#2e2a4a"><a href="#003111" label="[00:31:11]">&lt;muurkha&gt;</a></span><span class="message">like Thumb and RV32C/RV64C</span></div><div class="line" id="003134"><span class="nick" style="color:#2e2a4a"><a href="#003134" label="[00:31:34]">&lt;muurkha&gt;</a></span><span class="message">the MuP21 was 7000 transistors, less than twice the size of the (Intersil 6100) PDP-8</span></div><div class="line" id="003151"><span class="nick" style="color:#8dd3c7"><a href="#003151" label="[00:31:51]">&lt;oriansj&gt;</a></span><span class="message">well Thumb can expand to more than just 1 instruction</span></div><div class="line" id="003151"><span class="nick" style="color:#2e2a4a"><a href="#003151" label="[00:31:51]">&lt;muurkha&gt;</a></span><span class="message">oh really?  I didn't know that!</span></div><div class="line" id="003231"><span class="nick" style="color:#2e2a4a"><a href="#003231" label="[00:32:31]">&lt;muurkha&gt;</a></span><span class="message">btw if you think the RISC-V intruction encoding is ridiculous, wait until you hear about the MuP21 encoding</span></div><div class="line" id="003249"><span class="nick" style="color:#2e2a4a"><a href="#003249" label="[00:32:49]">&lt;muurkha&gt;</a></span><span class="message">instead of concatenating the four instructions in the word one after the other, their bits are interleaved</span></div><div class="line" id="003256"><span class="nick" style="color:#2e2a4a"><a href="#003256" label="[00:32:56]">&lt;muurkha&gt;</a></span><span class="message">and the odd-numbered instructions are complemented</span></div><div class="line" id="003353"><span class="nick" style="color:#2e2a4a"><a href="#003353" label="[00:33:53]">&lt;muurkha&gt;</a></span><span class="message">why?  presumably because that saved real estate in the instruction register, you only have to shift the register by one bit in between instructions instead of 5 bits</span></div><div class="line" id="003359"><span class="nick" style="color:#8dd3c7"><a href="#003359" label="[00:33:59]">&lt;oriansj&gt;</a></span><span class="message">muurkha: and I thought Itanic had bad instruction ideas</span></div><div class="line" id="003416"><span class="nick" style="color:#2e2a4a"><a href="#003416" label="[00:34:16]">&lt;muurkha&gt;</a></span><span class="message">well, it worked out reasonably well, I think</span></div><div class="line" id="003527"><span class="nick" style="color:#2e2a4a"><a href="#003527" label="[00:35:27]">&lt;muurkha&gt;</a></span><span class="message">interleaving the instructions and XORing with 0x55555 (or 0xAAAAA? I forget) is only two or three lines of code in the assembler, and it has the result of making all the instructions run faster and at lower power, and making the chip cheaper (I guess)</span></div><div class="line" id="003608"><span class="nick" style="color:#2e2a4a"><a href="#003608" label="[00:36:08]">&lt;muurkha&gt;</a></span><span class="message">the main difficulty is that nobody ever targeted a C compiler to the chip, I think because Jeff Fox had this irrational hate for C</span></div><div class="line" id="003622"><span class="nick" style="color:#2e2a4a"><a href="#003622" label="[00:36:22]">&lt;muurkha&gt;</a></span><span class="message">and he would have been the obvious person to do it</span></div><div class="line" id="003722"><span class="nick" style="color:#8dd3c7"><a href="#003722" label="[00:37:22]">&lt;oriansj&gt;</a></span><span class="message">well C is a very easy language to hate</span></div><div class="line" id="003728"><span class="nick" style="color:#2e2a4a"><a href="#003728" label="[00:37:28]">&lt;muurkha&gt;</a></span><span class="message">unlike the GA144 processors, the MuP21 had an external memory bus with a 1-mebiword address space (2.5 mebibytes), so a C compiler would have been a very reasonable way to program it</span></div><div class="line" id="004000"><span class="nick" style="color:#2e2a4a"><a href="#004000" label="[00:40:00]">&lt;muurkha&gt;</a></span><span class="message">the MuP21 came out in 01994 at &quot;80 MIPS&quot;, probably close to 40 Dhrystone MIPS: <a rel="nofollow" href="http://www.ultratechnology.com/p21.html">http://www.ultratechnology.com/p21.html</a> </span></div><div class="line" id="004128"><span class="nick" style="color:#8dd3c7"><a href="#004128" label="[00:41:28]">&lt;oriansj&gt;</a></span><span class="message">yeah I was reading: <a rel="nofollow" href="http://www.ultratechnology.com/mup21.html">http://www.ultratechnology.com/mup21.html</a>  and i can't help but feel it was VLIW but with too clever by half instruction encoding</span></div><div class="line" id="004154"><span class="nick" style="color:#2e2a4a"><a href="#004154" label="[00:41:54]">&lt;muurkha&gt;</a></span><span class="message">no, it's the opposite extreme from VLIW</span></div><div class="line" id="004244"><span class="nick" style="color:#2e2a4a"><a href="#004244" label="[00:42:44]">&lt;muurkha&gt;</a></span><span class="message">VLIW is about unlocking lots of instruction-level parallelism by making the parallelism explicit in the instruction stream, like horizontal microcode</span></div><div class="line" id="004433"><span class="nick" style="color:#2e2a4a"><a href="#004433" label="[00:44:33]">&lt;muurkha&gt;</a></span><span class="message">MISC, by contrast, is about minimizing the hardware complexity of the processor and the path length per instruction, even at the expense of needing multiple machine instructions in multiple cycles to do what conventional processors do in a single instruction, like a more extreme RISC</span></div><div class="line" id="004530"><span class="nick" style="color:#2e2a4a"><a href="#004530" label="[00:45:30]">&lt;muurkha&gt;</a></span><span class="message">in the code I've looked at (which may not be ideal because I wrote most of it myself and am no expert on Forth) you need about two MISC instructions per RISC or CISC instruction</span></div><div class="line" id="004632"><span class="nick" style="color:#2e2a4a"><a href="#004632" label="[00:46:32]">&lt;muurkha&gt;</a></span><span class="message">you can get a higher clock rate because you don't need to wait for operand MUXes to provide the right operands from the register file to the ALU; the TOS and NOS registers are hard-wired to the ALU inputs</span></div><div class="line" id="004740"><span class="nick" style="color:#2e2a4a"><a href="#004740" label="[00:47:40]">&lt;muurkha&gt;</a></span><span class="message">but the tradeoff is that sometimes what's in them isn't what you actually want to operate on, so you often need another instruction or two to get the right values into those registers</span></div><div class="line" id="004817"><span class="nick" style="color:#2e2a4a"><a href="#004817" label="[00:48:17]">&lt;muurkha&gt;</a></span><span class="message">this is also, in my experience, more cognitive effort when you're writing machine code, although Forth fans disagree</span></div><div class="line" id="004930"><span class="nick" style="color:#8dd3c7"><a href="#004930" label="[00:49:30]">&lt;oriansj&gt;</a></span><span class="message">well if one thinks like a C stack machine and not as an assembly programmer, it is easier</span></div><div class="line" id="004934"><span class="nick" style="color:#2e2a4a"><a href="#004934" label="[00:49:34]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="004949"><span class="nick" style="color:#2e2a4a"><a href="#004949" label="[00:49:49]">&lt;muurkha&gt;</a></span><span class="message">it's easier to write a reasonable compiler for because generally you don't need register allocation for expression evaluation</span></div><div class="line" id="005154"><span class="nick" style="color:#2e2a4a"><a href="#005154" label="[00:51:54]">&lt;muurkha&gt;</a></span><span class="message">although on the MuP21 I think the operand stack was only 10 words deep, so overflow is possible</span></div><div class="line" id="005406"><span class="nick" style="color:#2e2a4a"><a href="#005406" label="[00:54:06]">&lt;muurkha&gt;</a></span><span class="message">hmm, no, 4 return-stack items and 6 data-stack items.  Moore expanded these to 8 and 10 on the F18A and maybe even on the F21, not sure</span></div><div class="line" id="005445"><span class="nick" style="color:#2e2a4a"><a href="#005445" label="[00:54:45]">&lt;muurkha&gt;</a></span><span class="message">so maybe extra compiler complexity instead of reduced compiler complexity</span></div><div class="line" id="005515"><span class="nick" style="color:#2e2a4a"><a href="#005515" label="[00:55:15]">&lt;muurkha&gt;</a></span><span class="message">according to <a rel="nofollow" href="http://www.ultratechnology.com/mfp21.htm:">http://www.ultratechnology.com/mfp21.htm:</a>  &quot;The P21 has on chip stacks a total of 13 registers: 6 data stack cell registers...&quot;</span></div><div class="line" id="005745"><span class="nick" style="color:#8dd3c7"><a href="#005745" label="[00:57:45]">&lt;oriansj&gt;</a></span><span class="message">wow and even AT&amp;T did a better FORTH chip than that</span></div><div class="line" id="005817"><span class="nick" style="color:#2e2a4a"><a href="#005817" label="[00:58:17]">&lt;muurkha&gt;</a></span><span class="message">perhaps if you think it's better your metric of what makes good Forth is opposed to Moore's :)</span></div><div class="line" id="005829"><span class="nick" style="color:#8dd3c7"><a href="#005829" label="[00:58:29]">&lt;oriansj&gt;</a></span><span class="message">AT&amp;T Hobbit</span></div><div class="line" id="005841"><span class="nick" style="color:#2e2a4a"><a href="#005841" label="[00:58:41]">&lt;muurkha&gt;</a></span><span class="message">the one they were going to use in the Newton</span></div><div class="line" id="005900"><span class="nick" style="color:#8dd3c7"><a href="#005900" label="[00:59:00]">&lt;oriansj&gt;</a></span><span class="message">and BeBox</span></div><div class="line" id="010006"><span class="nick" style="color:#2e2a4a"><a href="#010006" label="[01:00:06]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="010018"><span class="nick" style="color:#2e2a4a"><a href="#010018" label="[01:00:18]">&lt;muurkha&gt;</a></span><span class="message">I don't think the Hobbit was really meant as a Forth processor, but as a C processor</span></div><div class="line" id="010215"><span class="nick" style="color:#8dd3c7"><a href="#010215" label="[01:02:15]">&lt;oriansj&gt;</a></span><span class="message">true but it was a 1:1 map to forth in terms of assembly</span></div><div class="line" id="010221"><span class="nick" style="color:#2e2a4a"><a href="#010221" label="[01:02:21]">&lt;muurkha&gt;</a></span><span class="message">kind of</span></div><div class="line" id="010307"><span class="nick" style="color:#2e2a4a"><a href="#010307" label="[01:03:07]">&lt;muurkha&gt;</a></span><span class="message">the thing about having an infinitely deep data stack (or a 64-deep one like the Hobbit) allows you to write really bad Forth</span></div><div class="line" id="010317"><span class="nick" style="color:#2e2a4a"><a href="#010317" label="[01:03:17]">&lt;muurkha&gt;</a></span><span class="message">stuff that takes an inordinate amount of mental effort to get working</span></div><div class="line" id="010439"><span class="nick" style="color:#8dd3c7"><a href="#010439" label="[01:04:39]">&lt;oriansj&gt;</a></span><span class="message">as a really bad FORTH programmer: fair</span></div><div class="line" id="010742"><span class="nick" style="color:#8dd3c7"><a href="#010742" label="[01:07:42]">&lt;oriansj&gt;</a></span><span class="message">but perhaps I prefer architectures where bad programmers can work and learn to become better.</span></div><div class="line" id="010852"><span class="nick" style="color:#8dd3c7"><a href="#010852" label="[01:08:52]">&lt;oriansj&gt;</a></span><span class="message">make mistakes more forgivable and a gentle transition path to better code</span></div><div class="line" id="011102"><span class="nick" style="color:#8dd3c7"><a href="#011102" label="[01:11:02]">&lt;oriansj&gt;</a></span><span class="message">I guess that is why I like Knight; you can do it the wrong way if you want or even try something crazy</span></div><div class="line" id="011103"><span class="nick" style="color:#2e2a4a"><a href="#011103" label="[01:11:03]">&lt;muurkha&gt;</a></span><span class="message">well, I think that's what the stack limit does: your bad code crashes and you realize that it's because you have too much stuff on the stack</span></div><div class="line" id="011125"><span class="nick" style="color:#2e2a4a"><a href="#011125" label="[01:11:25]">&lt;muurkha&gt;</a></span><span class="message">so you put it in variables instead and your code becomes much more comprehensible</span></div><div class="line" id="011152"><span class="nick" style="color:#2e2a4a"><a href="#011152" label="[01:11:52]">&lt;muurkha&gt;</a></span><span class="message">that way you can avoid spending a lot of time debugging things with super complicated stack manipulations that very cleverly avoid ever putting anything in memory</span></div><div class="line" id="011212"><span class="nick" style="color:#2e2a4a"><a href="#011212" label="[01:12:12]">&lt;muurkha&gt;</a></span><span class="message">it doesn't give you enough rope to shoot yourself in the foot, as they say</span></div><div class="line" id="011320"><span class="nick" style="color:#2e2a4a"><a href="#011320" label="[01:13:20]">&lt;muurkha&gt;</a></span><span class="message">it's pretty much the same thing that happens with 8 or 16 named registers, just manifesting slightly differently</span></div><div class="line" id="011453"><span class="nick" style="color:#8dd3c7"><a href="#011453" label="[01:14:53]">&lt;oriansj&gt;</a></span><span class="message">well doing void foo(struct list* a) { if(NULL == a) return; foo(a-&gt;next); puts(a-&gt;text); } is simple but will segfault but reversing the list twice and just iterating, I guess would be the more correct way...</span></div><div class="line" id="011805"><span class="nick" style="color:#2e2a4a"><a href="#011805" label="[01:18:05]">&lt;muurkha&gt;</a></span><span class="message">why will it segfault?</span></div><div class="line" id="011814"><span class="nick" style="color:#8dd3c7"><a href="#011814" label="[01:18:14]">&lt;oriansj&gt;</a></span><span class="message">stack overflow</span></div><div class="line" id="011822"><span class="nick" style="color:#8dd3c7"><a href="#011822" label="[01:18:22]">&lt;oriansj&gt;</a></span><span class="message">if your list is long enough</span></div><div class="line" id="011840"><span class="nick" style="color:#2e2a4a"><a href="#011840" label="[01:18:40]">&lt;muurkha&gt;</a></span><span class="message">oh, you mean if you don't store your return addresses in memory?</span></div><div class="line" id="011904"><span class="nick" style="color:#2e2a4a"><a href="#011904" label="[01:19:04]">&lt;muurkha&gt;</a></span><span class="message">I think you need to store your return addresses in memory</span></div><div class="line" id="011920"><span class="nick" style="color:#8dd3c7"><a href="#011920" label="[01:19:20]">&lt;oriansj&gt;</a></span><span class="message">well that code stores the return address on the stack</span></div><div class="line" id="011928"><span class="nick" style="color:#2e2a4a"><a href="#011928" label="[01:19:28]">&lt;muurkha&gt;</a></span><span class="message">same as on RISC-V or ARM</span></div><div class="line" id="011944"><span class="nick" style="color:#2e2a4a"><a href="#011944" label="[01:19:44]">&lt;muurkha&gt;</a></span><span class="message">yeah, you can't use the MuP21 return stack as the C call stack, it's not deep enough</span></div><div class="line" id="012002"><span class="nick" style="color:#2e2a4a"><a href="#012002" label="[01:20:02]">&lt;muurkha&gt;</a></span><span class="message">it's more like a link register, as in a JAL instruction</span></div><div class="line" id="012015"><span class="nick" style="color:#8dd3c7"><a href="#012015" label="[01:20:15]">&lt;oriansj&gt;</a></span><span class="message">ugh</span></div><div class="line" id="012034"><span class="nick" style="color:#8dd3c7"><a href="#012034" label="[01:20:34]">&lt;oriansj&gt;</a></span><span class="message">if it was an option and not the only option it would be fine</span></div><div class="line" id="012051"><span class="nick" style="color:#2e2a4a"><a href="#012051" label="[01:20:51]">&lt;muurkha&gt;</a></span><span class="message">this is not a difference between ARM and MuP21</span></div><div class="line" id="012108"><span class="nick" style="color:#2e2a4a"><a href="#012108" label="[01:21:08]">&lt;muurkha&gt;</a></span><span class="message">the ARM's &quot;return stack&quot; is only one level deep</span></div><div class="line" id="012127"><span class="nick" style="color:#2e2a4a"><a href="#012127" label="[01:21:27]">&lt;muurkha&gt;</a></span><span class="message">so storing your return address in memory (for non-leaf subroutines) is the only option on ARM</span></div><div class="line" id="012150"><span class="nick" style="color:#2e2a4a"><a href="#012150" label="[01:21:50]">&lt;muurkha&gt;</a></span><span class="message">(x86 too, it's just sneakier about it)</span></div><div class="line" id="012150"><span class="nick" style="color:#8dd3c7"><a href="#012150" label="[01:21:50]">&lt;oriansj&gt;</a></span><span class="message">well link registers are the more *riscy* return option but perhaps I find them suboptimal</span></div><div class="line" id="012215"><span class="nick" style="color:#2e2a4a"><a href="#012215" label="[01:22:15]">&lt;muurkha&gt;</a></span><span class="message">they do require a bit of extra prologue and epilogue code for non-leaf subroutines</span></div><div class="line" id="012241"><span class="nick" style="color:#8dd3c7"><a href="#012241" label="[01:22:41]">&lt;oriansj&gt;</a></span><span class="message">indeed</span></div><div class="line" id="012251"><span class="nick" style="color:#2e2a4a"><a href="#012251" label="[01:22:51]">&lt;muurkha&gt;</a></span><span class="message">they're surely higher performance than implicitly hitting the dcache, though</span></div><div class="line" id="012305"><span class="nick" style="color:#8dd3c7"><a href="#012305" label="[01:23:05]">&lt;oriansj&gt;</a></span><span class="message">as M2-Planet spent a good bit of time documenting</span></div><div class="line" id="012344"><span class="nick" style="color:#2e2a4a"><a href="#012344" label="[01:23:44]">&lt;muurkha&gt;</a></span><span class="message">the MuP21 approach lets you use the return stack for a loop counter or other local variable or two, as well</span></div><div class="line" id="012345"><span class="nick" style="color:#8dd3c7"><a href="#012345" label="[01:23:45]">&lt;oriansj&gt;</a></span><span class="message">or explicitly hitting in knight's pushr R15 R0</span></div><div class="line" id="012413"><span class="nick" style="color:#8dd3c7"><a href="#012413" label="[01:24:13]">&lt;oriansj&gt;</a></span><span class="message">call R15 @foo</span></div><div class="line" id="012515"><span class="nick" style="color:#2e2a4a"><a href="#012515" label="[01:25:15]">&lt;muurkha&gt;</a></span><span class="message">by making the user-visible architectural storages stacks instead of registers you need fewer of them: data, return, PC, and A on the P21</span></div><div class="line" id="012723"><span class="nick" style="color:#2e2a4a"><a href="#012723" label="[01:27:23]">&lt;muurkha&gt;</a></span><span class="message">in a totally different direction, I was thinking about how the PDP-8's goofy addressing scheme is sort of like Smalltalk</span></div><div class="line" id="012802"><span class="nick" style="color:#8dd3c7"><a href="#012802" label="[01:28:02]">&lt;oriansj&gt;</a></span><span class="message">but without the missing source code problem</span></div><div class="line" id="012815"><span class="nick" style="color:#2e2a4a"><a href="#012815" label="[01:28:15]">&lt;muurkha&gt;</a></span><span class="message">missing source code problem?</span></div><div class="line" id="012922"><span class="nick" style="color:#8dd3c7"><a href="#012922" label="[01:29:22]">&lt;oriansj&gt;</a></span><span class="message">smalltalks tend to &quot;lose&quot; source code, especially in regards to complex features</span></div><div class="line" id="013022"><span class="nick" style="color:#8dd3c7"><a href="#013022" label="[01:30:22]">&lt;oriansj&gt;</a></span><span class="message">much like we saw in Bison in regards to features that are ugly to implement but can be used to produce a cleaner version of themselves</span></div><div class="line" id="013040"><span class="nick" style="color:#2e2a4a"><a href="#013040" label="[01:30:40]">&lt;muurkha&gt;</a></span><span class="message">oh, I understand what you mean</span></div><div class="line" id="013105"><span class="nick" style="color:#2e2a4a"><a href="#013105" label="[01:31:05]">&lt;muurkha&gt;</a></span><span class="message">yeah, they build from an image, not from source code</span></div><div class="line" id="013108"><span class="nick" style="color:#2e2a4a"><a href="#013108" label="[01:31:08]">&lt;muurkha&gt;</a></span><span class="message">I meant that each page of memory is sort of like a Smalltalk object though</span></div><div class="line" id="013151"><span class="nick" style="color:#2e2a4a"><a href="#013151" label="[01:31:51]">&lt;muurkha&gt;</a></span><span class="message">you have one form of instruction to access &quot;instance variables&quot; (in the current page) and another form of instruction to access other things (by using the indirect bit)</span></div><div class="line" id="013158"><span class="nick" style="color:#2e2a4a"><a href="#013158" label="[01:31:58]">&lt;muurkha&gt;</a></span><span class="message">on the PDP-8</span></div><div class="line" id="013219"><span class="nick" style="color:#8dd3c7"><a href="#013219" label="[01:32:19]">&lt;oriansj&gt;</a></span><span class="message">I can see that</span></div><div class="line" id="013236"><span class="nick" style="color:#2e2a4a"><a href="#013236" label="[01:32:36]">&lt;muurkha&gt;</a></span><span class="message">I was thinking it would be better if you had a class pointer as well as an instance pointer so that you can share the same code between different instances</span></div><div class="line" id="013242"><span class="nick" style="color:#2e2a4a"><a href="#013242" label="[01:32:42]">&lt;muurkha&gt;</a></span><span class="message">and a stack pointer</span></div><div class="line" id="013351"><span class="nick" style="color:#8dd3c7"><a href="#013351" label="[01:33:51]">&lt;oriansj&gt;</a></span><span class="message">I say, no special purpose pointers (besides PC maybe)</span></div><div class="line" id="013410"><span class="nick" style="color:#2e2a4a"><a href="#013410" label="[01:34:10]">&lt;muurkha&gt;</a></span><span class="message">well, that's the MISC/RISC direction</span></div><div class="line" id="013422"><span class="nick" style="color:#2e2a4a"><a href="#013422" label="[01:34:22]">&lt;muurkha&gt;</a></span><span class="message">I'm talking about the PDP/8 direction, which has lots of irregularities</span></div><div class="line" id="013427"><span class="nick" style="color:#2e2a4a"><a href="#013427" label="[01:34:27]">&lt;muurkha&gt;</a></span><span class="message">in order to save transistors</span></div><div class="line" id="013437"><span class="nick" style="color:#2e2a4a"><a href="#013437" label="[01:34:37]">&lt;muurkha&gt;</a></span><span class="message">if you restrict instances to have sizes that are a small range of powers of 2, you can index off the instance base pointers with bitwise OR instead of with addition, saving you a word-width adder</span></div><div class="line" id="013533"><span class="nick" style="color:#2e2a4a"><a href="#013533" label="[01:35:33]">&lt;muurkha&gt;</a></span><span class="message">if you want to avoid having a link register or self-modifying code you probably also need a stack pointer for subroutine calls</span></div><div class="line" id="013544"><span class="nick" style="color:#8dd3c7"><a href="#013544" label="[01:35:44]">&lt;oriansj&gt;</a></span><span class="message">I was thinking more RCA 1802</span></div><div class="line" id="013554"><span class="nick" style="color:#2e2a4a"><a href="#013554" label="[01:35:54]">&lt;muurkha&gt;</a></span><span class="message">I've never looked at its instruction set</span></div><div class="line" id="013655"><span class="nick" style="color:#8dd3c7"><a href="#013655" label="[01:36:55]">&lt;oriansj&gt;</a></span><span class="message">it has no dedicated PC</span></div><div class="line" id="013708"><span class="nick" style="color:#8dd3c7"><a href="#013708" label="[01:37:08]">&lt;oriansj&gt;</a></span><span class="message">and any register can be set to be the PC at anytime</span></div><div class="line" id="013842"><span class="nick" style="color:#2e2a4a"><a href="#013842" label="[01:38:42]">&lt;muurkha&gt;</a></span><span class="message">I see, so you could have a hardware stack in the same way, by having a &quot;set stack pointer&quot; instruction that determines which of various registers is the current stack pointer</span></div><div class="line" id="013933"><span class="nick" style="color:#8dd3c7"><a href="#013933" label="[01:39:33]">&lt;oriansj&gt;</a></span><span class="message">or as was done in knight, encode which register to use as the stack pointer in the instruction itself</span></div><div class="line" id="014010"><span class="nick" style="color:#2e2a4a"><a href="#014010" label="[01:40:10]">&lt;muurkha&gt;</a></span><span class="message">sure, same as the RISC-V or 68000</span></div><div class="line" id="014048"><span class="nick" style="color:#8dd3c7"><a href="#014048" label="[01:40:48]">&lt;oriansj&gt;</a></span><span class="message">and i can imagine using multiple stack registers but I can't imagine a *good idea* where one would want to change the PC register often</span></div><div class="line" id="014054"><span class="nick" style="color:#2e2a4a"><a href="#014054" label="[01:40:54]">&lt;muurkha&gt;</a></span><span class="message">I mean, RISC-V doesn't store the return address on the stack, but you can use any register as the stack pointer</span></div><div class="line" id="014126"><span class="nick" style="color:#8dd3c7"><a href="#014126" label="[01:41:26]">&lt;oriansj&gt;</a></span><span class="message">and without any push or pop instructions</span></div><div class="line" id="014133"><span class="nick" style="color:#2e2a4a"><a href="#014133" label="[01:41:33]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="014205"><span class="nick" style="color:#2e2a4a"><a href="#014205" label="[01:42:05]">&lt;muurkha&gt;</a></span><span class="message">typically on RISC-V you subtract a constant from the stack pointer and then do a buch of indexed stores to set up your stack frame</span></div><div class="line" id="014226"><span class="nick" style="color:#2e2a4a"><a href="#014226" label="[01:42:26]">&lt;muurkha&gt;</a></span><span class="message">also, for that matter, that's what GCC does for i386 and amd64 generally</span></div><div class="line" id="014242"><span class="nick" style="color:#2e2a4a"><a href="#014242" label="[01:42:42]">&lt;muurkha&gt;</a></span><span class="message">you could reserve different PCs for different coroutines</span></div><div class="line" id="014347"><span class="nick" style="color:#2e2a4a"><a href="#014347" label="[01:43:47]">&lt;muurkha&gt;</a></span><span class="message">or different stack levels: register 0 for the PC for leaf subroutines, register 1 for subroutines that call only leaf subroutines, and register 2 for all other subroutines</span></div><div class="line" id="014504"><span class="nick" style="color:#2e2a4a"><a href="#014504" label="[01:45:04]">&lt;muurkha&gt;</a></span><span class="message">that way the return from level-0 and level-1 subroutines is just a SEP instruction, and calling them is two instructions</span></div><div class="line" id="014708"><span class="nick" style="color:#2e2a4a"><a href="#014708" label="[01:47:08]">&lt;muurkha&gt;</a></span><span class="message">I have this intuition that dynamically most calls and returns are to leaf subroutines, and even more are to leaf subroutines or subroutines that call only leaf subroutines</span></div><div class="line" id="020545"><span class="nick" style="color:#2e2a4a"><a href="#020545" label="[02:05:45]">&lt;muurkha&gt;</a></span><span class="message">btw, oriansj, do you know about the history of the PDP-X?  not jcowan's PDP-8/X</span></div><div class="line" id="023517"><span class="nick" style="color:#8dd3c7"><a href="#023517" label="[02:35:17]">&lt;oriansj&gt;</a></span><span class="message">muurkha: you mean the one that became the DG Nova?</span></div><div class="line" id="023536"><span class="nick" style="color:#2e2a4a"><a href="#023536" label="[02:35:36]">&lt;muurkha&gt;</a></span><span class="message">yes, and also the Alto and the PDP-11</span></div><div class="line" id="023550"><span class="nick" style="color:#2e2a4a"><a href="#023550" label="[02:35:50]">&lt;muurkha&gt;</a></span><span class="message">and thus gave us WIMP and Unix</span></div><div class="line" id="023832"><span class="nick" style="color:#8dd3c7"><a href="#023832" label="[02:38:32]">&lt;oriansj&gt;</a></span><span class="message">I am pretty sure the PDP-11 and PDP-X were competitors and the PDP-X lost out</span></div><div class="line" id="023859"><span class="nick" style="color:#2e2a4a"><a href="#023859" label="[02:38:59]">&lt;muurkha&gt;</a></span><span class="message">well, the PDP-X itself was canceled, which is why the team left DEC to start Data General</span></div><div class="line" id="023936"><span class="nick" style="color:#2e2a4a"><a href="#023936" label="[02:39:36]">&lt;muurkha&gt;</a></span><span class="message">the PDP-11 project itself started a couple of years later as Desk Calculator</span></div><div class="line" id="023951"><span class="nick" style="color:#8dd3c7"><a href="#023951" label="[02:39:51]">&lt;oriansj&gt;</a></span><span class="message">and looking at its description was rather ambitious as a register-memory instruction architecture</span></div><div class="line" id="024017"><span class="nick" style="color:#2e2a4a"><a href="#024017" label="[02:40:17]">&lt;muurkha&gt;</a></span><span class="message">what's a register-memory instruction architecture?</span></div><div class="line" id="024113"><span class="nick" style="color:#8dd3c7"><a href="#024113" label="[02:41:13]">&lt;oriansj&gt;</a></span><span class="message">think vax instructions with 1 operand always in memory</span></div><div class="line" id="024327"><span class="nick" style="color:#8dd3c7"><a href="#024327" label="[02:43:27]">&lt;oriansj&gt;</a></span><span class="message">2 operand only btw</span></div><div class="line" id="024524"><span class="nick" style="color:#8dd3c7"><a href="#024524" label="[02:45:24]">&lt;oriansj&gt;</a></span><span class="message">so add r0 [address] and add [address] r5 but never add r0 r5</span></div><div class="line" id="024624"><span class="nick" style="color:#2e2a4a"><a href="#024624" label="[02:46:24]">&lt;muurkha&gt;</a></span><span class="message">hmm, what's ambitious about that?</span></div><div class="line" id="024652"><span class="nick" style="color:#2e2a4a"><a href="#024652" label="[02:46:52]">&lt;muurkha&gt;</a></span><span class="message">I mean the PDP-8 could be described that way too, it's just that it had a single accumulator instead of several</span></div><div class="line" id="024908"><span class="nick" style="color:#8dd3c7"><a href="#024908" label="[02:49:08]">&lt;oriansj&gt;</a></span><span class="message">fitting it in the manufacturing cost budget</span></div><div class="line" id="025009"><span class="nick" style="color:#8dd3c7"><a href="#025009" label="[02:50:09]">&lt;oriansj&gt;</a></span><span class="message">VAX sort of complexity in a pdp-8 budget is no simple feat</span></div><div class="line" id="025046"><span class="nick" style="color:#2e2a4a"><a href="#025046" label="[02:50:46]">&lt;muurkha&gt;</a></span><span class="message">I don't think having multiple general-purpose registers amounts to VAX sort of complexity</span></div><div class="line" id="025129"><span class="nick" style="color:#8dd3c7"><a href="#025129" label="[02:51:29]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="http://simh.trailing-edge.com/docs/pdpx.pdf">http://simh.trailing-edge.com/docs/pdpx.pdf</a> </span></div><div class="line" id="025147"><span class="nick" style="color:#2e2a4a"><a href="#025147" label="[02:51:47]">&lt;muurkha&gt;</a></span><span class="message">I mean the PDP-11 had 8 GPRs and the Nova had 4</span></div><div class="line" id="025302"><span class="nick" style="color:#2e2a4a"><a href="#025302" label="[02:53:02]">&lt;muurkha&gt;</a></span><span class="message">interesting!</span></div><div class="line" id="025352"><span class="nick" style="color:#2e2a4a"><a href="#025352" label="[02:53:52]">&lt;muurkha&gt;</a></span><span class="message">it sounds like it was *less* ambitious than its children though. as you'd expect!</span></div><div class="line" id="025413"><span class="nick" style="color:#8dd3c7"><a href="#025413" label="[02:54:13]">&lt;oriansj&gt;</a></span><span class="message">the multiple register sets was certainly new</span></div><div class="line" id="025449"><span class="nick" style="color:#2e2a4a"><a href="#025449" label="[02:54:49]">&lt;muurkha&gt;</a></span><span class="message">well, it was a difference from the PDP-8, but not, for example, the IBM 360 model 20</span></div><div class="line" id="025519"><span class="nick" style="color:#2e2a4a"><a href="#025519" label="[02:55:19]">&lt;muurkha&gt;</a></span><span class="message">I don't think it had multiple register *files*, though, just multiple accumulators (what we'd call &quot;registers&quot; today)</span></div><div class="line" id="025538"><span class="nick" style="color:#2e2a4a"><a href="#025538" label="[02:55:38]">&lt;muurkha&gt;</a></span><span class="message">no, I'm wrong</span></div><div class="line" id="025541"><span class="nick" style="color:#2e2a4a"><a href="#025541" label="[02:55:41]">&lt;muurkha&gt;</a></span><span class="message">it did</span></div><div class="line" id="025613"><span class="nick" style="color:#8dd3c7"><a href="#025613" label="[02:56:13]">&lt;oriansj&gt;</a></span><span class="message">the NOVA was massively simplified relative to the PDP-X and it still costed more than a PDP-8</span></div><div class="line" id="025701"><span class="nick" style="color:#2e2a4a"><a href="#025701" label="[02:57:01]">&lt;muurkha&gt;</a></span><span class="message">it did have some simplifications</span></div><div class="line" id="025721"><span class="nick" style="color:#2e2a4a"><a href="#025721" label="[02:57:21]">&lt;muurkha&gt;</a></span><span class="message">there were previous processors that had multiple register files, too, like the TX-0 on which Sketchpad was written and the PPU of the CDC 6600.  the later Z-80 did too</span></div><div class="line" id="025927"><span class="nick" style="color:#8dd3c7"><a href="#025927" label="[02:59:27]">&lt;oriansj&gt;</a></span><span class="message">alot of simplifications but yeah</span></div><div class="line" id="030010"><span class="nick" style="color:#2e2a4a"><a href="#030010" label="[03:00:10]">&lt;muurkha&gt;</a></span><span class="message">the TMS 9900 that was in the TI-99/4A home computer a bit later actually had an unlimited number of register files because they were in RAM</span></div><div class="line" id="030054"><span class="nick" style="color:#8dd3c7"><a href="#030054" label="[03:00:54]">&lt;oriansj&gt;</a></span><span class="message">super unreliable chips though</span></div><div class="line" id="030151"><span class="nick" style="color:#2e2a4a"><a href="#030151" label="[03:01:51]">&lt;muurkha&gt;</a></span><span class="message">what, the TMS 9900?</span></div><div class="line" id="030216"><span class="nick" style="color:#2e2a4a"><a href="#030216" label="[03:02:16]">&lt;muurkha&gt;</a></span><span class="message">I hadn't ever heard that</span></div><div class="line" id="030404"><span class="nick" style="color:#2e2a4a"><a href="#030404" label="[03:04:04]">&lt;muurkha&gt;</a></span><span class="message">it sounds like the Nova really was sort of VLIWish.  I mean the PDP-8 is a little bit that way but the Nova seems to have been much more so</span></div><div class="line" id="030601"><span class="nick" style="color:#2e2a4a"><a href="#030601" label="[03:06:01]">&lt;muurkha&gt;</a></span><span class="message">the addressing modes on the Nova sound almost exactly the same as the addressing modes on the PDP-X</span></div><div class="line" id="030612"><span class="nick" style="color:#8dd3c7"><a href="#030612" label="[03:06:12]">&lt;oriansj&gt;</a></span><span class="message">muurkha: yeah, I seen lots of issues with reliablity on those chips by people trying to make custom Computers with them</span></div><div class="line" id="030635"><span class="nick" style="color:#2e2a4a"><a href="#030635" label="[03:06:35]">&lt;muurkha&gt;</a></span><span class="message">interesting, where did they get them?</span></div><div class="line" id="030702"><span class="nick" style="color:#8dd3c7"><a href="#030702" label="[03:07:02]">&lt;oriansj&gt;</a></span><span class="message">couldn't say but if I had to guess, I would say third party distributors</span></div><div class="line" id="030901"><span class="nick" style="color:#2e2a4a"><a href="#030901" label="[03:09:01]">&lt;muurkha&gt;</a></span><span class="message">I agree with Supnik's assertion that both the Nova and the PDP-11 were major advances over the PDP-X</span></div><div class="line" id="031101"><span class="nick" style="color:#2e2a4a"><a href="#031101" label="[03:11:01]">&lt;muurkha&gt;</a></span><span class="message">but I also think it's reasonable to see the PDP-11 and especially the Nova as being more fully developed versions of the PDP-X; there's a pretty clear family resemblance from my point of view</span></div><div class="line" id="031114"><span class="nick" style="color:#8dd3c7"><a href="#031114" label="[03:11:14]">&lt;oriansj&gt;</a></span><span class="message">the reliablity had often to do the very touchy RAM requirements which if not exactly right lead to impossible to trace bugs</span></div><div class="line" id="031149"><span class="nick" style="color:#2e2a4a"><a href="#031149" label="[03:11:49]">&lt;muurkha&gt;</a></span><span class="message">though Supnik disagrees, and I guess he knows a thing or two I don't :)</span></div><div class="line" id="031243"><span class="nick" style="color:#8dd3c7"><a href="#031243" label="[03:12:43]">&lt;oriansj&gt;</a></span><span class="message">did you see the Jason Scott Supnik interview yet?</span></div><div class="line" id="031250"><span class="nick" style="color:#2e2a4a"><a href="#031250" label="[03:12:50]">&lt;muurkha&gt;</a></span><span class="message">no, that sounds cool</span></div><div class="line" id="031327"><span class="nick" style="color:#2e2a4a"><a href="#031327" label="[03:13:27]">&lt;muurkha&gt;</a></span><span class="message">the Smalltalk-80 virtual machine also had four addressing modes, like the Nova (on the hardware of a clone of which it was implemented in microcode) and the PDP-X</span></div><div class="line" id="031349"><span class="nick" style="color:#8dd3c7"><a href="#031349" label="[03:13:49]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://archive.org/details/GETLAMP-Supnik">https://archive.org/details/GETLAMP-Supnik</a> </span></div><div class="line" id="031456"><span class="nick" style="color:#8dd3c7"><a href="#031456" label="[03:14:56]">&lt;oriansj&gt;</a></span><span class="message">most if it never made it into Get LAMP</span></div><div class="line" id="031500"><span class="nick" style="color:#8dd3c7"><a href="#031500" label="[03:15:00]">&lt;oriansj&gt;</a></span><span class="message">but it is an interview that really should have been much longer</span></div><div class="line" id="031851"><span class="nick" style="color:#2e2a4a"><a href="#031851" label="[03:18:51]">&lt;muurkha&gt;</a></span><span class="message">the four Smalltalk-80 addressing modes were: local variables; instance variables; global variables; and constant-pool entries</span></div><div class="line" id="031928"><span class="nick" style="color:#2e2a4a"><a href="#031928" label="[03:19:28]">&lt;muurkha&gt;</a></span><span class="message">global variables and constant-pool entries roughly correspond to PDP-8 zero-page and current-page addressing</span></div><div class="line" id="031952"><span class="nick" style="color:#2e2a4a"><a href="#031952" label="[03:19:52]">&lt;muurkha&gt;</a></span><span class="message">except you also had to use current-page addressing for local variables and instance variables</span></div><div class="line" id="032039"><span class="nick" style="color:#2e2a4a"><a href="#032039" label="[03:20:39]">&lt;muurkha&gt;</a></span><span class="message">so I was thinking that two more registers for those would be handy.  apparently the PDP-X and Nova designers had the same thought</span></div><div class="line" id="032122"><span class="nick" style="color:#2e2a4a"><a href="#032122" label="[03:21:22]">&lt;muurkha&gt;</a></span><span class="message">very plausibly I was unconsciously recycling the Nova idea as laundered through Smalltalk</span></div><div class="line" id="032944"><span class="nick" style="color:#2e2a4a"><a href="#032944" label="[03:29:44]">&lt;muurkha&gt;</a></span><span class="message">I think Supnik is talking about 01977 or 01978 in the early part of this interview, &quot;5 years before the IBM PC&quot;</span></div><div class="line" id="033001"><span class="nick" style="color:#2e2a4a"><a href="#033001" label="[03:30:01]">&lt;muurkha&gt;</a></span><span class="message">when PDP-11 access was widespread within DEC</span></div><div class="line" id="033055"><span class="nick" style="color:#2e2a4a"><a href="#033055" label="[03:30:55]">&lt;muurkha&gt;</a></span><span class="message">ah, yep.  &quot;I only joined DEC in the summer of 1977&quot;.</span></div><div class="line" id="043226"><span class="nick" style="color:#8dd3c7"><a href="#043226" label="[04:32:26]">&lt;oriansj&gt;</a></span><span class="message">thinking deeper on the 1802 SEP instruction and if it was extended to multiprocessing; it probably should be a Kernel level or above only instruction as otherwise polymorphic code becomes the least of your concerns</span></div><div class="line" id="043404"><span class="nick" style="color:#2e2a4a"><a href="#043404" label="[04:34:04]">&lt;muurkha&gt;</a></span><span class="message">hmm?  no, I think calling subroutines and returning from them is a reasonable thing for user code to do</span></div><div class="line" id="043432"><span class="nick" style="color:#2e2a4a"><a href="#043432" label="[04:34:32]">&lt;muurkha&gt;</a></span><span class="message">as is yielding to coroutines</span></div><div class="line" id="043456"><span class="nick" style="color:#2e2a4a"><a href="#043456" label="[04:34:56]">&lt;muurkha&gt;</a></span><span class="message">but what does &quot;if it was extended to multiprocessing&quot; mean?  adding a compare-and-swap instruction to the instruction set?</span></div><div class="line" id="043504"><span class="nick" style="color:#8dd3c7"><a href="#043504" label="[04:35:04]">&lt;oriansj&gt;</a></span><span class="message">muurkha: imagine you are a kernel and you don't know which register is the instruction pointer</span></div><div class="line" id="043549"><span class="nick" style="color:#8dd3c7"><a href="#043549" label="[04:35:49]">&lt;oriansj&gt;</a></span><span class="message">store the current process state correctly.</span></div><div class="line" id="043605"><span class="nick" style="color:#2e2a4a"><a href="#043605" label="[04:36:05]">&lt;muurkha&gt;</a></span><span class="message">well, you do need to have a register you can save and restore that tells you which accumulator is the PC at the moment, yes</span></div><div class="line" id="043634"><span class="nick" style="color:#2e2a4a"><a href="#043634" label="[04:36:34]">&lt;muurkha&gt;</a></span><span class="message">oh, you meant multitasking, not multiple CPUs sharing memory</span></div><div class="line" id="043826"><span class="nick" style="color:#8dd3c7"><a href="#043826" label="[04:38:26]">&lt;oriansj&gt;</a></span><span class="message">sorry if I used the incorrect term but I am glad you realized the implied meaning</span></div><div class="line" id="044238"><span class="nick" style="color:#2e2a4a"><a href="#044238" label="[04:42:38]">&lt;muurkha&gt;</a></span><span class="message">sometimes it takes me a while but I did eventually figure it out</span></div><div class="line" id="044608"><span class="nick" style="color:#2e2a4a"><a href="#044608" label="[04:46:08]">&lt;muurkha&gt;</a></span><span class="message">hey, I had no idea Supnik managed Alpha</span></div><div class="line" id="044625"><span class="nick" style="color:#8dd3c7"><a href="#044625" label="[04:46:25]">&lt;oriansj&gt;</a></span><span class="message">muurkha: he was also the one that killed Prism</span></div><div class="line" id="044648"><span class="nick" style="color:#8dd3c7"><a href="#044648" label="[04:46:48]">&lt;oriansj&gt;</a></span><span class="message">^Prism^DEC Prism^</span></div><div class="line" id="044650"><span class="nick" style="color:#2e2a4a"><a href="#044650" label="[04:46:50]">&lt;muurkha&gt;</a></span><span class="message">Prism?</span></div><div class="line" id="044707"><span class="nick" style="color:#2e2a4a"><a href="#044707" label="[04:47:07]">&lt;muurkha&gt;</a></span><span class="message">I'm amused to hear that he thought of encoding strings in RADIX-50 as being &quot;an ugly trick&quot;</span></div><div class="line" id="044736"><span class="nick" style="color:#2e2a4a"><a href="#044736" label="[04:47:36]">&lt;muurkha&gt;</a></span><span class="message">the Infocom Z-machine did something similar but slightly less extreme IIRC</span></div><div class="line" id="044810"><span class="nick" style="color:#8dd3c7"><a href="#044810" label="[04:48:10]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="http://simh.trailing-edge.com/semi/uprism.html">http://simh.trailing-edge.com/semi/uprism.html</a> </span></div><div class="line" id="044822"><span class="nick" style="color:#8dd3c7"><a href="#044822" label="[04:48:22]">&lt;oriansj&gt;</a></span><span class="message">the precursor to DEC Alpha</span></div><div class="line" id="044824"><span class="nick" style="color:#2e2a4a"><a href="#044824" label="[04:48:24]">&lt;muurkha&gt;</a></span><span class="message">yeah, a 5-bit encoding: <a rel="nofollow" href="https://www.inform-fiction.org/zmachine/standards/z1point0/sect03.html">https://www.inform-fiction.org/zmachine/standards/z1point0/sect03.html</a> </span></div><div class="line" id="044847"><span class="nick" style="color:#2e2a4a"><a href="#044847" label="[04:48:47]">&lt;muurkha&gt;</a></span><span class="message">so 32 characters rather than the 40 of RADIX50</span></div><div class="line" id="044913"><span class="nick" style="color:#2e2a4a"><a href="#044913" label="[04:49:13]">&lt;muurkha&gt;</a></span><span class="message">but similarly three characters per 16-bit word</span></div><div class="line" id="044956"><span class="nick" style="color:#8dd3c7"><a href="#044956" label="[04:49:56]">&lt;oriansj&gt;</a></span><span class="message">very clever given the memory limits</span></div><div class="line" id="045221"><span class="nick" style="color:#2e2a4a"><a href="#045221" label="[04:52:21]">&lt;muurkha&gt;</a></span><span class="message">Prism sounds very painful</span></div><div class="line" id="045234"><span class="nick" style="color:#8dd3c7"><a href="#045234" label="[04:52:34]">&lt;oriansj&gt;</a></span><span class="message">64 truly general purpose registers (floating point/integer) and EPICODE which was much more powerful to the later PALCODE of DEC Alpha</span></div><div class="line" id="045454"><span class="nick" style="color:#2e2a4a"><a href="#045454" label="[04:54:54]">&lt;muurkha&gt;</a></span><span class="message">sounds like context switching would have been very slow</span></div><div class="line" id="045547"><span class="nick" style="color:#2e2a4a"><a href="#045547" label="[04:55:47]">&lt;muurkha&gt;</a></span><span class="message">it'd be interesting to find out how its performance compared with MIPS</span></div><div class="line" id="045604"><span class="nick" style="color:#2e2a4a"><a href="#045604" label="[04:56:04]">&lt;muurkha&gt;</a></span><span class="message">probably Supnik made the right call</span></div><div class="line" id="045710"><span class="nick" style="color:#2e2a4a"><a href="#045710" label="[04:57:10]">&lt;muurkha&gt;</a></span><span class="message">RADIX50 didn't have shift states, so ZSCII actually had a larger character repertoire</span></div><div class="line" id="045815"><span class="nick" style="color:#2e2a4a"><a href="#045815" label="[04:58:15]">&lt;muurkha&gt;</a></span><span class="message">including, importantly for Zork, lower case</span></div><div class="line" id="045835"><span class="nick" style="color:#8dd3c7"><a href="#045835" label="[04:58:35]">&lt;oriansj&gt;</a></span><span class="message">right business call, probably. Right engineering call, harder to say</span></div><div class="line" id="045928"><span class="nick" style="color:#2e2a4a"><a href="#045928" label="[04:59:28]">&lt;muurkha&gt;</a></span><span class="message">yeah, DEC wasn't yet on the ropes the way it would be ten years and a farrago of patent lawsuits later</span></div><div class="line" id="050002"><span class="nick" style="color:#2e2a4a"><a href="#050002" label="[05:00:02]">&lt;muurkha&gt;</a></span><span class="message">so maybe developing their own high-performance RISC chip in 01988 instead of 01993 would have been worth the cost</span></div><div class="line" id="050100"><span class="nick" style="color:#2e2a4a"><a href="#050100" label="[05:01:00]">&lt;muurkha&gt;</a></span><span class="message">last night I was reading Kevin Carson's &quot;The Homebrew Industrial Revolution&quot; (CC-BY-SA) in which he documents, among other things, the nightmarish patent landscape around electricity in the late 01800s that led to the GE/Westinghouse duopoly</span></div><div class="line" id="050108"><span class="nick" style="color:#8dd3c7"><a href="#050108" label="[05:01:08]">&lt;oriansj&gt;</a></span><span class="message">also, DEC did refuse to sell their Alpha CPUs to Apple which only ended up creating PowerPC as a competitor</span></div><div class="line" id="050120"><span class="nick" style="color:#2e2a4a"><a href="#050120" label="[05:01:20]">&lt;muurkha&gt;</a></span><span class="message">did they? I didn't know that</span></div><div class="line" id="050156"><span class="nick" style="color:#2e2a4a"><a href="#050156" label="[05:01:56]">&lt;muurkha&gt;</a></span><span class="message">retaining Dave Cutler instead of losing him to Microsloth probably would have helped DEC significantly</span></div><div class="line" id="050240"><span class="nick" style="color:#8dd3c7"><a href="#050240" label="[05:02:40]">&lt;oriansj&gt;</a></span><span class="message">yeah Ken Olsen the CEO of DEC was the one who refused to make business deals with a man who would cheat so brazenly on his wife: <a rel="nofollow" href="https://www.goodreads.com/book/show/341220.DEC_Is_Dead_Long_Live_DEC">https://www.goodreads.com/book/show/341220.DEC_Is_Dead_Long_Live_DEC</a> </span></div><div class="line" id="050343"><span class="nick" style="color:#2e2a4a"><a href="#050343" label="[05:03:43]">&lt;muurkha&gt;</a></span><span class="message">hm?</span></div><div class="line" id="050353"><span class="nick" style="color:#2e2a4a"><a href="#050353" label="[05:03:53]">&lt;muurkha&gt;</a></span><span class="message">you may be seeing something on that page I don't</span></div><div class="line" id="050414"><span class="nick" style="color:#8dd3c7"><a href="#050414" label="[05:04:14]">&lt;oriansj&gt;</a></span><span class="message">oh, no it is just a link to the book where I find that tidbit</span></div><div class="line" id="050452"><span class="nick" style="color:#2e2a4a"><a href="#050452" label="[05:04:52]">&lt;muurkha&gt;</a></span><span class="message">ah</span></div><div class="line" id="050541"><span class="nick" style="color:#2e2a4a"><a href="#050541" label="[05:05:41]">&lt;muurkha&gt;</a></span><span class="message">I think that in general in business you have to be prepared for the risk that you're buying and selling to people who are not entirely honest and who may rip you off</span></div><div class="line" id="050728"><span class="nick" style="color:#8dd3c7"><a href="#050728" label="[05:07:28]">&lt;oriansj&gt;</a></span><span class="message">be willing to sell the rope needed to hang you sort of model...</span></div><div class="line" id="050850"><span class="nick" style="color:#8dd3c7"><a href="#050850" label="[05:08:50]">&lt;oriansj&gt;</a></span><span class="message">John Sculley, Apple's CEO of those days, met with Kenneth Olsen in June of the same year and offered him to use the new processor of DEC in future Macs. Olsen refused the offer</span></div><div class="line" id="050854"><span class="nick" style="color:#8dd3c7"><a href="#050854" label="[05:08:54]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="http://alasir.com/articles/alpha_history/dec_collapse.shtml">http://alasir.com/articles/alpha_history/dec_collapse.shtml</a> </span></div><div class="line" id="050924"><span class="nick" style="color:#8dd3c7"><a href="#050924" label="[05:09:24]">&lt;oriansj&gt;</a></span><span class="message">with a slightly different reason given than the book</span></div><div class="line" id="050947"><span class="nick" style="color:#8dd3c7"><a href="#050947" label="[05:09:47]">&lt;oriansj&gt;</a></span><span class="message">but the meeting did occur and the sale was ultimately refused.</span></div><div class="line" id="051126"><span class="nick" style="color:#8dd3c7"><a href="#051126" label="[05:11:26]">&lt;oriansj&gt;</a></span><span class="message">but one could argue the culture of DEC was ultimately what killed it as a company. It just didn't have the money gene needed to become only a componet company instead of a computer company</span></div><div class="line" id="051428"><span class="nick" style="color:#2e2a4a"><a href="#051428" label="[05:14:28]">&lt;muurkha&gt;</a></span><span class="message">CDC ended up making disk drives</span></div><div class="line" id="051636"><span class="nick" style="color:#2e2a4a"><a href="#051636" label="[05:16:36]">&lt;muurkha&gt;</a></span><span class="message">Unisys is best known nowadays as a patent troll</span></div><div class="line" id="051701"><span class="nick" style="color:#2e2a4a"><a href="#051701" label="[05:17:01]">&lt;muurkha&gt;</a></span><span class="message">though, speaking of stack machines, they do still sell ClearPath MCP mainframes</span></div><div class="line" id="051702"><span class="nick" style="color:#8dd3c7"><a href="#051702" label="[05:17:02]">&lt;oriansj&gt;</a></span><span class="message">IBM is now most successful reselling Red Hat support</span></div><div class="line" id="051719"><span class="nick" style="color:#2e2a4a"><a href="#051719" label="[05:17:19]">&lt;muurkha&gt;</a></span><span class="message">I think IBM Global Services may be their biggest division</span></div><div class="line" id="052136"><span class="nick" style="color:#8dd3c7"><a href="#052136" label="[05:21:36]">&lt;oriansj&gt;</a></span><span class="message">well those Red Hat Government contracts certainly are a great cash machine for them</span></div><div class="line" id="052230"><span class="nick" style="color:#8dd3c7"><a href="#052230" label="[05:22:30]">&lt;oriansj&gt;</a></span><span class="message">assuming they don't get too greedy and kill that golden goose...</span></div><div class="line" id="052253"><span class="nick" style="color:#2e2a4a"><a href="#052253" label="[05:22:53]">&lt;muurkha&gt;</a></span><span class="message">it may happen due to events outside their control</span></div><div class="line" id="052304"><span class="nick" style="color:#2e2a4a"><a href="#052304" label="[05:23:04]">&lt;muurkha&gt;</a></span><span class="message">no goose is immortal</span></div><div class="line" id="052437"><span class="nick" style="color:#8dd3c7"><a href="#052437" label="[05:24:37]">&lt;oriansj&gt;</a></span><span class="message">but a smart person knows that proper geese herding involves breeding; thus providing an eternal line</span></div><div class="line" id="194443"><span class="nick" style="color:#2e2a4a"><a href="#194443" label="[19:44:43]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="http://alasir.com/articles/alpha_history/prism_to_alpha.html">http://alasir.com/articles/alpha_history/prism_to_alpha.html</a>  claims PRISM had Cray-style (RV64V-style) vector registers, although it says they were &quot;64-bit vector registers&quot;, which is way too small</span></div><div class="line" id="194521"><span class="nick" style="color:#2e2a4a"><a href="#194521" label="[19:45:21]">&lt;muurkha&gt;</a></span><span class="message">it says there was a 7-bit vector length register, so presumably the vector registers were actually 128-entry</span></div><div class="line" id="195509"><span class="nick" style="color:#6b8072"><a href="#195509" label="[19:55:09]">&lt;GeDaMo&gt;</a></span><span class="message"> <a rel="nofollow" href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>  &quot;This wiki has no edits or logs made within the last 45 days, therefore it is marked as inactive. If you would like to prevent this wiki from being closed, please start showing signs of activity here.&quot;</span></div><div class="line" id="195636"><span class="nick" style="color:#2e2a4a"><a href="#195636" label="[19:56:36]">&lt;muurkha&gt;</a></span><span class="message">thanks for the reminder!</span></div><div class="line" id="195654"><span class="nick" style="color:#2e2a4a"><a href="#195654" label="[19:56:54]">&lt;muurkha&gt;</a></span><span class="message">I don't think I have an account</span></div><div class="line" id="205302"><span class="nick">***</span><span class="message notice">genr8eofl__ is now known as genr8eofl</span></div><div class="line" id="214140"><span class="nick">***</span><span class="message notice">Noisytoot_ is now known as Noisytoot</span></div><br /></div></body></html>