<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-03-08.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000118"><span class="nick" style="color:#389600"><a href="#000118" label="[00:01:18]">&lt;muurkha&gt;</a></span><span class="message">usually filesystems have to worry a lot about disk sequencing, consistency on power outages, consistency of the buffer cache, fragmentation vs. block allocation efficiency, that kind of thing.  those problems mostly go away if you can get away with just writing the entire consistent filesystem image to disk when someone says `sync`</span></div><div class="line" id="000233"><span class="nick" style="color:#8dd3c7"><a href="#000233" label="[00:02:33]">&lt;oriansj&gt;</a></span><span class="message">muurkha: we also can dictate no power outages; do no buffering, ignore fragmentation and just stick to 4K blocks</span></div><div class="line" id="000250"><span class="nick" style="color:#389600"><a href="#000250" label="[00:02:50]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="000358"><span class="nick" style="color:#8dd3c7"><a href="#000358" label="[00:03:58]">&lt;oriansj&gt;</a></span><span class="message">performance doesn't matter nor do we have to be efficient in any regard than simplicity</span></div><div class="line" id="000423"><span class="nick" style="color:#389600"><a href="#000423" label="[00:04:23]">&lt;muurkha&gt;</a></span><span class="message">well, if the resulting system isn't usable, people won't use it to look at the source</span></div><div class="line" id="000440"><span class="nick" style="color:#389600"><a href="#000440" label="[00:04:40]">&lt;muurkha&gt;</a></span><span class="message">so you're back to trusting mainstream Linux or whatever to not lie to you about what the source says</span></div><div class="line" id="000511"><span class="nick" style="color:#389600"><a href="#000511" label="[00:05:11]">&lt;muurkha&gt;</a></span><span class="message">but that's still a lot better than where we are now</span></div><div class="line" id="000537"><span class="nick" style="color:#8dd3c7"><a href="#000537" label="[00:05:37]">&lt;oriansj&gt;</a></span><span class="message">well nothing will be there to stop us from building a better version in the M2-Planet C subset and just switch to that too</span></div><div class="line" id="001005"><span class="nick" style="color:#8dd3c7"><a href="#001005" label="[00:10:05]">&lt;oriansj&gt;</a></span><span class="message">also I am planning on using BootOS (possibly with some tweaks) and manually making a GFK file system by hand and a couple boot sector programs for manually writing the pieces onto the disk</span></div><div class="line" id="001123"><span class="nick" style="color:#8dd3c7"><a href="#001123" label="[00:11:23]">&lt;oriansj&gt;</a></span><span class="message">but first things first, I need to solve this kernel problem and shrink the TCB more and into a form that I can then snuff out</span></div><div class="line" id="001624"><span class="nick" style="color:#389600"><a href="#001624" label="[00:16:24]">&lt;muurkha&gt;</a></span><span class="message">Green Fluorescent Knowledge?</span></div><div class="line" id="001705"><span class="nick" style="color:#389600"><a href="#001705" label="[00:17:05]">&lt;muurkha&gt;</a></span><span class="message">Grand Forks?  Ghostface Killah?</span></div><div class="line" id="003750"><span class="nick" style="color:#8dd3c7"><a href="#003750" label="[00:37:50]">&lt;oriansj&gt;</a></span><span class="message">muurkha: good forking knight filesystem</span></div><div class="line" id="004144"><span class="nick" style="color:#389600"><a href="#004144" label="[00:41:44]">&lt;muurkha&gt;</a></span><span class="message">heh</span></div><div class="line" id="005510"><span class="nick" style="color:#8dd3c7"><a href="#005510" label="[00:55:10]">&lt;oriansj&gt;</a></span><span class="message">figured I might as well make a filesystem made to be hand edited and trivial in assembly to support</span></div><div class="line" id="010416"><span class="nick" style="color:#389600"><a href="#010416" label="[01:04:16]">&lt;muurkha&gt;</a></span><span class="message">the UCSD p-System filesystem didn't support fragmented files at all</span></div><div class="line" id="010450"><span class="nick" style="color:#389600"><a href="#010450" label="[01:04:50]">&lt;muurkha&gt;</a></span><span class="message">if you wanted to write a file that wouldn't fit into any of the free spaces on the disk, you had to run a defragmenter program to defragment the disk</span></div><div class="line" id="010533"><span class="nick" style="color:#389600"><a href="#010533" label="[01:05:33]">&lt;muurkha&gt;</a></span><span class="message">for a usable bootstrapped system I've been thinking of directly accessing NAND Flash without a FTL</span></div><div class="line" id="010537"><span class="nick" style="color:#8dd3c7"><a href="#010537" label="[01:05:37]">&lt;oriansj&gt;</a></span><span class="message">page based filesystem seems relatively simple to do and then I can just ignore being fragmented</span></div><div class="line" id="010650"><span class="nick" style="color:#389600"><a href="#010650" label="[01:06:50]">&lt;muurkha&gt;</a></span><span class="message">not sure why they made that choice but possibly one reason was so that the whole filesystem catalog would fit in one sector (this was floppy-disk era, so the disk might be up to a megabyte)</span></div><div class="line" id="010901"><span class="nick" style="color:#389600"><a href="#010901" label="[01:09:01]">&lt;muurkha&gt;</a></span><span class="message">another reason might be that poor performance due to fragmentation was a much worse problem on a floppy than on a hard disk or an SSD</span></div><div class="line" id="010931"><span class="nick" style="color:#389600"><a href="#010931" label="[01:09:31]">&lt;muurkha&gt;</a></span><span class="message">random seek times were close to a second on floppies</span></div><div class="line" id="013523"><span class="nick">***</span><span class="message notice">alMalsamo is now known as lumberjack123</span></div><div class="line" id="013928"><span class="nick" style="color:#8dd3c7"><a href="#013928" label="[01:39:28]">&lt;oriansj&gt;</a></span><span class="message">that I certainly believe and they had to care about being fast and efficient</span></div><div class="line" id="014029"><span class="nick" style="color:#8dd3c7"><a href="#014029" label="[01:40:29]">&lt;oriansj&gt;</a></span><span class="message">I get to waste GB of disk and RAM to make my work easier</span></div><div class="line" id="015014"><span class="nick" style="color:#389600"><a href="#015014" label="[01:50:14]">&lt;muurkha&gt;</a></span><span class="message">the p-System was ridiculously inefficient as I recall</span></div><div class="line" id="015059"><span class="nick" style="color:#389600"><a href="#015059" label="[01:50:59]">&lt;muurkha&gt;</a></span><span class="message">which is why we all ended up using CP/M and AppleDOS and stuff instead</span></div><div class="line" id="015141"><span class="nick" style="color:#389600"><a href="#015141" label="[01:51:41]">&lt;muurkha&gt;</a></span><span class="message">but it did have to run in 64 KiB RAM, or even less</span></div><div class="line" id="015236"><span class="nick" style="color:#8dd3c7"><a href="#015236" label="[01:52:36]">&lt;oriansj&gt;</a></span><span class="message">inefficient those standards is crazy efficient by modern standards</span></div><div class="line" id="020023"><span class="nick" style="color:#389600"><a href="#020023" label="[02:00:23]">&lt;muurkha&gt;</a></span><span class="message">well, I mean, it could do many fewer arithmetic operations or memory accesses per second than JS code JIT-compiled with V8</span></div><div class="line" id="020038"><span class="nick" style="color:#389600"><a href="#020038" label="[02:00:38]">&lt;muurkha&gt;</a></span><span class="message">or per clock cycle, or even per instruction executed</span></div><div class="line" id="023716"><span class="nick" style="color:#8dd3c7"><a href="#023716" label="[02:37:16]">&lt;oriansj&gt;</a></span><span class="message">well one wouldn't expect a pascal interpreter running in 64KB to be as efficient as a 1+GB JavaScript interpreter.</span></div><div class="line" id="023836"><span class="nick" style="color:#389600"><a href="#023836" label="[02:38:36]">&lt;muurkha&gt;</a></span><span class="message">exactly</span></div><div class="line" id="023904"><span class="nick" style="color:#8dd3c7"><a href="#023904" label="[02:39:04]">&lt;oriansj&gt;</a></span><span class="message">much like how -0s probably will have less performance than -03</span></div><div class="line" id="023920"><span class="nick" style="color:#389600"><a href="#023920" label="[02:39:20]">&lt;muurkha&gt;</a></span><span class="message">you'd be surprised how often that isn't true</span></div><div class="line" id="023947"><span class="nick" style="color:#389600"><a href="#023947" label="[02:39:47]">&lt;muurkha&gt;</a></span><span class="message">the bigger reason is that it really was an interpreter, and V8 isn't, it's a JIT compiler</span></div><div class="line" id="023955"><span class="nick" style="color:#8dd3c7"><a href="#023955" label="[02:39:55]">&lt;oriansj&gt;</a></span><span class="message">as often as the hot path stops fitting in the L1 cache due to code expansion</span></div><div class="line" id="024210"><span class="nick" style="color:#8dd3c7"><a href="#024210" label="[02:42:10]">&lt;oriansj&gt;</a></span><span class="message">but if your hot path is big enough that -03 can cause it to not fit in 64KB, then you have other issues besides your compiler flags</span></div><div class="line" id="024345"><span class="nick" style="color:#389600"><a href="#024345" label="[02:43:45]">&lt;muurkha&gt;</a></span><span class="message">as you optimize code your hot path tends to get bigger and bigger</span></div><div class="line" id="024429"><span class="nick" style="color:#389600"><a href="#024429" label="[02:44:29]">&lt;muurkha&gt;</a></span><span class="message">because you're trying to eliminate the tiny hotspots.  decrease inequality, you might say.  redistribute execution time</span></div><div class="line" id="024505"><span class="nick" style="color:#389600"><a href="#024505" label="[02:45:05]">&lt;muurkha&gt;</a></span><span class="message">sometimes you can't, but often you can</span></div><div class="line" id="024521"><span class="nick" style="color:#389600"><a href="#024521" label="[02:45:21]">&lt;muurkha&gt;</a></span><span class="message">but also -Os often produces surprisingly fast code on its own</span></div><div class="line" id="024535"><span class="nick" style="color:#389600"><a href="#024535" label="[02:45:35]">&lt;muurkha&gt;</a></span><span class="message">quite aside from cache effects</span></div><div class="line" id="025439"><span class="nick" style="color:#8dd3c7"><a href="#025439" label="[02:54:39]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well fast code these days is mostly just reduce the number of syscalls and don't touch disk much</span></div><div class="line" id="025603"><span class="nick" style="color:#389600"><a href="#025603" label="[02:56:03]">&lt;muurkha&gt;</a></span><span class="message">that depends a lot on what you're doing.  certainly there are programs for which that is true</span></div><div class="line" id="025607"><span class="nick" style="color:#8dd3c7"><a href="#025607" label="[02:56:07]">&lt;oriansj&gt;</a></span><span class="message">even M2-Planet generated code got a 10x performance increase by just improving the M2libc caching behavior</span></div><div class="line" id="025855"><span class="nick" style="color:#389600"><a href="#025855" label="[02:58:55]">&lt;muurkha&gt;</a></span><span class="message">Amdahl's law applies</span></div><div class="line" id="025914"><span class="nick" style="color:#389600"><a href="#025914" label="[02:59:14]">&lt;muurkha&gt;</a></span><span class="message">if your code is spending 90% of its time making syscalls, you can make it up to 10× faster by reducing the number of syscalls</span></div><div class="line" id="025921"><span class="nick" style="color:#389600"><a href="#025921" label="[02:59:21]">&lt;muurkha&gt;</a></span><span class="message">but you can never make it 11× faster</span></div><div class="line" id="030011"><span class="nick" style="color:#389600"><a href="#030011" label="[03:00:11]">&lt;muurkha&gt;</a></span><span class="message">if you can reduce the amount of work done in syscalls by 100× then your code is now spending 8% of its time in syscalls</span></div><div class="line" id="030222"><span class="nick" style="color:#8dd3c7"><a href="#030222" label="[03:02:22]">&lt;oriansj&gt;</a></span><span class="message">well we went from 1-2 syscall(s) per byte to 1 syscall per file</span></div><div class="line" id="030321"><span class="nick" style="color:#8dd3c7"><a href="#030321" label="[03:03:21]">&lt;oriansj&gt;</a></span><span class="message">as fgetc was doing just read(fd, &amp;stack, 1); pop and return</span></div><div class="line" id="030348"><span class="nick" style="color:#8dd3c7"><a href="#030348" label="[03:03:48]">&lt;oriansj&gt;</a></span><span class="message">and fputc was just doing push; write(fd &amp;stack, 1); and return</span></div><div class="line" id="030445"><span class="nick" style="color:#389600"><a href="#030445" label="[03:04:45]">&lt;muurkha&gt;</a></span><span class="message">right, if you're spending 99% of your time in syscalls, it's straightforward to get a 10× performance increase</span></div><div class="line" id="030453"><span class="nick" style="color:#8dd3c7"><a href="#030453" label="[03:04:53]">&lt;oriansj&gt;</a></span><span class="message">now we just open, lseek (to get size), brk (to allocate enough memory), lseek (to reset), read and close</span></div><div class="line" id="030456"><span class="nick" style="color:#389600"><a href="#030456" label="[03:04:56]">&lt;muurkha&gt;</a></span><span class="message">but not all code is spending 99% of its time in syscalls</span></div><div class="line" id="030523"><span class="nick" style="color:#8dd3c7"><a href="#030523" label="[03:05:23]">&lt;oriansj&gt;</a></span><span class="message">completely agree muurkha</span></div><div class="line" id="030607"><span class="nick" style="color:#389600"><a href="#030607" label="[03:06:07]">&lt;muurkha&gt;</a></span><span class="message">some code is spending 99% of its time on something else, like running the p-System interpreter (probably closer to 90%)</span></div><div class="line" id="030708"><span class="nick" style="color:#389600"><a href="#030708" label="[03:07:08]">&lt;muurkha&gt;</a></span><span class="message">and in the modern world you can often also make code go faster by not spending 80% of your cores on being idle</span></div><div class="line" id="030727"><span class="nick" style="color:#389600"><a href="#030727" label="[03:07:27]">&lt;muurkha&gt;</a></span><span class="message">even if that means doing more somewhat ore computation rather than less</span></div><div class="line" id="030729"><span class="nick" style="color:#389600"><a href="#030729" label="[03:07:29]">&lt;muurkha&gt;</a></span><span class="message">*more</span></div><div class="line" id="030930"><span class="nick" style="color:#8dd3c7"><a href="#030930" label="[03:09:30]">&lt;oriansj&gt;</a></span><span class="message">well unfortunately prolog never got to a generally useful state and performance became a human problem</span></div><div class="line" id="030936"><span class="nick" style="color:#389600"><a href="#030936" label="[03:09:36]">&lt;muurkha&gt;</a></span><span class="message">and of course interleaving disk I/O with CPU work is sort of similar in that it also requires you to have multiple different threads that can proceed as soon as they get data from the disk</span></div><div class="line" id="031042"><span class="nick" style="color:#389600"><a href="#031042" label="[03:10:42]">&lt;muurkha&gt;</a></span><span class="message">I think Prolog is about as generally useful as other programming languages?  it's better suited for some things and worse for others, but the difference is just not big enough to make the mental paradigm shift compelling</span></div><div class="line" id="031100"><span class="nick" style="color:#389600"><a href="#031100" label="[03:11:00]">&lt;muurkha&gt;</a></span><span class="message">maybe similar to APL/J/K?</span></div><div class="line" id="031216"><span class="nick" style="color:#389600"><a href="#031216" label="[03:12:16]">&lt;muurkha&gt;</a></span><span class="message">nowadays SSD I/O has a latency on the order of 10-100 μs, which is enough smaller than hard-disk 8000 μs or floppy-disk 1000000 μs that the optimal tradeoffs change</span></div><div class="line" id="031245"><span class="nick" style="color:#389600"><a href="#031245" label="[03:12:45]">&lt;muurkha&gt;</a></span><span class="message">in-RAM caching that was a performance win with spinning rust can be a performance loss with SSD, for example</span></div><div class="line" id="031338"><span class="nick" style="color:#8dd3c7"><a href="#031338" label="[03:13:38]">&lt;oriansj&gt;</a></span><span class="message">well I gave up on the APL/J/K route simply because they never managed to make a C compiler with it</span></div><div class="line" id="031346"><span class="nick" style="color:#389600"><a href="#031346" label="[03:13:46]">&lt;muurkha&gt;</a></span><span class="message">and the bandwidth is high enough that the memory-to-memory copy implied by the read() and write() interface starts to become a significant performance loss, as it did long ago for spewing raster data to the display</span></div><div class="line" id="031453"><span class="nick" style="color:#389600"><a href="#031453" label="[03:14:53]">&lt;muurkha&gt;</a></span><span class="message">yeah, I feel like there must be *something* there with APL/J/K but it obviously wasn't the kind of silver bullet that going from assembly to C, or punchcards to screen editors, was</span></div><div class="line" id="031552"><span class="nick" style="color:#389600"><a href="#031552" label="[03:15:52]">&lt;muurkha&gt;</a></span><span class="message">like, it doesn't cut development effort much for anything besides very small systems, and it might actually increase it</span></div><div class="line" id="031634"><span class="nick" style="color:#389600"><a href="#031634" label="[03:16:34]">&lt;muurkha&gt;</a></span><span class="message">also true of Forth, dynamic languages like Python and JS and arguably Lisps</span></div><div class="line" id="031816"><span class="nick" style="color:#8dd3c7"><a href="#031816" label="[03:18:16]">&lt;oriansj&gt;</a></span><span class="message">well going from assembly to C is a huge jump in productivity; even if it doesn't prevent you from doing more fun constructs</span></div><div class="line" id="031827"><span class="nick" style="color:#389600"><a href="#031827" label="[03:18:27]">&lt;muurkha&gt;</a></span><span class="message">yup</span></div><div class="line" id="031859"><span class="nick" style="color:#389600"><a href="#031859" label="[03:18:59]">&lt;muurkha&gt;</a></span><span class="message">I thought going from C to Python was a similarly huge jump in productivity, but then I measured it, and I had a dismaying epiphany</span></div><div class="line" id="031922"><span class="nick" style="color:#8dd3c7"><a href="#031922" label="[03:19:22]">&lt;oriansj&gt;</a></span><span class="message">going from C to lisp doesn't bring any advantage until you get comfortable with macros</span></div><div class="line" id="031939"><span class="nick" style="color:#389600"><a href="#031939" label="[03:19:39]">&lt;muurkha&gt;</a></span><span class="message">I don't think that's true; Lisp is similar to Python in a lot of ways</span></div><div class="line" id="032024"><span class="nick" style="color:#389600"><a href="#032024" label="[03:20:24]">&lt;muurkha&gt;</a></span><span class="message">because of dynamic typing Lisp and Python code is implicitly parametrically polymorphic, and it's easy to do ad-hoc polymorphism too</span></div><div class="line" id="032032"><span class="nick" style="color:#8dd3c7"><a href="#032032" label="[03:20:32]">&lt;oriansj&gt;</a></span><span class="message">but that might just be the perspective shift that learning macros forces upon you; that in retrospect will also make your C programming more efficient too</span></div><div class="line" id="032046"><span class="nick" style="color:#389600"><a href="#032046" label="[03:20:46]">&lt;muurkha&gt;</a></span><span class="message">and data structure literals make it easy to do embedded DSLs in either Lisp or Python without macros</span></div><div class="line" id="032317"><span class="nick" style="color:#389600"><a href="#032317" label="[03:23:17]">&lt;muurkha&gt;</a></span><span class="message">also, GC</span></div><div class="line" id="032319"><span class="nick" style="color:#389600"><a href="#032319" label="[03:23:19]">&lt;muurkha&gt;</a></span><span class="message">so I think you do get some improved productivity by going from C to Lisp, even without macros or fexprs</span></div><div class="line" id="032336"><span class="nick" style="color:#389600"><a href="#032336" label="[03:23:36]">&lt;muurkha&gt;</a></span><span class="message">especially for small programs</span></div><div class="line" id="032337"><span class="nick" style="color:#389600"><a href="#032337" label="[03:23:37]">&lt;muurkha&gt;</a></span><span class="message">it's just a lot smaller than I used to think</span></div><div class="line" id="032346"><span class="nick" style="color:#389600"><a href="#032346" label="[03:23:46]">&lt;muurkha&gt;</a></span><span class="message">(the productivity boost)</span></div><div class="line" id="032549"><span class="nick" style="color:#8dd3c7"><a href="#032549" label="[03:25:49]">&lt;oriansj&gt;</a></span><span class="message">well garbage collection certainly is very great for userspace code productivity and unfortunately the deciding factor is library support these days.</span></div><div class="line" id="032740"><span class="nick" style="color:#389600"><a href="#032740" label="[03:27:40]">&lt;muurkha&gt;</a></span><span class="message">again, though, the boost over C from all the goodness in Python is less than an order of magnitude, even in programs that take only hours to write</span></div><div class="line" id="032743"><span class="nick" style="color:#389600"><a href="#032743" label="[03:27:43]">&lt;muurkha&gt;</a></span><span class="message">for me</span></div><div class="line" id="032758"><span class="nick" style="color:#389600"><a href="#032758" label="[03:27:58]">&lt;muurkha&gt;</a></span><span class="message">and for larger programs I suspect it may actually be negative</span></div><div class="line" id="032833"><span class="nick" style="color:#8dd3c7"><a href="#032833" label="[03:28:33]">&lt;oriansj&gt;</a></span><span class="message">I tend to pick the language I use after I look at what I want to do.</span></div><div class="line" id="032901"><span class="nick" style="color:#389600"><a href="#032901" label="[03:29:01]">&lt;muurkha&gt;</a></span><span class="message">in theory Prolog should be ideal for writing compilers</span></div><div class="line" id="033006"><span class="nick" style="color:#389600"><a href="#033006" label="[03:30:06]">&lt;muurkha&gt;</a></span><span class="message">but oddly enough its use for that is almost nil nowadays.  Haskell and ML are a bit higher</span></div><div class="line" id="033118"><span class="nick" style="color:#8dd3c7"><a href="#033118" label="[03:31:18]">&lt;oriansj&gt;</a></span><span class="message">well the biggest factor in the use of any language is the number of people working to make it better.</span></div><div class="line" id="033151"><span class="nick" style="color:#389600"><a href="#033151" label="[03:31:51]">&lt;muurkha&gt;</a></span><span class="message">if that were true then COBOL or FORTRAN would have been the language of choice since their inception</span></div><div class="line" id="033216"><span class="nick" style="color:#389600"><a href="#033216" label="[03:32:16]">&lt;muurkha&gt;</a></span><span class="message">or possibly Intel assembly</span></div><div class="line" id="033222"><span class="nick" style="color:#389600"><a href="#033222" label="[03:32:22]">&lt;muurkha&gt;</a></span><span class="message">or IBM 360 assembly</span></div><div class="line" id="033306"><span class="nick" style="color:#389600"><a href="#033306" label="[03:33:06]">&lt;muurkha&gt;</a></span><span class="message">JS probably has the biggest library nowadays: npm</span></div><div class="line" id="033555"><span class="nick" style="color:#389600"><a href="#033555" label="[03:35:55]">&lt;muurkha&gt;</a></span><span class="message">GNU Prolog generates substantially faster code and uses less memory than V8 for most purposes, but many more compilers are written in JS</span></div><div class="line" id="033610"><span class="nick" style="color:#8dd3c7"><a href="#033610" label="[03:36:10]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I have serious doubts on the idea that JavaScript has more developers working to make the language better than other languages</span></div><div class="line" id="033706"><span class="nick" style="color:#389600"><a href="#033706" label="[03:37:06]">&lt;muurkha&gt;</a></span><span class="message">maybe, but it certainly has a bigger library than all but a few, probably more than all</span></div><div class="line" id="033716"><span class="nick" style="color:#8dd3c7"><a href="#033716" label="[03:37:16]">&lt;oriansj&gt;</a></span><span class="message">I'll grant you it probably has the most people working on scratching their own programming itch but its bootstrappng state is seriously f$*ked</span></div><div class="line" id="033733"><span class="nick" style="color:#389600"><a href="#033733" label="[03:37:33]">&lt;muurkha&gt;</a></span><span class="message">oh, agreed</span></div><div class="line" id="033942"><span class="nick" style="color:#389600"><a href="#033942" label="[03:39:42]">&lt;muurkha&gt;</a></span><span class="message">it probably has more people working on improving optimizing compilers for it too.  I wrote a raytracer in JS a few years ago</span></div><div class="line" id="034135"><span class="nick" style="color:#389600"><a href="#034135" label="[03:41:35]">&lt;muurkha&gt;</a></span><span class="message">I mentioned it a bit in <a rel="nofollow" href="https://news.ycombinator.com/item?id=30378986">https://news.ycombinator.com/item?id=30378986</a> </span></div><div class="line" id="034253"><span class="nick" style="color:#389600"><a href="#034253" label="[03:42:53]">&lt;muurkha&gt;</a></span><span class="message">when I wrote it in 02017 it took 6.8 seconds to render a particular scene in Node.js (V8)</span></div><div class="line" id="034314"><span class="nick" style="color:#389600"><a href="#034314" label="[03:43:14]">&lt;muurkha&gt;</a></span><span class="message">user meetups323 reports that now it takes 0.25 seconds</span></div><div class="line" id="034402"><span class="nick" style="color:#389600"><a href="#034402" label="[03:44:02]">&lt;muurkha&gt;</a></span><span class="message">that kind of thing trades off heavily against having to optimize your own code</span></div><div class="line" id="034733"><span class="nick" style="color:#8dd3c7"><a href="#034733" label="[03:47:33]">&lt;oriansj&gt;</a></span><span class="message">eventually one gets to the point where things are just fast enough to not care</span></div><div class="line" id="040513"><span class="nick" style="color:#389600"><a href="#040513" label="[04:05:13]">&lt;muurkha&gt;</a></span><span class="message">no, that doesn't happen</span></div><div class="line" id="041143"><span class="nick" style="color:#389600"><a href="#041143" label="[04:11:43]">&lt;muurkha&gt;</a></span><span class="message">I mean, you can decide to not care, sure</span></div><div class="line" id="041201"><span class="nick" style="color:#389600"><a href="#041201" label="[04:12:01]">&lt;muurkha&gt;</a></span><span class="message">but having your code run faster always opens up new possibilities, whether you take them or not</span></div><div class="line" id="041231"><span class="nick" style="color:#389600"><a href="#041231" label="[04:12:31]">&lt;muurkha&gt;</a></span><span class="message">fuzzing, Monte Carlo simulation, gradient descent, etc.</span></div><div class="line" id="044940"><span class="nick" style="color:#8dd3c7"><a href="#044940" label="[04:49:40]">&lt;oriansj&gt;</a></span><span class="message">fair. But then again people optimizing for performance are not likely going to go for interpreted languages or even dynamicly typed languages.</span></div><div class="line" id="045044"><span class="nick" style="color:#8dd3c7"><a href="#045044" label="[04:50:44]">&lt;oriansj&gt;</a></span><span class="message">type information is too useful for optimization and JIT is no substitute for good old compilation</span></div><div class="line" id="052515"><span class="nick" style="color:#389600"><a href="#052515" label="[05:25:15]">&lt;muurkha&gt;</a></span><span class="message">LuaJIT and Java HotSpot are competitive with all but the best traditional AOT compilers for statically typed languages</span></div><div class="line" id="052551"><span class="nick" style="color:#389600"><a href="#052551" label="[05:25:51]">&lt;muurkha&gt;</a></span><span class="message">so I don't agree that JIT is no substitute for good old compilation, if average performance is your objective</span></div><div class="line" id="052611"><span class="nick" style="color:#389600"><a href="#052611" label="[05:26:11]">&lt;muurkha&gt;</a></span><span class="message">average speed</span></div><div class="line" id="052615"><span class="nick" style="color:#389600"><a href="#052615" label="[05:26:15]">&lt;muurkha&gt;</a></span><span class="message">good old compilation can definitely beat JIT for worst-case performance and memory usage though</span></div><div class="line" id="052642"><span class="nick" style="color:#389600"><a href="#052642" label="[05:26:42]">&lt;muurkha&gt;</a></span><span class="message">dynamic typing and interpreters definitely have a performance cost, but sometimes it's worth it</span></div><div class="line" id="063328"><span class="nick" style="color:#6b8072"><a href="#063328" label="[06:33:28]">&lt;lumberjack123&gt;</a></span><span class="message">Sorry dumb question what is &quot;literate programming&quot;?</span></div><div class="line" id="064742"><span class="nick" style="color:#6b8072"><a href="#064742" label="[06:47:42]">&lt;lumberjack123&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a> </span></div><div class="line" id="064745"><span class="nick" style="color:#6b8072"><a href="#064745" label="[06:47:45]">&lt;lumberjack123&gt;</a></span><span class="message">nvm ^_^</span></div><div class="line" id="064931"><span class="nick" style="color:#389600"><a href="#064931" label="[06:49:31]">&lt;muurkha&gt;</a></span><span class="message">np :)</span></div><div class="line" id="093556"><span class="nick" style="color:#80b1d3"><a href="#093556" label="[09:35:56]">&lt;fossy&gt;</a></span><span class="message">stikonas[m]: can you send your perl-5.6.2_0.tar.gz, qemu or chroot. don't even know where to start looking</span></div><div class="line" id="100503"><span class="nick" style="color:#6d2462"><a href="#100503" label="[10:05:03]">&lt;stikonas[m]&gt;</a></span><span class="message">fossy: OK, will do so</span></div><div class="line" id="114944"><span class="nick" style="color:#234e69"><a href="#114944" label="[11:49:44]">&lt;stikonas&gt;</a></span><span class="message">fossy: <a rel="nofollow" href="https://stikonas.eu/files/perl-5.6.2_0.tar.gz">https://stikonas.eu/files/perl-5.6.2_0.tar.gz</a> </span></div><div class="line" id="124936"><span class="nick" style="color:#8dd3c7"><a href="#124936" label="[12:49:36]">&lt;oriansj&gt;</a></span><span class="message">lumberjack123: no such thing as a dumb question. Only questions that lacks sufficient shared context and then clarifying is helpful to bridge that gap.</span></div><div class="line" id="131933"><span class="nick" style="color:#8dd3c7"><a href="#131933" label="[13:19:33]">&lt;oriansj&gt;</a></span><span class="message">for example today I am learning about setting up a multiboot elf binary and starting to use qemu and that grub-file --is-x86-multiboot can provide a sanity check</span></div><div class="line" id="132111"><span class="nick" style="color:#8dd3c7"><a href="#132111" label="[13:21:11]">&lt;oriansj&gt;</a></span><span class="message">and dear lord, putting a handful of bytes in the right place is annoying using linker scripts</span></div><div class="line" id="132453"><span class="nick" style="color:#8dd3c7"><a href="#132453" label="[13:24:53]">&lt;oriansj&gt;</a></span><span class="message">but I guess I am spoiled rotten with hex2 doing exactly as I tell it in the order I tell it to do it</span></div><div class="line" id="220207"><span class="nick">***</span><span class="message notice">alMalsamo is now known as lumberjack123</span></div><br /></div></body></html>