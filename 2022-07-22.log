<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-07-22.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="053712"><span class="nick" style="color:#8dd3c7"><a href="#053712" label="[05:37:12]">&lt;muurkha&gt;</a></span><span class="message">wrote my first RISC-V assembly program last night</span></div><div class="line" id="053747"><span class="nick" style="color:#8dd3c7"><a href="#053747" label="[05:37:47]">&lt;muurkha&gt;</a></span><span class="message">I feel like RISC-V assembly is not as easy to read as i386, amd64, or m86k?</span></div><div class="line" id="053829"><span class="nick" style="color:#8dd3c7"><a href="#053829" label="[05:38:29]">&lt;muurkha&gt;</a></span><span class="message">in part just because it's longer but also because the operand order in the standard assembly syntax is so inconsistent</span></div><div class="line" id="055221"><span class="nick" style="color:#8dd3c7"><a href="#055221" label="[05:52:21]">&lt;muurkha&gt;</a></span><span class="message">or is it just unfamiliarity?</span></div><div class="line" id="135328"><span class="nick" style="color:#2e2a4a"><a href="#135328" label="[13:53:28]">&lt;stikonas[m]&gt;</a></span><span class="message">muurkha: only sd instruction has somewhat different order</span></div><div class="line" id="135350"><span class="nick" style="color:#8dd3c7"><a href="#135350" label="[13:53:50]">&lt;muurkha&gt;</a></span><span class="message">also sw, sh, sb</span></div><div class="line" id="135356"><span class="nick" style="color:#2e2a4a"><a href="#135356" label="[13:53:56]">&lt;stikonas[m]&gt;</a></span><span class="message">well, yes, same thing</span></div><div class="line" id="135406"><span class="nick" style="color:#2e2a4a"><a href="#135406" label="[13:54:06]">&lt;stikonas[m]&gt;</a></span><span class="message">but basically it is explained that it uses 2 source registers</span></div><div class="line" id="135412"><span class="nick" style="color:#2e2a4a"><a href="#135412" label="[13:54:12]">&lt;stikonas[m]&gt;</a></span><span class="message">rather that source and destination</span></div><div class="line" id="135524"><span class="nick" style="color:#8dd3c7"><a href="#135524" label="[13:55:24]">&lt;muurkha&gt;</a></span><span class="message">and t3 is not a destination register in bne t3, t4, overflow</span></div><div class="line" id="135559"><span class="nick" style="color:#2e2a4a"><a href="#135559" label="[13:55:59]">&lt;stikonas[m]&gt;</a></span><span class="message">But in general I find it easy enough to read after working on stage0-posix</span></div><div class="line" id="135638"><span class="nick" style="color:#8dd3c7"><a href="#135638" label="[13:56:38]">&lt;muurkha&gt;</a></span><span class="message">that's good!  there's still hope for me yet</span></div><div class="line" id="135708"><span class="nick" style="color:#2e2a4a"><a href="#135708" label="[13:57:08]">&lt;stikonas[m]&gt;</a></span><span class="message">Probably just takes time to get used to if you worked with other asm</span></div><div class="line" id="135720"><span class="nick" style="color:#2e2a4a"><a href="#135720" label="[13:57:20]">&lt;stikonas[m]&gt;</a></span><span class="message">I just started with risc-v</span></div><div class="line" id="135736"><span class="nick" style="color:#2e2a4a"><a href="#135736" label="[13:57:36]">&lt;stikonas[m]&gt;</a></span><span class="message">Well B instructions just compare two values...</span></div><div class="line" id="135749"><span class="nick" style="color:#8dd3c7"><a href="#135749" label="[13:57:49]">&lt;muurkha&gt;</a></span><span class="message">or sometimes one, as in bnez t3, foo</span></div><div class="line" id="135755"><span class="nick" style="color:#2e2a4a"><a href="#135755" label="[13:57:55]">&lt;stikonas[m]&gt;</a></span><span class="message">I only found those SD, etc a bit unintuitive</span></div><div class="line" id="135830"><span class="nick" style="color:#2e2a4a"><a href="#135830" label="[13:58:30]">&lt;stikonas[m]&gt;</a></span><span class="message">Well yes but that's just shorthand for bne zero, t3, foo</span></div><div class="line" id="135834"><span class="nick" style="color:#8dd3c7"><a href="#135834" label="[13:58:34]">&lt;muurkha&gt;</a></span><span class="message">right</span></div><div class="line" id="135842"><span class="nick" style="color:#8dd3c7"><a href="#135842" label="[13:58:42]">&lt;muurkha&gt;</a></span><span class="message">possibly part of the problem is that I'm mostly reading disassembled GCC output :)</span></div><div class="line" id="135903"><span class="nick" style="color:#2e2a4a"><a href="#135903" label="[13:59:03]">&lt;stikonas[m]&gt;</a></span><span class="message">Oh that might be less readable</span></div><div class="line" id="135928"><span class="nick" style="color:#2e2a4a"><a href="#135928" label="[13:59:28]">&lt;stikonas[m]&gt;</a></span><span class="message">M0 riscv is somewhat different though</span></div><div class="line" id="140013"><span class="nick" style="color:#2e2a4a"><a href="#140013" label="[14:00:13]">&lt;stikonas[m]&gt;</a></span><span class="message">E.g. see <a rel="nofollow" href="https://github.com/oriansj/stage0-posix-riscv64/blob/master/Development/hex2_riscv64.M1">https://github.com/oriansj/stage0-posix-riscv64/blob/master/Development/hex2_riscv64.M1</a> </span></div><div class="line" id="140024"><span class="nick" style="color:#2e2a4a"><a href="#140024" label="[14:00:24]">&lt;stikonas[m]&gt;</a></span><span class="message">zero is always implicit in M0</span></div><div class="line" id="140142"><span class="nick" style="color:#8dd3c7"><a href="#140142" label="[14:01:42]">&lt;muurkha&gt;</a></span><span class="message">yeah, I don't know if M0/M1 is more or less readable syntactically</span></div><div class="line" id="140150"><span class="nick" style="color:#8dd3c7"><a href="#140150" label="[14:01:50]">&lt;muurkha&gt;</a></span><span class="message">but surely your code is more mentally coherent than GCC's output</span></div><div class="line" id="140159"><span class="nick" style="color:#2e2a4a"><a href="#140159" label="[14:01:59]">&lt;stikonas[m]&gt;</a></span><span class="message">I don't know either</span></div><div class="line" id="140204"><span class="nick" style="color:#2e2a4a"><a href="#140204" label="[14:02:04]">&lt;stikonas[m]&gt;</a></span><span class="message">It's just different</span></div><div class="line" id="140233"><span class="nick" style="color:#2e2a4a"><a href="#140233" label="[14:02:33]">&lt;stikonas[m]&gt;</a></span><span class="message">But far easier to parse for assembler</span></div><div class="line" id="140259"><span class="nick" style="color:#2e2a4a"><a href="#140259" label="[14:02:59]">&lt;stikonas[m]&gt;</a></span><span class="message">I guess it's like at&amp;t vs Intel syntax</span></div><div class="line" id="140329"><span class="nick" style="color:#2e2a4a"><a href="#140329" label="[14:03:29]">&lt;stikonas[m]&gt;</a></span><span class="message">At&amp;t is easier to parse for assembler</span></div><div class="line" id="140344"><span class="nick" style="color:#2e2a4a"><a href="#140344" label="[14:03:44]">&lt;stikonas[m]&gt;</a></span><span class="message">But maybe Intel syntax is easier for humans to read</span></div><div class="line" id="140635"><span class="nick" style="color:#8dd3c7"><a href="#140635" label="[14:06:35]">&lt;muurkha&gt;</a></span><span class="message">maybe, dunno</span></div><div class="line" id="140655"><span class="nick" style="color:#8dd3c7"><a href="#140655" label="[14:06:55]">&lt;muurkha&gt;</a></span><span class="message">I prefer the AT&amp;T mov source, dest syntax to the Intel mov dest, source syntax</span></div><div class="line" id="141208"><span class="nick" style="color:#2e2a4a"><a href="#141208" label="[14:12:08]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, it's not just that. It is also more explicit, e.g. registers are with %, etc</span></div><div class="line" id="141242"><span class="nick" style="color:#8dd3c7"><a href="#141242" label="[14:12:42]">&lt;muurkha&gt;</a></span><span class="message">in some cases; in other cases AT&amp;T syntax is less explicit</span></div><div class="line" id="141305"><span class="nick" style="color:#8dd3c7"><a href="#141305" label="[14:13:05]">&lt;muurkha&gt;</a></span><span class="message">one particularly egregious example is that mov 15, %eax is a segfault</span></div><div class="line" id="141313"><span class="nick" style="color:#8dd3c7"><a href="#141313" label="[14:13:13]">&lt;muurkha&gt;</a></span><span class="message">you meant mov $15, %eax</span></div><div class="line" id="141349"><span class="nick" style="color:#8dd3c7"><a href="#141349" label="[14:13:49]">&lt;muurkha&gt;</a></span><span class="message">the other case is that I think (%ebp,%esi,4) is less explicit than [EBP + ESI*4]</span></div><div class="line" id="141454"><span class="nick" style="color:#2e2a4a"><a href="#141454" label="[14:14:54]">&lt;stikonas[m]&gt;</a></span><span class="message">It's harder to parse esi*4</span></div><div class="line" id="141505"><span class="nick" style="color:#2e2a4a"><a href="#141505" label="[14:15:05]">&lt;stikonas[m]&gt;</a></span><span class="message">Than %esi,4</span></div><div class="line" id="141545"><span class="nick" style="color:#2e2a4a"><a href="#141545" label="[14:15:45]">&lt;stikonas[m]&gt;</a></span><span class="message">(I mean automatically parse for assembler, not humans)</span></div><div class="line" id="141729"><span class="nick" style="color:#8dd3c7"><a href="#141729" label="[14:17:29]">&lt;muurkha&gt;</a></span><span class="message">plausibly, yeah</span></div><div class="line" id="155302"><span class="nick" style="color:#6b8072"><a href="#155302" label="[15:53:02]">&lt;jbowen&gt;</a></span><span class="message">I feel like it's more a matter of which you learn first. My first exposure to asm was Intel x86 and it still feels like &quot;home&quot; to me, even though I've probably written more lines of 6502 for MCUs than x86 code</span></div><div class="line" id="155413"><span class="nick" style="color:#8dd3c7"><a href="#155413" label="[15:54:13]">&lt;muurkha&gt;</a></span><span class="message">I also feel like i386 is a bit higher level than RISC-V</span></div><div class="line" id="155513"><span class="nick" style="color:#8dd3c7"><a href="#155513" label="[15:55:13]">&lt;muurkha&gt;</a></span><span class="message">I mean, consider addl $3192, (%ebp, %esi, 4)</span></div><div class="line" id="155906"><span class="nick" style="color:#8dd3c7"><a href="#155906" label="[15:59:06]">&lt;muurkha&gt;</a></span><span class="message">in unabbreviated RISC-V assembly that's something like slli t1, a0, 2; add t1, s0, t1; lw t2, (t1); lui t3, 1; addi t3, t3, 904; add t2, t3, t3; sw t2, (t1)</span></div><div class="line" id="160054"><span class="nick" style="color:#8dd3c7"><a href="#160054" label="[16:00:54]">&lt;muurkha&gt;</a></span><span class="message">except the 904 is wrong</span></div><div class="line" id="160103"><span class="nick" style="color:#8dd3c7"><a href="#160103" label="[16:01:03]">&lt;muurkha&gt;</a></span><span class="message">that's kind of an extreme case though</span></div><div class="line" id="160117"><span class="nick" style="color:#6b8072"><a href="#160117" label="[16:01:17]">&lt;jbowen&gt;</a></span><span class="message">Yeah, i386 is CISC, so you'll have more &quot;programmer friendly&quot; instructions</span></div><div class="line" id="160237"><span class="nick" style="color:#8dd3c7"><a href="#160237" label="[16:02:37]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="160314"><span class="nick" style="color:#8dd3c7"><a href="#160314" label="[16:03:14]">&lt;muurkha&gt;</a></span><span class="message">even a lot of RISCs are terser though</span></div><div class="line" id="160341"><span class="nick" style="color:#8dd3c7"><a href="#160341" label="[16:03:41]">&lt;muurkha&gt;</a></span><span class="message">I mean RISC-V had good reasons for not including ARM-like LDM/STM or SPARC-like register windows</span></div><div class="line" id="160425"><span class="nick" style="color:#8dd3c7"><a href="#160425" label="[16:04:25]">&lt;muurkha&gt;</a></span><span class="message">or ARM-like ubiquitous bitshifts or predication</span></div><div class="line" id="160450"><span class="nick" style="color:#8dd3c7"><a href="#160450" label="[16:04:50]">&lt;muurkha&gt;</a></span><span class="message">whatever, compared to a 6502 I guess it's all luxury ;)</span></div><div class="line" id="160615"><span class="nick" style="color:#6b8072"><a href="#160615" label="[16:06:15]">&lt;jbowen&gt;</a></span><span class="message">6502 just feels really quaint to me</span></div><div class="line" id="160750"><span class="nick" style="color:#8dd3c7"><a href="#160750" label="[16:07:50]">&lt;muurkha&gt;</a></span><span class="message">aha, it should have been -904</span></div><div class="line" id="160757"><span class="nick" style="color:#8dd3c7"><a href="#160757" label="[16:07:57]">&lt;muurkha&gt;</a></span><span class="message">clearly time for bed ;)</span></div><div class="line" id="161115"><span class="nick" style="color:#6b8072"><a href="#161115" label="[16:11:15]">&lt;jbowen&gt;</a></span><span class="message">Recent quick video (&lt; 2 min) about x86's `repne scasb` as basically a oneliner for computing string length: <a rel="nofollow" href="https://www.youtube.com/watch?v=WiyUf8u78-w">https://www.youtube.com/watch?v=WiyUf8u78-w</a> </span></div><div class="line" id="161215"><span class="nick" style="color:#8dd3c7"><a href="#161215" label="[16:12:15]">&lt;muurkha&gt;</a></span><span class="message">oh yeah, of course</span></div><div class="line" id="164029"><span class="nick" style="color:#80b1d3"><a href="#164029" label="[16:40:29]">&lt;stikonas&gt;</a></span><span class="message">but x86 machine code is significantly smaller</span></div><div class="line" id="164044"><span class="nick" style="color:#80b1d3"><a href="#164044" label="[16:40:44]">&lt;stikonas&gt;</a></span><span class="message">risc-v has all instructions 32-bit</span></div><div class="line" id="164104"><span class="nick" style="color:#80b1d3"><a href="#164104" label="[16:41:04]">&lt;stikonas&gt;</a></span><span class="message">there is no way we can fit hex0-riscv32 into 256 bytes</span></div><div class="line" id="164137"><span class="nick" style="color:#80b1d3"><a href="#164137" label="[16:41:37]">&lt;stikonas&gt;</a></span><span class="message">one would only have 43 instructions to do that</span></div><div class="line" id="190839"><span class="nick" style="color:#6d2462"><a href="#190839" label="[19:08:39]">&lt;oriansj&gt;</a></span><span class="message">stikonas: well that wouldn't be enitrely impossible if one was willing to do some really clever hex hack but yeah, one can't do hex0 cleanly in just 43 RISC instructions. (VAX might be able to do it in 43 instructions cleanly [maybe])</span></div><div class="line" id="190950"><span class="nick" style="color:#6d2462"><a href="#190950" label="[19:09:50]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well most &quot;clever&quot; cpu instructions end up be just a waste of transistors but PowerPC showed, even having a boatload of simple instructions is still actually a useful option as well.</span></div><div class="line" id="191024"><span class="nick" style="color:#6d2462"><a href="#191024" label="[19:10:24]">&lt;oriansj&gt;</a></span><span class="message">It could have done with out the extra special case registers and more general design but too late now</span></div><div class="line" id="214336"><span class="nick" style="color:#8dd3c7"><a href="#214336" label="[21:43:36]">&lt;muurkha&gt;</a></span><span class="message">stikonas[m]: RVC is usually denser than amd64, though uncompressed RISC-V is looser</span></div><div class="line" id="214830"><span class="nick" style="color:#80b1d3"><a href="#214830" label="[21:48:30]">&lt;stikonas&gt;</a></span><span class="message">yeah, compressed risc-v might be</span></div><div class="line" id="214840"><span class="nick" style="color:#80b1d3"><a href="#214840" label="[21:48:40]">&lt;stikonas&gt;</a></span><span class="message">but I didn't use it for stage0-posix...</span></div><div class="line" id="214853"><span class="nick" style="color:#8dd3c7"><a href="#214853" label="[21:48:53]">&lt;muurkha&gt;</a></span><span class="message">no, much more headache than just rv</span></div><div class="line" id="222315"><span class="nick" style="color:#6d2462"><a href="#222315" label="[22:23:15]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well compressed instruction support hasn't been deeply looked at yet, There are a great deal many encoding details that would have to be worked out first.</span></div><div class="line" id="222407"><span class="nick" style="color:#6d2462"><a href="#222407" label="[22:24:07]">&lt;oriansj&gt;</a></span><span class="message">if I remember correctly stikonas did the impressive task of just using the core RISC-V instructions that all RISC-V chips are required to support</span></div><div class="line" id="222440"><span class="nick" style="color:#8dd3c7"><a href="#222440" label="[22:24:40]">&lt;muurkha&gt;</a></span><span class="message">the core RISC-V instructions are pretty expressive</span></div><div class="line" id="222455"><span class="nick" style="color:#80b1d3"><a href="#222455" label="[22:24:55]">&lt;stikonas&gt;</a></span><span class="message">oriansj: well, I used multiplication and division a bit...</span></div><div class="line" id="222505"><span class="nick" style="color:#8dd3c7"><a href="#222505" label="[22:25:05]">&lt;muurkha&gt;</a></span><span class="message">oh really?</span></div><div class="line" id="222508"><span class="nick" style="color:#8dd3c7"><a href="#222508" label="[22:25:08]">&lt;muurkha&gt;</a></span><span class="message">I didn't realize that</span></div><div class="line" id="222511"><span class="nick" style="color:#8dd3c7"><a href="#222511" label="[22:25:11]">&lt;muurkha&gt;</a></span><span class="message">those are in M</span></div><div class="line" id="222520"><span class="nick" style="color:#80b1d3"><a href="#222520" label="[22:25:20]">&lt;stikonas&gt;</a></span><span class="message">yes, we use them in a couple of places</span></div><div class="line" id="222528"><span class="nick" style="color:#80b1d3"><a href="#222528" label="[22:25:28]">&lt;stikonas&gt;</a></span><span class="message">but I think fairly late</span></div><div class="line" id="222530"><span class="nick" style="color:#80b1d3"><a href="#222530" label="[22:25:30]">&lt;stikonas&gt;</a></span><span class="message">maybe in M0</span></div><div class="line" id="222542"><span class="nick" style="color:#8dd3c7"><a href="#222542" label="[22:25:42]">&lt;muurkha&gt;</a></span><span class="message">the summary of compressed instruction support is that in addition to the 5 basic 32-bit instruction formats, RVC adds another 8 16-bit formats for the most commonly used instructions</span></div><div class="line" id="222559"><span class="nick" style="color:#8dd3c7"><a href="#222559" label="[22:25:59]">&lt;muurkha&gt;</a></span><span class="message">they're just alternate encodings for instructions that could be expressed as 32-bit instructions</span></div><div class="line" id="222613"><span class="nick" style="color:#8dd3c7"><a href="#222613" label="[22:26:13]">&lt;muurkha&gt;</a></span><span class="message">so you can implement them in an assembler; the compiler doesn't have to know about them</span></div><div class="line" id="222637"><span class="nick" style="color:#6d2462"><a href="#222637" label="[22:26:37]">&lt;oriansj&gt;</a></span><span class="message">muurkha: yes, however in M1/hex2 we need to know the details about how to encode the bits</span></div><div class="line" id="222640"><span class="nick" style="color:#80b1d3"><a href="#222640" label="[22:26:40]">&lt;stikonas&gt;</a></span><span class="message">ok, it's in cc_riscv64</span></div><div class="line" id="222641"><span class="nick" style="color:#8dd3c7"><a href="#222641" label="[22:26:41]">&lt;muurkha&gt;</a></span><span class="message">yes</span></div><div class="line" id="222643"><span class="nick" style="color:#80b1d3"><a href="#222643" label="[22:26:43]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/oriansj/stage0-posix-riscv64/blob/master/cc_riscv64.M1#L1718">https://github.com/oriansj/stage0-posix-riscv64/blob/master/cc_riscv64.M1#L1718</a> </span></div><div class="line" id="222704"><span class="nick" style="color:#6d2462"><a href="#222704" label="[22:27:04]">&lt;oriansj&gt;</a></span><span class="message">stikonas: so easy to remove if needed</span></div><div class="line" id="222706"><span class="nick" style="color:#80b1d3"><a href="#222706" label="[22:27:06]">&lt;stikonas&gt;</a></span><span class="message">and <a rel="nofollow" href="https://github.com/oriansj/stage0-posix-riscv64/blob/master/cc_riscv64.M1#L833">https://github.com/oriansj/stage0-posix-riscv64/blob/master/cc_riscv64.M1#L833</a> </span></div><div class="line" id="222717"><span class="nick" style="color:#80b1d3"><a href="#222717" label="[22:27:17]">&lt;stikonas&gt;</a></span><span class="message">yeah, one can write functions to multiply and divide</span></div><div class="line" id="222722"><span class="nick" style="color:#8dd3c7"><a href="#222722" label="[22:27:22]">&lt;muurkha&gt;</a></span><span class="message">this gives RV64C significantly better code density than things like amd64, sparc64, or alpha, on par with arm thum2</span></div><div class="line" id="222725"><span class="nick" style="color:#8dd3c7"><a href="#222725" label="[22:27:25]">&lt;muurkha&gt;</a></span><span class="message">*thumb2</span></div><div class="line" id="222810"><span class="nick" style="color:#8dd3c7"><a href="#222810" label="[22:28:10]">&lt;muurkha&gt;</a></span><span class="message">stikonas[m]: in this case it could be a very short function because member_type-&gt;type-&gt;size is presumably a small integer, like, less than 64</span></div><div class="line" id="222828"><span class="nick" style="color:#80b1d3"><a href="#222828" label="[22:28:28]">&lt;stikonas&gt;</a></span><span class="message">yes, it is small</span></div><div class="line" id="222831"><span class="nick" style="color:#8dd3c7"><a href="#222831" label="[22:28:31]">&lt;muurkha&gt;</a></span><span class="message">so you could implement multiplication by repeatedly adding the multiplier without even shifting</span></div><div class="line" id="222831"><span class="nick" style="color:#6d2462"><a href="#222831" label="[22:28:31]">&lt;oriansj&gt;</a></span><span class="message">muurkha: depends upon the task as there is no universal optimal density instruction set possible</span></div><div class="line" id="222834"><span class="nick" style="color:#80b1d3"><a href="#222834" label="[22:28:34]">&lt;stikonas&gt;</a></span><span class="message">divu a bit more complicated, but not too hard</span></div><div class="line" id="222849"><span class="nick" style="color:#8dd3c7"><a href="#222849" label="[22:28:49]">&lt;muurkha&gt;</a></span><span class="message">oriansj: that is of course true!  and surely there are exceptions</span></div><div class="line" id="222850"><span class="nick" style="color:#80b1d3"><a href="#222850" label="[22:28:50]">&lt;stikonas&gt;</a></span><span class="message">and it's already assembly code, no hex needed</span></div><div class="line" id="222902"><span class="nick" style="color:#6d2462"><a href="#222902" label="[22:29:02]">&lt;oriansj&gt;</a></span><span class="message">stikonas: steal the division solution from armv7l</span></div><div class="line" id="222910"><span class="nick" style="color:#80b1d3"><a href="#222910" label="[22:29:10]">&lt;stikonas&gt;</a></span><span class="message">yeah, I saw it</span></div><div class="line" id="222924"><span class="nick" style="color:#8dd3c7"><a href="#222924" label="[22:29:24]">&lt;muurkha&gt;</a></span><span class="message">in particular I was disappointed with the density of RV64C code for dumpulse, which I optimized to be as little code as possible</span></div><div class="line" id="222929"><span class="nick" style="color:#8dd3c7"><a href="#222929" label="[22:29:29]">&lt;muurkha&gt;</a></span><span class="message">...on a big-endian ARM</span></div><div class="line" id="222933"><span class="nick" style="color:#80b1d3"><a href="#222933" label="[22:29:33]">&lt;stikonas&gt;</a></span><span class="message">but I thought that either I can leave it for somebody else to play with, or maybe until somebody actually needs it</span></div><div class="line" id="222936"><span class="nick" style="color:#6d2462"><a href="#222936" label="[22:29:36]">&lt;oriansj&gt;</a></span><span class="message">it is mod, modu, divu and div</span></div><div class="line" id="223026"><span class="nick" style="color:#8dd3c7"><a href="#223026" label="[22:30:26]">&lt;muurkha&gt;</a></span><span class="message">yeah, probably sensible</span></div><div class="line" id="223026"><span class="nick" style="color:#80b1d3"><a href="#223026" label="[22:30:26]">&lt;stikonas&gt;</a></span><span class="message">and I suspect it's might be more needed on riscv32 rather htan riscv64...</span></div><div class="line" id="223030"><span class="nick" style="color:#6d2462"><a href="#223030" label="[22:30:30]">&lt;oriansj&gt;</a></span><span class="message">stikonas: you can leave it until somebody actually needs it; although a minor comment next to it might be kind</span></div><div class="line" id="223041"><span class="nick" style="color:#8dd3c7"><a href="#223041" label="[22:30:41]">&lt;muurkha&gt;</a></span><span class="message">yeah, anything that runs Linux probably has the M extension</span></div><div class="line" id="223043"><span class="nick" style="color:#80b1d3"><a href="#223043" label="[22:30:43]">&lt;stikonas&gt;</a></span><span class="message">yeah, I can add it...</span></div><div class="line" id="223056"><span class="nick" style="color:#80b1d3"><a href="#223056" label="[22:30:56]">&lt;stikonas&gt;</a></span><span class="message">probably...\</span></div><div class="line" id="223119"><span class="nick" style="color:#8dd3c7"><a href="#223119" label="[22:31:19]">&lt;muurkha&gt;</a></span><span class="message">I don't know if Linux can even be compiled for RV64I or RV64IA rather than RV64IMACFD</span></div><div class="line" id="223120"><span class="nick" style="color:#6d2462"><a href="#223120" label="[22:31:20]">&lt;oriansj&gt;</a></span><span class="message">muurkha: no one has a more dense string comparison than x86</span></div><div class="line" id="223147"><span class="nick" style="color:#8dd3c7"><a href="#223147" label="[22:31:47]">&lt;muurkha&gt;</a></span><span class="message">oriansj: on x86 it's two bytes, plus more bytes to set up the length.  surely you could do it in one byte.  or ¼ byte</span></div><div class="line" id="223329"><span class="nick" style="color:#6d2462"><a href="#223329" label="[22:33:29]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I have yet to see any instruction set dedicate one of their prime 256 opcodes to string comparision, let alone multiple to make it even more efficient</span></div><div class="line" id="223509"><span class="nick" style="color:#80b1d3"><a href="#223509" label="[22:35:09]">&lt;stikonas&gt;</a></span><span class="message">muurkha: well, Linux might not, but we might reuse most of the same code for e.g. baremetal bootstrap</span></div><div class="line" id="223529"><span class="nick" style="color:#6d2462"><a href="#223529" label="[22:35:29]">&lt;oriansj&gt;</a></span><span class="message">also stage0 doesn't have to run on a kernel so RV64IMACFD isn't ensured.</span></div><div class="line" id="223536"><span class="nick" style="color:#80b1d3"><a href="#223536" label="[22:35:36]">&lt;stikonas&gt;</a></span><span class="message">if some RV32I system comes with UEFI support then it might be useful</span></div><div class="line" id="223607"><span class="nick" style="color:#80b1d3"><a href="#223607" label="[22:36:07]">&lt;stikonas&gt;</a></span><span class="message">or even without UEFI support if somebody does something like builder-hex0 but replaces bios calls with hardware specific driver</span></div><div class="line" id="223609"><span class="nick" style="color:#6d2462"><a href="#223609" label="[22:36:09]">&lt;oriansj&gt;</a></span><span class="message">and if we gain more comfort, just straight off a trivial bootloader</span></div><div class="line" id="223636"><span class="nick" style="color:#6d2462"><a href="#223636" label="[22:36:36]">&lt;oriansj&gt;</a></span><span class="message">indeed stikonas</span></div><div class="line" id="223711"><span class="nick" style="color:#80b1d3"><a href="#223711" label="[22:37:11]">&lt;stikonas&gt;</a></span><span class="message">speaking of UEFI, I tried to create some TE executable but failed to get it to run...</span></div><div class="line" id="223748"><span class="nick" style="color:#80b1d3"><a href="#223748" label="[22:37:48]">&lt;stikonas&gt;</a></span><span class="message">but I have not found any examples of TE executables online</span></div><div class="line" id="223820"><span class="nick" style="color:#6d2462"><a href="#223820" label="[22:38:20]">&lt;oriansj&gt;</a></span><span class="message">there is a chance it was something planned but not actually implemented?</span></div><div class="line" id="223858"><span class="nick" style="color:#80b1d3"><a href="#223858" label="[22:38:58]">&lt;stikonas&gt;</a></span><span class="message">hard to tell, more likely I just messed something up while trying to guess...</span></div><div class="line" id="223920"><span class="nick" style="color:#80b1d3"><a href="#223920" label="[22:39:20]">&lt;stikonas&gt;</a></span><span class="message">I could find some references to TE in tianocore ed2k</span></div><div class="line" id="224126"><span class="nick" style="color:#80b1d3"><a href="#224126" label="[22:41:26]">&lt;stikonas&gt;</a></span><span class="message">possibly need to sort out more fields...</span></div><div class="line" id="224209"><span class="nick" style="color:#80b1d3"><a href="#224209" label="[22:42:09]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://paste.debian.net/1248086/">https://paste.debian.net/1248086/</a> </span></div><div class="line" id="224333"><span class="nick" style="color:#80b1d3"><a href="#224333" label="[22:43:33]">&lt;stikonas&gt;</a></span><span class="message">or maybe something wrong with addresses...</span></div><div class="line" id="224626"><span class="nick" style="color:#6d2462"><a href="#224626" label="[22:46:26]">&lt;oriansj&gt;</a></span><span class="message">well the one thing I noticed about the assembly is there is a reference to SystemBoot there might need to be a reference to it in the binary to set it regardless of it it is used or not</span></div><div class="line" id="224731"><span class="nick" style="color:#80b1d3"><a href="#224731" label="[22:47:31]">&lt;stikonas&gt;</a></span><span class="message">maybe... But I would guess the issue is somewhere else...</span></div><div class="line" id="224810"><span class="nick" style="color:#80b1d3"><a href="#224810" label="[22:48:10]">&lt;stikonas&gt;</a></span><span class="message">well, SystemBoot there is actually system-&gt;boot. And system is just second argument to the entry point (so on x86_64 it is stored in rdx)</span></div><div class="line" id="224812"><span class="nick" style="color:#6d2462"><a href="#224812" label="[22:48:12]">&lt;oriansj&gt;</a></span><span class="message">also you would want to set RAX to 42 to be sure that it did run successfully</span></div><div class="line" id="224822"><span class="nick" style="color:#80b1d3"><a href="#224822" label="[22:48:22]">&lt;stikonas&gt;</a></span><span class="message">in principle yes...</span></div><div class="line" id="224832"><span class="nick" style="color:#80b1d3"><a href="#224832" label="[22:48:32]">&lt;stikonas&gt;</a></span><span class="message">though at this stage is simply refuses to load</span></div><div class="line" id="224841"><span class="nick" style="color:#80b1d3"><a href="#224841" label="[22:48:41]">&lt;stikonas&gt;</a></span><span class="message">so I thought RAX 42 is the next step</span></div><div class="line" id="224854"><span class="nick" style="color:#80b1d3"><a href="#224854" label="[22:48:54]">&lt;stikonas&gt;</a></span><span class="message">but if you want, we can add it...</span></div><div class="line" id="225000"><span class="nick" style="color:#6d2462"><a href="#225000" label="[22:50:00]">&lt;oriansj&gt;</a></span><span class="message">is stripped size supposed to be 16bits?</span></div><div class="line" id="225011"><span class="nick" style="color:#80b1d3"><a href="#225011" label="[22:50:11]">&lt;stikonas&gt;</a></span><span class="message">hmm, I can try that...</span></div><div class="line" id="225019"><span class="nick" style="color:#80b1d3"><a href="#225019" label="[22:50:19]">&lt;stikonas&gt;</a></span><span class="message">I have no idea what it has to be set to...\</span></div><div class="line" id="225038"><span class="nick" style="color:#80b1d3"><a href="#225038" label="[22:50:38]">&lt;stikonas&gt;</a></span><span class="message">right now I only get &quot;Command Error Status: Unsupported&quot;</span></div><div class="line" id="225051"><span class="nick" style="color:#80b1d3"><a href="#225051" label="[22:50:51]">&lt;stikonas&gt;</a></span><span class="message">so it might be something  even more wrong</span></div><div class="line" id="225101"><span class="nick" style="color:#80b1d3"><a href="#225101" label="[22:51:01]">&lt;stikonas&gt;</a></span><span class="message">should probably grep for that error in tianocore...</span></div><div class="line" id="225109"><span class="nick" style="color:#6d2462"><a href="#225109" label="[22:51:09]">&lt;oriansj&gt;</a></span><span class="message">do we know of any method of making a TE binary with any standard assembler?</span></div><div class="line" id="225150"><span class="nick" style="color:#80b1d3"><a href="#225150" label="[22:51:50]">&lt;stikonas&gt;</a></span><span class="message">no...</span></div><div class="line" id="225154"><span class="nick" style="color:#80b1d3"><a href="#225154" label="[22:51:54]">&lt;stikonas&gt;</a></span><span class="message">I've only found <a rel="nofollow" href="https://uefi.org/sites/default/files/resources/PI_Spec_1_6.pdf">https://uefi.org/sites/default/files/resources/PI_Spec_1_6.pdf</a> </span></div><div class="line" id="225158"><span class="nick" style="color:#80b1d3"><a href="#225158" label="[22:51:58]">&lt;stikonas&gt;</a></span><span class="message">page 243</span></div><div class="line" id="225206"><span class="nick" style="color:#80b1d3"><a href="#225206" label="[22:52:06]">&lt;stikonas&gt;</a></span><span class="message">and TE2PE converter</span></div><div class="line" id="225232"><span class="nick" style="color:#80b1d3"><a href="#225232" label="[22:52:32]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://uefi.org/sites/default/files/resources/PI_Spec_1_6.pdf">https://uefi.org/sites/default/files/resources/PI_Spec_1_6.pdf</a> </span></div><div class="line" id="225240"><span class="nick" style="color:#80b1d3"><a href="#225240" label="[22:52:40]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/LongSoft/TE2PE/blob/master/TE2PE.c">https://github.com/LongSoft/TE2PE/blob/master/TE2PE.c</a> </span></div><div class="line" id="225343"><span class="nick" style="color:#80b1d3"><a href="#225343" label="[22:53:43]">&lt;stikonas&gt;</a></span><span class="message">right now we don't even know if UEFI can actually load TE executables later (not in it's own internal stages but as bootloaders)</span></div><div class="line" id="225407"><span class="nick" style="color:#80b1d3"><a href="#225407" label="[22:54:07]">&lt;stikonas&gt;</a></span><span class="message">but if it can, TE seems to be terse enough that binaries might be as small as in stage0-posix</span></div><div class="line" id="225644"><span class="nick" style="color:#6d2462"><a href="#225644" label="[22:56:44]">&lt;oriansj&gt;</a></span><span class="message">StrippedSize: would require us to figure out the number of bytes a PE header would have and do some subtraction</span></div><div class="line" id="225718"><span class="nick" style="color:#80b1d3"><a href="#225718" label="[22:57:18]">&lt;stikonas&gt;</a></span><span class="message">oh yes, it's not just size of file...</span></div><div class="line" id="225735"><span class="nick" style="color:#6d2462"><a href="#225735" label="[22:57:35]">&lt;oriansj&gt;</a></span><span class="message">but the size of the shrink from a PE file</span></div><div class="line" id="225754"><span class="nick" style="color:#80b1d3"><a href="#225754" label="[22:57:54]">&lt;stikonas&gt;</a></span><span class="message">probably best to try to check some UEFI implementations...</span></div><div class="line" id="225808"><span class="nick" style="color:#80b1d3"><a href="#225808" label="[22:58:08]">&lt;stikonas&gt;</a></span><span class="message">since the docs/specs are not very clear</span></div><div class="line" id="230348"><span class="nick" style="color:#80b1d3"><a href="#230348" label="[23:03:48]">&lt;stikonas&gt;</a></span><span class="message">oriansj: maybe this is useful <a rel="nofollow" href="https://github.com/tianocore/edk2/blob/master/BaseTools/Source/C/Common/BasePeCoff.c#L1281">https://github.com/tianocore/edk2/blob/master/BaseTools/Source/C/Common/BasePeCoff.c#L1281</a>  ?</span></div><div class="line" id="230915"><span class="nick" style="color:#80b1d3"><a href="#230915" label="[23:09:15]">&lt;stikonas&gt;</a></span><span class="message">hmm, StrippedSize might be more used if sombody uses tools to convert PE32+-&gt;TE</span></div><div class="line" id="230921"><span class="nick" style="color:#80b1d3"><a href="#230921" label="[23:09:21]">&lt;stikonas&gt;</a></span><span class="message">maybe we can just set it to 0</span></div><div class="line" id="231712"><span class="nick" style="color:#8dd3c7"><a href="#231712" label="[23:17:12]">&lt;muurkha&gt;</a></span><span class="message">stikonas: yeah, RV32I is a reasonable target, and something like SeRV is a much more manageable piece of hardware to build than something like ARM or Knight or something</span></div><div class="line" id="231730"><span class="nick" style="color:#8dd3c7"><a href="#231730" label="[23:17:30]">&lt;muurkha&gt;</a></span><span class="message">tianocore eDonkey 2000?</span></div><div class="line" id="231804"><span class="nick" style="color:#80b1d3"><a href="#231804" label="[23:18:04]">&lt;stikonas&gt;</a></span><span class="message">well, typo...</span></div><div class="line" id="231815"><span class="nick" style="color:#80b1d3"><a href="#231815" label="[23:18:15]">&lt;stikonas&gt;</a></span><span class="message">it's edk2</span></div><div class="line" id="231843"><span class="nick" style="color:#80b1d3"><a href="#231843" label="[23:18:43]">&lt;stikonas&gt;</a></span><span class="message">I think edonkey is ed2k</span></div><div class="line" id="235050"><span class="nick" style="color:#8dd3c7"><a href="#235050" label="[23:50:50]">&lt;muurkha&gt;</a></span><span class="message">aha</span></div><br /></div></body></html>