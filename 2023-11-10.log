<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2023-11-10.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="085718"><span class="nick" style="color:#389600"><a href="#085718" label="[08:57:18]">&lt;janneke&gt;</a></span><span class="message">in a few moments: <a rel="nofollow" href="https://hpc.guix.info/events/2023/workshop/program/#how-to-get-started-using-guix">https://hpc.guix.info/events/2023/workshop/program/#how-to-get-started-using-guix</a> </span></div><div class="line" id="085726"><span class="nick" style="color:#389600"><a href="#085726" label="[08:57:26]">&lt;janneke&gt;</a></span><span class="message">=&gt; <a rel="nofollow" href="https://www.youtube.com/watch?v=dT5S72x18R8">https://www.youtube.com/watch?v=dT5S72x18R8</a> </span></div><div class="line" id="090235"><span class="nick" style="color:#389600"><a href="#090235" label="[09:02:35]">&lt;janneke&gt;</a></span><span class="message">hmm, maybe i misread the schedule?</span></div><div class="line" id="192720"><span class="nick" style="color:#8dd3c7"><a href="#192720" label="[19:27:20]">&lt;oriansj&gt;</a></span><span class="message">yeah and default will have to be the last statement of the switch</span></div><div class="line" id="204914"><span class="nick" style="color:#8dd3c7"><a href="#204914" label="[20:49:14]">&lt;oriansj&gt;</a></span><span class="message">we really need to clean up  armv7l and AArch64 M1 assembly</span></div><div class="line" id="211725"><span class="nick" style="color:#8dd3c7"><a href="#211725" label="[21:17:25]">&lt;oriansj&gt;</a></span><span class="message">but switch statements should be in M2-Planet shortly (doing tests now)</span></div><div class="line" id="211951"><span class="nick" style="color:#2e2a4a"><a href="#211951" label="[21:19:51]">&lt;Googulator&gt;</a></span><span class="message">Hi All! For a few days now, I have been experimenting with live-bootstrap as a provable anti-Trusting-Trust mechanism, i.e. a means to establish a trusted compilation environment that can compile modern software, while also being free of any self-propagating backdoors (at least beyond what could fit in a 512-byte boot sector image, which is not</span></div><div class="line" id="211952"><span class="nick" style="color:#2e2a4a"><a href="#211952" label="[21:19:52]">&lt;Googulator&gt;</a></span><span class="message">much).</span></div><div class="line" id="212253"><span class="nick" style="color:#2e2a4a"><a href="#212253" label="[21:22:53]">&lt;Googulator&gt;</a></span><span class="message">Primary the bare metal route, on some older hardware that's presumed trustworthy.</span></div><div class="line" id="212513"><span class="nick" style="color:#8dd3c7"><a href="#212513" label="[21:25:13]">&lt;oriansj&gt;</a></span><span class="message">^_^ good fun</span></div><div class="line" id="212557"><span class="nick" style="color:#2e2a4a"><a href="#212557" label="[21:25:57]">&lt;Googulator&gt;</a></span><span class="message">Unfortunately, I see a potential attack vector in the current implementation: assuming that I can't trust my current, modern system used for preparing the bare metal images (which would pretty much be the starting assumption for such an endeavor), there's always a possibility that when I write the image to disk for bare metal bootstrap, what gets</span></div><div class="line" id="212557"><span class="nick" style="color:#2e2a4a"><a href="#212557" label="[21:25:57]">&lt;Googulator&gt;</a></span><span class="message">written isn't what I _think_ is being written; specifically that either there's more binary code written than just that one sector, or that the source written to disk (the srcfs) doesn't match what I can view on my host machine. I've been working on solving this for the last few days, and came up with some pretty wild attack vectors, as well as</span></div><div class="line" id="212558"><span class="nick" style="color:#2e2a4a"><a href="#212558" label="[21:25:58]">&lt;Googulator&gt;</a></span><span class="message">potential ways to block them.</span></div><div class="line" id="212710"><span class="nick" style="color:#2e2a4a"><a href="#212710" label="[21:27:10]">&lt;Googulator&gt;</a></span><span class="message">For the issue of &quot;more binary code written than acknowledged&quot;, I'm thinking of a hardware-based countermeasure: some kind of flash drive/SSD build in an open-source way using parallel NAND flash (with actual A0...An address lines) and a discrete controller.</span></div><div class="line" id="212851"><span class="nick" style="color:#6b8072"><a href="#212851" label="[21:28:51]">&lt;vagrantc&gt;</a></span><span class="message">sure, you can always work on custom hardware or take everything down another layer deeper!</span></div><div class="line" id="212906"><span class="nick" style="color:#2e2a4a"><a href="#212906" label="[21:29:06]">&lt;Googulator&gt;</a></span><span class="message">With such a drive, it should be possible to add a physical switch to the A8 line (assuming the output is byte-oriented - the exact address line depends on the width of the parallel flash's data bus), such that byte address 0x200 will wrap back to 0x0 when the switch is open.</span></div><div class="line" id="212936"><span class="nick" style="color:#2e2a4a"><a href="#212936" label="[21:29:36]">&lt;Googulator&gt;</a></span><span class="message">i.e. when the boot sector tries to load sector 1; it instead reloads itself.</span></div><div class="line" id="213108"><span class="nick" style="color:#2e2a4a"><a href="#213108" label="[21:31:08]">&lt;Googulator&gt;</a></span><span class="message">We can then format the stage2 hex0 code in such a way to have it start with a comment, and modify the code of the boot sector to check if it's reading itself, a sector that begins with a hex0 comment, or something else.</span></div><div class="line" id="213148"><span class="nick" style="color:#2e2a4a"><a href="#213148" label="[21:31:48]">&lt;Googulator&gt;</a></span><span class="message">If it sees itself, it tries again until it sees something. If it sees a hex0 comment, it proceeds with normal boot. Anything else, and it stops with an error, as that indicates a compromise.</span></div><div class="line" id="213244"><span class="nick" style="color:#2e2a4a"><a href="#213244" label="[21:32:44]">&lt;Googulator&gt;</a></span><span class="message">Additionally, provide some visual or serial-console-output evidence as to whether it's still rereading itself, or has moved on to actually parsing hex0.</span></div><div class="line" id="213255"><span class="nick" style="color:#8dd3c7"><a href="#213255" label="[21:32:55]">&lt;oriansj&gt;</a></span><span class="message">well microcode and firmware attacks are a problem until we make our own hardware</span></div><div class="line" id="213304"><span class="nick" style="color:#2e2a4a"><a href="#213304" label="[21:33:04]">&lt;Googulator&gt;</a></span><span class="message">(e.g. printing a dot on the screen or serial out everytime it rereads itself)</span></div><div class="line" id="213316"><span class="nick" style="color:#8dd3c7"><a href="#213316" label="[21:33:16]">&lt;oriansj&gt;</a></span><span class="message">and that isn't even including the more exotic Nexus intruder types of attacks</span></div><div class="line" id="213403"><span class="nick" style="color:#8dd3c7"><a href="#213403" label="[21:34:03]">&lt;oriansj&gt;</a></span><span class="message">where you need to bootstrap your lithography machines to be sure the circuits you print/make actually match your design</span></div><div class="line" id="213408"><span class="nick" style="color:#2e2a4a"><a href="#213408" label="[21:34:08]">&lt;Googulator&gt;</a></span><span class="message">I'm assuming that the hardware used for the bare metal bootstrap is old enough that even if it's compromised, it won't recognize the bootstrap code and be able to interfere - for example, something from 2004.</span></div><div class="line" id="213448"><span class="nick" style="color:#8dd3c7"><a href="#213448" label="[21:34:48]">&lt;oriansj&gt;</a></span><span class="message">fair enough assumption to have when making progress (no need to solve all issues right off the bat)</span></div><div class="line" id="213534"><span class="nick" style="color:#2e2a4a"><a href="#213534" label="[21:35:34]">&lt;Googulator&gt;</a></span><span class="message">The challenge is instead in seeding that old system with something that won't successfully bootstrap itself if it's compromised in any way (assuming no compromise can be hidden in a 512-byte boot sector while retaining its apparent normal functionality).</span></div><div class="line" id="213623"><span class="nick" style="color:#2e2a4a"><a href="#213623" label="[21:36:23]">&lt;Googulator&gt;</a></span><span class="message">So now, we boot the 2004 system with our specially prepared flash disk, with the switch open. If there's no compromise, it starts printing a series of dots.</span></div><div class="line" id="213728"><span class="nick" style="color:#6b8072"><a href="#213728" label="[21:37:28]">&lt;vagrantc&gt;</a></span><span class="message">would be curious to apply bootstrappable builds + reproducible builds + diverse double-compiling ... each adds some degree of strong confidence, but all together is quite solid</span></div><div class="line" id="213804"><span class="nick" style="color:#6b8072"><a href="#213804" label="[21:38:04]">&lt;vagrantc&gt;</a></span><span class="message">i think live-bootstrap does actually result in bit-for-bit identical results ... so the main thing would be to introduce an alternate bootstrap path that ends in the same bit-for-bit identical result</span></div><div class="line" id="213806"><span class="nick" style="color:#2e2a4a"><a href="#213806" label="[21:38:06]">&lt;Googulator&gt;</a></span><span class="message">The next change we need to make to the boot sector (builder-hex0-x86-stage1) is to make it print every byte of hex0 code it sees.</span></div><div class="line" id="213849"><span class="nick" style="color:#2e2a4a"><a href="#213849" label="[21:38:49]">&lt;Googulator&gt;</a></span><span class="message">And now, we flip the switch - and if nothing has been compromised, at that exact moment, the boot sector stops printing dots, and instead prints out hex0 source for the next stage.</span></div><div class="line" id="213922"><span class="nick" style="color:#2e2a4a"><a href="#213922" label="[21:39:22]">&lt;Googulator&gt;</a></span><span class="message">If anything else happens - compromise!</span></div><div class="line" id="213959"><span class="nick" style="color:#2e2a4a"><a href="#213959" label="[21:39:59]">&lt;Googulator&gt;</a></span><span class="message">Assuming we have a trustworthy way of recording and later reviewing the data printed out, we can then verify that it is indeed the code we thought we've written out in the first place.</span></div><div class="line" id="214033"><span class="nick" style="color:#2e2a4a"><a href="#214033" label="[21:40:33]">&lt;Googulator&gt;</a></span><span class="message">(An actual printer printing to paper would be ideal for security and trust, but it would probably be too slow.)</span></div><div class="line" id="214124"><span class="nick" style="color:#80b1d3"><a href="#214124" label="[21:41:24]">&lt;stikonas&gt;</a></span><span class="message">well, there is no way to enter bytes into memory on modern machines</span></div><div class="line" id="214136"><span class="nick" style="color:#8dd3c7"><a href="#214136" label="[21:41:36]">&lt;oriansj&gt;</a></span><span class="message">well the problem is up until mescc-tools-extras we have no ability to do sha256sum on the input files</span></div><div class="line" id="214141"><span class="nick" style="color:#80b1d3"><a href="#214141" label="[21:41:41]">&lt;stikonas&gt;</a></span><span class="message">you would have to go older to something like PDP-8 with front panel switches</span></div><div class="line" id="214202"><span class="nick" style="color:#80b1d3"><a href="#214202" label="[21:42:02]">&lt;stikonas&gt;</a></span><span class="message">or maybe one of those arm/riscv SoCs with SPI bus</span></div><div class="line" id="214213"><span class="nick" style="color:#2e2a4a"><a href="#214213" label="[21:42:13]">&lt;Googulator&gt;</a></span><span class="message">With what I'm proposing, there's no need to directly enter bytes.</span></div><div class="line" id="214213"><span class="nick" style="color:#80b1d3"><a href="#214213" label="[21:42:13]">&lt;stikonas&gt;</a></span><span class="message">it might be possible to program SPI manually</span></div><div class="line" id="214240"><span class="nick" style="color:#8dd3c7"><a href="#214240" label="[21:42:40]">&lt;oriansj&gt;</a></span><span class="message">I'm opted for a hardware tape readers</span></div><div class="line" id="214243"><span class="nick" style="color:#2e2a4a"><a href="#214243" label="[21:42:43]">&lt;Googulator&gt;</a></span><span class="message">But if you want to go that route, I2C has certainly been bitbanged using discrete mechanical switches.</span></div><div class="line" id="214306"><span class="nick" style="color:#8dd3c7"><a href="#214306" label="[21:43:06]">&lt;oriansj&gt;</a></span><span class="message">and we have how to hand toggle PROMs</span></div><div class="line" id="214340"><span class="nick" style="color:#2e2a4a"><a href="#214340" label="[21:43:40]">&lt;Googulator&gt;</a></span><span class="message">For my proposal to work, only a single mechanical switch is required - the one in line with the parallel flash's A9 line.</span></div><div class="line" id="214409"><span class="nick" style="color:#8dd3c7"><a href="#214409" label="[21:44:09]">&lt;oriansj&gt;</a></span><span class="message">sounds interesting</span></div><div class="line" id="214410"><span class="nick" style="color:#2e2a4a"><a href="#214410" label="[21:44:10]">&lt;Googulator&gt;</a></span><span class="message">or A8 rather</span></div><div class="line" id="214441"><span class="nick" style="color:#2e2a4a"><a href="#214441" label="[21:44:41]">&lt;Googulator&gt;</a></span><span class="message">You close it when programming the flash using the untrusted host system, then open it, plug into the bootstrap machine, boot to the boot sector, wait for dots to start printing, then you close the switch, and off we go.</span></div><div class="line" id="214625"><span class="nick" style="color:#2e2a4a"><a href="#214625" label="[21:46:25]">&lt;Googulator&gt;</a></span><span class="message">What makes this work is the fact that assuming no compromise, the first thing the boot sector (residing in LBA #0) needs to read is LBA #1, but with the switch open, we mask the low-order bit of the LBA address, so LBA #1 becomes a copy of #0, #3 of #2, and so on.</span></div><div class="line" id="214634"><span class="nick" style="color:#8dd3c7"><a href="#214634" label="[21:46:34]">&lt;oriansj&gt;</a></span><span class="message">so a source code Flash chip and a bootstrap binary ROM chip (or unwritable flash)</span></div><div class="line" id="214715"><span class="nick" style="color:#2e2a4a"><a href="#214715" label="[21:47:15]">&lt;Googulator&gt;</a></span><span class="message">A binary ROM would probably add even more trust, but really a single Flash chip is enough.</span></div><div class="line" id="214748"><span class="nick" style="color:#8dd3c7"><a href="#214748" label="[21:47:48]">&lt;oriansj&gt;</a></span><span class="message">functioning as say an IDE/SATA drive would enable any older system to be leveraged</span></div><div class="line" id="214822"><span class="nick" style="color:#2e2a4a"><a href="#214822" label="[21:48:22]">&lt;Googulator&gt;</a></span><span class="message">LBA #0 holds the builder-hex0 stage1 boot sector (modified to fit my proposal), the rest holds the stage2 hex0 source and the srcfs.</span></div><div class="line" id="214901"><span class="nick" style="color:#8dd3c7"><a href="#214901" label="[21:49:01]">&lt;oriansj&gt;</a></span><span class="message">yeah, that would work</span></div><div class="line" id="214917"><span class="nick" style="color:#2e2a4a"><a href="#214917" label="[21:49:17]">&lt;Googulator&gt;</a></span><span class="message">I was thinking more in terms of USB - this is where using a machine from around 2004 comes in, as USB flash drives were already common at that point, and many motherboards from that era can boot off USB just fine.</span></div><div class="line" id="214949"><span class="nick" style="color:#2e2a4a"><a href="#214949" label="[21:49:49]">&lt;Googulator&gt;</a></span><span class="message">And with 2004-era USB drives, there's a good chance they would have the discrete controller-and-NAND construction needed.</span></div><div class="line" id="215027"><span class="nick" style="color:#2e2a4a"><a href="#215027" label="[21:50:27]">&lt;Googulator&gt;</a></span><span class="message">(i.e. with an actual PCB trace connecting the A8 line between the controller and the NAND that can be cut and wired to a switch)</span></div><div class="line" id="215050"><span class="nick" style="color:#8dd3c7"><a href="#215050" label="[21:50:50]">&lt;oriansj&gt;</a></span><span class="message">would be neat to see done</span></div><div class="line" id="215211"><span class="nick" style="color:#2e2a4a"><a href="#215211" label="[21:52:11]">&lt;Googulator&gt;</a></span><span class="message">So the procedure is: create image on untrusted host, close switch, plug flash drive into untrusted host, write the image to it.</span></div><div class="line" id="215235"><span class="nick" style="color:#2e2a4a"><a href="#215235" label="[21:52:35]">&lt;Googulator&gt;</a></span><span class="message">Unplug, open the switch, plug into target machine, boot off it, and watch for dots.</span></div><div class="line" id="215427"><span class="nick" style="color:#2e2a4a"><a href="#215427" label="[21:54:27]">&lt;Googulator&gt;</a></span><span class="message">Now, you can start recording the log output using whatever trusted mechanism you have (old VHS camera, mechanical printer, some purpose-built device for this purpose... or just slow things down enough so you can read it live), and close the switch.</span></div><div class="line" id="215513"><span class="nick" style="color:#8dd3c7"><a href="#215513" label="[21:55:13]">&lt;oriansj&gt;</a></span><span class="message">I would suggest having the ability to connect to an external circuit, enabling you to manually the validate the first 512bytes</span></div><div class="line" id="215605"><span class="nick" style="color:#8dd3c7"><a href="#215605" label="[21:56:05]">&lt;oriansj&gt;</a></span><span class="message">that way you can also catch if the untrusted host puts untrusted values in the first 512bytes</span></div><div class="line" id="215618"><span class="nick" style="color:#2e2a4a"><a href="#215618" label="[21:56:18]">&lt;Googulator&gt;</a></span><span class="message">Boot sector prints out the stage2 hex0 source code while compiling it, then hands off to stage2, which likewise prints out the srcfs as it loads.</span></div><div class="line" id="215636"><span class="nick" style="color:#8dd3c7"><a href="#215636" label="[21:56:36]">&lt;oriansj&gt;</a></span><span class="message">fair enough</span></div><div class="line" id="215658"><span class="nick" style="color:#8dd3c7"><a href="#215658" label="[21:56:58]">&lt;oriansj&gt;</a></span><span class="message">but the boot sector needs a way to be inspected</span></div><div class="line" id="215754"><span class="nick" style="color:#2e2a4a"><a href="#215754" label="[21:57:54]">&lt;Googulator&gt;</a></span><span class="message">An external circuit (if itself trusted) would help validate the exact contents of the boot sector - however, it's not really required for trust, because I highly doubt anyone can write a functional boot sector, plus a backdoor, plus some code that can predict when I'm gonna flip the switch, in just 512 bytes.</span></div><div class="line" id="215826"><span class="nick" style="color:#8dd3c7"><a href="#215826" label="[21:58:26]">&lt;oriansj&gt;</a></span><span class="message">completely fair</span></div><div class="line" id="215839"><span class="nick" style="color:#2e2a4a"><a href="#215839" label="[21:58:39]">&lt;Googulator&gt;</a></span><span class="message">You can of course do this several times, and gain more confidence that the dots stopping at just the right moment weren't just the backdoor code getting lucky.</span></div><div class="line" id="220118"><span class="nick" style="color:#2e2a4a"><a href="#220118" label="[22:01:18]">&lt;Googulator&gt;</a></span><span class="message">Anyway, once the whole srcfs is loaded, the next stage of the bootstrap process starts with &quot;hex0 ./bootstrap-seeds/POSIX/x86/hex0_x86.hex0 ./bootstrap-seeds/POSIX/x86/hex0-seed; hex0 ./bootstrap-seeds/POSIX/x86/kaem-minimal.hex0 ./bootstrap-seeds/POSIX/x86/kaem-optional-seed; ./bootstrap-seeds/POSIX/x86/kaem-optional-seed ./kaem.x86&quot; inside</span></div><div class="line" id="220119"><span class="nick" style="color:#2e2a4a"><a href="#220119" label="[22:01:19]">&lt;Googulator&gt;</a></span><span class="message">builder-stage2's shell, kicking off the build of everything within the srcfs and beyond.</span></div><div class="line" id="220230"><span class="nick" style="color:#2e2a4a"><a href="#220230" label="[22:02:30]">&lt;Googulator&gt;</a></span><span class="message">Then, once we reach the point where the srcfs is no longer needed, we securely erase it from the target, so the only place it remains is on our trusted recording device (or paper), and on the untrusted host. This will come in important later.</span></div><div class="line" id="220412"><span class="nick" style="color:#2e2a4a"><a href="#220412" label="[22:04:12]">&lt;Googulator&gt;</a></span><span class="message">From this point on, we're getting the remaining sources over the internet, and running the rest of the bootstrap all the way up into GCC 13.x.</span></div><div class="line" id="220459"><span class="nick" style="color:#2e2a4a"><a href="#220459" label="[22:04:59]">&lt;Googulator&gt;</a></span><span class="message">Also when the srcfs gets erased, we pause to unplug the modified flash drive.</span></div><div class="line" id="220716"><span class="nick" style="color:#2e2a4a"><a href="#220716" label="[22:07:16]">&lt;Googulator&gt;</a></span><span class="message">Once we have modern GCC and our shell, we plug in another such specially prepared (but still empty) flash drive, with the switch closed - and use the bootstrapped system to run live-bootstrap again, writing to that drive. Then, we use that drive to bootstrap again the same way we did the first time, all the way until the entire srcfs is printed. Of</span></div><div class="line" id="220716"><span class="nick" style="color:#2e2a4a"><a href="#220716" label="[22:07:16]">&lt;Googulator&gt;</a></span><span class="message">course, record everything with the trusted recorder.</span></div><div class="line" id="220800"><span class="nick" style="color:#2e2a4a"><a href="#220800" label="[22:08:00]">&lt;Googulator&gt;</a></span><span class="message">Now, we can compare the records from the 2 stage2 and srcfs printouts. If they match - we can be sure no backdoor propagated from our untrusted system to the bootstrapped one!</span></div><div class="line" id="220851"><span class="nick" style="color:#2e2a4a"><a href="#220851" label="[22:08:51]">&lt;Googulator&gt;</a></span><span class="message">(In fact, since srcfs resides in RAM once it's loaded, it's better to unplug the first flash drive just as srcfs loading finishes.)</span></div><div class="line" id="221210"><span class="nick" style="color:#2e2a4a"><a href="#221210" label="[22:12:10]">&lt;Googulator&gt;</a></span><span class="message">This is the reason we erased srcfs when it was no longer needed - to leave no way for the rest of the system (build from code downloaded later) to just copy the original srcfs instead of reconstructing it from source.</span></div><div class="line" id="221405"><span class="nick" style="color:#2e2a4a"><a href="#221405" label="[22:14:05]">&lt;Googulator&gt;</a></span><span class="message">The only issue that remains at this point is the fact that all of the code we compiled and executed theoretically had write access to all of the sources that built it, so a sophisticated attacker could send us sources that when compiled, alter the previously downloaded source code to hide a backdoor. In such a case, when we then try to audit the</span></div><div class="line" id="221405"><span class="nick" style="color:#2e2a4a"><a href="#221405" label="[22:14:05]">&lt;Googulator&gt;</a></span><span class="message">sources left behind on the system, we're 1. potentially reading sources that have been altered, and 2. potentially reading those sources through backdoored tools that might not present the sources faithfully to us.</span></div><div class="line" id="221631"><span class="nick" style="color:#8dd3c7"><a href="#221631" label="[22:16:31]">&lt;oriansj&gt;</a></span><span class="message">hmmm</span></div><div class="line" id="221739"><span class="nick" style="color:#2e2a4a"><a href="#221739" label="[22:17:39]">&lt;Googulator&gt;</a></span><span class="message">To close this hole, 3 things are needed: first, make sure that the post-srcfs of the build keeps the downloaded sources for later auditing in the first place; second, include hashes of every source file or package that will be downloaded later in the srcfs, so we can compare against the trusted recording (AFAIK live-bootstrap already does this),</span></div><div class="line" id="221739"><span class="nick" style="color:#2e2a4a"><a href="#221739" label="[22:17:39]">&lt;Googulator&gt;</a></span><span class="message">and finally, make a somewhat extended version of the srcfs-built system (still buildable entirely via the srcfs mechanism) that's powerful enough that we can plug in the drive containing our bootstrapped system, and without executing anything from it, be able to review and audit all the source code present.</span></div><div class="line" id="221800"><span class="nick" style="color:#2e2a4a"><a href="#221800" label="[22:18:00]">&lt;Googulator&gt;</a></span><span class="message">(as well as recompute hashes of the source packages kept)</span></div><div class="line" id="222026"><span class="nick" style="color:#2e2a4a"><a href="#222026" label="[22:20:26]">&lt;Googulator&gt;</a></span><span class="message">If all the hashes recomputed in this &quot;audit-srcfs&quot; system match the ones in the trusted record, then when we view the retained sources retained in the bootstrapped image from the &quot;audit-srcfs&quot; system, we're reading the true sources that built the bootstrapped image.</span></div><div class="line" id="222046"><span class="nick" style="color:#2e2a4a"><a href="#222046" label="[22:20:46]">&lt;Googulator&gt;</a></span><span class="message">(oops, too many retaineds)</span></div><div class="line" id="225450"><span class="nick" style="color:#8dd3c7"><a href="#225450" label="[22:54:50]">&lt;oriansj&gt;</a></span><span class="message">Googulator: do we need cryptographically secure hashes for the steps leading up to mescc-tools-extras?</span></div><div class="line" id="225528"><span class="nick" style="color:#8dd3c7"><a href="#225528" label="[22:55:28]">&lt;oriansj&gt;</a></span><span class="message">or would a CRC type of hash be sufficient?</span></div><div class="line" id="225542"><span class="nick" style="color:#8dd3c7"><a href="#225542" label="[22:55:42]">&lt;oriansj&gt;</a></span><span class="message">as one could implement that in only a few dozen bytes</span></div><div class="line" id="225633"><span class="nick" style="color:#8dd3c7"><a href="#225633" label="[22:56:33]">&lt;oriansj&gt;</a></span><span class="message">and something like that could fit in the builder-hex0-mini along with existing functionality</span></div><div class="line" id="225756"><span class="nick" style="color:#8dd3c7"><a href="#225756" label="[22:57:56]">&lt;oriansj&gt;</a></span><span class="message">then instead of dots, you could see checksums</span></div><div class="line" id="225814"><span class="nick" style="color:#8dd3c7"><a href="#225814" label="[22:58:14]">&lt;oriansj&gt;</a></span><span class="message">of not only the sources but also the resulting binaries</span></div><div class="line" id="230313"><span class="nick" style="color:#2e2a4a"><a href="#230313" label="[23:03:13]">&lt;Googulator&gt;</a></span><span class="message">Dots are only printed while waiting for the switch to toggle</span></div><div class="line" id="230323"><span class="nick" style="color:#2e2a4a"><a href="#230323" label="[23:03:23]">&lt;Googulator&gt;</a></span><span class="message">From that point on, the plan is to print the sources themselves</span></div><div class="line" id="230357"><span class="nick" style="color:#2e2a4a"><a href="#230357" label="[23:03:57]">&lt;Googulator&gt;</a></span><span class="message">So that each byte of source code is printed and recorded before any binary built from it had a chance to execute</span></div><div class="line" id="230420"><span class="nick" style="color:#2e2a4a"><a href="#230420" label="[23:04:20]">&lt;Googulator&gt;</a></span><span class="message">Hence a hash at this stage wouldn't be enough</span></div><div class="line" id="230437"><span class="nick" style="color:#8dd3c7"><a href="#230437" label="[23:04:37]">&lt;oriansj&gt;</a></span><span class="message">to say a line printer over a parallel port I am assuming?</span></div><div class="line" id="230509"><span class="nick" style="color:#2e2a4a"><a href="#230509" label="[23:05:09]">&lt;Googulator&gt;</a></span><span class="message">I was thinking either a UART or to a VGA-style console</span></div><div class="line" id="230532"><span class="nick" style="color:#2e2a4a"><a href="#230532" label="[23:05:32]">&lt;Googulator&gt;</a></span><span class="message">But a parallel port could work as well</span></div><div class="line" id="230700"><span class="nick" style="color:#2e2a4a"><a href="#230700" label="[23:07:00]">&lt;Googulator&gt;</a></span><span class="message">The key to countering malicious source code that modifies itself after it's compiled and executed is to make sure that every source byte up to that point is printed before it's executed</span></div><div class="line" id="230750"><span class="nick" style="color:#8dd3c7"><a href="#230750" label="[23:07:50]">&lt;oriansj&gt;</a></span><span class="message">well a VGA-style console tends to have the limit of time and only so many lines (for people who don't read fast it is easy to miss different text)</span></div><div class="line" id="230835"><span class="nick" style="color:#2e2a4a"><a href="#230835" label="[23:08:35]">&lt;Googulator&gt;</a></span><span class="message">VGA has the advantage that it's analog RGB video, which can be recorded using consumer electronics, hopefully with enough precision so that it can be read back later</span></div><div class="line" id="230905"><span class="nick" style="color:#2e2a4a"><a href="#230905" label="[23:09:05]">&lt;Googulator&gt;</a></span><span class="message">VHS probably wouldn't cut it, but a TiVo-style PVR could</span></div><div class="line" id="231000"><span class="nick" style="color:#8dd3c7"><a href="#231000" label="[23:10:00]">&lt;oriansj&gt;</a></span><span class="message">well a UART or a parallel port could directly write the output into a storage media of choice (be it paper or digital)</span></div><div class="line" id="231027"><span class="nick" style="color:#2e2a4a"><a href="#231027" label="[23:10:27]">&lt;Googulator&gt;</a></span><span class="message">But you need a trusted way to then view that record</span></div><div class="line" id="231038"><span class="nick" style="color:#2e2a4a"><a href="#231038" label="[23:10:38]">&lt;Googulator&gt;</a></span><span class="message">Paper doesn't have this issue, but it's slower to write than to read</span></div><div class="line" id="231111"><span class="nick" style="color:#2e2a4a"><a href="#231111" label="[23:11:11]">&lt;Googulator&gt;</a></span><span class="message">vs VGA which can scroll faster than you can read it, so long as it's not too fast for a PVR to record</span></div><div class="line" id="231119"><span class="nick" style="color:#2e2a4a"><a href="#231119" label="[23:11:19]">&lt;Googulator&gt;</a></span><span class="message">&amp; then you can play it back slowed down to read</span></div><div class="line" id="231122"><span class="nick" style="color:#8dd3c7"><a href="#231122" label="[23:11:22]">&lt;oriansj&gt;</a></span><span class="message">depends if you have an old commadore line printer</span></div><div class="line" id="231152"><span class="nick" style="color:#2e2a4a"><a href="#231152" label="[23:11:52]">&lt;Googulator&gt;</a></span><span class="message">How fast are those?</span></div><div class="line" id="231203"><span class="nick" style="color:#8dd3c7"><a href="#231203" label="[23:12:03]">&lt;oriansj&gt;</a></span><span class="message">those could hit 30 pages a minute</span></div><div class="line" id="231319"><span class="nick" style="color:#8dd3c7"><a href="#231319" label="[23:13:19]">&lt;oriansj&gt;</a></span><span class="message">but you were limited to petscii characters and a ribbon cable</span></div><div class="line" id="231359"><span class="nick" style="color:#2e2a4a"><a href="#231359" label="[23:13:59]">&lt;Googulator&gt;</a></span><span class="message">30 pages/minute? That sounds very fast, even by modern printer standards.</span></div><div class="line" id="231414"><span class="nick" style="color:#8dd3c7"><a href="#231414" label="[23:14:14]">&lt;oriansj&gt;</a></span><span class="message">plus had a bad habit of jamming and unexpectedly dying; which is why their write speed was usually software limited</span></div><div class="line" id="231415"><span class="nick" style="color:#2e2a4a"><a href="#231415" label="[23:14:15]">&lt;Googulator&gt;</a></span><span class="message">That's a whole page every 2 seconds.</span></div><div class="line" id="231551"><span class="nick" style="color:#8dd3c7"><a href="#231551" label="[23:15:51]">&lt;oriansj&gt;</a></span><span class="message">10 pages per minute was pretty common in that era with some hitting 2500 lines per minute</span></div><div class="line" id="231800"><span class="nick" style="color:#6b8072"><a href="#231800" label="[23:18:00]">&lt;vagrantc&gt;</a></span><span class="message">yeah, printer speeds slowed down significantly with the transition to ink and toner</span></div><div class="line" id="231841"><span class="nick" style="color:#8dd3c7"><a href="#231841" label="[23:18:41]">&lt;oriansj&gt;</a></span><span class="message">and the resultion went way up</span></div><div class="line" id="231904"><span class="nick" style="color:#6b8072"><a href="#231904" label="[23:19:04]">&lt;vagrantc&gt;</a></span><span class="message">yeah, very pretty.</span></div><div class="line" id="232059"><span class="nick" style="color:#8dd3c7"><a href="#232059" label="[23:20:59]">&lt;oriansj&gt;</a></span><span class="message">we can do images now</span></div><div class="line" id="232944"><span class="nick" style="color:#8dd3c7"><a href="#232944" label="[23:29:44]">&lt;oriansj&gt;</a></span><span class="message">which would be nice if I actually printed anything anymore</span></div><div class="line" id="233658"><span class="nick" style="color:#8dd3c7"><a href="#233658" label="[23:36:58]">&lt;oriansj&gt;</a></span><span class="message">stikonas: the switch prototype with test is up</span></div><div class="line" id="233714"><span class="nick" style="color:#80b1d3"><a href="#233714" label="[23:37:14]">&lt;stikonas&gt;</a></span><span class="message">oh, so quickly!</span></div><div class="line" id="233735"><span class="nick" style="color:#8dd3c7"><a href="#233735" label="[23:37:35]">&lt;oriansj&gt;</a></span><span class="message">janneke: feel free to let me know what I did wrong so that you can use it in mes.c ^_^</span></div><div class="line" id="233816"><span class="nick" style="color:#8dd3c7"><a href="#233816" label="[23:38:16]">&lt;oriansj&gt;</a></span><span class="message">it is only 214 lines of code</span></div><div class="line" id="234005"><span class="nick" style="color:#8dd3c7"><a href="#234005" label="[23:40:05]">&lt;oriansj&gt;</a></span><span class="message">and the test cases definitely could use some expanding</span></div><div class="line" id="235225"><span class="nick" style="color:#80b1d3"><a href="#235225" label="[23:52:25]">&lt;stikonas&gt;</a></span><span class="message">oriansj: can we not optimize risc-v assembly at else if((RISCV32 == Architecture) || (RISCV64 == Architecture)) emit_out(&quot;rd_a0 rs1_a0 rs2_a1 sub\nrs1_a0 @8 bnez\n$_SWITCH_CASE_&quot;); ?</span></div><div class="line" id="235235"><span class="nick" style="color:#80b1d3"><a href="#235235" label="[23:52:35]">&lt;stikonas&gt;</a></span><span class="message">(line 2201)</span></div><div class="line" id="235255"><span class="nick" style="color:#80b1d3"><a href="#235255" label="[23:52:55]">&lt;stikonas&gt;</a></span><span class="message">here we are just comparing two registers?</span></div><div class="line" id="235334"><span class="nick" style="color:#80b1d3"><a href="#235334" label="[23:53:34]">&lt;stikonas&gt;</a></span><span class="message">hmm, let me think...</span></div><div class="line" id="235506"><span class="nick" style="color:#80b1d3"><a href="#235506" label="[23:55:06]">&lt;stikonas&gt;</a></span><span class="message">hmm, maybe not...</span></div><div class="line" id="235720"><span class="nick" style="color:#80b1d3"><a href="#235720" label="[23:57:20]">&lt;stikonas&gt;</a></span><span class="message">oriansj: ok, I think it makes sense</span></div><div class="line" id="235748"><span class="nick" style="color:#80b1d3"><a href="#235748" label="[23:57:48]">&lt;stikonas&gt;</a></span><span class="message">it would be interesting now to test it with mes, but of course one would first have to restore switches in mes.c...</span></div><br /></div></body></html>