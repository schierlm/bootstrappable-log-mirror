<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2023-10-29.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="020747"><span class="nick" style="color:#389600"><a href="#020747" label="[02:07:47]">&lt;jcowan&gt;</a></span><span class="message">Is there a statement anywhere of what C dialect mescc accepts?</span></div><div class="line" id="021527"><span class="nick" style="color:#8dd3c7"><a href="#021527" label="[02:15:27]">&lt;stikonas&gt;</a></span><span class="message">jcowan: not really...</span></div><div class="line" id="021551"><span class="nick" style="color:#8dd3c7"><a href="#021551" label="[02:15:51]">&lt;stikonas&gt;</a></span><span class="message">probaly most C89 stuff</span></div><div class="line" id="021554"><span class="nick" style="color:#8dd3c7"><a href="#021554" label="[02:15:54]">&lt;stikonas&gt;</a></span><span class="message">some C99 too</span></div><div class="line" id="021610"><span class="nick" style="color:#8dd3c7"><a href="#021610" label="[02:16:10]">&lt;stikonas&gt;</a></span><span class="message">jcowan: thoguh what do you want to achieve?</span></div><div class="line" id="021636"><span class="nick" style="color:#389600"><a href="#021636" label="[02:16:36]">&lt;jcowan&gt;</a></span><span class="message">I'm interested in small C dialects</span></div><div class="line" id="021822"><span class="nick" style="color:#8dd3c7"><a href="#021822" label="[02:18:22]">&lt;stikonas&gt;</a></span><span class="message">well, mescc generally supports slighty more than M2-Planet</span></div><div class="line" id="021931"><span class="nick" style="color:#8dd3c7"><a href="#021931" label="[02:19:31]">&lt;stikonas&gt;</a></span><span class="message">and M2-Planet supports if/else statements, for/do/while loops, asm blocks (with it's own M1 asm syntax), goto, unions, structs, arrays</span></div><div class="line" id="022038"><span class="nick" style="color:#8dd3c7"><a href="#022038" label="[02:20:38]">&lt;stikonas&gt;</a></span><span class="message">I think mescc also supports switch/case on top of that</span></div><div class="line" id="022053"><span class="nick" style="color:#8dd3c7"><a href="#022053" label="[02:20:53]">&lt;stikonas&gt;</a></span><span class="message">also increment/decrement operators</span></div><div class="line" id="022109"><span class="nick" style="color:#8dd3c7"><a href="#022109" label="[02:21:09]">&lt;stikonas&gt;</a></span><span class="message">possibly a few other things</span></div><div class="line" id="022130"><span class="nick" style="color:#8dd3c7"><a href="#022130" label="[02:21:30]">&lt;stikonas&gt;</a></span><span class="message">though mescc is orders of magnitute slower than M2-Planet</span></div><div class="line" id="022535"><span class="nick" style="color:#389600"><a href="#022535" label="[02:25:35]">&lt;jcowan&gt;</a></span><span class="message">Hopefully it's faster if you run it on a more performant Scheme</span></div><div class="line" id="022613"><span class="nick" style="color:#8dd3c7"><a href="#022613" label="[02:26:13]">&lt;stikonas&gt;</a></span><span class="message">yeah, a bit faster if you run it with guile</span></div><div class="line" id="022632"><span class="nick" style="color:#8dd3c7"><a href="#022632" label="[02:26:32]">&lt;stikonas&gt;</a></span><span class="message">but if you are in bootstrapping environment where you have just built mes, then it is fairly slow</span></div><div class="line" id="022657"><span class="nick" style="color:#389600"><a href="#022657" label="[02:26:57]">&lt;jcowan&gt;</a></span><span class="message">Unsurprising</span></div><div class="line" id="022711"><span class="nick" style="color:#389600"><a href="#022711" label="[02:27:11]">&lt;jcowan&gt;</a></span><span class="message">not that Guile is a very fast Scheme either</span></div><div class="line" id="022935"><span class="nick" style="color:#8dd3c7"><a href="#022935" label="[02:29:35]">&lt;stikonas&gt;</a></span><span class="message">yes, but still faster than mes</span></div><div class="line" id="022957"><span class="nick" style="color:#389600"><a href="#022957" label="[02:29:57]">&lt;jcowan&gt;</a></span><span class="message">Gambit would probably be much more performant than Guile</span></div><div class="line" id="023002"><span class="nick" style="color:#8dd3c7"><a href="#023002" label="[02:30:02]">&lt;stikonas&gt;</a></span><span class="message">and when combined with some non-performant hardware, e.g. risc-v, it can take a week to build tcc...</span></div><div class="line" id="023013"><span class="nick" style="color:#389600"><a href="#023013" label="[02:30:13]">&lt;jcowan&gt;</a></span><span class="message">a week!</span></div><div class="line" id="023026"><span class="nick" style="color:#8dd3c7"><a href="#023026" label="[02:30:26]">&lt;stikonas&gt;</a></span><span class="message">yeah...</span></div><div class="line" id="023032"><span class="nick" style="color:#8dd3c7"><a href="#023032" label="[02:30:32]">&lt;stikonas&gt;</a></span><span class="message">risc-v is slow</span></div><div class="line" id="023041"><span class="nick" style="color:#8dd3c7"><a href="#023041" label="[02:30:41]">&lt;stikonas&gt;</a></span><span class="message">we probably output not very optimized code too</span></div><div class="line" id="023053"><span class="nick" style="color:#389600"><a href="#023053" label="[02:30:53]">&lt;jcowan&gt;</a></span><span class="message">Sure</span></div><div class="line" id="023102"><span class="nick" style="color:#8dd3c7"><a href="#023102" label="[02:31:02]">&lt;stikonas&gt;</a></span><span class="message">(kind of following x86 ideas, so not really most optimal for riscv)</span></div><div class="line" id="023110"><span class="nick" style="color:#389600"><a href="#023110" label="[02:31:10]">&lt;jcowan&gt;</a></span><span class="message">mmm</span></div><div class="line" id="023116"><span class="nick" style="color:#8dd3c7"><a href="#023116" label="[02:31:16]">&lt;stikonas&gt;</a></span><span class="message">e.g. heavy stack use rather than registers</span></div><div class="line" id="023131"><span class="nick" style="color:#8dd3c7"><a href="#023131" label="[02:31:31]">&lt;stikonas&gt;</a></span><span class="message">on x86 it's 20 minutes though</span></div><div class="line" id="023223"><span class="nick" style="color:#389600"><a href="#023223" label="[02:32:23]">&lt;jcowan&gt;</a></span><span class="message">x86 is a horrible use of silicon</span></div><div class="line" id="023253"><span class="nick" style="color:#389600"><a href="#023253" label="[02:32:53]">&lt;jcowan&gt;</a></span><span class="message">what cpus are supported right now?</span></div><div class="line" id="023325"><span class="nick" style="color:#8dd3c7"><a href="#023325" label="[02:33:25]">&lt;stikonas&gt;</a></span><span class="message">well, full bootstrap works only on x86</span></div><div class="line" id="023337"><span class="nick" style="color:#8dd3c7"><a href="#023337" label="[02:33:37]">&lt;stikonas&gt;</a></span><span class="message">on riscv we can now get from hex0 to tcc</span></div><div class="line" id="023342"><span class="nick" style="color:#8dd3c7"><a href="#023342" label="[02:33:42]">&lt;stikonas&gt;</a></span><span class="message">so mescc works there</span></div><div class="line" id="023436"><span class="nick" style="color:#8dd3c7"><a href="#023436" label="[02:34:36]">&lt;stikonas&gt;</a></span><span class="message">on amd64 we can start with hex0, get to mes, rebuild mes with mescc, then built very first tcc binary (but it is non-functional and crashes)</span></div><div class="line" id="023458"><span class="nick" style="color:#8dd3c7"><a href="#023458" label="[02:34:58]">&lt;stikonas&gt;</a></span><span class="message">there might be some support for arm/aarch64, but you might have to just between 32/64 bits</span></div><div class="line" id="023515"><span class="nick" style="color:#8dd3c7"><a href="#023515" label="[02:35:15]">&lt;stikonas&gt;</a></span><span class="message">so most likely also incomplete</span></div><div class="line" id="024037"><span class="nick" style="color:#8dd3c7"><a href="#024037" label="[02:40:37]">&lt;stikonas&gt;</a></span><span class="message">jcowan: some people in my work do design x86 chips :), though not me...</span></div><div class="line" id="024241"><span class="nick" style="color:#389600"><a href="#024241" label="[02:42:41]">&lt;jcowan&gt;</a></span><span class="message">You know the definition of Windows 95?</span></div><div class="line" id="024356"><span class="nick" style="color:#8dd3c7"><a href="#024356" label="[02:43:56]">&lt;stikonas&gt;</a></span><span class="message">?</span></div><div class="line" id="024436"><span class="nick" style="color:#8dd3c7"><a href="#024436" label="[02:44:36]">&lt;stikonas&gt;</a></span><span class="message">bloated?</span></div><div class="line" id="024508"><span class="nick" style="color:#8dd3c7"><a href="#024508" label="[02:45:08]">&lt;stikonas&gt;</a></span><span class="message">(for those days...)</span></div><div class="line" id="025453"><span class="nick" style="color:#389600"><a href="#025453" label="[02:54:53]">&lt;jcowan&gt;</a></span><span class="message">&quot;A 32-bit shell on top of a 16-bit operating system designed for an 8-bit computer based on a 4-bit chip, designed by a two-bit company that doesn’t care one bit about its users.&quot;</span></div><div class="line" id="020616"><span class="nick" style="color:#2e2a4a"><a href="#020616" label="[02:06:16]">&lt;pabs3&gt;</a></span><span class="message">btw, if anyone knows of other resources related to generated files; essays about source, or tools to detect generated files etc, let me know</span></div><div class="line" id="021822"><span class="nick" style="color:#6b8072"><a href="#021822" label="[02:18:22]">&lt;oriansj&gt;</a></span><span class="message">pabs3: well generated files took a very hard turn for the worse when it comes to detection due to the wide availability of Large Language Models which produce output that looks human written.</span></div><div class="line" id="022525"><span class="nick" style="color:#2e2a4a"><a href="#022525" label="[02:25:25]">&lt;pabs3&gt;</a></span><span class="message">yeah, that is a huge problem</span></div><div class="line" id="125341"><span class="nick" style="color:#6b8072"><a href="#125341" label="[12:53:41]">&lt;oriansj&gt;</a></span><span class="message">but then again people claiming generated crap as source code isn't a new problem and even GNU programs distribute generated files in its &quot;source&quot; tarballs. So that half of the bootstrapping fight will be a much harder fight.</span></div><div class="line" id="141841"><span class="nick" style="color:#8dd3c7"><a href="#141841" label="[14:18:41]">&lt;stikonas&gt;</a></span><span class="message">yeah, but LLM makes it much harder to identify those</span></div><div class="line" id="141921"><span class="nick" style="color:#8dd3c7"><a href="#141921" label="[14:19:21]">&lt;stikonas&gt;</a></span><span class="message">and then you start getting semi-generated files</span></div><div class="line" id="141941"><span class="nick" style="color:#8dd3c7"><a href="#141941" label="[14:19:41]">&lt;stikonas&gt;</a></span><span class="message">i.e. there was some source code that was pregenerated, possibly with some bugs and then human edits i</span></div><div class="line" id="141945"><span class="nick" style="color:#8dd3c7"><a href="#141945" label="[14:19:45]">&lt;stikonas&gt;</a></span><span class="message">s/i/it/</span></div><div class="line" id="142516"><span class="nick" style="color:#8dd3c7"><a href="#142516" label="[14:25:16]">&lt;stikonas&gt;</a></span><span class="message">oriansj: so I think ekaitz and I are at the point where there isn't much more to do from hex0 to bootstrappable tcc on riscv64, so we'll need to think about releasing</span></div><div class="line" id="142538"><span class="nick" style="color:#8dd3c7"><a href="#142538" label="[14:25:38]">&lt;stikonas&gt;</a></span><span class="message">do you think you'll have a bit of time to create stage0-posix tarballs?</span></div><div class="line" id="142546"><span class="nick" style="color:#8dd3c7"><a href="#142546" label="[14:25:46]">&lt;stikonas&gt;</a></span><span class="message">(and tags)</span></div><div class="line" id="142553"><span class="nick" style="color:#6b8072"><a href="#142553" label="[14:25:53]">&lt;oriansj&gt;</a></span><span class="message">of course</span></div><div class="line" id="142646"><span class="nick" style="color:#8dd3c7"><a href="#142646" label="[14:26:46]">&lt;stikonas&gt;</a></span><span class="message">it will probably be easier for janneke to test everything if we get stage0 out first</span></div><div class="line" id="142707"><span class="nick" style="color:#8dd3c7"><a href="#142707" label="[14:27:07]">&lt;stikonas&gt;</a></span><span class="message">though I think new stage0-posix also needs mes 0.25 (i.e. it's not compatible with earlier ones)</span></div><div class="line" id="143103"><span class="nick" style="color:#8dd3c7"><a href="#143103" label="[14:31:03]">&lt;stikonas&gt;</a></span><span class="message">at least this time we have a nice changelog at <a rel="nofollow" href="https://github.com/oriansj/stage0-posix/blob/master/CHANGELOG.org">https://github.com/oriansj/stage0-posix/blob/master/CHANGELOG.org</a> </span></div><div class="line" id="181423"><span class="nick" style="color:#80b1d3"><a href="#181423" label="[18:14:23]">&lt;muurkha&gt;</a></span><span class="message">man, it's been 28 years since Windows 95</span></div><div class="line" id="181517"><span class="nick" style="color:#80b1d3"><a href="#181517" label="[18:15:17]">&lt;muurkha&gt;</a></span><span class="message">RISC-V probably isn't inherently slow, but all the current implementations of it are</span></div><div class="line" id="181707"><span class="nick" style="color:#80b1d3"><a href="#181707" label="[18:17:07]">&lt;muurkha&gt;</a></span><span class="message">stikonas: when you say &quot;on x86&quot; do you mean &quot;on i386&quot;?  sometimes people use &quot;x86&quot; to mean &quot;amd64&quot; or {amd64, i386} or {amd64, i386, 8086}</span></div><div class="line" id="181710"><span class="nick" style="color:#8dd3c7"><a href="#181710" label="[18:17:10]">&lt;stikonas&gt;</a></span><span class="message">also our stage0 and mes compilers produce a non-optimized code</span></div><div class="line" id="181723"><span class="nick" style="color:#8dd3c7"><a href="#181723" label="[18:17:23]">&lt;stikonas&gt;</a></span><span class="message">muurkha: no, not i386... amd64</span></div><div class="line" id="181852"><span class="nick" style="color:#80b1d3"><a href="#181852" label="[18:18:52]">&lt;muurkha&gt;</a></span><span class="message">hmm, but you said &quot;full bootstrap works only on x86&quot; and then explained how it doesn't work on amd64: &quot;on amd64 we can ... [build the] very first tcc binary (but it is non-functional and crashes)&quot;</span></div><div class="line" id="182127"><span class="nick" style="color:#8dd3c7"><a href="#182127" label="[18:21:27]">&lt;stikonas&gt;</a></span><span class="message">well, yeah, I was not completely consistent with x86</span></div><div class="line" id="182130"><span class="nick" style="color:#80b1d3"><a href="#182130" label="[18:21:30]">&lt;muurkha&gt;</a></span><span class="message">it's probably the case that RISC-V depends more on compiler optimization than amd64; the larger register set is sort of like a level -1 data cache, explicitly managed by the compiler</span></div><div class="line" id="182148"><span class="nick" style="color:#80b1d3"><a href="#182148" label="[18:21:48]">&lt;muurkha&gt;</a></span><span class="message">so in &quot;works only on x86&quot; you meant i386?</span></div><div class="line" id="182151"><span class="nick" style="color:#8dd3c7"><a href="#182151" label="[18:21:51]">&lt;stikonas&gt;</a></span><span class="message">sometimes people refer to both 32bit and 64-bit when they say x86</span></div><div class="line" id="182203"><span class="nick" style="color:#8dd3c7"><a href="#182203" label="[18:22:03]">&lt;stikonas&gt;</a></span><span class="message">bootstrap is only completed on i386</span></div><div class="line" id="182210"><span class="nick" style="color:#8dd3c7"><a href="#182210" label="[18:22:10]">&lt;stikonas&gt;</a></span><span class="message">but again, 64-bit CPUs can still run 32-bit code for now</span></div><div class="line" id="182405"><span class="nick" style="color:#80b1d3"><a href="#182405" label="[18:24:05]">&lt;muurkha&gt;</a></span><span class="message">sure</span></div><div class="line" id="182516"><span class="nick" style="color:#80b1d3"><a href="#182516" label="[18:25:16]">&lt;muurkha&gt;</a></span><span class="message">thanks for unconfusing me!</span></div><div class="line" id="201202"><span class="nick" style="color:#6d2462"><a href="#201202" label="[20:12:02]">&lt;artemist&gt;</a></span><span class="message">There are some ARM cores which only support AArch64 (mostly in very new phones or Apple's ARM machines) but that's mostly unrelated, you still end up with a ton of 32 bit code on Windows and it will be supported for the forseeable future</span></div><div class="line" id="201855"><span class="nick" style="color:#8dd3c7"><a href="#201855" label="[20:18:55]">&lt;stikonas&gt;</a></span><span class="message">on the other hand 32-bit code on Linux will be seriously broken in 15 years or so</span></div><div class="line" id="201931"><span class="nick" style="color:#8dd3c7"><a href="#201931" label="[20:19:31]">&lt;stikonas&gt;</a></span><span class="message">I've tried running current bootstrap chain with clock moved forward and various things do break (in particular build systems)</span></div><div class="line" id="202330"><span class="nick" style="color:#234e69"><a href="#202330" label="[20:23:30]">&lt;nektro&gt;</a></span><span class="message">is the reason for why mes is slow well known/understood?</span></div><div class="line" id="202540"><span class="nick" style="color:#389600"><a href="#202540" label="[20:25:40]">&lt;jcowan&gt;</a></span><span class="message">mescc is not optimized and does not produce optimized code</span></div><div class="line" id="202709"><span class="nick" style="color:#389600"><a href="#202709" label="[20:27:09]">&lt;jcowan&gt;</a></span><span class="message">if you compile it with an optimizing Scheme-&gt;C compiler like Gambit and then compile the output with gcc/clang you will probably get a huge speedup</span></div><div class="line" id="202723"><span class="nick" style="color:#389600"><a href="#202723" label="[20:27:23]">&lt;jcowan&gt;</a></span><span class="message">s/Gambit/&amp; or Chicken</span></div><div class="line" id="203202"><span class="nick" style="color:#6b8072"><a href="#203202" label="[20:32:02]">&lt;oriansj&gt;</a></span><span class="message">nektro: M2-Planet produces very naive binaries and the lack of switch support means that mes.c needs to do a bunch of branching on every single s-expresion</span></div><div class="line" id="203237"><span class="nick" style="color:#6b8072"><a href="#203237" label="[20:32:37]">&lt;oriansj&gt;</a></span><span class="message">so if you wanted to speed up mes.c a good bit we would need to add switch/case support to M2-Planet</span></div><div class="line" id="204132"><span class="nick" style="color:#8dd3c7"><a href="#204132" label="[20:41:32]">&lt;stikonas&gt;</a></span><span class="message">nektro: I tried running callgrind on mes/mescc, it was spending 25% of time in eval_apply function</span></div><div class="line" id="204200"><span class="nick" style="color:#6b8072"><a href="#204200" label="[20:42:00]">&lt;oriansj&gt;</a></span><span class="message">(which is a giant if else if else block)</span></div><div class="line" id="204208"><span class="nick" style="color:#8dd3c7"><a href="#204208" label="[20:42:08]">&lt;stikonas&gt;</a></span><span class="message">yeah...</span></div><div class="line" id="204222"><span class="nick" style="color:#8dd3c7"><a href="#204222" label="[20:42:22]">&lt;stikonas&gt;</a></span><span class="message">still, it's unlikely that it would be massively faster</span></div><div class="line" id="204226"><span class="nick" style="color:#8dd3c7"><a href="#204226" label="[20:42:26]">&lt;stikonas&gt;</a></span><span class="message">maybe a bit faster</span></div><div class="line" id="204301"><span class="nick" style="color:#8dd3c7"><a href="#204301" label="[20:43:01]">&lt;stikonas&gt;</a></span><span class="message">and interpreters are slow in general</span></div><div class="line" id="204338"><span class="nick" style="color:#8dd3c7"><a href="#204338" label="[20:43:38]">&lt;stikonas&gt;</a></span><span class="message">we can't really compare mes and gambit since gambit just compiles it to C...</span></div><div class="line" id="204349"><span class="nick" style="color:#8dd3c7"><a href="#204349" label="[20:43:49]">&lt;stikonas&gt;</a></span><span class="message">and presumably something only gcc can deal with</span></div><div class="line" id="205818"><span class="nick" style="color:#6b8072"><a href="#205818" label="[20:58:18]">&lt;oriansj&gt;</a></span><span class="message">well going from if/else to switch would reduce the number of conditional jumps from 1-20 to just 1</span></div><div class="line" id="205923"><span class="nick" style="color:#6b8072"><a href="#205923" label="[20:59:23]">&lt;oriansj&gt;</a></span><span class="message">I remember when janneke went from switch to if/else even self-hosted it became a good bit slower.</span></div><div class="line" id="210241"><span class="nick" style="color:#8dd3c7"><a href="#210241" label="[21:02:41]">&lt;stikonas&gt;</a></span><span class="message">well, even self-hosted can't help much if code is using if/else, and it has to in order to be able to be bootstrapped with M2-Planet</span></div><div class="line" id="210248"><span class="nick" style="color:#8dd3c7"><a href="#210248" label="[21:02:48]">&lt;stikonas&gt;</a></span><span class="message">not sure how hard it would be to implement that</span></div><div class="line" id="210252"><span class="nick" style="color:#8dd3c7"><a href="#210252" label="[21:02:52]">&lt;stikonas&gt;</a></span><span class="message">perhaps not too hard</span></div><div class="line" id="210300"><span class="nick" style="color:#8dd3c7"><a href="#210300" label="[21:03:00]">&lt;stikonas&gt;</a></span><span class="message">but there are various corner cases</span></div><div class="line" id="210340"><span class="nick" style="color:#8dd3c7"><a href="#210340" label="[21:03:40]">&lt;stikonas&gt;</a></span><span class="message">like break, nested switch, etc...</span></div><div class="line" id="210719"><span class="nick" style="color:#6b8072"><a href="#210719" label="[21:07:19]">&lt;oriansj&gt;</a></span><span class="message">indeed, hence why it hasnt been implemented yet</span></div><div class="line" id="211924"><span class="nick" style="color:#389600"><a href="#211924" label="[21:19:24]">&lt;jcowan&gt;</a></span><span class="message">stikonas: Gambit supports at least gcc, clang, and tcc</span></div><div class="line" id="212112"><span class="nick" style="color:#389600"><a href="#212112" label="[21:21:12]">&lt;jcowan&gt;</a></span><span class="message">(also js and python)</span></div><div class="line" id="212550"><span class="nick" style="color:#8dd3c7"><a href="#212550" label="[21:25:50]">&lt;stikonas&gt;</a></span><span class="message">yeah, but in terms of bootstrapping, once you have tcc, scheme is less important</span></div><div class="line" id="212602"><span class="nick" style="color:#8dd3c7"><a href="#212602" label="[21:26:02]">&lt;stikonas&gt;</a></span><span class="message">tcc can build basically everything</span></div><div class="line" id="212720"><span class="nick" style="color:#389600"><a href="#212720" label="[21:27:20]">&lt;jcowan&gt;</a></span><span class="message"> well, anything written in c89</span></div><div class="line" id="234031"><span class="nick" style="color:#6c3d55"><a href="#234031" label="[23:40:31]">&lt;mihi&gt;</a></span><span class="message">just a side note: When your biggest problem is a huge if/else cascade on singleton pointers and your compiler cannot do switch/case or function pointers, but has goto (which is even used in eval_apply), the method known from last century was to give each singleton member (i.e. &quot;symbol&quot; in mes' case) a hand-crafted integer value (ordinal) and do range comparisons like &quot;if (ordinal &gt; 32) {if ordinal &gt; 24) goto x1;</span></div><div class="line" id="234031"><span class="nick" style="color:#6c3d55"><a href="#234031" label="[23:40:31]">&lt;mihi&gt;</a></span><span class="message">else goto x2;} else if (ordinal &gt; 16) goto x3; else goto x4;&quot; That way you get from O(n) worst case comparisons to somewhere near O(log n).</span></div><div class="line" id="234115"><span class="nick" style="color:#6c3d55"><a href="#234115" label="[23:41:15]">&lt;mihi&gt;</a></span><span class="message">But still, it only makes sense if that is the true bottleneck. If the bottleneck is that eval_apply is called in sequential loops where some more sensible lookup would make it faster, you'd have to optimize that first.</span></div><div class="line" id="234130"><span class="nick" style="color:#6c3d55"><a href="#234130" label="[23:41:30]">&lt;mihi&gt;</a></span><span class="message">and in Lisp/Scheme there is lots of linked list processing :)</span></div><div class="line" id="234202"><span class="nick" style="color:#6c3d55"><a href="#234202" label="[23:42:02]">&lt;mihi&gt;</a></span><span class="message">(that *24* should have been *48* in the code above)</span></div><div class="line" id="235443"><span class="nick" style="color:#80b1d3"><a href="#235443" label="[23:54:43]">&lt;muurkha&gt;</a></span><span class="message">stikonas: not all 32-bit code on Linux, just the code that cares about time</span></div><div class="line" id="235452"><span class="nick" style="color:#80b1d3"><a href="#235452" label="[23:54:52]">&lt;muurkha&gt;</a></span><span class="message">like, libjpeg wont' care</span></div><div class="line" id="235501"><span class="nick" style="color:#8dd3c7"><a href="#235501" label="[23:55:01]">&lt;stikonas&gt;</a></span><span class="message">yes, which is why I specifically mentioned build systems</span></div><div class="line" id="235538"><span class="nick" style="color:#8dd3c7"><a href="#235538" label="[23:55:38]">&lt;stikonas&gt;</a></span><span class="message">so live-bootstrap did fail at some point when trying to run it in 2040 or so...</span></div><div class="line" id="235554"><span class="nick" style="color:#8dd3c7"><a href="#235554" label="[23:55:54]">&lt;stikonas&gt;</a></span><span class="message">not immediately, but somewhere between tcc and gcc...</span></div><div class="line" id="235621"><span class="nick" style="color:#8dd3c7"><a href="#235621" label="[23:56:21]">&lt;stikonas&gt;</a></span><span class="message">once more complicated build systems really kick in... Earlier steps with kaem or handcrafted make files usually work fine</span></div><div class="line" id="235653"><span class="nick" style="color:#80b1d3"><a href="#235653" label="[23:56:53]">&lt;muurkha&gt;</a></span><span class="message">if you want reproducible bootstrapping you should probably do it with a fake system clock</span></div><div class="line" id="235716"><span class="nick" style="color:#80b1d3"><a href="#235716" label="[23:57:16]">&lt;muurkha&gt;</a></span><span class="message">because otherwise the system clock is an input into the build process that's different every time you run it</span></div><div class="line" id="235810"><span class="nick" style="color:#8dd3c7"><a href="#235810" label="[23:58:10]">&lt;stikonas&gt;</a></span><span class="message">well, other clock bugs are fixed in live-bootstrap</span></div><div class="line" id="235824"><span class="nick" style="color:#8dd3c7"><a href="#235824" label="[23:58:24]">&lt;stikonas&gt;</a></span><span class="message">there were initially a few bugs were year was stored in documentation, etc...</span></div><div class="line" id="235844"><span class="nick" style="color:#8dd3c7"><a href="#235844" label="[23:58:44]">&lt;stikonas&gt;</a></span><span class="message">but 2038 problem is a bit more complicated...</span></div><div class="line" id="235849"><span class="nick" style="color:#80b1d3"><a href="#235849" label="[23:58:49]">&lt;muurkha&gt;</a></span><span class="message">is it?</span></div><div class="line" id="235858"><span class="nick" style="color:#8dd3c7"><a href="#235858" label="[23:58:58]">&lt;stikonas&gt;</a></span><span class="message">yeah, cause clocks wrap to 1900 or so...</span></div><div class="line" id="235911"><span class="nick" style="color:#80b1d3"><a href="#235911" label="[23:59:11]">&lt;muurkha&gt;</a></span><span class="message">not if you use a fake system clock</span></div><div class="line" id="235912"><span class="nick" style="color:#8dd3c7"><a href="#235912" label="[23:59:12]">&lt;stikonas&gt;</a></span><span class="message">and e.g. make can get confused which file is newer and which is not</span></div><div class="line" id="235930"><span class="nick" style="color:#8dd3c7"><a href="#235930" label="[23:59:30]">&lt;stikonas&gt;</a></span><span class="message">well, if you fake it completely to some fixed value</span></div><div class="line" id="235936"><span class="nick" style="color:#8dd3c7"><a href="#235936" label="[23:59:36]">&lt;stikonas&gt;</a></span><span class="message">then yes, that's a workaround</span></div><div class="line" id="235950"><span class="nick" style="color:#8dd3c7"><a href="#235950" label="[23:59:50]">&lt;stikonas&gt;</a></span><span class="message">and in modern linux systems you could use namespaces for that</span></div><br /></div></body></html>