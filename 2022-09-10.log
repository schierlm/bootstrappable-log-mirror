<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-09-10.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000356"><span class="nick" style="color:#8dd3c7"><a href="#000356" label="[00:03:56]">&lt;muurkha&gt;</a></span><span class="message">the particular ML features that make ML better than C for compilers are efficient automatic memory management (usually GC), strong static typing with sum types, statically checked pattern matching, implementations that generate efficient code, and duck typing in the form of higher-order functions</span></div><div class="line" id="000402"><span class="nick" style="color:#8dd3c7"><a href="#000402" label="[00:04:02]">&lt;muurkha&gt;</a></span><span class="message">of these Scheme has the first and the last</span></div><div class="line" id="000448"><span class="nick" style="color:#8dd3c7"><a href="#000448" label="[00:04:48]">&lt;muurkha&gt;</a></span><span class="message">I'm inclined to think that the *implicitness* of typing in ML and Scheme is also a benefit, but I think there are people who would disagree with that, and they might be right</span></div><div class="line" id="000743"><span class="nick" style="color:#8dd3c7"><a href="#000743" label="[00:07:43]">&lt;muurkha&gt;</a></span><span class="message">I feel like other aspects of parametric polymorphism like the ability to add your own safe polymorphic containers are maybe not as important in the context of compilers</span></div><div class="line" id="000903"><span class="nick" style="color:#2e2a4a"><a href="#000903" label="[00:09:03]">&lt;oriansj&gt;</a></span><span class="message">well polymorphism never seems like a real good idea when you are working in a problem space of meaningful results</span></div><div class="line" id="001028"><span class="nick" style="color:#8dd3c7"><a href="#001028" label="[00:10:28]">&lt;muurkha&gt;</a></span><span class="message">I don't know how to interpret that statement as something that could be true; can you elaborate? :)</span></div><div class="line" id="001148"><span class="nick" style="color:#8dd3c7"><a href="#001148" label="[00:11:48]">&lt;muurkha&gt;</a></span><span class="message">parametric polymorphism means that you can implement, for example, quicksort, binary search, a hash table, or a B-tree once, and then use it on many different types of objects, rather than having to implement a separate quicksort or hash table for each type of object</span></div><div class="line" id="001241"><span class="nick" style="color:#2e2a4a"><a href="#001241" label="[00:12:41]">&lt;oriansj&gt;</a></span><span class="message">a function or a data type can be written generically so that it can handle values identically without depending on their type; but types REALLY matter for most specialized operations.</span></div><div class="line" id="001337"><span class="nick" style="color:#8dd3c7"><a href="#001337" label="[00:13:37]">&lt;muurkha&gt;</a></span><span class="message">can you give an example?</span></div><div class="line" id="001510"><span class="nick" style="color:#2e2a4a"><a href="#001510" label="[00:15:10]">&lt;oriansj&gt;</a></span><span class="message">ok sort {name: foo; age: 1; ssn: 1234567} {name: bar; age: 10; ssn: 2345678}</span></div><div class="line" id="001623"><span class="nick" style="color:#2e2a4a"><a href="#001623" label="[00:16:23]">&lt;oriansj&gt;</a></span><span class="message">and now consider a language where functions can be passed.</span></div><div class="line" id="001736"><span class="nick" style="color:#2e2a4a"><a href="#001736" label="[00:17:36]">&lt;oriansj&gt;</a></span><span class="message">sort(a, b, myfunc); that is just plain C no polymorphic needed</span></div><div class="line" id="002606"><span class="nick" style="color:#2e2a4a"><a href="#002606" label="[00:26:06]">&lt;oriansj&gt;</a></span><span class="message">but maybe because my dream language is based on the idea that every bit of the language becomes part of the source code space.</span></div><div class="line" id="002735"><span class="nick" style="color:#2e2a4a"><a href="#002735" label="[00:27:35]">&lt;oriansj&gt;</a></span><span class="message">DEFINE (INT64 a) + (INT64 b) AS LAMBDA RETURNS INT64 .. sort of thing</span></div><div class="line" id="002749"><span class="nick" style="color:#6b8072"><a href="#002749" label="[00:27:49]">&lt;drakonis&gt;</a></span><span class="message">that exists now</span></div><div class="line" id="002759"><span class="nick" style="color:#6b8072"><a href="#002759" label="[00:27:59]">&lt;drakonis&gt;</a></span><span class="message">academia has been looking into recently</span></div><div class="line" id="002804"><span class="nick" style="color:#6b8072"><a href="#002804" label="[00:28:04]">&lt;drakonis&gt;</a></span><span class="message">also, kernel?</span></div><div class="line" id="002854"><span class="nick" style="color:#6b8072"><a href="#002854" label="[00:28:54]">&lt;drakonis&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/frank-lang/frank">https://github.com/frank-lang/frank</a> </span></div><div class="line" id="003027"><span class="nick" style="color:#6b8072"><a href="#003027" label="[00:30:27]">&lt;drakonis&gt;</a></span><span class="message">its been evolving</span></div><div class="line" id="003834"><span class="nick" style="color:#2e2a4a"><a href="#003834" label="[00:38:34]">&lt;oriansj&gt;</a></span><span class="message">oh interesting.</span></div><div class="line" id="003934"><span class="nick" style="color:#6b8072"><a href="#003934" label="[00:39:34]">&lt;drakonis&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/yallop/effects-bibliography">https://github.com/yallop/effects-bibliography</a>  and <a rel="nofollow" href="https://github.com/metaocaml/metaocaml-bibliography">https://github.com/metaocaml/metaocaml-bibliography</a> </span></div><div class="line" id="003942"><span class="nick" style="color:#6b8072"><a href="#003942" label="[00:39:42]">&lt;drakonis&gt;</a></span><span class="message">for interesting bits related to the language</span></div><div class="line" id="003952"><span class="nick" style="color:#6b8072"><a href="#003952" label="[00:39:52]">&lt;drakonis&gt;</a></span><span class="message">your dream language is going to eventually release</span></div><div class="line" id="004104"><span class="nick" style="color:#2e2a4a"><a href="#004104" label="[00:41:04]">&lt;oriansj&gt;</a></span><span class="message">well it would be a simple language to implement. There is only 3 keywords and a list of types</span></div><div class="line" id="004112"><span class="nick" style="color:#6b8072"><a href="#004112" label="[00:41:12]">&lt;drakonis&gt;</a></span><span class="message">yes.</span></div><div class="line" id="004126"><span class="nick" style="color:#2e2a4a"><a href="#004126" label="[00:41:26]">&lt;oriansj&gt;</a></span><span class="message">DEFINE, TYPE and ASM</span></div><div class="line" id="004128"><span class="nick" style="color:#6b8072"><a href="#004128" label="[00:41:28]">&lt;drakonis&gt;</a></span><span class="message">though you gotta implement a standard library, innit?</span></div><div class="line" id="004133"><span class="nick" style="color:#2e2a4a"><a href="#004133" label="[00:41:33]">&lt;oriansj&gt;</a></span><span class="message">nope</span></div><div class="line" id="004148"><span class="nick" style="color:#6b8072"><a href="#004148" label="[00:41:48]">&lt;drakonis&gt;</a></span><span class="message"> <a rel="nofollow" href="https://web.cs.wpi.edu/~jshutt/kernel.html">https://web.cs.wpi.edu/~jshutt/kernel.html</a> </span></div><div class="line" id="004154"><span class="nick" style="color:#6b8072"><a href="#004154" label="[00:41:54]">&lt;drakonis&gt;</a></span><span class="message">this bad boy might be up your alley</span></div><div class="line" id="004157"><span class="nick" style="color:#2e2a4a"><a href="#004157" label="[00:41:57]">&lt;oriansj&gt;</a></span><span class="message">LAMBDA is defined in terms of TYPE and ASM</span></div><div class="line" id="004200"><span class="nick" style="color:#8dd3c7"><a href="#004200" label="[00:42:00]">&lt;muurkha&gt;</a></span><span class="message">Rest In Power</span></div><div class="line" id="004236"><span class="nick" style="color:#2e2a4a"><a href="#004236" label="[00:42:36]">&lt;oriansj&gt;</a></span><span class="message">just like stacks, iteration and even the definition of LAMBDA</span></div><div class="line" id="004441"><span class="nick" style="color:#6b8072"><a href="#004441" label="[00:44:41]">&lt;drakonis&gt;</a></span><span class="message">sure</span></div><div class="line" id="005156"><span class="nick" style="color:#2e2a4a"><a href="#005156" label="[00:51:56]">&lt;oriansj&gt;</a></span><span class="message">and the meaning of RETURNS gets kinda of interesting when you can change the number of arguments returned (literally forcing the programmer to manually deal with the impossible compiler problem)</span></div><div class="line" id="005258"><span class="nick" style="color:#2e2a4a"><a href="#005258" label="[00:52:58]">&lt;oriansj&gt;</a></span><span class="message">(which is already done in assembly programs like cc_*)</span></div><div class="line" id="005310"><span class="nick" style="color:#8dd3c7"><a href="#005310" label="[00:53:10]">&lt;muurkha&gt;</a></span><span class="message">sort(a, b, myfunc) is definitely polymorphic.  the polymorphism is the reason why qsort() and bsearch() in C use void pointers</span></div><div class="line" id="005358"><span class="nick" style="color:#8dd3c7"><a href="#005358" label="[00:53:58]">&lt;muurkha&gt;</a></span><span class="message">that's a good example of how to do duck typing in the form of higher-order functions; the problem is that in C you don't get the duck typing, so you have to just turn the type system off entirely</span></div><div class="line" id="005427"><span class="nick" style="color:#8dd3c7"><a href="#005427" label="[00:54:27]">&lt;muurkha&gt;</a></span><span class="message">incidentally, I thought the Golang approach to this problem was interesting</span></div><div class="line" id="005732"><span class="nick" style="color:#8dd3c7"><a href="#005732" label="[00:57:32]">&lt;muurkha&gt;</a></span><span class="message">Golang's sort.Interface consists of Len() int, Less(i, j int) bool, and Swap(i, j int)</span></div><div class="line" id="005818"><span class="nick" style="color:#8dd3c7"><a href="#005818" label="[00:58:18]">&lt;muurkha&gt;</a></span><span class="message">so it's a type for the whole container, not the individual elements</span></div><div class="line" id="005819"><span class="nick" style="color:#2e2a4a"><a href="#005819" label="[00:58:19]">&lt;oriansj&gt;</a></span><span class="message">well think about this DEFINE ANY AS TYPE {ENUMERATION of types}; (then the programmer can redefine ANY to include their custom types) and then DEFINE SORT (ANY A, ANY B, COMPARE) RETURNS ANY ...</span></div><div class="line" id="005841"><span class="nick" style="color:#6b8072"><a href="#005841" label="[00:58:41]">&lt;drakonis&gt;</a></span><span class="message"> <a rel="nofollow" href="http://casperbp.net/store/tfp22-abstract.pdf">http://casperbp.net/store/tfp22-abstract.pdf</a> </span></div><div class="line" id="005853"><span class="nick" style="color:#8dd3c7"><a href="#005853" label="[00:58:53]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://pkg.go.dev/sort#Interface">https://pkg.go.dev/sort#Interface</a> </span></div><div class="line" id="005858"><span class="nick" style="color:#2e2a4a"><a href="#005858" label="[00:58:58]">&lt;oriansj&gt;</a></span><span class="message">and DEFINE FOO AS COMPARE (int64 a, int64 b)</span></div><div class="line" id="010101"><span class="nick" style="color:#8dd3c7"><a href="#010101" label="[01:01:01]">&lt;muurkha&gt;</a></span><span class="message">sorting is a good example where it's *really* useful to be able to use a debugged reasonably efficient (and necessarily polymorphic) linearithmic sort function from the standard library rather than weighing whether it's worth the effort in this case of implementing heapsort yet again or if you should just go with insertion sort</span></div><div class="line" id="010137"><span class="nick" style="color:#8dd3c7"><a href="#010137" label="[01:01:37]">&lt;muurkha&gt;</a></span><span class="message">or whether quicksort is worth the risk of worst-case quadratic behavior (Golang's standard unstable sort is introsort to avoid this)</span></div><div class="line" id="010249"><span class="nick" style="color:#8dd3c7"><a href="#010249" label="[01:02:49]">&lt;muurkha&gt;</a></span><span class="message">but I would argue that, if for whatever reason you're stuck writing a compiler in Pascal, the amount of extra work from manually implementing potentially-polymorphic things like insertion sort N times is going to be a small fraction of the time you spend on the compiler</span></div><div class="line" id="010315"><span class="nick" style="color:#8dd3c7"><a href="#010315" label="[01:03:15]">&lt;muurkha&gt;</a></span><span class="message">(I mean standard Pascal, not the more reasonable vendor-specific extensions that people usually use)</span></div><div class="line" id="010339"><span class="nick" style="color:#2e2a4a"><a href="#010339" label="[01:03:39]">&lt;oriansj&gt;</a></span><span class="message">well insert sort for me tends to be shorter than quick sort</span></div><div class="line" id="010407"><span class="nick" style="color:#2e2a4a"><a href="#010407" label="[01:04:07]">&lt;oriansj&gt;</a></span><span class="message">and for my purposes plenty fast</span></div><div class="line" id="010417"><span class="nick" style="color:#8dd3c7"><a href="#010417" label="[01:04:17]">&lt;muurkha&gt;</a></span><span class="message">it absolutely is shorter, and it is often faster</span></div><div class="line" id="010449"><span class="nick" style="color:#8dd3c7"><a href="#010449" label="[01:04:49]">&lt;muurkha&gt;</a></span><span class="message">I was going to say &quot;but it's still not as short as a call to a standard library routine&quot; but in the case of Golang's sort.Interface that might not actually be true ;)</span></div><div class="line" id="010632"><span class="nick" style="color:#2e2a4a"><a href="#010632" label="[01:06:32]">&lt;oriansj&gt;</a></span><span class="message">hmmm insert sort in C is 8 lines if one keeps it clean;</span></div><div class="line" id="010733"><span class="nick" style="color:#8dd3c7"><a href="#010733" label="[01:07:33]">&lt;muurkha&gt;</a></span><span class="message">only three lines of actual code</span></div><div class="line" id="010755"><span class="nick" style="color:#8dd3c7"><a href="#010755" label="[01:07:55]">&lt;muurkha&gt;</a></span><span class="message">  for (size_t i = 1; i &lt; n; i++)</span></div><div class="line" id="010755"><span class="nick" style="color:#8dd3c7"><a href="#010755" label="[01:07:55]">&lt;muurkha&gt;</a></span><span class="message">    for (size_t j = i; j &gt; 0; j--)</span></div><div class="line" id="010755"><span class="nick" style="color:#8dd3c7"><a href="#010755" label="[01:07:55]">&lt;muurkha&gt;</a></span><span class="message">      if (a[j-1] &gt; a[j]) swap(&amp;a[j], &amp;a[j-1]);</span></div><div class="line" id="010800"><span class="nick" style="color:#2e2a4a"><a href="#010800" label="[01:08:00]">&lt;oriansj&gt;</a></span><span class="message">DEFINE mycompare (mytype a, mytype b) returns bool {return a-&gt;name &lt; b-&gt;name}; SORT (a, b, mycompare)</span></div><div class="line" id="010839"><span class="nick" style="color:#8dd3c7"><a href="#010839" label="[01:08:39]">&lt;muurkha&gt;</a></span><span class="message">I guess that presumes the implementation of swap</span></div><div class="line" id="010923"><span class="nick" style="color:#8dd3c7"><a href="#010923" label="[01:09:23]">&lt;muurkha&gt;</a></span><span class="message">right, invoking a purely comparator-based interface can be a bit terser, especially if you have lambdas</span></div><div class="line" id="010953"><span class="nick" style="color:#8dd3c7"><a href="#010953" label="[01:09:53]">&lt;muurkha&gt;</a></span><span class="message">but Golang's sort.Interface requires you to implement Len, Less, and Swap</span></div><div class="line" id="011115"><span class="nick" style="color:#2e2a4a"><a href="#011115" label="[01:11:15]">&lt;oriansj&gt;</a></span><span class="message">well copy rather than update removes the meaning of swap for sorting</span></div><div class="line" id="011219"><span class="nick" style="color:#8dd3c7"><a href="#011219" label="[01:12:19]">&lt;muurkha&gt;</a></span><span class="message">hm?</span></div><div class="line" id="011311"><span class="nick" style="color:#2e2a4a"><a href="#011311" label="[01:13:11]">&lt;oriansj&gt;</a></span><span class="message">if you are doing a sort on an array of type int64; you just create another new array of type int64 and return that</span></div><div class="line" id="011339"><span class="nick" style="color:#2e2a4a"><a href="#011339" label="[01:13:39]">&lt;oriansj&gt;</a></span><span class="message">there is no swap, only values copied</span></div><div class="line" id="011530"><span class="nick" style="color:#8dd3c7"><a href="#011530" label="[01:15:30]">&lt;muurkha&gt;</a></span><span class="message">do you mean that you can implement a sort without swaps?  that's certainly true</span></div><div class="line" id="011617"><span class="nick" style="color:#8dd3c7"><a href="#011617" label="[01:16:17]">&lt;muurkha&gt;</a></span><span class="message">insertion sort in particular can also be significantly faster if you do it that way</span></div><div class="line" id="011630"><span class="nick" style="color:#8dd3c7"><a href="#011630" label="[01:16:30]">&lt;muurkha&gt;</a></span><span class="message">and mergesort doesn't really benefit from swap</span></div><div class="line" id="011733"><span class="nick" style="color:#8dd3c7"><a href="#011733" label="[01:17:33]">&lt;muurkha&gt;</a></span><span class="message">a nice thing about heapsort, though, is that it's very predictable</span></div><div class="line" id="011847"><span class="nick" style="color:#2e2a4a"><a href="#011847" label="[01:18:47]">&lt;oriansj&gt;</a></span><span class="message">also in retrospect if ANY is defined to be expanded to iterate the function over all possible types and then pruned to only those combinations of those used; you enable some fun optimizations</span></div><div class="line" id="011918"><span class="nick" style="color:#8dd3c7"><a href="#011918" label="[01:19:18]">&lt;muurkha&gt;</a></span><span class="message">it never fails because you don't have enough memory, it never takes more time than it usually does because the input is in a different order</span></div><div class="line" id="012041"><span class="nick" style="color:#8dd3c7"><a href="#012041" label="[01:20:41]">&lt;muurkha&gt;</a></span><span class="message">yeah, there are a lot of interesting whole-program optimizations like that that are rarely used</span></div><div class="line" id="012053"><span class="nick" style="color:#2e2a4a"><a href="#012053" label="[01:20:53]">&lt;oriansj&gt;</a></span><span class="message">muurkha: no quantum-bogosort attached to destory universe device?</span></div><div class="line" id="012413"><span class="nick" style="color:#8dd3c7"><a href="#012413" label="[01:24:13]">&lt;muurkha&gt;</a></span><span class="message">not in my standard library, no.  universe-destroying devices are not a portable solution because they don't work in universes obeying the Copenhagen interpretation rather than MWI</span></div><div class="line" id="012742"><span class="nick" style="color:#8dd3c7"><a href="#012742" label="[01:27:42]">&lt;muurkha&gt;</a></span><span class="message">unlike parametric polymorphism, automatic memory management has a pervasive simplifying effect on your code, because it allows you to pass around arbitrary data structures as easily as ints</span></div><div class="line" id="012800"><span class="nick" style="color:#8dd3c7"><a href="#012800" label="[01:28:00]">&lt;muurkha&gt;</a></span><span class="message">and pattern-matching simplifies almost every part of a compiler</span></div><div class="line" id="012947"><span class="nick" style="color:#2e2a4a"><a href="#012947" label="[01:29:47]">&lt;oriansj&gt;</a></span><span class="message">and Pointers despite being *VERY* powerful tend to be misused so easily</span></div><div class="line" id="013652"><span class="nick" style="color:#2e2a4a"><a href="#013652" label="[01:36:52]">&lt;oriansj&gt;</a></span><span class="message">so I am torn between 2 options: no pointers but Garbage collection and safety or pointers and absolute insane levels of freedom in the language.</span></div><div class="line" id="013730"><span class="nick" style="color:#8dd3c7"><a href="#013730" label="[01:37:30]">&lt;muurkha&gt;</a></span><span class="message">by &quot;pointers&quot; do you mean pointer arithmetic?  or just shared references to mutable objects, as in Scheme?</span></div><div class="line" id="013813"><span class="nick" style="color:#8dd3c7"><a href="#013813" label="[01:38:13]">&lt;muurkha&gt;</a></span><span class="message">(and as in Golang)</span></div><div class="line" id="013834"><span class="nick" style="color:#2e2a4a"><a href="#013834" label="[01:38:34]">&lt;oriansj&gt;</a></span><span class="message">I mean real pointers in the crazy sense</span></div><div class="line" id="013839"><span class="nick" style="color:#8dd3c7"><a href="#013839" label="[01:38:39]">&lt;muurkha&gt;</a></span><span class="message">that doesn't help!</span></div><div class="line" id="013923"><span class="nick" style="color:#2e2a4a"><a href="#013923" label="[01:39:23]">&lt;oriansj&gt;</a></span><span class="message">where the pointer could point in the middle of objects and arbitrary byte addresses</span></div><div class="line" id="014016"><span class="nick" style="color:#8dd3c7"><a href="#014016" label="[01:40:16]">&lt;muurkha&gt;</a></span><span class="message">well, there are several different kinds of language semantics where pointers can point into the middle of objects and arbitrary byte addresses</span></div><div class="line" id="014036"><span class="nick" style="color:#8dd3c7"><a href="#014036" label="[01:40:36]">&lt;muurkha&gt;</a></span><span class="message">one is the C/assembly approach, where you can freely convert between pointers and integers</span></div><div class="line" id="014043"><span class="nick" style="color:#2e2a4a"><a href="#014043" label="[01:40:43]">&lt;oriansj&gt;</a></span><span class="message">and could be objects or functions or parts of the stack</span></div><div class="line" id="014053"><span class="nick" style="color:#8dd3c7"><a href="#014053" label="[01:40:53]">&lt;muurkha&gt;</a></span><span class="message">another is the Golang approach, where you can't do that but you can embed objects inside other objects and then take pointers to them</span></div><div class="line" id="014123"><span class="nick" style="color:#2e2a4a"><a href="#014123" label="[01:41:23]">&lt;oriansj&gt;</a></span><span class="message">I was thinking the assembly approach (much more free than the C restrictions)</span></div><div class="line" id="014136"><span class="nick" style="color:#8dd3c7"><a href="#014136" label="[01:41:36]">&lt;muurkha&gt;</a></span><span class="message">aha, I see</span></div><div class="line" id="014224"><span class="nick" style="color:#8dd3c7"><a href="#014224" label="[01:42:24]">&lt;muurkha&gt;</a></span><span class="message">maybe your options are best as two different levels in the same system, rather than alterantives?</span></div><div class="line" id="014456"><span class="nick" style="color:#2e2a4a"><a href="#014456" label="[01:44:56]">&lt;oriansj&gt;</a></span><span class="message">well rust is already trying to do that to a degree</span></div><div class="line" id="014716"><span class="nick" style="color:#8dd3c7"><a href="#014716" label="[01:47:16]">&lt;muurkha&gt;</a></span><span class="message">rust is the only language I know (other than Tcl and Bash) attempting to eliminate pointers in the sense of &quot;shared references to mutable objects&quot;</span></div><div class="line" id="014742"><span class="nick" style="color:#8dd3c7"><a href="#014742" label="[01:47:42]">&lt;muurkha&gt;</a></span><span class="message">which I think is a really interesting experiment, and seems to be bearing some very interesting fruit</span></div><div class="line" id="014813"><span class="nick" style="color:#8dd3c7"><a href="#014813" label="[01:48:13]">&lt;muurkha&gt;</a></span><span class="message">but I'd like a smaller language</span></div><div class="line" id="020055"><span class="nick" style="color:#2e2a4a"><a href="#020055" label="[02:00:55]">&lt;oriansj&gt;</a></span><span class="message">zig</span></div><div class="line" id="020422"><span class="nick" style="color:#8dd3c7"><a href="#020422" label="[02:04:22]">&lt;muurkha&gt;</a></span><span class="message">zig isn't attempting to eliminate pointers in the sense of &quot;shared references to mutable objects&quot;, is it?</span></div><div class="line" id="020448"><span class="nick" style="color:#8dd3c7"><a href="#020448" label="[02:04:48]">&lt;muurkha&gt;</a></span><span class="message">I admit I haven't tried to use zig</span></div><div class="line" id="020538"><span class="nick" style="color:#2e2a4a"><a href="#020538" label="[02:05:38]">&lt;oriansj&gt;</a></span><span class="message">zig feels like rust light</span></div><div class="line" id="021953"><span class="nick" style="color:#8dd3c7"><a href="#021953" label="[02:19:53]">&lt;muurkha&gt;</a></span><span class="message">but AFAIK it doesn't have the particular feature I was talking about, which is fairly central to Rust</span></div><div class="line" id="024535"><span class="nick" style="color:#2e2a4a"><a href="#024535" label="[02:45:35]">&lt;oriansj&gt;</a></span><span class="message">hmmmmm.</span></div><div class="line" id="024630"><span class="nick" style="color:#2e2a4a"><a href="#024630" label="[02:46:30]">&lt;oriansj&gt;</a></span><span class="message">used cryptsetup to make /dev/sda1 into a luks volume but on init cryptsetup says /dev/sda1 is not a valid LUKS device</span></div><div class="line" id="025314"><span class="nick" style="color:#8dd3c7"><a href="#025314" label="[02:53:14]">&lt;muurkha&gt;</a></span><span class="message">oh dear.  that's very disheartening</span></div><div class="line" id="025411"><span class="nick" style="color:#8dd3c7"><a href="#025411" label="[02:54:11]">&lt;muurkha&gt;</a></span><span class="message">if you cryptsetup luksDump /dev/sda1 from a livecd pendrive, what does it say?</span></div><div class="line" id="025921"><span class="nick" style="color:#2e2a4a"><a href="#025921" label="[02:59:21]">&lt;oriansj&gt;</a></span><span class="message">fortunately this is in qemu</span></div><div class="line" id="025956"><span class="nick" style="color:#2e2a4a"><a href="#025956" label="[02:59:56]">&lt;oriansj&gt;</a></span><span class="message">so it is valid but it looks like I forgot to setup mount -t devtmpfs none /dev on my initramfs</span></div><div class="line" id="030032"><span class="nick" style="color:#8dd3c7"><a href="#030032" label="[03:00:32]">&lt;muurkha&gt;</a></span><span class="message">is it booting now?</span></div><div class="line" id="030116"><span class="nick" style="color:#8dd3c7"><a href="#030116" label="[03:01:16]">&lt;muurkha&gt;</a></span><span class="message">I lost track of how devfs stuff worked around the beginning of systemd</span></div><div class="line" id="030542"><span class="nick" style="color:#8dd3c7"><a href="#030542" label="[03:05:42]">&lt;muurkha&gt;</a></span><span class="message">oriansj: Graydon's presentation mentions Turbo Pascal and Aztec C as examples of Variation #7</span></div><div class="line" id="030552"><span class="nick" style="color:#8dd3c7"><a href="#030552" label="[03:05:52]">&lt;muurkha&gt;</a></span><span class="message">TP I'm pretty sure was written in assembly; not sure about Aztec C</span></div><div class="line" id="030610"><span class="nick" style="color:#8dd3c7"><a href="#030610" label="[03:06:10]">&lt;muurkha&gt;</a></span><span class="message">also he mentions something called 8cc</span></div><div class="line" id="030654"><span class="nick" style="color:#8dd3c7"><a href="#030654" label="[03:06:54]">&lt;muurkha&gt;</a></span><span class="message">&quot;6'740 lines of C, self-hosting, compiles to ~110kb via clang, 220kb via self.  Don't have to use assembly to get this small!  Quite readable and simple.  Works.&quot;</span></div><div class="line" id="031035"><span class="nick" style="color:#8dd3c7"><a href="#031035" label="[03:10:35]">&lt;muurkha&gt;</a></span><span class="message">which is apparently now chibicc: <a rel="nofollow" href="https://github.com/rui314/chibicc">https://github.com/rui314/chibicc</a> </span></div><div class="line" id="031056"><span class="nick" style="color:#2e2a4a"><a href="#031056" label="[03:10:56]">&lt;oriansj&gt;</a></span><span class="message">well doing C compilers is pretty easy, even in assembly</span></div><div class="line" id="031110"><span class="nick" style="color:#8dd3c7"><a href="#031110" label="[03:11:10]">&lt;muurkha&gt;</a></span><span class="message">which David A. Wheeler's 'SLOCCount' tells me is 9'232 lines of C</span></div><div class="line" id="031322"><span class="nick" style="color:#8dd3c7"><a href="#031322" label="[03:13:22]">&lt;muurkha&gt;</a></span><span class="message">ah, the author is the original author of lld, which is why his name seemed familiar</span></div><div class="line" id="031417"><span class="nick" style="color:#8dd3c7"><a href="#031417" label="[03:14:17]">&lt;muurkha&gt;</a></span><span class="message">or maybe because I read <a rel="nofollow" href="https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days">https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days</a> </span></div><div class="line" id="031450"><span class="nick" style="color:#2e2a4a"><a href="#031450" label="[03:14:50]">&lt;oriansj&gt;</a></span><span class="message">smart and capable people, tend to produce multiple interesting things in their lives</span></div><div class="line" id="031852"><span class="nick" style="color:#2e2a4a"><a href="#031852" label="[03:18:52]">&lt;oriansj&gt;</a></span><span class="message">just like you muurkha</span></div><div class="line" id="031906"><span class="nick" style="color:#8dd3c7"><a href="#031906" label="[03:19:06]">&lt;muurkha&gt;</a></span><span class="message">aww *blush*</span></div><div class="line" id="031910"><span class="nick" style="color:#8dd3c7"><a href="#031910" label="[03:19:10]">&lt;muurkha&gt;</a></span><span class="message">I'm just a muurkha</span></div><div class="line" id="032213"><span class="nick" style="color:#2e2a4a"><a href="#032213" label="[03:22:13]">&lt;oriansj&gt;</a></span><span class="message">but results speak for themselves</span></div><div class="line" id="032803"><span class="nick" style="color:#2e2a4a"><a href="#032803" label="[03:28:03]">&lt;oriansj&gt;</a></span><span class="message">if nothing else, this gentoo encrypted / and /boot has forced me to memorize the mount -t proc none proc; mount --rbind /sys sys; mount --rbind /dev dev; mount --bind /run run; chroot . pattern</span></div><div class="line" id="033246"><span class="nick" style="color:#2e2a4a"><a href="#033246" label="[03:32:46]">&lt;oriansj&gt;</a></span><span class="message">well I got it to the asking for luks password</span></div><div class="line" id="033335"><span class="nick" style="color:#2e2a4a"><a href="#033335" label="[03:33:35]">&lt;oriansj&gt;</a></span><span class="message">now I just get a device mapper error: reload ioctl on failed: invalid argument</span></div><div class="line" id="034129"><span class="nick" style="color:#80b1d3"><a href="#034129" label="[03:41:29]">&lt;sam_&gt;</a></span><span class="message">hehe</span></div><div class="line" id="034150"><span class="nick" style="color:#2e2a4a"><a href="#034150" label="[03:41:50]">&lt;oriansj&gt;</a></span><span class="message">did I forget dm_crypt module ?</span></div><div class="line" id="034648"><span class="nick" style="color:#2e2a4a"><a href="#034648" label="[03:46:48]">&lt;oriansj&gt;</a></span><span class="message">my script for making an initramfs however needs lots of work: <a rel="nofollow" href="https://paste.debian.net/1253362">https://paste.debian.net/1253362</a> </span></div><div class="line" id="035423"><span class="nick" style="color:#8dd3c7"><a href="#035423" label="[03:54:23]">&lt;muurkha&gt;</a></span><span class="message">oops!</span></div><div class="line" id="035532"><span class="nick" style="color:#8dd3c7"><a href="#035532" label="[03:55:32]">&lt;muurkha&gt;</a></span><span class="message">Walter Bright suggests how C could have done slices: <a rel="nofollow" href="https://www.digitalmars.com/articles/C-biggest-mistake.html">https://www.digitalmars.com/articles/C-biggest-mistake.html</a> </span></div><div class="line" id="041250"><span class="nick" style="color:#2e2a4a"><a href="#041250" label="[04:12:50]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well slices would be nice but I would have to say the biggest mistake is probably &amp; (address of) because without it C would have been forced to a better more strict language</span></div><div class="line" id="042442"><span class="nick" style="color:#2e2a4a"><a href="#042442" label="[04:24:42]">&lt;oriansj&gt;</a></span><span class="message">well if I add to package.use sys-kernel/genkernel cryptsetup; I hit the linux-firmware being masked. So how would I get around that?</span></div><div class="line" id="042632"><span class="nick" style="color:#2e2a4a"><a href="#042632" label="[04:26:32]">&lt;oriansj&gt;</a></span><span class="message">and I mean in regards to not needing to use binary blobs</span></div><div class="line" id="042808"><span class="nick" style="color:#80b1d3"><a href="#042808" label="[04:28:08]">&lt;sam_&gt;</a></span><span class="message">genkernel[-firmware]</span></div><div class="line" id="042814"><span class="nick" style="color:#80b1d3"><a href="#042814" label="[04:28:14]">&lt;sam_&gt;</a></span><span class="message">(although I'd still recommend not using genkernel)</span></div><div class="line" id="042909"><span class="nick" style="color:#2e2a4a"><a href="#042909" label="[04:29:09]">&lt;oriansj&gt;</a></span><span class="message">sam_: ok, I can avoid genkernel if I knew what the better way would be</span></div><div class="line" id="042926"><span class="nick" style="color:#80b1d3"><a href="#042926" label="[04:29:26]">&lt;sam_&gt;</a></span><span class="message">dist-kernels! (gentoo-kernel &amp; gentoo-kernel-bin, although I assume you wouldn't be using -bin: <a rel="nofollow" href="https://wiki.gentoo.org/wiki/Project:Distribution_Kernel">https://wiki.gentoo.org/wiki/Project:Distribution_Kernel</a>) </span></div><div class="line" id="042933"><span class="nick" style="color:#2e2a4a"><a href="#042933" label="[04:29:33]">&lt;oriansj&gt;</a></span><span class="message">as I am willing to do a manual build and a hand rolled initramfs if I need</span></div><div class="line" id="043135"><span class="nick" style="color:#2e2a4a"><a href="#043135" label="[04:31:35]">&lt;oriansj&gt;</a></span><span class="message">and that will work with  the current issue I am seeing with the lack of the dm_crypt module in the kernel I built?</span></div><div class="line" id="043405"><span class="nick" style="color:#80b1d3"><a href="#043405" label="[04:34:05]">&lt;sam_&gt;</a></span><span class="message">I don't see why it shouldn't at all -- the reason I in particular dislike genkernel is that it makes it way too hard to actually use your own config</span></div><div class="line" id="043411"><span class="nick" style="color:#80b1d3"><a href="#043411" label="[04:34:11]">&lt;sam_&gt;</a></span><span class="message">it ends up overwriting it evne when you think it wouldn't</span></div><div class="line" id="043905"><span class="nick" style="color:#2e2a4a"><a href="#043905" label="[04:39:05]">&lt;oriansj&gt;</a></span><span class="message">I can work with hard; I just need the process to be reliable enough</span></div><div class="line" id="043934"><span class="nick" style="color:#80b1d3"><a href="#043934" label="[04:39:34]">&lt;sam_&gt;</a></span><span class="message">I would say it's not very reliable</span></div><div class="line" id="043942"><span class="nick" style="color:#80b1d3"><a href="#043942" label="[04:39:42]">&lt;sam_&gt;</a></span><span class="message">I mean, some people like it, but it's not something I recommend for a reason</span></div><div class="line" id="043954"><span class="nick" style="color:#80b1d3"><a href="#043954" label="[04:39:54]">&lt;sam_&gt;</a></span><span class="message">my experience has been that it has confusing UX and it's not as well maintained as it ought to be</span></div><div class="line" id="044149"><span class="nick" style="color:#2e2a4a"><a href="#044149" label="[04:41:49]">&lt;oriansj&gt;</a></span><span class="message">that I can imagine</span></div><div class="line" id="044906"><span class="nick" style="color:#8dd3c7"><a href="#044906" label="[04:49:06]">&lt;muurkha&gt;</a></span><span class="message">oriansj: &amp; definitely constrains the compilation approaches applicable to C and can be bug-prone</span></div><div class="line" id="045034"><span class="nick" style="color:#8dd3c7"><a href="#045034" label="[04:50:34]">&lt;muurkha&gt;</a></span><span class="message">I think most of its uses are covered by Pascal-style var parameters: self pointers, state machines, multiple returns, in-out parameters, that kind of thing</span></div><div class="line" id="045342"><span class="nick" style="color:#8dd3c7"><a href="#045342" label="[04:53:42]">&lt;muurkha&gt;</a></span><span class="message">maybe paradigmatic is tcc's TokenString</span></div><div class="line" id="045349"><span class="nick" style="color:#8dd3c7"><a href="#045349" label="[04:53:49]">&lt;muurkha&gt;</a></span><span class="message">            TokenString ws_str;</span></div><div class="line" id="045349"><span class="nick" style="color:#8dd3c7"><a href="#045349" label="[04:53:49]">&lt;muurkha&gt;</a></span><span class="message">            tok_str_new(&amp;ws_str);</span></div><div class="line" id="045359"><span class="nick" style="color:#8dd3c7"><a href="#045359" label="[04:53:59]">&lt;muurkha&gt;</a></span><span class="message">            t = next_argstream(nested_list, &amp;ws_str);</span></div><div class="line" id="045511"><span class="nick" style="color:#8dd3c7"><a href="#045511" label="[04:55:11]">&lt;muurkha&gt;</a></span><span class="message">but that can be handled just as well by heap-allocating it, which is what you'd do in Scheme</span></div><div class="line" id="045812"><span class="nick" style="color:#8dd3c7"><a href="#045812" label="[04:58:12]">&lt;muurkha&gt;</a></span><span class="message">somewhat more tricky is when you want to pass a mutable reference to a field to a subroutine; the simplest example is scanf:</span></div><div class="line" id="045823"><span class="nick" style="color:#8dd3c7"><a href="#045823" label="[04:58:23]">&lt;muurkha&gt;</a></span><span class="message">(void)sscanf(departure, &quot;%02u-%02uT%02u:%02uZ&quot;, &amp;ais-&gt;type6.dac1fid12.lmonth, ...);</span></div><div class="line" id="045827"><span class="nick" style="color:#2e2a4a"><a href="#045827" label="[04:58:27]">&lt;oriansj&gt;</a></span><span class="message">it literally isn't used once in M2-Planet or mescc-tools</span></div><div class="line" id="045856"><span class="nick" style="color:#8dd3c7"><a href="#045856" label="[04:58:56]">&lt;muurkha&gt;</a></span><span class="message">but a more compelling example, I think, is the sort of use you see in Dear Imgui,</span></div><div class="line" id="045901"><span class="nick" style="color:#2e2a4a"><a href="#045901" label="[04:59:01]">&lt;oriansj&gt;</a></span><span class="message">muurkha: but is that really actually a good idea</span></div><div class="line" id="050136"><span class="nick" style="color:#8dd3c7"><a href="#050136" label="[05:01:36]">&lt;muurkha&gt;</a></span><span class="message">where you can ImGui::SliderFloat for any arbitrary floating-point field</span></div><div class="line" id="050209"><span class="nick" style="color:#8dd3c7"><a href="#050209" label="[05:02:09]">&lt;muurkha&gt;</a></span><span class="message">inside a struct or whatever</span></div><div class="line" id="050220"><span class="nick" style="color:#8dd3c7"><a href="#050220" label="[05:02:20]">&lt;muurkha&gt;</a></span><span class="message">that both reads and writes the field</span></div><div class="line" id="050333"><span class="nick" style="color:#8dd3c7"><a href="#050333" label="[05:03:33]">&lt;muurkha&gt;</a></span><span class="message">gpsd does something similar for its JSON serialization:</span></div><div class="line" id="050343"><span class="nick" style="color:#8dd3c7"><a href="#050343" label="[05:03:43]">&lt;muurkha&gt;</a></span><span class="message">	{&quot;lon&quot;,    t_real,    .addr.real = &amp;gpsdata-&gt;fix.longitude, .dflt.real = NAN},</span></div><div class="line" id="050346"><span class="nick" style="color:#8dd3c7"><a href="#050346" label="[05:03:46]">&lt;muurkha&gt;</a></span><span class="message">	{&quot;lat&quot;,    t_real,    .addr.real = &amp;gpsdata-&gt;fix.latitude,  .dflt.real = NAN},</span></div><div class="line" id="050350"><span class="nick" style="color:#2e2a4a"><a href="#050350" label="[05:03:50]">&lt;oriansj&gt;</a></span><span class="message">and doing float a; ... ; a = SliderFloat(a); would achieve the same</span></div><div class="line" id="050427"><span class="nick" style="color:#8dd3c7"><a href="#050427" label="[05:04:27]">&lt;muurkha&gt;</a></span><span class="message">well, clearly &amp; isn't necessary for Turing-completeness!</span></div><div class="line" id="050512"><span class="nick" style="color:#2e2a4a"><a href="#050512" label="[05:05:12]">&lt;oriansj&gt;</a></span><span class="message">and by removing it, you are forced to be more explicit</span></div><div class="line" id="050523"><span class="nick" style="color:#8dd3c7"><a href="#050523" label="[05:05:23]">&lt;muurkha&gt;</a></span><span class="message">but by removing it, the code is more bug-prone in that case</span></div><div class="line" id="050600"><span class="nick" style="color:#8dd3c7"><a href="#050600" label="[05:06:00]">&lt;muurkha&gt;</a></span><span class="message">because you can accidentally discard the return value, or store it somewhere else than in a</span></div><div class="line" id="050701"><span class="nick" style="color:#2e2a4a"><a href="#050701" label="[05:07:01]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well sometimes b = SliderFloat(a); is actually what you want and SliderFloat(a); can easily be a compiler error</span></div><div class="line" id="050730"><span class="nick" style="color:#8dd3c7"><a href="#050730" label="[05:07:30]">&lt;muurkha&gt;</a></span><span class="message">no, with an IMGUI toolkit b = SliderFloat(a); is never what you want</span></div><div class="line" id="050807"><span class="nick" style="color:#8dd3c7"><a href="#050807" label="[05:08:07]">&lt;muurkha&gt;</a></span><span class="message">because on the next screen update the slider will still be at the same place it was before even though you dragged it</span></div><div class="line" id="050839"><span class="nick" style="color:#2e2a4a"><a href="#050839" label="[05:08:39]">&lt;oriansj&gt;</a></span><span class="message">muurkha: yes; sometimes you want to be a bad UI experience</span></div><div class="line" id="050909"><span class="nick" style="color:#8dd3c7"><a href="#050909" label="[05:09:09]">&lt;muurkha&gt;</a></span><span class="message">well, you could set a back to its previous value explicitly if you wanted that</span></div><div class="line" id="050913"><span class="nick" style="color:#2e2a4a"><a href="#050913" label="[05:09:13]">&lt;oriansj&gt;</a></span><span class="message">much like tetris which only returns the worst possible piece evertime</span></div><div class="line" id="050934"><span class="nick" style="color:#8dd3c7"><a href="#050934" label="[05:09:34]">&lt;muurkha&gt;</a></span><span class="message">Pascal-style var parameters handle cases like that pretty well, but maybe not the gpsd example</span></div><div class="line" id="051144"><span class="nick" style="color:#8dd3c7"><a href="#051144" label="[05:11:44]">&lt;muurkha&gt;</a></span><span class="message">occasionally a pointer to a pointer is handy for linked-list walking code.  like, if you have a hash table with separate chaining, you want to follow the linked list chain from the appropriate hash bucket until you find a null pointer, but then what you do depends on whether you're inserting or just searching</span></div><div class="line" id="051215"><span class="nick" style="color:#8dd3c7"><a href="#051215" label="[05:12:15]">&lt;muurkha&gt;</a></span><span class="message">returning a pointer to the pointer (which might be an array element or a field of a linked-list node) is convenient in that case; it keeps you from having to write the function twice</span></div><div class="line" id="051239"><span class="nick" style="color:#2e2a4a"><a href="#051239" label="[05:12:39]">&lt;oriansj&gt;</a></span><span class="message">muurkha: that is done in hex2 and M1 &amp; wouldn't help there</span></div><div class="line" id="051311"><span class="nick" style="color:#8dd3c7"><a href="#051311" label="[05:13:11]">&lt;muurkha&gt;</a></span><span class="message">gawk's r_get_lhs does something like that, though not in a hash table</span></div><div class="line" id="051536"><span class="nick" style="color:#8dd3c7"><a href="#051536" label="[05:15:36]">&lt;muurkha&gt;</a></span><span class="message">in Emacs's acl_nfs4_nontrivial there's an interesting case where &amp; is used just to shorten the code a lot</span></div><div class="line" id="051541"><span class="nick" style="color:#8dd3c7"><a href="#051541" label="[05:15:41]">&lt;muurkha&gt;</a></span><span class="message">      nfs4_ace_int_t *ace = &amp;a-&gt;aclEntry[i];</span></div><div class="line" id="051617"><span class="nick" style="color:#8dd3c7"><a href="#051617" label="[05:16:17]">&lt;muurkha&gt;</a></span><span class="message">this is followed by a 9-line-long if condition which references ace 7 times</span></div><div class="line" id="051624"><span class="nick" style="color:#8dd3c7"><a href="#051624" label="[05:16:24]">&lt;muurkha&gt;</a></span><span class="message">      if (!((ace-&gt;flags &amp; ACE4_ID_SPECIAL) != 0</span></div><div class="line" id="051624"><span class="nick" style="color:#8dd3c7"><a href="#051624" label="[05:16:24]">&lt;muurkha&gt;</a></span><span class="message">            &amp;&amp; (ace-&gt;aceWho.special_whoid == ACE4_WHO_OWNER</span></div><div class="line" id="051626"><span class="nick" style="color:#8dd3c7"><a href="#051626" label="[05:16:26]">&lt;muurkha&gt;</a></span><span class="message">...</span></div><div class="line" id="051719"><span class="nick" style="color:#8dd3c7"><a href="#051719" label="[05:17:19]">&lt;muurkha&gt;</a></span><span class="message">of course if the nfs4_ace_int_t were separately heap-allocated, as it would be in Scheme, instead of embedded in an array, you wouldn't need &amp;</span></div><div class="line" id="051736"><span class="nick" style="color:#2e2a4a"><a href="#051736" label="[05:17:36]">&lt;oriansj&gt;</a></span><span class="message">indeed</span></div><div class="line" id="051755"><span class="nick" style="color:#8dd3c7"><a href="#051755" label="[05:17:55]">&lt;muurkha&gt;</a></span><span class="message">and you could also say nfs4_ace_int_t ace = a-&gt;aclEntry[i]; and then use ace. instead of ace-&gt;</span></div><div class="line" id="051807"><span class="nick" style="color:#2e2a4a"><a href="#051807" label="[05:18:07]">&lt;oriansj&gt;</a></span><span class="message">and without &amp;, with a bit of cleverness you can make C support garbage collection.</span></div><div class="line" id="051809"><span class="nick" style="color:#8dd3c7"><a href="#051809" label="[05:18:09]">&lt;muurkha&gt;</a></span><span class="message">but both of those options are less efficient</span></div><div class="line" id="051939"><span class="nick" style="color:#8dd3c7"><a href="#051939" label="[05:19:39]">&lt;muurkha&gt;</a></span><span class="message">people make C support garbage collection even with &amp; though</span></div><div class="line" id="052101"><span class="nick" style="color:#8dd3c7"><a href="#052101" label="[05:21:01]">&lt;muurkha&gt;</a></span><span class="message">if you just remove &amp; from C without adding var parameters, you add significant inconvenience and error-proneness in cases like these, and you lose the ability to do multiple return values without declaring a struct type for them</span></div><div class="line" id="052140"><span class="nick" style="color:#2e2a4a"><a href="#052140" label="[05:21:40]">&lt;oriansj&gt;</a></span><span class="message">like go and implicit struct return type is possible</span></div><div class="line" id="052240"><span class="nick" style="color:#8dd3c7"><a href="#052240" label="[05:22:40]">&lt;muurkha&gt;</a></span><span class="message">*like go, an?</span></div><div class="line" id="052315"><span class="nick" style="color:#8dd3c7"><a href="#052315" label="[05:23:15]">&lt;muurkha&gt;</a></span><span class="message">note btw that Golang supports garbage collection (precise GC, even) without removing &amp;</span></div><div class="line" id="052521"><span class="nick" style="color:#8dd3c7"><a href="#052521" label="[05:25:21]">&lt;muurkha&gt;</a></span><span class="message">because you can't convert pointers back and forth to integers in Golang, GC can be precise rather than conservative; the fact that sometimes pointers go into the middle of an object instead of its beginning does complicate the GC a bit but doesn't make it impossible</span></div><div class="line" id="052532"><span class="nick" style="color:#8dd3c7"><a href="#052532" label="[05:25:32]">&lt;muurkha&gt;</a></span><span class="message">or require it to be conservative</span></div><div class="line" id="052543"><span class="nick" style="color:#8dd3c7"><a href="#052543" label="[05:25:43]">&lt;muurkha&gt;</a></span><span class="message">did I misunderstand you?</span></div><div class="line" id="052637"><span class="nick" style="color:#2e2a4a"><a href="#052637" label="[05:26:37]">&lt;oriansj&gt;</a></span><span class="message">muurkha: the point isn't that removing features could result in some cases getting worse (which I certainly grant you) but the lack of features such as &amp; could have allowed more time for better concepts to develop and have enough demand to become part of the C language</span></div><div class="line" id="052707"><span class="nick" style="color:#8dd3c7"><a href="#052707" label="[05:27:07]">&lt;muurkha&gt;</a></span><span class="message">dig.c in nethack does a somewhat similar thing to the Emacs example in mkcavepos</span></div><div class="line" id="052720"><span class="nick" style="color:#8dd3c7"><a href="#052720" label="[05:27:20]">&lt;muurkha&gt;</a></span><span class="message">first it says</span></div><div class="line" id="052727"><span class="nick" style="color:#8dd3c7"><a href="#052727" label="[05:27:27]">&lt;muurkha&gt;</a></span><span class="message">    lev = &amp;levl[x][y];</span></div><div class="line" id="052746"><span class="nick" style="color:#8dd3c7"><a href="#052746" label="[05:27:46]">&lt;muurkha&gt;</a></span><span class="message">and then it uses lev-&gt; extensively, both for reads and writes</span></div><div class="line" id="052807"><span class="nick" style="color:#8dd3c7"><a href="#052807" label="[05:28:07]">&lt;muurkha&gt;</a></span><span class="message">it never changes x and y, so you could certainly have rewritten things like</span></div><div class="line" id="052828"><span class="nick" style="color:#8dd3c7"><a href="#052828" label="[05:28:28]">&lt;muurkha&gt;</a></span><span class="message">    lev-&gt;seenv = 0;</span></div><div class="line" id="052830"><span class="nick" style="color:#8dd3c7"><a href="#052830" label="[05:28:30]">&lt;muurkha&gt;</a></span><span class="message">to</span></div><div class="line" id="052841"><span class="nick" style="color:#8dd3c7"><a href="#052841" label="[05:28:41]">&lt;muurkha&gt;</a></span><span class="message">   levl[x][y].seenv = 0;</span></div><div class="line" id="052905"><span class="nick" style="color:#8dd3c7"><a href="#052905" label="[05:29:05]">&lt;muurkha&gt;</a></span><span class="message">and that wouldn't even necessarily be less efficient, although making it efficient does demand a little more from the compiler</span></div><div class="line" id="052916"><span class="nick" style="color:#8dd3c7"><a href="#052916" label="[05:29:16]">&lt;muurkha&gt;</a></span><span class="message">but it would definitely be more error-prone</span></div><div class="line" id="053259"><span class="nick" style="color:#8dd3c7"><a href="#053259" label="[05:32:59]">&lt;muurkha&gt;</a></span><span class="message">I think that if your &quot;memory model&quot; (in the sense I use the phrase in <a rel="nofollow" href="http://canonical.org/~kragen/memory-models/">http://canonical.org/~kragen/memory-models/</a>)  supports nested objects, you're going to experience a lot of pressure toward adding &amp;.  even if you already have var parameters; the Pascal that the original Macintosh System apps were written in had var parameters, and they added &amp; (spelled @)</span></div><div class="line" id="053402"><span class="nick" style="color:#8dd3c7"><a href="#053402" label="[05:34:02]">&lt;muurkha&gt;</a></span><span class="message">(I think actually they got it from some Pascal compiler on the Apple ][)</span></div><div class="line" id="053621"><span class="nick" style="color:#8dd3c7"><a href="#053621" label="[05:36:21]">&lt;muurkha&gt;</a></span><span class="message">though maybe they mostly used that for interfacing with routines written in assembly!</span></div><div class="line" id="053836"><span class="nick" style="color:#8dd3c7"><a href="#053836" label="[05:38:36]">&lt;muurkha&gt;</a></span><span class="message">things like</span></div><div class="line" id="053844"><span class="nick" style="color:#8dd3c7"><a href="#053844" label="[05:38:44]">&lt;muurkha&gt;</a></span><span class="message">  mainBits.baseAddr := @mainBuf;</span></div><div class="line" id="053844"><span class="nick" style="color:#8dd3c7"><a href="#053844" label="[05:38:44]">&lt;muurkha&gt;</a></span><span class="message">  mainBits.rowBytes := 52;</span></div><div class="line" id="053844"><span class="nick" style="color:#8dd3c7"><a href="#053844" label="[05:38:44]">&lt;muurkha&gt;</a></span><span class="message">  SetRect(mainBits.bounds,80,120,80+416,120+240);</span></div><div class="line" id="053844"><span class="nick" style="color:#8dd3c7"><a href="#053844" label="[05:38:44]">&lt;muurkha&gt;</a></span><span class="message">  ZeroBuf(@mainBuf);</span></div><div class="line" id="053847"><span class="nick" style="color:#8dd3c7"><a href="#053847" label="[05:38:47]">&lt;muurkha&gt;</a></span><span class="message">that's from MacPaint</span></div><div class="line" id="054003"><span class="nick" style="color:#8dd3c7"><a href="#054003" label="[05:40:03]">&lt;muurkha&gt;</a></span><span class="message">which is, interestingly enough, only about 3500 lines of Pascal and 2000 lines of assembly</span></div><div class="line" id="055036"><span class="nick" style="color:#8dd3c7"><a href="#055036" label="[05:50:36]">&lt;muurkha&gt;</a></span><span class="message">as I see it, the main difficulty with &amp; is only a problem for machines with addressing of 16 bits or less: it means that all your data has to live in the same address space.  in particular, you can't store all local variables outside of what wasm calls &quot;linear memory&quot;; your subroutine parameters, or at least some of them, have to live in the same address space as your heap and globals, so that you</span></div><div class="line" id="055042"><span class="nick" style="color:#8dd3c7"><a href="#055042" label="[05:50:42]">&lt;muurkha&gt;</a></span><span class="message">can &amp; them</span></div><div class="line" id="061637"><span class="nick" style="color:#2e2a4a"><a href="#061637" label="[06:16:37]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I grant you all of that but in all of those cases &amp; still probably wasn't the right idea.</span></div><div class="line" id="062922"><span class="nick" style="color:#8dd3c7"><a href="#062922" label="[06:29:22]">&lt;muurkha&gt;</a></span><span class="message">what do you think would be a better way to handle them?</span></div><div class="line" id="063403"><span class="nick" style="color:#2e2a4a"><a href="#063403" label="[06:34:03]">&lt;oriansj&gt;</a></span><span class="message">well my first question would be why not lev = levl[x][y];</span></div><div class="line" id="063801"><span class="nick" style="color:#2e2a4a"><a href="#063801" label="[06:38:01]">&lt;oriansj&gt;</a></span><span class="message">unless the point is to just update levl[x][y] with a value; then why bother with the extra pointer</span></div><div class="line" id="064751"><span class="nick" style="color:#2e2a4a"><a href="#064751" label="[06:47:51]">&lt;oriansj&gt;</a></span><span class="message">struct foo { struct bar[x]}; struct baz { struct foo [y]}; then it becomes baz-&gt;foo[y]-&gt;bar[x]-&gt;seenv;</span></div><div class="line" id="070810"><span class="nick" style="color:#8dd3c7"><a href="#070810" label="[07:08:10]">&lt;muurkha&gt;</a></span><span class="message">if you do lev = levl[x][y]; then the later lev.seenv = 0; won't have the desired effect; it will update your local variable rather than the cell of the level</span></div><div class="line" id="070853"><span class="nick" style="color:#8dd3c7"><a href="#070853" label="[07:08:53]">&lt;muurkha&gt;</a></span><span class="message">previously it says things like 	if(IS_ROCK(lev-&gt;typ)) return;</span></div><div class="line" id="070934"><span class="nick" style="color:#8dd3c7"><a href="#070934" label="[07:09:34]">&lt;muurkha&gt;</a></span><span class="message">which would work fine with a copy of the cell</span></div><div class="line" id="071111"><span class="nick" style="color:#8dd3c7"><a href="#071111" label="[07:11:11]">&lt;muurkha&gt;</a></span><span class="message">something like a C++ &quot;reference&quot; would work fine for cases like that, though, and that doesn't pose any extra difficulty over Pascal-style var parameters</span></div><div class="line" id="071125"><span class="nick" style="color:#8dd3c7"><a href="#071125" label="[07:11:25]">&lt;muurkha&gt;</a></span><span class="message">in fact I think the reason Bjarne added references to C++ was to get Pascal-style var parameters</span></div><div class="line" id="071239"><span class="nick" style="color:#8dd3c7"><a href="#071239" label="[07:12:39]">&lt;muurkha&gt;</a></span><span class="message">(or maybe so that operator[] could return something you could not just read but also assign to?  which is kind of the deal with the hash table or gawk use case for &amp;)</span></div><div class="line" id="071330"><span class="nick" style="color:#8dd3c7"><a href="#071330" label="[07:13:30]">&lt;muurkha&gt;</a></span><span class="message">(although in fact operator[] doing that in C++ turned out to be a terrible idea because it results in autovivification)</span></div><div class="line" id="071801"><span class="nick" style="color:#2e2a4a"><a href="#071801" label="[07:18:01]">&lt;oriansj&gt;</a></span><span class="message">only if the language doesn't do strict array size checks</span></div><div class="line" id="071833"><span class="nick" style="color:#2e2a4a"><a href="#071833" label="[07:18:33]">&lt;oriansj&gt;</a></span><span class="message">and require the programmer put checks around dynamically sized bits</span></div><div class="line" id="072051"><span class="nick" style="color:#8dd3c7"><a href="#072051" label="[07:20:51]">&lt;muurkha&gt;</a></span><span class="message">hmm?  what do array size checks have to do with anything?</span></div><div class="line" id="072134"><span class="nick" style="color:#8dd3c7"><a href="#072134" label="[07:21:34]">&lt;muurkha&gt;</a></span><span class="message">*returning* references like operator[] is definitely a potentially unsafe thing to do, btw</span></div><div class="line" id="072446"><span class="nick" style="color:#8dd3c7"><a href="#072446" label="[07:24:46]">&lt;muurkha&gt;</a></span><span class="message">what I mean about autovivification is that, to take the example from <a rel="nofollow" href="https://en.cppreference.com/w/cpp/language/operators">https://en.cppreference.com/w/cpp/language/operators</a>,  std::map&lt;int, int&gt; m; m[1]; invokes m.operator[], which IIRC is defined to return a reference (an int&amp; in this case)</span></div><div class="line" id="072537"><span class="nick" style="color:#8dd3c7"><a href="#072537" label="[07:25:37]">&lt;muurkha&gt;</a></span><span class="message">in order to have something to return a reference to, it allocates a node, inserts it into the red-black tree, and returns a reference to one of its fields</span></div><div class="line" id="072748"><span class="nick" style="color:#8dd3c7"><a href="#072748" label="[07:27:48]">&lt;muurkha&gt;</a></span><span class="message">this is terrible because you wouldn't think that i = m[1]; would insert a new key-value pair into m, but it does: <a rel="nofollow" href="https://en.cppreference.com/w/cpp/container/map/operator_at">https://en.cppreference.com/w/cpp/container/map/operator_at</a> </span></div><div class="line" id="072855"><span class="nick" style="color:#8dd3c7"><a href="#072855" label="[07:28:55]">&lt;muurkha&gt;</a></span><span class="message">a much more reasonable way to handle this sort of thing is given by <a rel="nofollow" href="https://en.cppreference.com/w/cpp/utility/bitset/reference">https://en.cppreference.com/w/cpp/utility/bitset/reference</a> </span></div><div class="line" id="072941"><span class="nick" style="color:#8dd3c7"><a href="#072941" label="[07:29:41]">&lt;muurkha&gt;</a></span><span class="message">you define your operator[] to return a proxy class instead of a reference, and then you can detect whether it's being written or read</span></div><div class="line" id="073327"><span class="nick" style="color:#8dd3c7"><a href="#073327" label="[07:33:27]">&lt;muurkha&gt;</a></span><span class="message">does that make sense?</span></div><div class="line" id="073604"><span class="nick" style="color:#2e2a4a"><a href="#073604" label="[07:36:04]">&lt;oriansj&gt;</a></span><span class="message">and here I was thinking if you know m[1] is beyond the length of m would just be a compile error;</span></div><div class="line" id="073700"><span class="nick" style="color:#8dd3c7"><a href="#073700" label="[07:37:00]">&lt;muurkha&gt;</a></span><span class="message">std::map doesn't have a fixed length; you can insert into it at runtime</span></div><div class="line" id="073729"><span class="nick" style="color:#2e2a4a"><a href="#073729" label="[07:37:29]">&lt;oriansj&gt;</a></span><span class="message">yeah that is a bad idea</span></div><div class="line" id="073739"><span class="nick" style="color:#8dd3c7"><a href="#073739" label="[07:37:39]">&lt;muurkha&gt;</a></span><span class="message">which part?</span></div><div class="line" id="073812"><span class="nick" style="color:#2e2a4a"><a href="#073812" label="[07:38:12]">&lt;oriansj&gt;</a></span><span class="message">doesn't have a fixed length</span></div><div class="line" id="073912"><span class="nick" style="color:#8dd3c7"><a href="#073912" label="[07:39:12]">&lt;muurkha&gt;</a></span><span class="message">oh, well, as you know, it's often useful to program with flexible containers that expand at runtime to accommodate whatever you insert into them :)</span></div><div class="line" id="074023"><span class="nick" style="color:#2e2a4a"><a href="#074023" label="[07:40:23]">&lt;oriansj&gt;</a></span><span class="message">as the second you do something like m[i] where i exceeds the length of your array; you then have to do either a new array and copy (reference problems all around) or hope you can can extend your array (or throw an exception on potentially a boatload of operations)</span></div><div class="line" id="074121"><span class="nick" style="color:#8dd3c7"><a href="#074121" label="[07:41:21]">&lt;muurkha&gt;</a></span><span class="message">but m isn't an array, it doesn't have any arrays in it anywhere</span></div><div class="line" id="074129"><span class="nick" style="color:#8dd3c7"><a href="#074129" label="[07:41:29]">&lt;muurkha&gt;</a></span><span class="message">it's a std::map, which is implemented as a red-black tree</span></div><div class="line" id="074246"><span class="nick" style="color:#8dd3c7"><a href="#074246" label="[07:42:46]">&lt;muurkha&gt;</a></span><span class="message">but inserting into a std::map can indeed throw an exception!</span></div><div class="line" id="074327"><span class="nick" style="color:#2e2a4a"><a href="#074327" label="[07:43:27]">&lt;oriansj&gt;</a></span><span class="message">m[i] only can be fast if it is an array (or vector which is just another word for array with a few extra bits)</span></div><div class="line" id="074327"><span class="nick" style="color:#8dd3c7"><a href="#074327" label="[07:43:27]">&lt;muurkha&gt;</a></span><span class="message">and std::vector also has the other problem, in which push_back invalidates all previous references and iterators into the vector</span></div><div class="line" id="074338"><span class="nick" style="color:#8dd3c7"><a href="#074338" label="[07:43:38]">&lt;muurkha&gt;</a></span><span class="message">m[i] is not especially fast, no</span></div><div class="line" id="074546"><span class="nick" style="color:#2e2a4a"><a href="#074546" label="[07:45:46]">&lt;oriansj&gt;</a></span><span class="message">so why bother to have m[i] ?</span></div><div class="line" id="074745"><span class="nick" style="color:#2e2a4a"><a href="#074745" label="[07:47:45]">&lt;oriansj&gt;</a></span><span class="message">and in the case of m[i] going off the end, why not just return a NULL pointer</span></div><div class="line" id="080710"><span class="nick" style="color:#8dd3c7"><a href="#080710" label="[08:07:10]">&lt;muurkha&gt;</a></span><span class="message">I don't understand those questions</span></div><div class="line" id="080726"><span class="nick" style="color:#8dd3c7"><a href="#080726" label="[08:07:26]">&lt;muurkha&gt;</a></span><span class="message">what would it mean to not have m[i]?</span></div><div class="line" id="080736"><span class="nick" style="color:#8dd3c7"><a href="#080736" label="[08:07:36]">&lt;muurkha&gt;</a></span><span class="message">what would it mean to go off the end of a std::map?</span></div><div class="line" id="081841"><span class="nick" style="color:#2e2a4a"><a href="#081841" label="[08:18:41]">&lt;oriansj&gt;</a></span><span class="message">well as std:map is just a red/black tree so why use it like an array/vector when it can be used like a tree.</span></div><div class="line" id="081923"><span class="nick" style="color:#2e2a4a"><a href="#081923" label="[08:19:23]">&lt;oriansj&gt;</a></span><span class="message">to go off the end of a std::map would be to ask for the subtree of a tree that doesn't exist</span></div><div class="line" id="115420"><span class="nick" style="color:#6d2462"><a href="#115420" label="[11:54:20]">&lt;doras&gt;</a></span><span class="message">stikonas: regarding dynamic linking with musl, there's the matter of either using the `musl-gcc` wrapper when building instead of `gcc`, or patching GCC itself to natively build against musl's linker. Do we have a preference?</span></div><div class="line" id="115521"><span class="nick" style="color:#234e69"><a href="#115521" label="[11:55:21]">&lt;stikonas&gt;</a></span><span class="message">I would say patching gcc makes more sense</span></div><div class="line" id="115530"><span class="nick" style="color:#234e69"><a href="#115530" label="[11:55:30]">&lt;stikonas&gt;</a></span><span class="message">fossy?</span></div><div class="line" id="115631"><span class="nick" style="color:#6d2462"><a href="#115631" label="[11:56:31]">&lt;doras&gt;</a></span><span class="message">Because it gets a bit annoying with C++, where musl doesn't provide a wrapper script for the `g++` command. It can technically work with some manual changes based on my tests, however.</span></div><div class="line" id="115645"><span class="nick" style="color:#234e69"><a href="#115645" label="[11:56:45]">&lt;stikonas&gt;</a></span><span class="message">musl-gcc wrapper probably makes more sense if base system is glibc</span></div><div class="line" id="115720"><span class="nick" style="color:#6d2462"><a href="#115720" label="[11:57:20]">&lt;doras&gt;</a></span><span class="message">stikonas: so are we in favor of heavy patching of GCC? Specifically: <a rel="nofollow" href="https://github.com/GregorR/musl-cross/blob/master/patches/gcc-4.7.4-musl.diff">https://github.com/GregorR/musl-cross/blob/master/patches/gcc-4.7.4-musl.diff</a> </span></div><div class="line" id="115726"><span class="nick" style="color:#234e69"><a href="#115726" label="[11:57:26]">&lt;stikonas&gt;</a></span><span class="message">let me see</span></div><div class="line" id="115817"><span class="nick" style="color:#234e69"><a href="#115817" label="[11:58:17]">&lt;stikonas&gt;</a></span><span class="message">should be fine in my opinion</span></div><div class="line" id="115825"><span class="nick" style="color:#234e69"><a href="#115825" label="[11:58:25]">&lt;stikonas&gt;</a></span><span class="message">well, at least for 4.7.4</span></div><div class="line" id="115850"><span class="nick" style="color:#234e69"><a href="#115850" label="[11:58:50]">&lt;stikonas&gt;</a></span><span class="message">doras: does newer GCC include this patch?</span></div><div class="line" id="115905"><span class="nick" style="color:#234e69"><a href="#115905" label="[11:59:05]">&lt;stikonas&gt;</a></span><span class="message">I looked at parent dir and there are no patches for newer gccs</span></div><div class="line" id="120112"><span class="nick" style="color:#6d2462"><a href="#120112" label="[12:01:12]">&lt;doras&gt;</a></span><span class="message">So far I only tried the wrapper scripts, but with some modifications I got it working for C and C++.</span></div><div class="line" id="120205"><span class="nick" style="color:#6d2462"><a href="#120205" label="[12:02:05]">&lt;doras&gt;</a></span><span class="message">It does requiring specifically setting environment variables during configure, however. e.g.,`CC=musl-gcc`.</span></div><div class="line" id="120217"><span class="nick" style="color:#6d2462"><a href="#120217" label="[12:02:17]">&lt;doras&gt;</a></span><span class="message">I don't mind trying the patch to see what it does.</span></div><div class="line" id="120338"><span class="nick" style="color:#6d2462"><a href="#120338" label="[12:03:38]">&lt;doras&gt;</a></span><span class="message">It doesn't have a clear license though.</span></div><div class="line" id="120404"><span class="nick" style="color:#234e69"><a href="#120404" label="[12:04:04]">&lt;stikonas&gt;</a></span><span class="message">it has to be GPL</span></div><div class="line" id="120410"><span class="nick" style="color:#234e69"><a href="#120410" label="[12:04:10]">&lt;stikonas&gt;</a></span><span class="message">it's patching GCC which is under GPL</span></div><div class="line" id="120426"><span class="nick" style="color:#234e69"><a href="#120426" label="[12:04:26]">&lt;stikonas&gt;</a></span><span class="message">though I don't know if that assumption is good enough</span></div><div class="line" id="120526"><span class="nick" style="color:#234e69"><a href="#120526" label="[12:05:26]">&lt;stikonas&gt;</a></span><span class="message">I mean the author of the patch either has to agree that is is GPL or they are infringing GPL</span></div><div class="line" id="122643"><span class="nick" style="color:#234e69"><a href="#122643" label="[12:26:43]">&lt;stikonas&gt;</a></span><span class="message">though if we have support for dynamic linking in live-bootstrap (which is good to have as some stuff depends on it) it raises a question how much we want to use it</span></div><div class="line" id="122700"><span class="nick" style="color:#234e69"><a href="#122700" label="[12:27:00]">&lt;stikonas&gt;</a></span><span class="message">I think fossy would prefer to only use it when strictly required</span></div><div class="line" id="122734"><span class="nick" style="color:#6c3d55"><a href="#122734" label="[12:27:34]">&lt;AwesomeAdam54321&gt;</a></span><span class="message">Why would static linking be better than dynamic linking for the bootstrap?</span></div><div class="line" id="123129"><span class="nick" style="color:#234e69"><a href="#123129" label="[12:31:29]">&lt;stikonas&gt;</a></span><span class="message">AwesomeAdam54321: better is probably not the right description, more convenient for some things</span></div><div class="line" id="123213"><span class="nick" style="color:#234e69"><a href="#123213" label="[12:32:13]">&lt;stikonas&gt;</a></span><span class="message">e.g. you can create a self-contained binary package of some application (say bison or bash) that you can reuse anywhere</span></div><div class="line" id="123223"><span class="nick" style="color:#234e69"><a href="#123223" label="[12:32:23]">&lt;stikonas&gt;</a></span><span class="message">with dynamic linking you need to think about dependencies</span></div><div class="line" id="123459"><span class="nick" style="color:#234e69"><a href="#123459" label="[12:34:59]">&lt;stikonas&gt;</a></span><span class="message">well, there is some size overhead but the whole live-bootstrap package repo is only about 137 MiB (not counting linux kernel)</span></div><div class="line" id="123522"><span class="nick" style="color:#234e69"><a href="#123522" label="[12:35:22]">&lt;stikonas&gt;</a></span><span class="message">but kernel is statically linked anyway</span></div><div class="line" id="123901"><span class="nick" style="color:#234e69"><a href="#123901" label="[12:39:01]">&lt;stikonas&gt;</a></span><span class="message">though perhaps at some point we should start thinking about dependencies between packages</span></div><div class="line" id="140249"><span class="nick" style="color:#2e2a4a"><a href="#140249" label="[14:02:49]">&lt;oriansj&gt;</a></span><span class="message">AwesomeAdam54321: well static vs dynamic linking; is just an engineering tradeoff between trying to avoid dependency hell and not wanting to do a recompile everything everytime a library is updated.</span></div><div class="line" id="140450"><span class="nick" style="color:#2e2a4a"><a href="#140450" label="[14:04:50]">&lt;oriansj&gt;</a></span><span class="message">although functional package managers (like nix and guix) tend to make the second point invalid and static linking just becomes a better idea.</span></div><div class="line" id="163358"><span class="nick" style="color:#234e69"><a href="#163358" label="[16:33:58]">&lt;stikonas&gt;</a></span><span class="message">well, live-bootstrap does not use that many libraries yet, so we mostly used static linking</span></div><div class="line" id="163420"><span class="nick" style="color:#234e69"><a href="#163420" label="[16:34:20]">&lt;stikonas&gt;</a></span><span class="message">C library is the main thing we use, but then we switch a lot between incompatible libraries</span></div><div class="line" id="163509"><span class="nick" style="color:#234e69"><a href="#163509" label="[16:35:09]">&lt;stikonas&gt;</a></span><span class="message">e.g. once you upgrade from musl 1.1 to musl 1.2 you need to rebuild anyway</span></div><div class="line" id="163521"><span class="nick" style="color:#234e69"><a href="#163521" label="[16:35:21]">&lt;stikonas&gt;</a></span><span class="message">it's not ABI compatible</span></div><div class="line" id="183921"><span class="nick">***</span><span class="message notice">lukedashjr is now known as luke-jr</span></div><div class="line" id="194928"><span class="nick" style="color:#d9d9d9"><a href="#194928" label="[19:49:28]">&lt;ericonr&gt;</a></span><span class="message">stikonas: it very much is ABI compatible</span></div><div class="line" id="195025"><span class="nick" style="color:#d9d9d9"><a href="#195025" label="[19:50:25]">&lt;ericonr&gt;</a></span><span class="message">you do want to recompile the world on 32-bit architectures, though, because otherwise any ABI boundary that uses time_t will be inconsistent across applications built with the older or newer headers</span></div><div class="line" id="195029"><span class="nick" style="color:#234e69"><a href="#195029" label="[19:50:29]">&lt;stikonas&gt;</a></span><span class="message">I thought time was 32-bit in musl 1.1.x but 64-bit</span></div><div class="line" id="195049"><span class="nick" style="color:#234e69"><a href="#195049" label="[19:50:49]">&lt;stikonas&gt;</a></span><span class="message">well, live-bootstrap is 32-bit</span></div><div class="line" id="195126"><span class="nick" style="color:#234e69"><a href="#195126" label="[19:51:26]">&lt;stikonas&gt;</a></span><span class="message">though it is not Y2038 safe anyway</span></div><div class="line" id="195135"><span class="nick" style="color:#d9d9d9"><a href="#195135" label="[19:51:35]">&lt;ericonr&gt;</a></span><span class="message">fair</span></div><div class="line" id="222605"><span class="nick" style="color:#6d2462"><a href="#222605" label="[22:26:05]">&lt;doras&gt;</a></span><span class="message">stikonas: I got it working by backporting a few upstream commits instead. I'll upload a PR soon.</span></div><div class="line" id="222618"><span class="nick" style="color:#234e69"><a href="#222618" label="[22:26:18]">&lt;stikonas&gt;</a></span><span class="message">nice</span></div><div class="line" id="222629"><span class="nick" style="color:#234e69"><a href="#222629" label="[22:26:29]">&lt;stikonas&gt;</a></span><span class="message">and libtool PR is almost done from what I can see</span></div><div class="line" id="223438"><span class="nick" style="color:#6d2462"><a href="#223438" label="[22:34:38]">&lt;doras&gt;</a></span><span class="message">Apparently I got disconnected again and probably a few messages of mine didn't reach IRC.</span></div><div class="line" id="223715"><span class="nick" style="color:#6d2462"><a href="#223715" label="[22:37:15]">&lt;doras&gt;</a></span><span class="message">bash-5.1# g++ test.cc -o test-musl-dynamic... (full message at <a rel="nofollow" href="https://libera.ems.host/_matrix/media/r0/download/libera.chat/4dee6baa750f2ef78efacb4768a879911b33b801">https://libera.ems.host/_matrix/media/r0/download/libera.chat/4dee6baa750f2ef78efacb4768a879911b33b801</a>) </span></div><div class="line" id="223854"><span class="nick" style="color:#6d2462"><a href="#223854" label="[22:38:54]">&lt;doras&gt;</a></span><span class="message">^ dynamic linking with musl in live-bootstrap</span></div><div class="line" id="233302"><span class="nick" style="color:#6d2462"><a href="#233302" label="[23:33:02]">&lt;doras&gt;</a></span><span class="message">Most of Python 3's in-tree modules are building and running successfully on the live-bootstrap side now.</span></div><div class="line" id="233350"><span class="nick" style="color:#6d2462"><a href="#233350" label="[23:33:50]">&lt;doras&gt;</a></span><span class="message">For some reason zlib doesn't, which fails Python's own `install` stage. I'll need to take a look why.</span></div><br /></div></body></html>