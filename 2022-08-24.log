<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-08-24.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="024135"><span class="nick" style="color:#8dd3c7"><a href="#024135" label="[02:41:35]">&lt;oriansj&gt;</a></span><span class="message">theruran: assuming you are talking about: <a rel="nofollow" href="https://www.cl.cam.ac.uk/~mom22/jitawa/">https://www.cl.cam.ac.uk/~mom22/jitawa/</a>  well there is no license information so completely unusable</span></div><div class="line" id="024247"><span class="nick" style="color:#8dd3c7"><a href="#024247" label="[02:42:47]">&lt;oriansj&gt;</a></span><span class="message">all software *MUST* be explicitly licensed under an FSF approved license to be useful in bootstrapping</span></div><div class="line" id="024422"><span class="nick" style="color:#2e2a4a"><a href="#024422" label="[02:44:22]">&lt;theruran&gt;</a></span><span class="message">looks like a MIT or BSD license. source files are here: <a rel="nofollow" href="https://github.com/HOL-Theorem-Prover/HOL/blob/master/COPYRIGHT">https://github.com/HOL-Theorem-Prover/HOL/blob/master/COPYRIGHT</a> </span></div><div class="line" id="024439"><span class="nick" style="color:#2e2a4a"><a href="#024439" label="[02:44:39]">&lt;theruran&gt;</a></span><span class="message">but you're right. the distributed C code is unlicensed, it seems</span></div><div class="line" id="024511"><span class="nick" style="color:#2e2a4a"><a href="#024511" label="[02:45:11]">&lt;theruran&gt;</a></span><span class="message">oh, no, wrapper.c is there too</span></div><div class="line" id="024524"><span class="nick" style="color:#2e2a4a"><a href="#024524" label="[02:45:24]">&lt;theruran&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/HOL-Theorem-Prover/HOL/tree/master/examples/theorem-prover/lisp-runtime">https://github.com/HOL-Theorem-Prover/HOL/tree/master/examples/theorem-prover/lisp-runtime</a> </span></div><div class="line" id="024737"><span class="nick" style="color:#8dd3c7"><a href="#024737" label="[02:47:37]">&lt;oriansj&gt;</a></span><span class="message">it also seems to reference a verified_code.s <a rel="nofollow" href="https://github.com/HOL-Theorem-Prover/HOL/tree/master/examples/theorem-prover/lisp-runtime/bin">https://github.com/HOL-Theorem-Prover/HOL/tree/master/examples/theorem-prover/lisp-runtime/bin</a> </span></div><div class="line" id="024854"><span class="nick" style="color:#8dd3c7"><a href="#024854" label="[02:48:54]">&lt;oriansj&gt;</a></span><span class="message">ok, it seems to be doing: cd ../implementation &amp;&amp; Holmake &amp;&amp; cd ../bin</span></div><div class="line" id="024945"><span class="nick" style="color:#8dd3c7"><a href="#024945" label="[02:49:45]">&lt;oriansj&gt;</a></span><span class="message">so it depends upon a generate file which is just a hex dump of a binary blob built using Holmake</span></div><div class="line" id="025229"><span class="nick" style="color:#8dd3c7"><a href="#025229" label="[02:52:29]">&lt;oriansj&gt;</a></span><span class="message">So if getting a lisp was a problem, it would provide an option *after* we successfully bootstrap the HOL-Theorem-Prover using A Standard ML compiler</span></div><div class="line" id="025408"><span class="nick" style="color:#8dd3c7"><a href="#025408" label="[02:54:08]">&lt;oriansj&gt;</a></span><span class="message">The proof of correctness is neat</span></div><div class="line" id="025849"><span class="nick" style="color:#6b8072"><a href="#025849" label="[02:58:49]">&lt;stikonas&gt;</a></span><span class="message">sometimes with those no-license projects I had success writing an author</span></div><div class="line" id="025943"><span class="nick" style="color:#6b8072"><a href="#025943" label="[02:59:43]">&lt;stikonas&gt;</a></span><span class="message">anyway, bootstrap and proof of correctness are somewhat orthogonal</span></div><div class="line" id="030022"><span class="nick" style="color:#6b8072"><a href="#030022" label="[03:00:22]">&lt;stikonas&gt;</a></span><span class="message">you have to start with non checked theorem-proven code</span></div><div class="line" id="030027"><span class="nick" style="color:#6b8072"><a href="#030027" label="[03:00:27]">&lt;stikonas&gt;</a></span><span class="message">build theorem prover</span></div><div class="line" id="030032"><span class="nick" style="color:#6b8072"><a href="#030032" label="[03:00:32]">&lt;stikonas&gt;</a></span><span class="message">and only then you can prove things with it</span></div><div class="line" id="030041"><span class="nick" style="color:#6b8072"><a href="#030041" label="[03:00:41]">&lt;stikonas&gt;</a></span><span class="message">and NOT theorem prover itself</span></div><div class="line" id="030043"><span class="nick" style="color:#80b1d3"><a href="#030043" label="[03:00:43]">&lt;muurkha&gt;</a></span><span class="message">proofs of correctness could be very useful for bootstrapping</span></div><div class="line" id="030109"><span class="nick" style="color:#80b1d3"><a href="#030109" label="[03:01:09]">&lt;muurkha&gt;</a></span><span class="message">the metamath zero approach takes your theorem prover out of the trusted computing base</span></div><div class="line" id="030110"><span class="nick" style="color:#6b8072"><a href="#030110" label="[03:01:10]">&lt;stikonas&gt;</a></span><span class="message">yes, but none of the theorem provers can prove their own correctness</span></div><div class="line" id="030122"><span class="nick" style="color:#80b1d3"><a href="#030122" label="[03:01:22]">&lt;muurkha&gt;</a></span><span class="message">that is, the theorem prover doesn't need to be correct</span></div><div class="line" id="030133"><span class="nick" style="color:#80b1d3"><a href="#030133" label="[03:01:33]">&lt;muurkha&gt;</a></span><span class="message">because what it does is that it emits a proof witness</span></div><div class="line" id="030143"><span class="nick" style="color:#6b8072"><a href="#030143" label="[03:01:43]">&lt;stikonas&gt;</a></span><span class="message">well, that is true</span></div><div class="line" id="030146"><span class="nick" style="color:#80b1d3"><a href="#030146" label="[03:01:46]">&lt;muurkha&gt;</a></span><span class="message">the proof witness checker does need to be correct</span></div><div class="line" id="030213"><span class="nick" style="color:#6b8072"><a href="#030213" label="[03:02:13]">&lt;stikonas&gt;</a></span><span class="message">anyway, signing off for the night</span></div><div class="line" id="030215"><span class="nick" style="color:#80b1d3"><a href="#030215" label="[03:02:15]">&lt;muurkha&gt;</a></span><span class="message">but there are something like two dozen proof witness checkers for metamath zero written in different languages</span></div><div class="line" id="030225"><span class="nick" style="color:#80b1d3"><a href="#030225" label="[03:02:25]">&lt;muurkha&gt;</a></span><span class="message">and some of them are very small and simple</span></div><div class="line" id="030332"><span class="nick" style="color:#80b1d3"><a href="#030332" label="[03:03:32]">&lt;muurkha&gt;</a></span><span class="message">(also the underlying logical theory needs to be consistent, so that you can't &quot;prove&quot; things that are false)</span></div><div class="line" id="032347"><span class="nick" style="color:#8dd3c7"><a href="#032347" label="[03:23:47]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well I would certainly love to see more proofs of correctness in general as we are long past the era where such omissions should be thought of as either strange or of a very specialized reason.</span></div><div class="line" id="032415"><span class="nick" style="color:#2e2a4a"><a href="#032415" label="[03:24:15]">&lt;theruran&gt;</a></span><span class="message">Milawa is a ACL2-like theorem prover the proves itself minus the ~2000 lines for 'socially verified' code</span></div><div class="line" id="032416"><span class="nick" style="color:#80b1d3"><a href="#032416" label="[03:24:16]">&lt;muurkha&gt;</a></span><span class="message">I wish that were true!</span></div><div class="line" id="032505"><span class="nick" style="color:#2e2a4a"><a href="#032505" label="[03:25:05]">&lt;theruran&gt;</a></span><span class="message">I was thinking the Jitawa verified_code.s could be translated by hand to M1 assembly</span></div><div class="line" id="032528"><span class="nick" style="color:#2e2a4a"><a href="#032528" label="[03:25:28]">&lt;theruran&gt;</a></span><span class="message">but anyway, it doesn't have setq so I doubt its practical usefulness here.</span></div><div class="line" id="032601"><span class="nick" style="color:#2e2a4a"><a href="#032601" label="[03:26:01]">&lt;theruran&gt;</a></span><span class="message">Milawa self-verification takes over 8 GB of memory</span></div><div class="line" id="032700"><span class="nick" style="color:#6d2462"><a href="#032700" label="[03:27:00]">&lt;stikonas[m]&gt;</a></span><span class="message">theruran: how does that work given GÃ¶del's incompleteness theorem?</span></div><div class="line" id="032747"><span class="nick" style="color:#80b1d3"><a href="#032747" label="[03:27:47]">&lt;muurkha&gt;</a></span><span class="message">GIT shows that there are some theorems, and thus some programs that can't be proven correct, in any given consistent formal system</span></div><div class="line" id="032801"><span class="nick" style="color:#80b1d3"><a href="#032801" label="[03:28:01]">&lt;muurkha&gt;</a></span><span class="message">it doesn't imply that no theorems can be proven or that no programs can be proven correct</span></div><div class="line" id="032838"><span class="nick" style="color:#2e2a4a"><a href="#032838" label="[03:28:38]">&lt;theruran&gt;</a></span><span class="message">stikonas[m]: literally, the ~2000 line of socially-verified code part</span></div><div class="line" id="032904"><span class="nick" style="color:#6d2462"><a href="#032904" label="[03:29:04]">&lt;stikonas[m]&gt;</a></span><span class="message">But git 2 says no system can prove its own consistency</span></div><div class="line" id="032920"><span class="nick" style="color:#2e2a4a"><a href="#032920" label="[03:29:20]">&lt;theruran&gt;</a></span><span class="message">'completely' right?</span></div><div class="line" id="032937"><span class="nick" style="color:#2e2a4a"><a href="#032937" label="[03:29:37]">&lt;theruran&gt;</a></span><span class="message">you may have to read the thesis to dispel your doubts</span></div><div class="line" id="033258"><span class="nick" style="color:#6d2462"><a href="#033258" label="[03:32:58]">&lt;stikonas[m]&gt;</a></span><span class="message">In any case isn't self verification same as self compilation? Compiler binary might be backdoored and emit malware even if source is good</span></div><div class="line" id="033315"><span class="nick" style="color:#6d2462"><a href="#033315" label="[03:33:15]">&lt;stikonas[m]&gt;</a></span><span class="message">Doesn't the same apply to theorem provers?</span></div><div class="line" id="033347"><span class="nick" style="color:#6d2462"><a href="#033347" label="[03:33:47]">&lt;stikonas[m]&gt;</a></span><span class="message">Maybe I'm wrong since I'm not expert on theorem provers...</span></div><div class="line" id="033353"><span class="nick" style="color:#8dd3c7"><a href="#033353" label="[03:33:53]">&lt;oriansj&gt;</a></span><span class="message">theruran: well converting the verified_code.s into M1 would probably result in a 10Kline project which puts it in about double the size of cc_* so logically about 4x harder to audit</span></div><div class="line" id="033355"><span class="nick" style="color:#2e2a4a"><a href="#033355" label="[03:33:55]">&lt;theruran&gt;</a></span><span class="message">hmm, well it produces verification conditions in over 8 stages, with lower-levels verifying the level above each</span></div><div class="line" id="033429"><span class="nick" style="color:#2e2a4a"><a href="#033429" label="[03:34:29]">&lt;theruran&gt;</a></span><span class="message">oriansj: but it's just bytes? like hex1</span></div><div class="line" id="033504"><span class="nick" style="color:#2e2a4a"><a href="#033504" label="[03:35:04]">&lt;theruran&gt;</a></span><span class="message">~8000 lines</span></div><div class="line" id="033505"><span class="nick" style="color:#8dd3c7"><a href="#033505" label="[03:35:05]">&lt;oriansj&gt;</a></span><span class="message">theruran: well proper M1 wouldn't be just bytes, it would be Assembly instructions and comments</span></div><div class="line" id="033515"><span class="nick" style="color:#2e2a4a"><a href="#033515" label="[03:35:15]">&lt;theruran&gt;</a></span><span class="message">I know that</span></div><div class="line" id="033532"><span class="nick" style="color:#2e2a4a"><a href="#033532" label="[03:35:32]">&lt;theruran&gt;</a></span><span class="message">translate to x86_64 instructions, then convert to M1</span></div><div class="line" id="033546"><span class="nick" style="color:#8dd3c7"><a href="#033546" label="[03:35:46]">&lt;oriansj&gt;</a></span><span class="message">and assuming the current code is only 1 instruction per line; just basic whitespacing for comments would result in an additional 2K lines</span></div><div class="line" id="033606"><span class="nick" style="color:#2e2a4a"><a href="#033606" label="[03:36:06]">&lt;theruran&gt;</a></span><span class="message">OK - I didn't realize that's much bigger than cc_*</span></div><div class="line" id="033653"><span class="nick" style="color:#8dd3c7"><a href="#033653" label="[03:36:53]">&lt;oriansj&gt;</a></span><span class="message">yeah: 5408  19234 210936 cc_amd64.M1</span></div><div class="line" id="033727"><span class="nick" style="color:#2e2a4a"><a href="#033727" label="[03:37:27]">&lt;theruran&gt;</a></span><span class="message">what are the column names here</span></div><div class="line" id="033751"><span class="nick" style="color:#8dd3c7"><a href="#033751" label="[03:37:51]">&lt;oriansj&gt;</a></span><span class="message">lines words characters</span></div><div class="line" id="033757"><span class="nick" style="color:#8dd3c7"><a href="#033757" label="[03:37:57]">&lt;oriansj&gt;</a></span><span class="message">as standard for wc</span></div><div class="line" id="033800"><span class="nick" style="color:#8dd3c7"><a href="#033800" label="[03:38:00]">&lt;oriansj&gt;</a></span><span class="message">8238  43581 261524 verified_code.s</span></div><div class="line" id="033811"><span class="nick" style="color:#2e2a4a"><a href="#033811" label="[03:38:11]">&lt;theruran&gt;</a></span><span class="message">I see</span></div><div class="line" id="033817"><span class="nick" style="color:#2e2a4a"><a href="#033817" label="[03:38:17]">&lt;theruran&gt;</a></span><span class="message">I always just wc -l</span></div><div class="line" id="033922"><span class="nick" style="color:#80b1d3"><a href="#033922" label="[03:39:22]">&lt;muurkha&gt;</a></span><span class="message">self-verification is not the same as self-compilation because the theorem prover can't emit malware</span></div><div class="line" id="033939"><span class="nick" style="color:#8dd3c7"><a href="#033939" label="[03:39:39]">&lt;oriansj&gt;</a></span><span class="message">so, yeah just basic comments would easily get verified_code.s to 10K lines and if there is more instructions per line, it could easily go much higher.</span></div><div class="line" id="034027"><span class="nick" style="color:#80b1d3"><a href="#034027" label="[03:40:27]">&lt;muurkha&gt;</a></span><span class="message">I mean, it can claim that a false proof of correctness is true, or vice versa</span></div><div class="line" id="034028"><span class="nick" style="color:#8dd3c7"><a href="#034028" label="[03:40:28]">&lt;oriansj&gt;</a></span><span class="message">muurkha: assuming the output is only verified or not verified</span></div><div class="line" id="034036"><span class="nick" style="color:#80b1d3"><a href="#034036" label="[03:40:36]">&lt;muurkha&gt;</a></span><span class="message">but it can't actually change the software</span></div><div class="line" id="034106"><span class="nick" style="color:#80b1d3"><a href="#034106" label="[03:41:06]">&lt;muurkha&gt;</a></span><span class="message">and the metamath zero approach means the prover itself can't even claim that a false proof of correctness is true</span></div><div class="line" id="034145"><span class="nick" style="color:#80b1d3"><a href="#034145" label="[03:41:45]">&lt;muurkha&gt;</a></span><span class="message">because the metamath-zero verifier will examine the proof witness and tell you whether it's true or not.  you'd have to backdoor the verifier, not the prover</span></div><div class="line" id="034154"><span class="nick" style="color:#80b1d3"><a href="#034154" label="[03:41:54]">&lt;muurkha&gt;</a></span><span class="message">moreover, you'd have to backdoor *every* everifier</span></div><div class="line" id="034156"><span class="nick" style="color:#80b1d3"><a href="#034156" label="[03:41:56]">&lt;muurkha&gt;</a></span><span class="message">*verifier</span></div><div class="line" id="034314"><span class="nick" style="color:#8dd3c7"><a href="#034314" label="[03:43:14]">&lt;oriansj&gt;</a></span><span class="message">in exactly the same way</span></div><div class="line" id="034410"><span class="nick" style="color:#80b1d3"><a href="#034410" label="[03:44:10]">&lt;muurkha&gt;</a></span><span class="message">not necessarily exactly the same way; maybe you could backdoor some of them to just always claim that any putative proof witness is valid</span></div><div class="line" id="034439"><span class="nick" style="color:#80b1d3"><a href="#034439" label="[03:44:39]">&lt;muurkha&gt;</a></span><span class="message">and hope nobody notices</span></div><div class="line" id="034441"><span class="nick" style="color:#6d2462"><a href="#034441" label="[03:44:41]">&lt;stikonas[m]&gt;</a></span><span class="message">Yes but same is true for compilers, you have to backdoor every compiler</span></div><div class="line" id="034508"><span class="nick" style="color:#6d2462"><a href="#034508" label="[03:45:08]">&lt;stikonas[m]&gt;</a></span><span class="message">So for verifiers it makes sense that you need to backdoor all of them</span></div><div class="line" id="034517"><span class="nick" style="color:#80b1d3"><a href="#034517" label="[03:45:17]">&lt;muurkha&gt;</a></span><span class="message">potentially, yes, but different compilers don't produce the same output</span></div><div class="line" id="034528"><span class="nick" style="color:#80b1d3"><a href="#034528" label="[03:45:28]">&lt;muurkha&gt;</a></span><span class="message">different metamath zero verifiers do, unless one of them is broken</span></div><div class="line" id="034550"><span class="nick" style="color:#80b1d3"><a href="#034550" label="[03:45:50]">&lt;muurkha&gt;</a></span><span class="message">as I understand it</span></div><div class="line" id="034602"><span class="nick" style="color:#6d2462"><a href="#034602" label="[03:46:02]">&lt;stikonas[m]&gt;</a></span><span class="message">OK, so maybe easier to spot if something tries to give you fake verifier</span></div><div class="line" id="034641"><span class="nick" style="color:#80b1d3"><a href="#034641" label="[03:46:41]">&lt;muurkha&gt;</a></span><span class="message">hopefully!</span></div><div class="line" id="034647"><span class="nick" style="color:#80b1d3"><a href="#034647" label="[03:46:47]">&lt;muurkha&gt;</a></span><span class="message">also the verifier is much, much simpler than a compiler</span></div><div class="line" id="034709"><span class="nick" style="color:#8dd3c7"><a href="#034709" label="[03:47:09]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I think we just proved that differently</span></div><div class="line" id="034713"><span class="nick" style="color:#6d2462"><a href="#034713" label="[03:47:13]">&lt;stikonas[m]&gt;</a></span><span class="message">Yeah, so potentially can inspect it by hand</span></div><div class="line" id="034734"><span class="nick" style="color:#6d2462"><a href="#034734" label="[03:47:34]">&lt;stikonas[m]&gt;</a></span><span class="message">Well cc_* is tiny</span></div><div class="line" id="034807"><span class="nick" style="color:#8dd3c7"><a href="#034807" label="[03:48:07]">&lt;oriansj&gt;</a></span><span class="message">stikonas[m]: I could probably cut it in half if I was willing to get ugly and strip more features out</span></div><div class="line" id="034817"><span class="nick" style="color:#80b1d3"><a href="#034817" label="[03:48:17]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://us.metamath.org/other.html#verifiers">https://us.metamath.org/other.html#verifiers</a> </span></div><div class="line" id="034836"><span class="nick" style="color:#80b1d3"><a href="#034836" label="[03:48:36]">&lt;muurkha&gt;</a></span><span class="message">I think I was confusing Metamath Zero with Metamath itself</span></div><div class="line" id="034944"><span class="nick" style="color:#6d2462"><a href="#034944" label="[03:49:44]">&lt;stikonas[m]&gt;</a></span><span class="message">Probably not worth cutting it, that would make m2-planet harder to work with</span></div><div class="line" id="034947"><span class="nick" style="color:#8dd3c7"><a href="#034947" label="[03:49:47]">&lt;oriansj&gt;</a></span><span class="message">muurkha: cc_amd64 is just 16,140bytes of binary</span></div><div class="line" id="035000"><span class="nick" style="color:#80b1d3"><a href="#035000" label="[03:50:00]">&lt;muurkha&gt;</a></span><span class="message">oriansj: but how many lines of source code?</span></div><div class="line" id="035024"><span class="nick" style="color:#8dd3c7"><a href="#035024" label="[03:50:24]">&lt;oriansj&gt;</a></span><span class="message">muurkha: currently: 5,408</span></div><div class="line" id="035036"><span class="nick" style="color:#80b1d3"><a href="#035036" label="[03:50:36]">&lt;muurkha&gt;</a></span><span class="message">verify.lua is almost the same number of bytes but it's only 380 lines of Lua</span></div><div class="line" id="035106"><span class="nick" style="color:#6d2462"><a href="#035106" label="[03:51:06]">&lt;stikonas[m]&gt;</a></span><span class="message">Plus lua interpreter which is huge</span></div><div class="line" id="035133"><span class="nick" style="color:#8dd3c7"><a href="#035133" label="[03:51:33]">&lt;oriansj&gt;</a></span><span class="message">muurkha: and cc_* always runs as close to the metal as possible</span></div><div class="line" id="035206"><span class="nick" style="color:#8dd3c7"><a href="#035206" label="[03:52:06]">&lt;oriansj&gt;</a></span><span class="message">only the syscalls/interrupts depend upon on external bits</span></div><div class="line" id="035257"><span class="nick" style="color:#6d2462"><a href="#035257" label="[03:52:57]">&lt;stikonas[m]&gt;</a></span><span class="message">And it's only read byte, write byte and memory allocation</span></div><div class="line" id="035303"><span class="nick" style="color:#8dd3c7"><a href="#035303" label="[03:53:03]">&lt;oriansj&gt;</a></span><span class="message">and when we go bare metal, it'll be byte for byte the same for all of the logic but the read_byte, malloc and write_byte functions</span></div><div class="line" id="035414"><span class="nick" style="color:#6d2462"><a href="#035414" label="[03:54:14]">&lt;stikonas[m]&gt;</a></span><span class="message">Well open file/tape too</span></div><div class="line" id="035447"><span class="nick" style="color:#8dd3c7"><a href="#035447" label="[03:54:47]">&lt;oriansj&gt;</a></span><span class="message">close and lseek if we are being pedantic</span></div><div class="line" id="035518"><span class="nick" style="color:#6d2462"><a href="#035518" label="[03:55:18]">&lt;stikonas[m]&gt;</a></span><span class="message">Does cc_* uses lseek?</span></div><div class="line" id="035533"><span class="nick" style="color:#6d2462"><a href="#035533" label="[03:55:33]">&lt;stikonas[m]&gt;</a></span><span class="message">I throught it just reads it into memory</span></div><div class="line" id="035546"><span class="nick" style="color:#6d2462"><a href="#035546" label="[03:55:46]">&lt;stikonas[m]&gt;</a></span><span class="message">Only hex1/2 lseeks</span></div><div class="line" id="035553"><span class="nick" style="color:#6d2462"><a href="#035553" label="[03:55:53]">&lt;stikonas[m]&gt;</a></span><span class="message">Or am I misremembering</span></div><div class="line" id="035617"><span class="nick" style="color:#6d2462"><a href="#035617" label="[03:56:17]">&lt;stikonas[m]&gt;</a></span><span class="message">Anyway, it's late, going to sleep...</span></div><div class="line" id="035723"><span class="nick" style="color:#8dd3c7"><a href="#035723" label="[03:57:23]">&lt;oriansj&gt;</a></span><span class="message">stikonas[m]: you are right on the current version of cc_*, it doesn't lseek. A prototype used lseek to figure out the size of the files for reading, create a single buffer and dump the files into memory to improve performance</span></div><div class="line" id="035824"><span class="nick" style="color:#80b1d3"><a href="#035824" label="[03:58:24]">&lt;muurkha&gt;</a></span><span class="message">goodnight stikonas[m]!</span></div><div class="line" id="035900"><span class="nick" style="color:#80b1d3"><a href="#035900" label="[03:59:00]">&lt;muurkha&gt;</a></span><span class="message">it's true that the Lua interpreter could conceivably have a bug or backdoor that causes verify.lua to execute incorrectly</span></div><div class="line" id="035908"><span class="nick" style="color:#8dd3c7"><a href="#035908" label="[03:59:08]">&lt;oriansj&gt;</a></span><span class="message">added about 30 instructions of complexity but cut runtime in half when double emulated</span></div><div class="line" id="035934"><span class="nick" style="color:#80b1d3"><a href="#035934" label="[03:59:34]">&lt;muurkha&gt;</a></span><span class="message">for Metamath Zero they are working on a proof of the Metamath Zero binary: <a rel="nofollow" href="https://arxiv.org/abs/1910.10703">https://arxiv.org/abs/1910.10703</a> </span></div><div class="line" id="040028"><span class="nick" style="color:#80b1d3"><a href="#040028" label="[04:00:28]">&lt;muurkha&gt;</a></span><span class="message">this wouldn't prove the Metamath system consistent; it would only prove that the executable implements the system as specified</span></div><div class="line" id="040129"><span class="nick" style="color:#80b1d3"><a href="#040129" label="[04:01:29]">&lt;muurkha&gt;</a></span><span class="message">moreover, it would still be possible that if all the verifiers capable of checking the proof were flawed in a particular way, that could allow an incorrect proof to slip through</span></div><div class="line" id="040211"><span class="nick" style="color:#80b1d3"><a href="#040211" label="[04:02:11]">&lt;muurkha&gt;</a></span><span class="message">but what it would show is that *if at least one* verifier correctly implements the Metamath semantics, then Metamath Zero correctly implements them as well</span></div><div class="line" id="040303"><span class="nick" style="color:#80b1d3"><a href="#040303" label="[04:03:03]">&lt;muurkha&gt;</a></span><span class="message">as I understand it</span></div><div class="line" id="040429"><span class="nick" style="color:#8dd3c7"><a href="#040429" label="[04:04:29]">&lt;oriansj&gt;</a></span><span class="message">muurkha: except for the common dev pattern of assuming you wrote a bug rather than all other &quot;verified&quot; systems are bugged and wrong.</span></div><div class="line" id="040707"><span class="nick" style="color:#80b1d3"><a href="#040707" label="[04:07:07]">&lt;muurkha&gt;</a></span><span class="message">I think this case is probably immune to that problem</span></div><div class="line" id="041050"><span class="nick" style="color:#8dd3c7"><a href="#041050" label="[04:10:50]">&lt;oriansj&gt;</a></span><span class="message">muurkha: that is probably one of the most dangerous phrases in our industry.</span></div><div class="line" id="041906"><span class="nick" style="color:#80b1d3"><a href="#041906" label="[04:19:06]">&lt;muurkha&gt;</a></span><span class="message">yeah, but it's not in our industry.  it's theorem proving</span></div><div class="line" id="041945"><span class="nick" style="color:#80b1d3"><a href="#041945" label="[04:19:45]">&lt;muurkha&gt;</a></span><span class="message">if your theorem prover accepts incorrect proofs it's wrong, there's no gray area</span></div><div class="line" id="042029"><span class="nick" style="color:#80b1d3"><a href="#042029" label="[04:20:29]">&lt;muurkha&gt;</a></span><span class="message">same if it rejects correct ones.  though maybe &quot;out of memory&quot; is a valid response in any case</span></div><div class="line" id="043418"><span class="nick" style="color:#2e2a4a"><a href="#043418" label="[04:34:18]">&lt;theruran&gt;</a></span><span class="message">part of the motivation for Milawa theorem prover is that ACL2 has had a number of defects (bugs) in its history that could have affected the prover system</span></div><div class="line" id="043524"><span class="nick" style="color:#2e2a4a"><a href="#043524" label="[04:35:24]">&lt;theruran&gt;</a></span><span class="message">as I see it, systems like this and Z3 are only socially verified in a similar way to how Erlang systems are correct-ish until a defect is found in production</span></div><div class="line" id="043525"><span class="nick" style="color:#8dd3c7"><a href="#043525" label="[04:35:25]">&lt;oriansj&gt;</a></span><span class="message">well, look if a human verified one of them correct that would be one thing but has that actually been done and did they publish that work?</span></div><div class="line" id="043554"><span class="nick" style="color:#2e2a4a"><a href="#043554" label="[04:35:54]">&lt;theruran&gt;</a></span><span class="message">Milawa is verified correct down to the x86 ISA semantics</span></div><div class="line" id="043649"><span class="nick" style="color:#2e2a4a"><a href="#043649" label="[04:36:49]">&lt;theruran&gt;</a></span><span class="message">I'm not aware of ACL2 self-verification projects. there is Meta-Coq though but I doubt they have completely verified Coq</span></div><div class="line" id="043825"><span class="nick" style="color:#2e2a4a"><a href="#043825" label="[04:38:25]">&lt;theruran&gt;</a></span><span class="message">FStar's type system is verified with assistance with Coq. they wrote a paper about it</span></div><div class="line" id="043830"><span class="nick" style="color:#2e2a4a"><a href="#043830" label="[04:38:30]">&lt;theruran&gt;</a></span><span class="message">nice lil diagram to go with</span></div><div class="line" id="043918"><span class="nick" style="color:#2e2a4a"><a href="#043918" label="[04:39:18]">&lt;theruran&gt;</a></span><span class="message">but you can see it is not at all straightforward because the systems can't verify themselves</span></div><div class="line" id="043944"><span class="nick" style="color:#8dd3c7"><a href="#043944" label="[04:39:44]">&lt;oriansj&gt;</a></span><span class="message">and errata in *ALL* architectures bring problems</span></div><div class="line" id="044011"><span class="nick" style="color:#2e2a4a"><a href="#044011" label="[04:40:11]">&lt;theruran&gt;</a></span><span class="message">yes. Jitawa targeting a simpler ISA would've been more interesting</span></div><div class="line" id="044154"><span class="nick" style="color:#2e2a4a"><a href="#044154" label="[04:41:54]">&lt;theruran&gt;</a></span><span class="message">if Jitawa could be run on a x86 softcore, then maybe we could have more confidence. but like, I couldn't even get it to run properly on my two computers. this computer gives no output when executing (consp)</span></div><div class="line" id="044238"><span class="nick" style="color:#8dd3c7"><a href="#044238" label="[04:42:38]">&lt;oriansj&gt;</a></span><span class="message">well binary dumps can embed bad assumptions, even when formally verified.</span></div><div class="line" id="044251"><span class="nick" style="color:#2e2a4a"><a href="#044251" label="[04:42:51]">&lt;theruran&gt;</a></span><span class="message">sure</span></div><div class="line" id="044306"><span class="nick" style="color:#2e2a4a"><a href="#044306" label="[04:43:06]">&lt;theruran&gt;</a></span><span class="message">another way to cross-verify is to run it through ACL2's x86 simulator</span></div><div class="line" id="044602"><span class="nick" style="color:#8dd3c7"><a href="#044602" label="[04:46:02]">&lt;oriansj&gt;</a></span><span class="message">makes me wonder why your computers couldn't run it properly.</span></div><div class="line" id="044952"><span class="nick" style="color:#2e2a4a"><a href="#044952" label="[04:49:52]">&lt;theruran&gt;</a></span><span class="message">one is Void Linux-musl. and it compiles with gcc but running any expression fails on memory address violation</span></div><div class="line" id="045027"><span class="nick" style="color:#2e2a4a"><a href="#045027" label="[04:50:27]">&lt;theruran&gt;</a></span><span class="message">this one is Hardened Gentoo-glibc with some hardening on the kernel as well. dunno why consp doesn't work since everything else seems to work</span></div><div class="line" id="045046"><span class="nick" style="color:#2e2a4a"><a href="#045046" label="[04:50:46]">&lt;theruran&gt;</a></span><span class="message">oh and I have also compiled it with musl here, and with CompCert</span></div><div class="line" id="045303"><span class="nick" style="color:#8dd3c7"><a href="#045303" label="[04:53:03]">&lt;oriansj&gt;</a></span><span class="message">aslr (address space layout randomization) enabled?</span></div><div class="line" id="045338"><span class="nick" style="color:#2e2a4a"><a href="#045338" label="[04:53:38]">&lt;theruran&gt;</a></span><span class="message">hol up.. i guess it is working but since newlines are not printed I don't see the output *sometimes*</span></div><div class="line" id="045341"><span class="nick" style="color:#2e2a4a"><a href="#045341" label="[04:53:41]">&lt;theruran&gt;</a></span><span class="message">rlwrap helps</span></div><div class="line" id="045359"><span class="nick" style="color:#2e2a4a"><a href="#045359" label="[04:53:59]">&lt;theruran&gt;</a></span><span class="message">ASLR enabled on both systems (I think) it is on this one anyway</span></div><div class="line" id="045521"><span class="nick" style="color:#2e2a4a"><a href="#045521" label="[04:55:21]">&lt;theruran&gt;</a></span><span class="message">but yeah, linking in libc sucks anyway, imo. wrapper.c just allocates some memory and runs the JIT</span></div><div class="line" id="045605"><span class="nick" style="color:#2e2a4a"><a href="#045605" label="[04:56:05]">&lt;theruran&gt;</a></span><span class="message">the stripped static-linked binary is 64K</span></div><div class="line" id="045610"><span class="nick" style="color:#8dd3c7"><a href="#045610" label="[04:56:10]">&lt;oriansj&gt;</a></span><span class="message">and probably should do a putc('\n'); to ensure you see output</span></div><div class="line" id="045755"><span class="nick" style="color:#2e2a4a"><a href="#045755" label="[04:57:55]">&lt;theruran&gt;</a></span><span class="message">Jitawa does not even have a concept of strings, as far as I can tell. (print &quot;a&quot;) errors out</span></div><div class="line" id="045804"><span class="nick" style="color:#2e2a4a"><a href="#045804" label="[04:58:04]">&lt;theruran&gt;</a></span><span class="message">no need, for Milawa!</span></div><div class="line" id="045918"><span class="nick" style="color:#2e2a4a"><a href="#045918" label="[04:59:18]">&lt;theruran&gt;</a></span><span class="message">muurkha: I am glad to see there is a Metamath proof checker done in Ada!</span></div><div class="line" id="045932"><span class="nick" style="color:#8dd3c7"><a href="#045932" label="[04:59:32]">&lt;oriansj&gt;</a></span><span class="message">theruran: I was referring to the output not being seen &quot;sometimes&quot; which would indicate your libc buffering output for performance reasons failing to dump the buffer prior to close</span></div><div class="line" id="050057"><span class="nick" style="color:#2e2a4a"><a href="#050057" label="[05:00:57]">&lt;theruran&gt;</a></span><span class="message">oh buffering makes sense</span></div><div class="line" id="050136"><span class="nick" style="color:#2e2a4a"><a href="#050136" label="[05:01:36]">&lt;theruran&gt;</a></span><span class="message">it's not really designed for interactive REPL. it was designed for reading Milawa verification conditions :P</span></div><div class="line" id="050655"><span class="nick" style="color:#8dd3c7"><a href="#050655" label="[05:06:55]">&lt;oriansj&gt;</a></span><span class="message">well I'm one which believes in human centered software design. If the use of the program in the hands of a naive user results in harm or no useful information to enable proper use, it failed to do its job correctly.</span></div><div class="line" id="051048"><span class="nick" style="color:#8dd3c7"><a href="#051048" label="[05:10:48]">&lt;oriansj&gt;</a></span><span class="message">heck even a simple: DONE\n after processing would have made the user experience much better.</span></div><div class="line" id="051330"><span class="nick" style="color:#8dd3c7"><a href="#051330" label="[05:13:30]">&lt;oriansj&gt;</a></span><span class="message">and I'm not even asking for the technical user experience improvements like fuzzing the input processing to ensure the user can't hit a segfault</span></div><div class="line" id="051442"><span class="nick" style="color:#8dd3c7"><a href="#051442" label="[05:14:42]">&lt;oriansj&gt;</a></span><span class="message">because if I can segfault your verifier, I can compromise its output too</span></div><div class="line" id="052935"><span class="nick" style="color:#8dd3c7"><a href="#052935" label="[05:29:35]">&lt;oriansj&gt;</a></span><span class="message">I wonder if we could express the need for bootstrappability in terms of Andresson's corollary</span></div><div class="line" id="053527"><span class="nick" style="color:#2e2a4a"><a href="#053527" label="[05:35:27]">&lt;theruran&gt;</a></span><span class="message">what is Adresson's corollary?</span></div><div class="line" id="053533"><span class="nick" style="color:#2e2a4a"><a href="#053533" label="[05:35:33]">&lt;theruran&gt;</a></span><span class="message">sorry gotta go to sleep. night!</span></div><div class="line" id="065203"><span class="nick" style="color:#80b1d3"><a href="#065203" label="[06:52:03]">&lt;muurkha&gt;</a></span><span class="message">there's a good list of self-verification papers in the bibliography of the arxiv MM0 paper I linked above</span></div><div class="line" id="065228"><span class="nick" style="color:#80b1d3"><a href="#065228" label="[06:52:28]">&lt;muurkha&gt;</a></span><span class="message">they think that they can do the MM0 proofs with the semantics of only about 25 instructions</span></div><div class="line" id="065314"><span class="nick" style="color:#80b1d3"><a href="#065314" label="[06:53:14]">&lt;muurkha&gt;</a></span><span class="message">oriansj: there are lots of programs that are not useful to naive users, but some of them are worthwhile anyway</span></div><div class="line" id="065341"><span class="nick" style="color:#80b1d3"><a href="#065341" label="[06:53:41]">&lt;muurkha&gt;</a></span><span class="message">you probably aren't going to be able to learn C from GCC, for example</span></div><div class="line" id="065400"><span class="nick" style="color:#80b1d3"><a href="#065400" label="[06:54:00]">&lt;muurkha&gt;</a></span><span class="message">agreed about segfaulting the verifier</span></div><div class="line" id="114526"><span class="nick" style="color:#8dd3c7"><a href="#114526" label="[11:45:26]">&lt;oriansj&gt;</a></span><span class="message">theruran: <a rel="nofollow" href="https://www.youtube.com/watch?v=0wtvQZijPzg">https://www.youtube.com/watch?v=0wtvQZijPzg</a> </span></div><div class="line" id="115137"><span class="nick" style="color:#8dd3c7"><a href="#115137" label="[11:51:37]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I'm surprised they didn't reduce it to: sub eax, ebx; mov eax, [ebx]; mov ebx, eax; mov [ebx], eax; cmp eax, ebx; call eax; ret; pop eax; push ebx; inc eax</span></div><div class="line" id="115423"><span class="nick" style="color:#8dd3c7"><a href="#115423" label="[11:54:23]">&lt;oriansj&gt;</a></span><span class="message">oh and call 5 (as a cheap way to get the pc onto the stack)</span></div><div class="line" id="145245"><span class="nick" style="color:#234e69"><a href="#145245" label="[14:52:45]">&lt;ekaitz&gt;</a></span><span class="message">hi all is anyone here familiarized with tinyCC's internals? I need some help</span></div><div class="line" id="145836"><span class="nick" style="color:#6b8072"><a href="#145836" label="[14:58:36]">&lt;stikonas&gt;</a></span><span class="message">I doubt it...</span></div><div class="line" id="145855"><span class="nick" style="color:#6b8072"><a href="#145855" label="[14:58:55]">&lt;stikonas&gt;</a></span><span class="message">I think janneke was the only one who actually was patching tcc</span></div><div class="line" id="145928"><span class="nick" style="color:#6b8072"><a href="#145928" label="[14:59:28]">&lt;stikonas&gt;</a></span><span class="message">does tcc have mailing list or IRC channel? That might be a better place</span></div><div class="line" id="152239"><span class="nick" style="color:#234e69"><a href="#152239" label="[15:22:39]">&lt;ekaitz&gt;</a></span><span class="message">stikonas: I tried the mailing list with no success</span></div><div class="line" id="152256"><span class="nick" style="color:#234e69"><a href="#152256" label="[15:22:56]">&lt;ekaitz&gt;</a></span><span class="message">also tried janneke :)</span></div><div class="line" id="153138"><span class="nick" style="color:#6b8072"><a href="#153138" label="[15:31:38]">&lt;stikonas&gt;</a></span><span class="message">perhaps the better approach would be too add more features to mescc</span></div><div class="line" id="153151"><span class="nick" style="color:#6b8072"><a href="#153151" label="[15:31:51]">&lt;stikonas&gt;</a></span><span class="message">hmm...</span></div><div class="line" id="153301"><span class="nick" style="color:#6b8072"><a href="#153301" label="[15:33:01]">&lt;stikonas&gt;</a></span><span class="message">but that's longer term project</span></div><div class="line" id="153446"><span class="nick" style="color:#234e69"><a href="#153446" label="[15:34:46]">&lt;ekaitz&gt;</a></span><span class="message">yes... I just want to fix a simple thing but the code is really obscure</span></div><div class="line" id="153621"><span class="nick" style="color:#234e69"><a href="#153621" label="[15:36:21]">&lt;ekaitz&gt;</a></span><span class="message">there was a big change in the past and i'm trying to translate that style back to Mes's tinycc fork and I'm having issues</span></div><div class="line" id="153704"><span class="nick" style="color:#234e69"><a href="#153704" label="[15:37:04]">&lt;ekaitz&gt;</a></span><span class="message">this is my specific question: <a rel="nofollow" href="https://lists.gnu.org/archive/html/tinycc-devel/2022-08/msg00026.html">https://lists.gnu.org/archive/html/tinycc-devel/2022-08/msg00026.html</a> </span></div><div class="line" id="160528"><span class="nick" style="color:#6c3d55"><a href="#160528" label="[16:05:28]">&lt;bauen1&gt;</a></span><span class="message">stikonas[m]: tcc does have a mailing list (somewhere)</span></div><div class="line" id="160608"><span class="nick" style="color:#d9d9d9"><a href="#160608" label="[16:06:08]">&lt;stikonas_&gt;</a></span><span class="message">bauen1: well, that didn't help ekaitz...</span></div><div class="line" id="160612"><span class="nick">***</span><span class="message notice">stikonas_ is now known as stikonas</span></div><div class="line" id="160622"><span class="nick" style="color:#6b8072"><a href="#160622" label="[16:06:22]">&lt;stikonas&gt;</a></span><span class="message">main developer was just asking: why don't you apply the patch to newer tcc</span></div><div class="line" id="160707"><span class="nick" style="color:#6c3d55"><a href="#160707" label="[16:07:07]">&lt;bauen1&gt;</a></span><span class="message">oof, but I also guess thats kind of expected, tinyccs git branch is a wildwest</span></div><div class="line" id="160828"><span class="nick" style="color:#234e69"><a href="#160828" label="[16:08:28]">&lt;ekaitz&gt;</a></span><span class="message">stikonas: yep... i almost answered: because you never wanted to simplify tcc's code so we have to do it ourselves</span></div><div class="line" id="161249"><span class="nick" style="color:#6b8072"><a href="#161249" label="[16:12:49]">&lt;stikonas&gt;</a></span><span class="message">well, but simplifying code is not necesserily the right thing to do</span></div><div class="line" id="161307"><span class="nick" style="color:#6b8072"><a href="#161307" label="[16:13:07]">&lt;stikonas&gt;</a></span><span class="message">it is a valid argument on their side that long term it's better to improve bootstrapping compiler</span></div><div class="line" id="161314"><span class="nick" style="color:#234e69"><a href="#161314" label="[16:13:14]">&lt;ekaitz&gt;</a></span><span class="message">ofc, but the's a reason for us to fork</span></div><div class="line" id="161334"><span class="nick" style="color:#6b8072"><a href="#161334" label="[16:13:34]">&lt;stikonas&gt;</a></span><span class="message">e.g. M2-Planet improved significantly over the last couple of years</span></div><div class="line" id="161402"><span class="nick" style="color:#6b8072"><a href="#161402" label="[16:14:02]">&lt;stikonas&gt;</a></span><span class="message">though we also simplified mes to bridge M2-Planet -&gt; mes gap</span></div><div class="line" id="161410"><span class="nick" style="color:#234e69"><a href="#161410" label="[16:14:10]">&lt;ekaitz&gt;</a></span><span class="message">yup</span></div><div class="line" id="161444"><span class="nick" style="color:#234e69"><a href="#161444" label="[16:14:44]">&lt;ekaitz&gt;</a></span><span class="message">otoh, the code of tcc is very obscure too, which doesn't help at all</span></div><div class="line" id="161452"><span class="nick" style="color:#234e69"><a href="#161452" label="[16:14:52]">&lt;ekaitz&gt;</a></span><span class="message">(maybe it's just me who can't read it??)</span></div><div class="line" id="161659"><span class="nick" style="color:#6b8072"><a href="#161659" label="[16:16:59]">&lt;stikonas&gt;</a></span><span class="message">it does seem to have a lot of one character variables...</span></div><div class="line" id="161721"><span class="nick" style="color:#234e69"><a href="#161721" label="[16:17:21]">&lt;ekaitz&gt;</a></span><span class="message">yes</span></div><div class="line" id="161944"><span class="nick" style="color:#bc80bd"><a href="#161944" label="[16:19:44]">&lt;acrow&gt;</a></span><span class="message">touching down in bootstrappable to lurk after seeing comments by orianjs in #guix that the guile maintainers have walked away from bootstrapability?  Tell me it isn't so.</span></div><div class="line" id="162119"><span class="nick" style="color:#6b8072"><a href="#162119" label="[16:21:19]">&lt;stikonas&gt;</a></span><span class="message">acrow: it depends</span></div><div class="line" id="162139"><span class="nick" style="color:#6b8072"><a href="#162139" label="[16:21:39]">&lt;stikonas&gt;</a></span><span class="message">acrow: guile ships some pre-expanded scheme files</span></div><div class="line" id="162208"><span class="nick" style="color:#6b8072"><a href="#162208" label="[16:22:08]">&lt;stikonas&gt;</a></span><span class="message">somebody here figured it out how to build those from source</span></div><div class="line" id="162215"><span class="nick" style="color:#6b8072"><a href="#162215" label="[16:22:15]">&lt;stikonas&gt;</a></span><span class="message">but I think guile didn't want to incorporate it</span></div><div class="line" id="162237"><span class="nick" style="color:#6b8072"><a href="#162237" label="[16:22:37]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/schierlm/guile-psyntax-bootstrapping">https://github.com/schierlm/guile-psyntax-bootstrapping</a> </span></div><div class="line" id="162312"><span class="nick" style="color:#6b8072"><a href="#162312" label="[16:23:12]">&lt;stikonas&gt;</a></span><span class="message">but this targets specific version of guile</span></div><div class="line" id="162329"><span class="nick" style="color:#6b8072"><a href="#162329" label="[16:23:29]">&lt;stikonas&gt;</a></span><span class="message">possibly can be adapted to the latest guile but doesn't work out of box</span></div><div class="line" id="162748"><span class="nick" style="color:#6b8072"><a href="#162748" label="[16:27:48]">&lt;stikonas&gt;</a></span><span class="message">acrow: this is the file we are talking about <a rel="nofollow" href="https://git.savannah.nongnu.org/cgit/guile.git/tree/module/ice-9/psyntax-pp.scm">https://git.savannah.nongnu.org/cgit/guile.git/tree/module/ice-9/psyntax-pp.scm</a> </span></div><div class="line" id="162930"><span class="nick" style="color:#6b8072"><a href="#162930" label="[16:29:30]">&lt;stikonas&gt;</a></span><span class="message">so it's not like e.g rust that depends on itself more strongly</span></div><div class="line" id="164823"><span class="nick" style="color:#bc80bd"><a href="#164823" label="[16:48:23]">&lt;acrow&gt;</a></span><span class="message">I share your concerns about software integrity (and people too).  I suspect that at least one former guile maintainer also shares these concerns.  I skimmed the objectionable source file but claim no understanding.  I'm just going to lurk and try to absorb the wisdom so I might later have a more informed opinion that I would try to defend.</span></div><div class="line" id="165123"><span class="nick" style="color:#bc80bd"><a href="#165123" label="[16:51:23]">&lt;acrow&gt;</a></span><span class="message">I'll also say that having seen some of the old software that your group has managed to pull into bootstrapability I think you are miracle workers.  I applaud your skills.  \o/</span></div><div class="line" id="165728"><span class="nick" style="color:#6b8072"><a href="#165728" label="[16:57:28]">&lt;stikonas&gt;</a></span><span class="message">yes, I can't really judge that psyntax-pp.scm either since I barely know any guile</span></div><div class="line" id="165735"><span class="nick" style="color:#6b8072"><a href="#165735" label="[16:57:35]">&lt;stikonas&gt;</a></span><span class="message">s/guile/scheme/</span></div><div class="line" id="170107"><span class="nick" style="color:#bc80bd"><a href="#170107" label="[17:01:07]">&lt;acrow&gt;</a></span><span class="message">stikonas: I have not yet seen any computer science asserting that rust must depend on itself in any way.  In fact, IIUC, Turing would have none of it.  If it were not for the existence of the guix recipes I wouldn't trust it.  I'm not investing in them.  There is some destructive hubris there.</span></div><div class="line" id="170138"><span class="nick" style="color:#6b8072"><a href="#170138" label="[17:01:38]">&lt;stikonas&gt;</a></span><span class="message">I don't mean it has to depend, there is mrustc that is written in C and can bootstrap it</span></div><div class="line" id="170155"><span class="nick" style="color:#6b8072"><a href="#170155" label="[17:01:55]">&lt;stikonas&gt;</a></span><span class="message">but that's just one example and we can bootstrap rust</span></div><div class="line" id="170212"><span class="nick" style="color:#6b8072"><a href="#170212" label="[17:02:12]">&lt;stikonas&gt;</a></span><span class="message">some others aren't bootstrappable yet, like ghc</span></div><div class="line" id="170236"><span class="nick" style="color:#6b8072"><a href="#170236" label="[17:02:36]">&lt;stikonas&gt;</a></span><span class="message">of course with enough work one can always bootstrap it</span></div><div class="line" id="170253"><span class="nick" style="color:#6b8072"><a href="#170253" label="[17:02:53]">&lt;stikonas&gt;</a></span><span class="message">in the worse case you can port line by line existing compiler to another language</span></div><div class="line" id="170321"><span class="nick" style="color:#bc80bd"><a href="#170321" label="[17:03:21]">&lt;acrow&gt;</a></span><span class="message">haskell? is not bootstrappable?  I didn't know that.  Scala is my example of bad behavior.</span></div><div class="line" id="170429"><span class="nick" style="color:#6b8072"><a href="#170429" label="[17:04:29]">&lt;stikonas&gt;</a></span><span class="message">scala too</span></div><div class="line" id="170432"><span class="nick" style="color:#6b8072"><a href="#170432" label="[17:04:32]">&lt;stikonas&gt;</a></span><span class="message">but haskell as well</span></div><div class="line" id="170519"><span class="nick" style="color:#6b8072"><a href="#170519" label="[17:05:19]">&lt;stikonas&gt;</a></span><span class="message">there are more examples I think</span></div><div class="line" id="170529"><span class="nick" style="color:#6b8072"><a href="#170529" label="[17:05:29]">&lt;stikonas&gt;</a></span><span class="message">and even more if you don't want to allow pre-generated files</span></div><div class="line" id="170549"><span class="nick" style="color:#6b8072"><a href="#170549" label="[17:05:49]">&lt;stikonas&gt;</a></span><span class="message">e.g. automatic conversions into low-level C or header files</span></div><div class="line" id="170552"><span class="nick" style="color:#bc80bd"><a href="#170552" label="[17:05:52]">&lt;acrow&gt;</a></span><span class="message">Glad to hear the story redeeming rust.  Is the rust team keeping mrustc up to date or is this team doing that?</span></div><div class="line" id="170603"><span class="nick" style="color:#6b8072"><a href="#170603" label="[17:06:03]">&lt;stikonas&gt;</a></span><span class="message">no, that's #mrustc</span></div><div class="line" id="170624"><span class="nick" style="color:#6b8072"><a href="#170624" label="[17:06:24]">&lt;stikonas&gt;</a></span><span class="message">but some people here (includign me) have used mrustc</span></div><div class="line" id="170653"><span class="nick" style="color:#6b8072"><a href="#170653" label="[17:06:53]">&lt;stikonas&gt;</a></span><span class="message">but sometimes even non compilers are in this dependency loop</span></div><div class="line" id="170712"><span class="nick" style="color:#6b8072"><a href="#170712" label="[17:07:12]">&lt;stikonas&gt;</a></span><span class="message">e.g. GNU Autogen uses itself to generate some of it's header files</span></div><div class="line" id="170934"><span class="nick" style="color:#bc80bd"><a href="#170934" label="[17:09:34]">&lt;acrow&gt;</a></span><span class="message">GNU autogen! I thought GNU was more concerned about foundations.</span></div><div class="line" id="171726"><span class="nick" style="color:#6b8072"><a href="#171726" label="[17:17:26]">&lt;stikonas&gt;</a></span><span class="message">yes, and GCC uses GNU autogen to build some of it's files (top-level Makefile.in if I remember correctly)</span></div><div class="line" id="171747"><span class="nick" style="color:#6b8072"><a href="#171747" label="[17:17:47]">&lt;stikonas&gt;</a></span><span class="message">though you could build gcc without using top-level configure</span></div><div class="line" id="174257"><span class="nick" style="color:#bc80bd"><a href="#174257" label="[17:42:57]">&lt;acrow&gt;</a></span><span class="message">IIUC, bootstrappable is all about foundations.  Bootstrappable is fine with any automated build tools provided that the provenance of the build tools is freely available.  Please feel free to take this apart.  I think this in many ways bootstrappability is tied or akin to proper documentation but that may be too glib.  Does that sound right to you?</span></div><div class="line" id="200935"><span class="nick" style="color:#80b1d3"><a href="#200935" label="[20:09:35]">&lt;muurkha&gt;</a></span><span class="message">oriansj: you mean as an instruction set rather than an instruction sequence?</span></div><div class="line" id="232823"><span class="nick" style="color:#8dd3c7"><a href="#232823" label="[23:28:23]">&lt;oriansj&gt;</a></span><span class="message">acrow: I prefer to think of bootstrappable as just the logical conclusion of Free Software principals.</span></div><div class="line" id="232938"><span class="nick" style="color:#8dd3c7"><a href="#232938" label="[23:29:38]">&lt;oriansj&gt;</a></span><span class="message">muurkha: as reducing the number of instruction semantics they would need in their proofs</span></div><br /></div></body></html>