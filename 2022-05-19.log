<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-05-19.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000622"><span class="nick" style="color:#389600"><a href="#000622" label="[00:06:22]">&lt;stikonas&gt;</a></span><span class="message">Hagfish: well, yes, basically you can't strictly prove anything from within, there should be some external check</span></div><div class="line" id="000815"><span class="nick" style="color:#389600"><a href="#000815" label="[00:08:15]">&lt;stikonas&gt;</a></span><span class="message">though of course those extra checks from withing are not useless</span></div><div class="line" id="000834"><span class="nick" style="color:#389600"><a href="#000834" label="[00:08:34]">&lt;stikonas&gt;</a></span><span class="message">as they could still make backdoor to be impractical</span></div><div class="line" id="005941"><span class="nick" style="color:#2e2a4a"><a href="#005941" label="[00:59:41]">&lt;oriansj&gt;</a></span><span class="message">bauen1: well given that expectation, yes it would be quite simpler than network support. The issue I was thinking about was how live-bootstrap requires 651MB of tarballs</span></div><div class="line" id="010219"><span class="nick" style="color:#2e2a4a"><a href="#010219" label="[01:02:19]">&lt;oriansj&gt;</a></span><span class="message">and as they are compressed tarballs, even if I were to add support for a compressed filesystem, there isn't much to gain.</span></div><div class="line" id="010227"><span class="nick" style="color:#6b8072"><a href="#010227" label="[01:02:27]">&lt;stikonas[m]&gt;</a></span><span class="message">oriansj: in sysa?</span></div><div class="line" id="010240"><span class="nick" style="color:#2e2a4a"><a href="#010240" label="[01:02:40]">&lt;oriansj&gt;</a></span><span class="message">./sources</span></div><div class="line" id="010246"><span class="nick" style="color:#6b8072"><a href="#010246" label="[01:02:46]">&lt;stikonas[m]&gt;</a></span><span class="message">Live-bootsrap puts sysc tarballs into separate disk</span></div><div class="line" id="010303"><span class="nick" style="color:#6b8072"><a href="#010303" label="[01:03:03]">&lt;stikonas[m]&gt;</a></span><span class="message">sources is gone now</span></div><div class="line" id="010335"><span class="nick" style="color:#2e2a4a"><a href="#010335" label="[01:03:35]">&lt;oriansj&gt;</a></span><span class="message">ok</span></div><div class="line" id="010406"><span class="nick" style="color:#2e2a4a"><a href="#010406" label="[01:04:06]">&lt;oriansj&gt;</a></span><span class="message">so how much downloaded sources are needed to build GCC+Linux?</span></div><div class="line" id="010417"><span class="nick" style="color:#6b8072"><a href="#010417" label="[01:04:17]">&lt;stikonas[m]&gt;</a></span><span class="message">There is /sysa/distfiles and /sysc/distfiles</span></div><div class="line" id="010440"><span class="nick" style="color:#389600"><a href="#010440" label="[01:04:40]">&lt;stikonas&gt;</a></span><span class="message">413 MB in /sysa/distfiles</span></div><div class="line" id="010502"><span class="nick" style="color:#389600"><a href="#010502" label="[01:05:02]">&lt;stikonas&gt;</a></span><span class="message">and 262 in /sysc/distfiles (but I guess eventually that will grow)</span></div><div class="line" id="010523"><span class="nick" style="color:#389600"><a href="#010523" label="[01:05:23]">&lt;stikonas&gt;</a></span><span class="message">sysc needs much bigger disk anyway, since it is not in memory</span></div><div class="line" id="010601"><span class="nick" style="color:#389600"><a href="#010601" label="[01:06:01]">&lt;stikonas&gt;</a></span><span class="message">oriansj: but do you think 2nd stage kernel (after builder-hex0) can go all the way to Linux?</span></div><div class="line" id="010652"><span class="nick" style="color:#389600"><a href="#010652" label="[01:06:52]">&lt;stikonas&gt;</a></span><span class="message">it might be tricky to write everything in M2 susbset</span></div><div class="line" id="010706"><span class="nick" style="color:#2e2a4a"><a href="#010706" label="[01:07:06]">&lt;oriansj&gt;</a></span><span class="message">stikonas: I am uncertain but it sounds like a serious problem</span></div><div class="line" id="010734"><span class="nick" style="color:#2e2a4a"><a href="#010734" label="[01:07:34]">&lt;oriansj&gt;</a></span><span class="message">enough to get TCC bootstrapped however is something doable</span></div><div class="line" id="010747"><span class="nick" style="color:#389600"><a href="#010747" label="[01:07:47]">&lt;stikonas&gt;</a></span><span class="message">yeah, that might be more realistic</span></div><div class="line" id="010759"><span class="nick" style="color:#389600"><a href="#010759" label="[01:07:59]">&lt;stikonas&gt;</a></span><span class="message">it's more stages which complicates things a bit, but tcc is way more powerful</span></div><div class="line" id="010818"><span class="nick" style="color:#2e2a4a"><a href="#010818" label="[01:08:18]">&lt;oriansj&gt;</a></span><span class="message">and there are already kernels that are buildable by TCC</span></div><div class="line" id="010833"><span class="nick" style="color:#2e2a4a"><a href="#010833" label="[01:08:33]">&lt;oriansj&gt;</a></span><span class="message">but are there any that could bootstrap Linux?</span></div><div class="line" id="010845"><span class="nick" style="color:#389600"><a href="#010845" label="[01:08:45]">&lt;stikonas&gt;</a></span><span class="message">I don't know</span></div><div class="line" id="010852"><span class="nick" style="color:#2e2a4a"><a href="#010852" label="[01:08:52]">&lt;oriansj&gt;</a></span><span class="message">nor do I</span></div><div class="line" id="010854"><span class="nick" style="color:#389600"><a href="#010854" label="[01:08:54]">&lt;stikonas&gt;</a></span><span class="message">fossy looked at tilk</span></div><div class="line" id="010903"><span class="nick" style="color:#2e2a4a"><a href="#010903" label="[01:09:03]">&lt;oriansj&gt;</a></span><span class="message">hence I need to think more about this</span></div><div class="line" id="014432"><span class="nick" style="color:#2e2a4a"><a href="#014432" label="[01:44:32]">&lt;oriansj&gt;</a></span><span class="message">stikonas: what if we read the tarballs off say a DVD ISO?</span></div><div class="line" id="014451"><span class="nick" style="color:#389600"><a href="#014451" label="[01:44:51]">&lt;stikonas&gt;</a></span><span class="message">doesn't matter where from...</span></div><div class="line" id="014506"><span class="nick" style="color:#389600"><a href="#014506" label="[01:45:06]">&lt;stikonas&gt;</a></span><span class="message">though it's simpler from the same media</span></div><div class="line" id="014517"><span class="nick" style="color:#389600"><a href="#014517" label="[01:45:17]">&lt;stikonas&gt;</a></span><span class="message">but I was thinking of USB sticks</span></div><div class="line" id="014541"><span class="nick" style="color:#389600"><a href="#014541" label="[01:45:41]">&lt;stikonas&gt;</a></span><span class="message">oriansj: how much can you read easily without complications?</span></div><div class="line" id="014748"><span class="nick" style="color:#2e2a4a"><a href="#014748" label="[01:47:48]">&lt;oriansj&gt;</a></span><span class="message">well I was thinking we boot the GFK filesystem + Kernel with none of the extra source files and mount an ISO and doing the steps to TCC and do a more advanced kernel. The sources ISO would stick around for the second kernel to continue the rest of the way</span></div><div class="line" id="014851"><span class="nick" style="color:#389600"><a href="#014851" label="[01:48:51]">&lt;stikonas&gt;</a></span><span class="message">and by iso you mean image? or real dvd?</span></div><div class="line" id="014939"><span class="nick" style="color:#2e2a4a"><a href="#014939" label="[01:49:39]">&lt;oriansj&gt;</a></span><span class="message">well a real DVD would be what we would be using on real hardware probably</span></div><div class="line" id="015013"><span class="nick" style="color:#2e2a4a"><a href="#015013" label="[01:50:13]">&lt;oriansj&gt;</a></span><span class="message">(assuming ATA DVD drives can be found in a trust-worthy manner)</span></div><div class="line" id="015052"><span class="nick" style="color:#2e2a4a"><a href="#015052" label="[01:50:52]">&lt;oriansj&gt;</a></span><span class="message">as that would be much simpler than USB support</span></div><div class="line" id="015328"><span class="nick" style="color:#389600"><a href="#015328" label="[01:53:28]">&lt;stikonas&gt;</a></span><span class="message">well, builder-hex0 relies on BIOS to do reads</span></div><div class="line" id="015420"><span class="nick" style="color:#389600"><a href="#015420" label="[01:54:20]">&lt;stikonas&gt;</a></span><span class="message">but I guess it's ideal to do that in later stages</span></div><div class="line" id="015425"><span class="nick" style="color:#389600"><a href="#015425" label="[01:54:25]">&lt;stikonas&gt;</a></span><span class="message">it's not ideal</span></div><div class="line" id="015549"><span class="nick" style="color:#389600"><a href="#015549" label="[01:55:49]">&lt;stikonas&gt;</a></span><span class="message">though it's a bit unfortunate that we would severly limit where bootstrap can run</span></div><div class="line" id="015627"><span class="nick" style="color:#80b1d3"><a href="#015627" label="[01:56:27]">&lt;muurkha&gt;</a></span><span class="message">you need a different bootstrap for different hardware is all</span></div><div class="line" id="015646"><span class="nick" style="color:#2e2a4a"><a href="#015646" label="[01:56:46]">&lt;oriansj&gt;</a></span><span class="message">yeah, I am thinking builder-hex0 only supporting 3 more builds ( new bootloader, gfk-create and gfk kernel) and then just dump mescc-tools, M2-Planet/M2-Mesoplanet and mescc-tools-extra and let the loading of additional sources be done entirely with the new kernel. To minimize the work needed to port the builder-hex0 kernel to new platforms</span></div><div class="line" id="015654"><span class="nick" style="color:#389600"><a href="#015654" label="[01:56:54]">&lt;stikonas&gt;</a></span><span class="message">well, you need to port drivers to bootstrap kernel</span></div><div class="line" id="015731"><span class="nick" style="color:#2e2a4a"><a href="#015731" label="[01:57:31]">&lt;oriansj&gt;</a></span><span class="message">yes but that is much easier to do in C than in hex0</span></div><div class="line" id="015738"><span class="nick" style="color:#389600"><a href="#015738" label="[01:57:38]">&lt;stikonas&gt;</a></span><span class="message">oh for sure</span></div><div class="line" id="015746"><span class="nick" style="color:#389600"><a href="#015746" label="[01:57:46]">&lt;stikonas&gt;</a></span><span class="message">well, in hex0 we don't even do that</span></div><div class="line" id="015804"><span class="nick" style="color:#389600"><a href="#015804" label="[01:58:04]">&lt;stikonas&gt;</a></span><span class="message">like I said it's basically calls into BIOS to do that work</span></div><div class="line" id="015809"><span class="nick" style="color:#389600"><a href="#015809" label="[01:58:09]">&lt;stikonas&gt;</a></span><span class="message">and drivers are in BIOS</span></div><div class="line" id="015838"><span class="nick" style="color:#2e2a4a"><a href="#015838" label="[01:58:38]">&lt;oriansj&gt;</a></span><span class="message">and other platforms don't have BIOS so we can't depend upon that</span></div><div class="line" id="015850"><span class="nick" style="color:#389600"><a href="#015850" label="[01:58:50]">&lt;stikonas&gt;</a></span><span class="message">yes, I know</span></div><div class="line" id="015901"><span class="nick" style="color:#389600"><a href="#015901" label="[01:59:01]">&lt;stikonas&gt;</a></span><span class="message">that's why other platforms can't easily have something like builder-hex0</span></div><div class="line" id="015914"><span class="nick" style="color:#389600"><a href="#015914" label="[01:59:14]">&lt;stikonas&gt;</a></span><span class="message">you need some other driver integrated (maybe spi)</span></div><div class="line" id="020011"><span class="nick" style="color:#2e2a4a"><a href="#020011" label="[02:00:11]">&lt;oriansj&gt;</a></span><span class="message">well they might be harder to port builder-hex0 to  but even if they were twice as complicated (6KB) they still would only be months of work and not years</span></div><div class="line" id="020056"><span class="nick" style="color:#2e2a4a"><a href="#020056" label="[02:00:56]">&lt;oriansj&gt;</a></span><span class="message">especially now that builder-hex0 can be used as  a roadmap</span></div><div class="line" id="021146"><span class="nick" style="color:#389600"><a href="#021146" label="[02:11:46]">&lt;stikonas&gt;</a></span><span class="message">oh, out of 413 MB in distfiles , 311 MB was linux</span></div><div class="line" id="021155"><span class="nick" style="color:#389600"><a href="#021155" label="[02:11:55]">&lt;stikonas&gt;</a></span><span class="message">-rw-r--r-- 1 andrius andrius  136M 2022-05-05 19:00 linux-4.9.10.tar.gz</span></div><div class="line" id="021220"><span class="nick" style="color:#389600"><a href="#021220" label="[02:12:20]">&lt;stikonas&gt;</a></span><span class="message">-rw-r--r-- 1 andrius andrius  175M 2022-05-05 19:00 linux-headers-5.10.41.tar.gz</span></div><div class="line" id="021244"><span class="nick" style="color:#389600"><a href="#021244" label="[02:12:44]">&lt;stikonas&gt;</a></span><span class="message">so we have two different versions of linux shipped</span></div><div class="line" id="021300"><span class="nick" style="color:#389600"><a href="#021300" label="[02:13:00]">&lt;stikonas&gt;</a></span><span class="message">though possibly just 4.9.10 might be enough</span></div><div class="line" id="021316"><span class="nick" style="color:#80b1d3"><a href="#021316" label="[02:13:16]">&lt;muurkha&gt;</a></span><span class="message">just two would be great</span></div><div class="line" id="021401"><span class="nick" style="color:#389600"><a href="#021401" label="[02:14:01]">&lt;stikonas&gt;</a></span><span class="message">well, what I mean we build one linux kernel but use headers from different version</span></div><div class="line" id="021406"><span class="nick" style="color:#389600"><a href="#021406" label="[02:14:06]">&lt;stikonas&gt;</a></span><span class="message">headers are used to build util-linux</span></div><div class="line" id="025200"><span class="nick" style="color:#2e2a4a"><a href="#025200" label="[02:52:00]">&lt;oriansj&gt;</a></span><span class="message">although a weird thought occurred to me; we don't actually need network/internet access to download files. We could do a BBS or FTPmail download</span></div><div class="line" id="025235"><span class="nick" style="color:#80b1d3"><a href="#025235" label="[02:52:35]">&lt;muurkha&gt;</a></span><span class="message">sure, or you could load them off a DVD</span></div><div class="line" id="025304"><span class="nick" style="color:#80b1d3"><a href="#025304" label="[02:53:04]">&lt;muurkha&gt;</a></span><span class="message">or have an army of volunteers type them in from a book</span></div><div class="line" id="025350"><span class="nick" style="color:#2e2a4a"><a href="#025350" label="[02:53:50]">&lt;oriansj&gt;</a></span><span class="message">muurkha: 413MB compressed data is a huge book (a library one might say)</span></div><div class="line" id="025410"><span class="nick" style="color:#6d2462"><a href="#025410" label="[02:54:10]">&lt;achaninja&gt;</a></span><span class="message">sneakernet</span></div><div class="line" id="025430"><span class="nick" style="color:#80b1d3"><a href="#025430" label="[02:54:30]">&lt;muurkha&gt;</a></span><span class="message">yeah, it's about 100 volumes</span></div><div class="line" id="025437"><span class="nick" style="color:#6d2462"><a href="#025437" label="[02:54:37]">&lt;achaninja&gt;</a></span><span class="message">carrier pidgeons :P</span></div><div class="line" id="025554"><span class="nick" style="color:#80b1d3"><a href="#025554" label="[02:55:54]">&lt;muurkha&gt;</a></span><span class="message">oriansj: probably most other platforms will be less of a pain to get a bootstrap kernel running than IBM PC compatibles</span></div><div class="line" id="025610"><span class="nick" style="color:#2e2a4a"><a href="#025610" label="[02:56:10]">&lt;oriansj&gt;</a></span><span class="message">but yeah, DVD is probably the simplest but I did want other fun options to be possibly considered to inspire some chaotic surprise</span></div><div class="line" id="025635"><span class="nick" style="color:#80b1d3"><a href="#025635" label="[02:56:35]">&lt;muurkha&gt;</a></span><span class="message">my favorite candidate is laser-damaged glass</span></div><div class="line" id="025800"><span class="nick" style="color:#2e2a4a"><a href="#025800" label="[02:58:00]">&lt;oriansj&gt;</a></span><span class="message">well floppy disks would take a bit; about 287 of them</span></div><div class="line" id="025807"><span class="nick" style="color:#80b1d3"><a href="#025807" label="[02:58:07]">&lt;muurkha&gt;</a></span><span class="message">but that's probably because I'm unhealthily obsessed with longevity</span></div><div class="line" id="025943"><span class="nick" style="color:#2e2a4a"><a href="#025943" label="[02:59:43]">&lt;oriansj&gt;</a></span><span class="message">To be honest once we get this whole bit sorted, I was tempted to do a book with every bit required to bootstrap to the GFK kernel included as sources and have a DVD in the back with the rest of the bootstrap tarballs ready to go</span></div><div class="line" id="030028"><span class="nick" style="color:#2e2a4a"><a href="#030028" label="[03:00:28]">&lt;oriansj&gt;</a></span><span class="message">as the only book you need to rebootstrap the world of software</span></div><div class="line" id="030305"><span class="nick" style="color:#80b1d3"><a href="#030305" label="[03:03:05]">&lt;muurkha&gt;</a></span><span class="message">I think that would be awesome</span></div><div class="line" id="030329"><span class="nick" style="color:#80b1d3"><a href="#030329" label="[03:03:29]">&lt;muurkha&gt;</a></span><span class="message">the sequel can include logic circuit designs</span></div><div class="line" id="030637"><span class="nick" style="color:#2e2a4a"><a href="#030637" label="[03:06:37]">&lt;oriansj&gt;</a></span><span class="message">probably how to build all of the major parts out of ICs with a follow up book about making those same ICs via lithography</span></div><div class="line" id="030733"><span class="nick" style="color:#2e2a4a"><a href="#030733" label="[03:07:33]">&lt;oriansj&gt;</a></span><span class="message">after that I hope someone much better at chemistry writes how to get the materials required to the level of purity required for IC manufacture</span></div><div class="line" id="030846"><span class="nick" style="color:#80b1d3"><a href="#030846" label="[03:08:46]">&lt;muurkha&gt;</a></span><span class="message">I think that's just a matter of zone melting</span></div><div class="line" id="030912"><span class="nick" style="color:#80b1d3"><a href="#030912" label="[03:09:12]">&lt;muurkha&gt;</a></span><span class="message">but you don't need IC manufacture or even transistors</span></div><div class="line" id="030940"><span class="nick" style="color:#80b1d3"><a href="#030940" label="[03:09:40]">&lt;muurkha&gt;</a></span><span class="message">well, probably to build GCC you do</span></div><div class="line" id="031048"><span class="nick" style="color:#80b1d3"><a href="#031048" label="[03:10:48]">&lt;muurkha&gt;</a></span><span class="message">but if you have a reasonably stable sequential recording medium you can make do with 4 KiB or so of RAM</span></div><div class="line" id="031247"><span class="nick" style="color:#2e2a4a"><a href="#031247" label="[03:12:47]">&lt;oriansj&gt;</a></span><span class="message">muurkha: maybe to bootstrap to M2-Planet (with a couple tweaks) but there is no way Mescc runs in 4MiB of RAM let alone 4KiB</span></div><div class="line" id="031456"><span class="nick" style="color:#2e2a4a"><a href="#031456" label="[03:14:56]">&lt;oriansj&gt;</a></span><span class="message">heck nyacc chokes on less than 500MB of RAM the last time I looked at it.</span></div><div class="line" id="031856"><span class="nick" style="color:#80b1d3"><a href="#031856" label="[03:18:56]">&lt;muurkha&gt;</a></span><span class="message">yeah, in 4K you'd probably want to bootstrap a smaller system than Scheme</span></div><div class="line" id="031910"><span class="nick" style="color:#80b1d3"><a href="#031910" label="[03:19:10]">&lt;muurkha&gt;</a></span><span class="message">probably something without GC</span></div><div class="line" id="032055"><span class="nick" style="color:#2e2a4a"><a href="#032055" label="[03:20:55]">&lt;oriansj&gt;</a></span><span class="message">and core memory is crazy expensive per bit</span></div><div class="line" id="032214"><span class="nick" style="color:#2e2a4a"><a href="#032214" label="[03:22:14]">&lt;oriansj&gt;</a></span><span class="message">so lithography even at 300nm really makes it economicially reasonable</span></div><div class="line" id="032225"><span class="nick" style="color:#80b1d3"><a href="#032225" label="[03:22:25]">&lt;muurkha&gt;</a></span><span class="message">32768 cores is an amount that it would be feasible for one person to thread by hand</span></div><div class="line" id="032352"><span class="nick" style="color:#80b1d3"><a href="#032352" label="[03:23:52]">&lt;muurkha&gt;</a></span><span class="message">and it's enough for a compiler for a high-level statically-typed language or for an interactive text editor</span></div><div class="line" id="032353"><span class="nick" style="color:#2e2a4a"><a href="#032353" label="[03:23:53]">&lt;oriansj&gt;</a></span><span class="message">even at the rate of 1 core per second that would take over 9 hours of work</span></div><div class="line" id="032353"><span class="nick" style="color:#80b1d3"><a href="#032353" label="[03:23:53]">&lt;muurkha&gt;</a></span><span class="message">but it is certainly true that ICs drop the cost immensely</span></div><div class="line" id="032407"><span class="nick" style="color:#80b1d3"><a href="#032407" label="[03:24:07]">&lt;muurkha&gt;</a></span><span class="message">yeah, I'm thinking it would probably be more like a year of work</span></div><div class="line" id="032423"><span class="nick" style="color:#80b1d3"><a href="#032423" label="[03:24:23]">&lt;muurkha&gt;</a></span><span class="message">to build a computer by hand that way</span></div><div class="line" id="032445"><span class="nick" style="color:#80b1d3"><a href="#032445" label="[03:24:45]">&lt;muurkha&gt;</a></span><span class="message">because you have to spend a lot of time debugging things, they don't all work the first time</span></div><div class="line" id="032532"><span class="nick" style="color:#80b1d3"><a href="#032532" label="[03:25:32]">&lt;muurkha&gt;</a></span><span class="message">but one person-year is feasible.  we're not talking about, like, 100 or ten million person-years</span></div><div class="line" id="032547"><span class="nick" style="color:#2e2a4a"><a href="#032547" label="[03:25:47]">&lt;oriansj&gt;</a></span><span class="message">fair and that is enough  for everything up to M2-Planet</span></div><div class="line" id="032618"><span class="nick" style="color:#2e2a4a"><a href="#032618" label="[03:26:18]">&lt;oriansj&gt;</a></span><span class="message">after that it gets quite memory wasteful</span></div><div class="line" id="032628"><span class="nick" style="color:#80b1d3"><a href="#032628" label="[03:26:28]">&lt;muurkha&gt;</a></span><span class="message">yeah.  you'd probably want to tweak it a lot to make it practically usable though</span></div><div class="line" id="032709"><span class="nick" style="color:#80b1d3"><a href="#032709" label="[03:27:09]">&lt;muurkha&gt;</a></span><span class="message">bootstrapping math: <a rel="nofollow" href="http://us.metamath.org/index.html">http://us.metamath.org/index.html</a> </span></div><div class="line" id="032724"><span class="nick" style="color:#2e2a4a"><a href="#032724" label="[03:27:24]">&lt;oriansj&gt;</a></span><span class="message">I'd have to tweak cc_* a bit too to make it not read all of the source at once</span></div><div class="line" id="032814"><span class="nick" style="color:#80b1d3"><a href="#032814" label="[03:28:14]">&lt;muurkha&gt;</a></span><span class="message">interestingly, by David A. Wheeler</span></div><div class="line" id="032843"><span class="nick" style="color:#80b1d3"><a href="#032843" label="[03:28:43]">&lt;muurkha&gt;</a></span><span class="message">yeah, I think a lot of the annoying aspects of C result from it being designed to be compilable in a single pass</span></div><div class="line" id="033223"><span class="nick" style="color:#2e2a4a"><a href="#033223" label="[03:32:23]">&lt;oriansj&gt;</a></span><span class="message">muurkha: most of the most annoying aspects of C seem more to me an aspect of people forgetting the simple core that exists and trying to be clever.</span></div><div class="line" id="033413"><span class="nick" style="color:#2e2a4a"><a href="#033413" label="[03:34:13]">&lt;oriansj&gt;</a></span><span class="message">for example #define was a clever hack but if they just did  CONSTANT name value then suddenly #define madness is gone.</span></div><div class="line" id="034904"><span class="nick" style="color:#80b1d3"><a href="#034904" label="[03:49:04]">&lt;muurkha&gt;</a></span><span class="message">oriansj: well, the great thing about #define is that you can implement constants and inline functions in a separate pass, so the implementation doesn't have to take up precious memory space in the compiler proper</span></div><div class="line" id="034932"><span class="nick" style="color:#80b1d3"><a href="#034932" label="[03:49:32]">&lt;muurkha&gt;</a></span><span class="message">they weren't running on 4K machines but they did have a 64kiB memory space for code + data, like MS-DOS &quot;tiny&quot; model</span></div><div class="line" id="035042"><span class="nick" style="color:#80b1d3"><a href="#035042" label="[03:50:42]">&lt;muurkha&gt;</a></span><span class="message">and if you compare the facilities of C in Unix with those of contemporary 16-bit operating systems like the Tandem OS or Data General RDOS (for the Nova), it's a night and day difference</span></div><div class="line" id="035135"><span class="nick" style="color:#2e2a4a"><a href="#035135" label="[03:51:35]">&lt;oriansj&gt;</a></span><span class="message">that I believe</span></div><div class="line" id="035156"><span class="nick" style="color:#80b1d3"><a href="#035156" label="[03:51:56]">&lt;muurkha&gt;</a></span><span class="message">Unix in 01979 is recognizably modern: SCCS, Makefiles, vi with ctags turning your source base into hypertext, metaprogramming with the C preprocessor (including, for example, generic data structures), high-level scripting with shell pipelines, etc.</span></div><div class="line" id="035337"><span class="nick" style="color:#80b1d3"><a href="#035337" label="[03:53:37]">&lt;muurkha&gt;</a></span><span class="message">while the facilities on other 16-bit machines of the time were extremely primitive by comparison.  lots of assembly language, no high-level scripting language, janky bletcherous build processes, etc.</span></div><div class="line" id="035348"><span class="nick" style="color:#80b1d3"><a href="#035348" label="[03:53:48]">&lt;muurkha&gt;</a></span><span class="message">meanwhile csh had things like filename completion</span></div><div class="line" id="035836"><span class="nick" style="color:#80b1d3"><a href="#035836" label="[03:58:36]">&lt;muurkha&gt;</a></span><span class="message">the bell labs team got a lot of mileage out of preprocessors and their loosely-coupled-tiny-tools approach even on bigger machines.  cpp is maybe not ideal for Fortran but Ratfor goes a long way to making Fortran 66 into a high-level programming langugae</span></div><div class="line" id="040033"><span class="nick" style="color:#2e2a4a"><a href="#040033" label="[04:00:33]">&lt;oriansj&gt;</a></span><span class="message">well Unix did somethings correctly but it did miss other good ideas. Like versioning filesystems (ITS), input validating shells (DCL anyone?) but that is another topic that could take a bit</span></div><div class="line" id="040113"><span class="nick" style="color:#80b1d3"><a href="#040113" label="[04:01:13]">&lt;muurkha&gt;</a></span><span class="message">yeah!  but ITS was on a 36-bit machine and DCL a 32-bit one</span></div><div class="line" id="040157"><span class="nick" style="color:#80b1d3"><a href="#040157" label="[04:01:57]">&lt;muurkha&gt;</a></span><span class="message">they weren't laboring under the same constraints</span></div><div class="line" id="040242"><span class="nick" style="color:#80b1d3"><a href="#040242" label="[04:02:42]">&lt;muurkha&gt;</a></span><span class="message">I liked programming in DCL a lot, but VMS programs weren't designed for composability the way Unix programs were</span></div><div class="line" id="040306"><span class="nick" style="color:#80b1d3"><a href="#040306" label="[04:03:06]">&lt;muurkha&gt;</a></span><span class="message">VMS's help files were a whole other world though</span></div><div class="line" id="040336"><span class="nick" style="color:#80b1d3"><a href="#040336" label="[04:03:36]">&lt;muurkha&gt;</a></span><span class="message">I think Linux reflinks allow you to sort of do versioning filesystems a la carte now?</span></div><div class="line" id="040448"><span class="nick" style="color:#2e2a4a"><a href="#040448" label="[04:04:48]">&lt;oriansj&gt;</a></span><span class="message">RSX-11 had file versioning on the same PDP-11 that Unix started on</span></div><div class="line" id="040512"><span class="nick" style="color:#80b1d3"><a href="#040512" label="[04:05:12]">&lt;muurkha&gt;</a></span><span class="message">yeah, file versioning doesn't require a lot of extra software complexity</span></div><div class="line" id="040521"><span class="nick" style="color:#80b1d3"><a href="#040521" label="[04:05:21]">&lt;muurkha&gt;</a></span><span class="message">it just uses more disk space</span></div><div class="line" id="040539"><span class="nick" style="color:#80b1d3"><a href="#040539" label="[04:05:39]">&lt;muurkha&gt;</a></span><span class="message">and that only potentially</span></div><div class="line" id="040556"><span class="nick" style="color:#2e2a4a"><a href="#040556" label="[04:05:56]">&lt;oriansj&gt;</a></span><span class="message">and DCL did evolve to be quite composable</span></div><div class="line" id="040638"><span class="nick" style="color:#2e2a4a"><a href="#040638" label="[04:06:38]">&lt;oriansj&gt;</a></span><span class="message">and it was available on the RT-11</span></div><div class="line" id="040718"><span class="nick" style="color:#80b1d3"><a href="#040718" label="[04:07:18]">&lt;muurkha&gt;</a></span><span class="message">I never used RT-11 so I don't know what it was like</span></div><div class="line" id="040741"><span class="nick" style="color:#80b1d3"><a href="#040741" label="[04:07:41]">&lt;muurkha&gt;</a></span><span class="message">but the problem with DCL wasn't the composability of DCL, it was the composability of the things you had at hand</span></div><div class="line" id="040815"><span class="nick" style="color:#2e2a4a"><a href="#040815" label="[04:08:15]">&lt;oriansj&gt;</a></span><span class="message">also lack of source code for those systems really limited one's ability to fix the defects</span></div><div class="line" id="040820"><span class="nick" style="color:#80b1d3"><a href="#040820" label="[04:08:20]">&lt;muurkha&gt;</a></span><span class="message">like, yesterday I wanted to know where people were reaching my &quot;isinstance considered harmful&quot; page, so I ran</span></div><div class="line" id="040823"><span class="nick" style="color:#80b1d3"><a href="#040823" label="[04:08:23]">&lt;muurkha&gt;</a></span><span class="message">(cat /var/log/apache2/access.log ; zcat /var/log/apache2/access.log.{2..14}*) | grep isinstance | awk '{print $11}' | sort | uniq -c | sort -n</span></div><div class="line" id="040904"><span class="nick" style="color:#80b1d3"><a href="#040904" label="[04:09:04]">&lt;muurkha&gt;</a></span><span class="message">now I'm not saying that this is the optimal way to be able to answer questions like that</span></div><div class="line" id="040943"><span class="nick" style="color:#2e2a4a"><a href="#040943" label="[04:09:43]">&lt;oriansj&gt;</a></span><span class="message">but it could be done because tools like grep, awk, sort and uniq exist</span></div><div class="line" id="040955"><span class="nick" style="color:#80b1d3"><a href="#040955" label="[04:09:55]">&lt;muurkha&gt;</a></span><span class="message">it would be much nicer to say something like select referer, count(*) as n from hits where url like '%isinstance%' group by referer sort by n asc limit 10;</span></div><div class="line" id="041010"><span class="nick" style="color:#80b1d3"><a href="#041010" label="[04:10:10]">&lt;muurkha&gt;</a></span><span class="message">or better still some sort of interactive exploration thing</span></div><div class="line" id="041104"><span class="nick" style="color:#2e2a4a"><a href="#041104" label="[04:11:04]">&lt;oriansj&gt;</a></span><span class="message">but unix can be hacked together in a manner that appears rather simple and produce useful results.</span></div><div class="line" id="041109"><span class="nick" style="color:#80b1d3"><a href="#041109" label="[04:11:09]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="041130"><span class="nick" style="color:#80b1d3"><a href="#041130" label="[04:11:30]">&lt;muurkha&gt;</a></span><span class="message">despite the data I was working with being a bit lame</span></div><div class="line" id="041134"><span class="nick" style="color:#2e2a4a"><a href="#041134" label="[04:11:34]">&lt;oriansj&gt;</a></span><span class="message">and the biggest win was source code could be obtained and people could  fix their own problems (to a degree)</span></div><div class="line" id="041144"><span class="nick" style="color:#80b1d3"><a href="#041144" label="[04:11:44]">&lt;muurkha&gt;</a></span><span class="message">I think that was a win, yeah</span></div><div class="line" id="041150"><span class="nick" style="color:#80b1d3"><a href="#041150" label="[04:11:50]">&lt;muurkha&gt;</a></span><span class="message">but another big win was that it was portable</span></div><div class="line" id="041222"><span class="nick" style="color:#80b1d3"><a href="#041222" label="[04:12:22]">&lt;muurkha&gt;</a></span><span class="message">so when people on a VAX solved a problem, it was also solved for users of the PDP-11 (usually) and the Interdata 8/32</span></div><div class="line" id="041255"><span class="nick" style="color:#80b1d3"><a href="#041255" label="[04:12:55]">&lt;muurkha&gt;</a></span><span class="message">a third thing though was just that you had a high-level scripting language capable of doing things like the above</span></div><div class="line" id="041413"><span class="nick" style="color:#2e2a4a"><a href="#041413" label="[04:14:13]">&lt;oriansj&gt;</a></span><span class="message">unix is no more portable than VMS, the biggest difference was someone without a PDP but with Unix Sources could pour in enough work to get it running on what they did have. Vs VMS where if it wasn't a DEC product, you had no chance and if it was, you didn't more thanVAX as an option.</span></div><div class="line" id="041513"><span class="nick" style="color:#2e2a4a"><a href="#041513" label="[04:15:13]">&lt;oriansj&gt;</a></span><span class="message">^more^have more^</span></div><div class="line" id="041619"><span class="nick" style="color:#2e2a4a"><a href="#041619" label="[04:16:19]">&lt;oriansj&gt;</a></span><span class="message">only after years of porting work, did unix get the title of being &quot;portable&quot; because it was made that way slowly after it escaped bell labs</span></div><div class="line" id="041850"><span class="nick" style="color:#2e2a4a"><a href="#041850" label="[04:18:50]">&lt;oriansj&gt;</a></span><span class="message">heck look at all of the Effort put in getting Xenix to run on x86 systems</span></div><div class="line" id="041937"><span class="nick" style="color:#80b1d3"><a href="#041937" label="[04:19:37]">&lt;muurkha&gt;</a></span><span class="message">VMS wasn't written in C, it was written in MACRO and BLISS.  MACRO is explicitly not portable and BLISS is only portable in theory</span></div><div class="line" id="041945"><span class="nick" style="color:#2e2a4a"><a href="#041945" label="[04:19:45]">&lt;oriansj&gt;</a></span><span class="message">or the years of pain in every Unix when adding a new architecture or the years of effort adding a new architecture to Linux</span></div><div class="line" id="041957"><span class="nick" style="color:#80b1d3"><a href="#041957" label="[04:19:57]">&lt;muurkha&gt;</a></span><span class="message">so Unix is *enormously* more portable than VMS was</span></div><div class="line" id="042021"><span class="nick" style="color:#80b1d3"><a href="#042021" label="[04:20:21]">&lt;muurkha&gt;</a></span><span class="message">eventually of course they did rewrite most of VMS in C so they could move to the Alpha αxp</span></div><div class="line" id="042055"><span class="nick" style="color:#80b1d3"><a href="#042055" label="[04:20:55]">&lt;muurkha&gt;</a></span><span class="message">but of course that wasn't until many years after Unix</span></div><div class="line" id="042121"><span class="nick" style="color:#80b1d3"><a href="#042121" label="[04:21:21]">&lt;muurkha&gt;</a></span><span class="message">quite aside from questions of DEC's commercial strategy</span></div><div class="line" id="042205"><span class="nick" style="color:#80b1d3"><a href="#042205" label="[04:22:05]">&lt;muurkha&gt;</a></span><span class="message">Unix was ported to the Interdata about the time it was released publicly</span></div><div class="line" id="042253"><span class="nick" style="color:#80b1d3"><a href="#042253" label="[04:22:53]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/Version_6_Unix#Portability">https://en.wikipedia.org/wiki/Version_6_Unix#Portability</a> </span></div><div class="line" id="042405"><span class="nick" style="color:#80b1d3"><a href="#042405" label="[04:24:05]">&lt;muurkha&gt;</a></span><span class="message">and most of the userland had previously been ported as part of PWB</span></div><div class="line" id="042456"><span class="nick" style="color:#80b1d3"><a href="#042456" label="[04:24:56]">&lt;muurkha&gt;</a></span><span class="message">hmm, I think I'm misremembering that part</span></div><div class="line" id="042540"><span class="nick" style="color:#2e2a4a"><a href="#042540" label="[04:25:40]">&lt;oriansj&gt;</a></span><span class="message">actually it looks like VMS is 1/3 BLISS and 1/3 MACRO still to today. With C only being added for the Itanium port</span></div><div class="line" id="042616"><span class="nick" style="color:#80b1d3"><a href="#042616" label="[04:26:16]">&lt;muurkha&gt;</a></span><span class="message">really?  is the source released?</span></div><div class="line" id="042636"><span class="nick" style="color:#2e2a4a"><a href="#042636" label="[04:26:36]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://groups.google.com/g/comp.os.vms/c/3SWQiRQA1Y4/m/npx29Nm-AwAJ">https://groups.google.com/g/comp.os.vms/c/3SWQiRQA1Y4/m/npx29Nm-AwAJ</a> </span></div><div class="line" id="042646"><span class="nick" style="color:#2e2a4a"><a href="#042646" label="[04:26:46]">&lt;oriansj&gt;</a></span><span class="message">not that I can tell</span></div><div class="line" id="042716"><span class="nick" style="color:#80b1d3"><a href="#042716" label="[04:27:16]">&lt;muurkha&gt;</a></span><span class="message">mala: danny your connection is bouncing</span></div><div class="line" id="042818"><span class="nick" style="color:#80b1d3"><a href="#042818" label="[04:28:18]">&lt;muurkha&gt;</a></span><span class="message">Kernighan &amp; Plauger published the Ratfor version of Software Tools in 01976, at which point I think they had been using the approach on a few different big machines for a couple of years after initial explorations on Unix</span></div><div class="line" id="042832"><span class="nick" style="color:#2e2a4a"><a href="#042832" label="[04:28:32]">&lt;oriansj&gt;</a></span><span class="message">they effectively made MACRO into a high level langauge to be compiled like C</span></div><div class="line" id="042836"><span class="nick" style="color:#80b1d3"><a href="#042836" label="[04:28:36]">&lt;muurkha&gt;</a></span><span class="message">speaking of cpp, one of the chapters in there is m4</span></div><div class="line" id="042853"><span class="nick" style="color:#80b1d3"><a href="#042853" label="[04:28:53]">&lt;muurkha&gt;</a></span><span class="message">that's pretty insane!</span></div><div class="line" id="042930"><span class="nick" style="color:#80b1d3"><a href="#042930" label="[04:29:30]">&lt;muurkha&gt;</a></span><span class="message">&quot;Oh, as to the original question, looking at recent x86-64 builds, the linker object files built by the different compilers are ~55% C, ~30% BLISS, ~15% MACRO-32, &lt;1% Assembler.&quot;</span></div><div class="line" id="043246"><span class="nick" style="color:#2e2a4a"><a href="#043246" label="[04:32:46]">&lt;oriansj&gt;</a></span><span class="message">well C programmers were much easier to find than BLISS programmers and honestly C is a better language than BLISS in several ways that matter to kernel writers</span></div><div class="line" id="043310"><span class="nick" style="color:#80b1d3"><a href="#043310" label="[04:33:10]">&lt;muurkha&gt;</a></span><span class="message">my main point is that C is a lot more portable than BLISS</span></div><div class="line" id="043324"><span class="nick" style="color:#80b1d3"><a href="#043324" label="[04:33:24]">&lt;muurkha&gt;</a></span><span class="message">whether it's better or worse in other ways</span></div><div class="line" id="043348"><span class="nick" style="color:#2e2a4a"><a href="#043348" label="[04:33:48]">&lt;oriansj&gt;</a></span><span class="message">so a transistion from no C code to &gt; 33% to 55% seems about right</span></div><div class="line" id="043404"><span class="nick" style="color:#80b1d3"><a href="#043404" label="[04:34:04]">&lt;muurkha&gt;</a></span><span class="message">it's true that C programs often embed assumptions about the machine word size, but BLISS programs tend to do so much more pervasively (in my extremely limited experience)</span></div><div class="line" id="043440"><span class="nick" style="color:#80b1d3"><a href="#043440" label="[04:34:40]">&lt;muurkha&gt;</a></span><span class="message">C was designed to be portable, while BLISS was designed to be a family of languages, one per architecture</span></div><div class="line" id="043503"><span class="nick" style="color:#2e2a4a"><a href="#043503" label="[04:35:03]">&lt;oriansj&gt;</a></span><span class="message">So perhaps it is best to say kernels written in more portable languages are less work to port and the design of the kernel ultimately plays a smaller role.</span></div><div class="line" id="043613"><span class="nick" style="color:#80b1d3"><a href="#043613" label="[04:36:13]">&lt;muurkha&gt;</a></span><span class="message">maybe!</span></div><div class="line" id="043724"><span class="nick" style="color:#80b1d3"><a href="#043724" label="[04:37:24]">&lt;muurkha&gt;</a></span><span class="message">I'm thinking that probably Unix gained a significant advantage by starting out on small, weak machines that barely had memory protection</span></div><div class="line" id="043815"><span class="nick" style="color:#80b1d3"><a href="#043815" label="[04:38:15]">&lt;muurkha&gt;</a></span><span class="message">porting 16-bit code to a 32-bit machine is a lot easier than vice versa, and porting a kernel whose memory protection consisted of segment registers to a machine with paging hardware also seems like it would be a lot easier than vice versa</span></div><div class="line" id="043953"><span class="nick" style="color:#80b1d3"><a href="#043953" label="[04:39:53]">&lt;muurkha&gt;</a></span><span class="message">I mean on Multics the fundamental filesystem access operation was mmap, and there was just no way to implement that on the PDP-7 or PDP-11</span></div><div class="line" id="044041"><span class="nick" style="color:#80b1d3"><a href="#044041" label="[04:40:41]">&lt;muurkha&gt;</a></span><span class="message">in the other direction though fork();execv() was gratuitously inefficient on the PDP-11, which is why we got vfork()</span></div><div class="line" id="044118"><span class="nick" style="color:#80b1d3"><a href="#044118" label="[04:41:18]">&lt;muurkha&gt;</a></span><span class="message">because fork() implies making a copy of the whole data segment, and then execv() throws it all away except for a few small bits</span></div><div class="line" id="044128"><span class="nick" style="color:#80b1d3"><a href="#044128" label="[04:41:28]">&lt;muurkha&gt;</a></span><span class="message">execve() i guess</span></div><div class="line" id="044339"><span class="nick" style="color:#80b1d3"><a href="#044339" label="[04:43:39]">&lt;muurkha&gt;</a></span><span class="message">and if you have even less memory protection, to the point of lacking a segment base register, your best approach to fork() is to write out a process image to disk and read it back in on process switch.  ridiculously slow.  spawn is much more desirable if you have enough RAM for more than one process at a time</span></div><div class="line" id="044422"><span class="nick" style="color:#234e69"><a href="#044422" label="[04:44:22]">*</a></span><span class="message">littlebobeep is not enthusiastic about needing an optical drive + disc to bootstrap</span></div><div class="line" id="044947"><span class="nick" style="color:#80b1d3"><a href="#044947" label="[04:49:47]">&lt;muurkha&gt;</a></span><span class="message">hey, it's less work than manually threading magnetic cores onto tiny wires</span></div><div class="line" id="051313"><span class="nick" style="color:#2e2a4a"><a href="#051313" label="[05:13:13]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: completely understandable. I however am very open to suggestions on how to do a more honest bootstrap and get 100s of MB of compressed tarballs onto disk</span></div><div class="line" id="051516"><span class="nick" style="color:#2e2a4a"><a href="#051516" label="[05:15:16]">&lt;oriansj&gt;</a></span><span class="message">as I can imagine someone taking a couple months to put stage0-posix on a hard disk or a floppy disk one sector at a time but I can't imagine someone doing the same for 10MB of tarballs let alone 100s of MB</span></div><div class="line" id="052202"><span class="nick" style="color:#2e2a4a"><a href="#052202" label="[05:22:02]">&lt;oriansj&gt;</a></span><span class="message">muurkha: part of me wonders if C started out being just a little more forward thinking in regards to types that a whole boatload of pain and suffering could have been avoided.</span></div><div class="line" id="084844"><span class="nick" style="color:#6c3d55"><a href="#084844" label="[08:48:44]">&lt;bauen1&gt;</a></span><span class="message">i would argue you don't need to hand write the source tars, as long as you can audit / verify their integrity before use</span></div><div class="line" id="151319"><span class="nick" style="color:#d9d9d9"><a href="#151319" label="[15:13:19]">&lt;davidak[m]&gt;</a></span><span class="message">The text at <a rel="nofollow" href="https://bootstrappable.org/best-practices.html#distro">https://bootstrappable.org/best-practices.html#distro</a>  seem outdated considering the last achievements of GUIX.</span></div><div class="line" id="151319"><span class="nick" style="color:#d9d9d9"><a href="#151319" label="[15:13:19]">&lt;davidak[m]&gt;</a></span><span class="message">&quot;It is unavoidable that distributions use some binaries as part of their bootstrap chain.&quot;</span></div><div class="line" id="151319"><span class="nick" style="color:#d9d9d9"><a href="#151319" label="[15:13:19]">&lt;davidak[m]&gt;</a></span><span class="message">Can someone update it? I would create a github issue, but there seem to be no issue tracker...</span></div><div class="line" id="151403"><span class="nick" style="color:#d9d9d9"><a href="#151403" label="[15:14:03]">&lt;davidak[m]&gt;</a></span><span class="message">Also, it would be great to see some names and faces at <a rel="nofollow" href="https://bootstrappable.org/who.html">https://bootstrappable.org/who.html</a> </span></div><div class="line" id="152142"><span class="nick" style="color:#bc80bd"><a href="#152142" label="[15:21:42]">&lt;Hagfish&gt;</a></span><span class="message">davidak[m]: i'm not sure if GUIX doesn't require *any* binaries.  there are the initial binary seeds, and there's the small issue of running them on a kernel which can build up to tcc and beyond</span></div><div class="line" id="152201"><span class="nick" style="color:#bc80bd"><a href="#152201" label="[15:22:01]">&lt;Hagfish&gt;</a></span><span class="message">you're right, though, that it's under-selling how close we are, and should probably be re-written sooner or later</span></div><div class="line" id="152620"><span class="nick" style="color:#3c5b35"><a href="#152620" label="[15:26:20]">&lt;j-k[m]&gt;</a></span><span class="message"> <a rel="nofollow" href="https://guix.gnu.org/en/blog/2020/guix-further-reduces-bootstrap-seed-to-25/">https://guix.gnu.org/en/blog/2020/guix-further-reduces-bootstrap-seed-to-25/</a> </span></div><div class="line" id="152621"><span class="nick" style="color:#3c5b35"><a href="#152621" label="[15:26:21]">&lt;j-k[m]&gt;</a></span><span class="message">has a graph of the bootstrapping, this is the latest bootstrapping post I've found</span></div><div class="line" id="152621"><span class="nick" style="color:#af8d2f"><a href="#152621" label="[15:26:21]">&lt;civodul&gt;</a></span><span class="message">i believe several of us here (me included) can push changes to the web site, so don't hesitate to propose patches</span></div><div class="line" id="152647"><span class="nick" style="color:#af8d2f"><a href="#152647" label="[15:26:47]">&lt;civodul&gt;</a></span><span class="message">j-k[m]: the latest achievements by janneke &amp; co. don't have a blog post yet</span></div><div class="line" id="152702"><span class="nick" style="color:#af8d2f"><a href="#152702" label="[15:27:02]">&lt;civodul&gt;</a></span><span class="message">but you can see that at <a rel="nofollow" href="https://issues.guix.gnu.org/55227">https://issues.guix.gnu.org/55227</a> </span></div><div class="line" id="152851"><span class="nick" style="color:#3c5b35"><a href="#152851" label="[15:28:51]">&lt;j-k[m]&gt;</a></span><span class="message">ah very very nice</span></div><div class="line" id="155741"><span class="nick" style="color:#bc80bd"><a href="#155741" label="[15:57:41]">&lt;Hagfish&gt;</a></span><span class="message">&quot;There will definately be a blog-post; I have already started to work on it.  I think it's probably best to time it after core-utils has been merged into master, when &quot;guix pull; guix system init ..&quot; actually installs a system built from 357 bytes.&quot;</span></div><div class="line" id="155749"><span class="nick" style="color:#bc80bd"><a href="#155749" label="[15:57:49]">&lt;Hagfish&gt;</a></span><span class="message">that blog post is going to blow people's minds!</span></div><div class="line" id="160427"><span class="nick" style="color:#bc80bd"><a href="#160427" label="[16:04:27]">&lt;Hagfish&gt;</a></span><span class="message">i wasn't around when Turing published &quot;On Computable Numbers&quot;, and i wasn't on Usenet when Stallman announced the start of the GNU project, but there is now a new generation who will get to witness the revealing of this bootstrapping achievement</span></div><div class="line" id="174652"><span class="nick" style="color:#389600"><a href="#174652" label="[17:46:52]">&lt;theruran&gt;</a></span><span class="message">Hagfish: true! but I think it will be important to make clear that the work doesn't stop there</span></div><div class="line" id="182609"><span class="nick" style="color:#bc80bd"><a href="#182609" label="[18:26:09]">&lt;Hagfish&gt;</a></span><span class="message">theruran: yeah, absolutely, that's why i'm comparing it to the start of the GNU project.  now that people can see this golden thread working from end to end, it's the perfect time for them to find an area they'd like to enhance</span></div><div class="line" id="182729"><span class="nick" style="color:#bc80bd"><a href="#182729" label="[18:27:29]">&lt;Hagfish&gt;</a></span><span class="message">i guess there are two extremes that need to be avoided:  making people think that all the work has already been done, and making them think that getting to this point was trivial and didn't require the sweat of heroes</span></div><div class="line" id="184529"><span class="nick" style="color:#2e2a4a"><a href="#184529" label="[18:45:29]">&lt;oriansj&gt;</a></span><span class="message">davidak[m]: well having atleast 1 binary file is unavoidable for most (if not all architectures); so the advice to &quot;be clear where the binary came from and how it was produced&quot; and &quot;Users can reproduce the binary to verify that it has not been tampered with&quot; still apply but I will admit suggesting to make as few binaries as possible and as small as possible would be a good idea.</span></div><div class="line" id="184643"><span class="nick" style="color:#8dd3c7"><a href="#184643" label="[18:46:43]">&lt;unmatched-paren&gt;</a></span><span class="message">oriansj: and as you have previously stated, it's technically possible to verify that the binary is correct with no software</span></div><div class="line" id="184752"><span class="nick" style="color:#2e2a4a"><a href="#184752" label="[18:47:52]">&lt;oriansj&gt;</a></span><span class="message">unmatched-paren: it just requires special storage media and manual inspection.</span></div><div class="line" id="184912"><span class="nick" style="color:#2e2a4a"><a href="#184912" label="[18:49:12]">&lt;oriansj&gt;</a></span><span class="message">and assumes that the system that writes it out doesn't strip out the subversion to prevent that sort of detection.</span></div><div class="line" id="184948"><span class="nick" style="color:#2e2a4a"><a href="#184948" label="[18:49:48]">&lt;oriansj&gt;</a></span><span class="message">and that the system reading it back in doesn't reinsert that subversion.</span></div><div class="line" id="184952"><span class="nick" style="color:#8dd3c7"><a href="#184952" label="[18:49:52]">&lt;unmatched-paren&gt;</a></span><span class="message">oh, hm. didn't think about that last point</span></div><div class="line" id="185231"><span class="nick" style="color:#d9d9d9"><a href="#185231" label="[18:52:31]">&lt;davidak[m]&gt;</a></span><span class="message">oriansj: so hex0 has to be in binary form to start bootstraping? and compiling it has to be done manually before?</span></div><div class="line" id="185317"><span class="nick" style="color:#8dd3c7"><a href="#185317" label="[18:53:17]">&lt;unmatched-paren&gt;</a></span><span class="message">davidak[m]: yes</span></div><div class="line" id="185442"><span class="nick" style="color:#2e2a4a"><a href="#185442" label="[18:54:42]">&lt;oriansj&gt;</a></span><span class="message">davidak[m]: processors generally only execute ISA instructions (which have binary encodings) and I am unware of an architecture which using only valid ascii chars would support everything required to open files, read their contents, write out the results, close the file handles and exit cleanly</span></div><div class="line" id="185600"><span class="nick" style="color:#2e2a4a"><a href="#185600" label="[18:56:00]">&lt;oriansj&gt;</a></span><span class="message">also how to handle the comments that also exist which the process would see as bytes following a valid instruction.</span></div><div class="line" id="185659"><span class="nick" style="color:#2e2a4a"><a href="#185659" label="[18:56:59]">&lt;oriansj&gt;</a></span><span class="message">and why we have our binaries here: <a rel="nofollow" href="https://github.com/oriansj/bootstrap-seeds">https://github.com/oriansj/bootstrap-seeds</a>  along with the hex0 needed to make them</span></div><div class="line" id="185745"><span class="nick" style="color:#2e2a4a"><a href="#185745" label="[18:57:45]">&lt;oriansj&gt;</a></span><span class="message">and why we are *VERY* explicit in stating &quot;NEVER TRUST ANYTHING IN HERE&quot;</span></div><div class="line" id="185841"><span class="nick" style="color:#2e2a4a"><a href="#185841" label="[18:58:41]">&lt;oriansj&gt;</a></span><span class="message">and one can manually toggle in their own hex0 binary without much effort</span></div><div class="line" id="185904"><span class="nick" style="color:#2e2a4a"><a href="#185904" label="[18:59:04]">&lt;oriansj&gt;</a></span><span class="message">or use countless methods to build the hex0 binary from its hex0 sources</span></div><div class="line" id="185933"><span class="nick" style="color:#2e2a4a"><a href="#185933" label="[18:59:33]">&lt;oriansj&gt;</a></span><span class="message">and all methods should produce the exact same binary output.</span></div><div class="line" id="190328"><span class="nick" style="color:#d9d9d9"><a href="#190328" label="[19:03:28]">&lt;davidak[m]&gt;</a></span><span class="message">thanks</span></div><div class="line" id="190737"><span class="nick" style="color:#80b1d3"><a href="#190737" label="[19:07:37]">&lt;muurkha&gt;</a></span><span class="message">oriansj: we can see what would have happened if C started out being just a little more forward-thinking with regard to types: it's Pascal</span></div><div class="line" id="190747"><span class="nick" style="color:#bc80bd"><a href="#190747" label="[19:07:47]">&lt;Hagfish&gt;</a></span><span class="message">oriansj: on the subject of &quot;only valid ASCII&quot;, i can't help remembering this incredible feat by (the inimitable) Tom7 <a rel="nofollow" href="https://www.youtube.com/watch?v=LA_DrBwkiJA">https://www.youtube.com/watch?v=LA_DrBwkiJA</a> </span></div><div class="line" id="190931"><span class="nick" style="color:#8dd3c7"><a href="#190931" label="[19:09:31]">&lt;unmatched-paren&gt;</a></span><span class="message">after researching pascal for `aesop`, i think it could be a neat language, but it was too small and impractical, so all the compiler writers just extended it and now it's basically a family of dialects</span></div><div class="line" id="191001"><span class="nick" style="color:#8dd3c7"><a href="#191001" label="[19:10:01]">&lt;unmatched-paren&gt;</a></span><span class="message">(it also annoys me how `writeln` et al are built in and have loads of special cases)</span></div><div class="line" id="191302"><span class="nick" style="color:#234e69"><a href="#191302" label="[19:13:02]">*</a></span><span class="message">unmatched-paren wonders if modula-3 or oberon fix these problems</span></div><div class="line" id="191331"><span class="nick" style="color:#80b1d3"><a href="#191331" label="[19:13:31]">&lt;muurkha&gt;</a></span><span class="message">well, they did avoid the family-of-dialects problem</span></div><div class="line" id="191357"><span class="nick" style="color:#80b1d3"><a href="#191357" label="[19:13:57]">&lt;muurkha&gt;</a></span><span class="message">I forget if they avoided the you-can't-write-printf problem</span></div><div class="line" id="191433"><span class="nick" style="color:#8dd3c7"><a href="#191433" label="[19:14:33]">&lt;unmatched-paren&gt;</a></span><span class="message">gm3c apparently isn't in guix :(</span></div><div class="line" id="191454"><span class="nick" style="color:#80b1d3"><a href="#191454" label="[19:14:54]">&lt;muurkha&gt;</a></span><span class="message">Brian Kernighan wrote a famous paper on this actually</span></div><div class="line" id="191456"><span class="nick" style="color:#8dd3c7"><a href="#191456" label="[19:14:56]">&lt;unmatched-paren&gt;</a></span><span class="message">neither is anything oberon-related</span></div><div class="line" id="191553"><span class="nick" style="color:#8dd3c7"><a href="#191553" label="[19:15:53]">&lt;unmatched-paren&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/Pascal_">https://en.wikipedia.org/wiki/Pascal_</a>(programming_language)#Early_criticism  ?</span></div><div class="line" id="191605"><span class="nick" style="color:#8dd3c7"><a href="#191605" label="[19:16:05]">&lt;unmatched-paren&gt;</a></span><span class="message">&quot;Why Pascal is Not My Favorite Programming Language&quot;?</span></div><div class="line" id="191700"><span class="nick" style="color:#80b1d3"><a href="#191700" label="[19:17:00]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://www.cs.virginia.edu/~evans/cs655/readings/bwk-on-pascal.html">https://www.cs.virginia.edu/~evans/cs655/readings/bwk-on-pascal.html</a>  yeah</span></div><div class="line" id="191706"><span class="nick" style="color:#8dd3c7"><a href="#191706" label="[19:17:06]">&lt;unmatched-paren&gt;</a></span><span class="message">muurkha: i think you _can_ write something like printf with fpc's `array of const`</span></div><div class="line" id="191716"><span class="nick" style="color:#80b1d3"><a href="#191716" label="[19:17:16]">&lt;muurkha&gt;</a></span><span class="message">oberon is super interesting</span></div><div class="line" id="191840"><span class="nick" style="color:#8dd3c7"><a href="#191840" label="[19:18:40]">&lt;unmatched-paren&gt;</a></span><span class="message">also imo pascal's syntax is a bit too verbose</span></div><div class="line" id="191849"><span class="nick" style="color:#8dd3c7"><a href="#191849" label="[19:18:49]">&lt;unmatched-paren&gt;</a></span><span class="message">`procedure` keyword, anyone?</span></div><div class="line" id="191905"><span class="nick" style="color:#8dd3c7"><a href="#191905" label="[19:19:05]">&lt;unmatched-paren&gt;</a></span><span class="message">or the array syntax</span></div><div class="line" id="191927"><span class="nick" style="color:#8dd3c7"><a href="#191927" label="[19:19:27]">&lt;unmatched-paren&gt;</a></span><span class="message">oh, that reminds me:</span></div><div class="line" id="191931"><span class="nick" style="color:#80b1d3"><a href="#191931" label="[19:19:31]">&lt;muurkha&gt;</a></span><span class="message">while that is true I regard it as being of distinctly secondary or tertiary importance</span></div><div class="line" id="191943"><span class="nick" style="color:#8dd3c7"><a href="#191943" label="[19:19:43]">&lt;unmatched-paren&gt;</a></span><span class="message">procedures and functions are different things for some reason</span></div><div class="line" id="192007"><span class="nick" style="color:#8dd3c7"><a href="#192007" label="[19:20:07]">&lt;unmatched-paren&gt;</a></span><span class="message">yeah, it's not a show-stopping issue, but it's annoying</span></div><div class="line" id="192119"><span class="nick" style="color:#d9d9d9"><a href="#192119" label="[19:21:19]">&lt;davidak[m]&gt;</a></span><span class="message">would it make sense to use GUIX to build the bootstrap seed for other distributions as a cheap option for a verifiable seed until they implement full source bootstrap themselves? e.g. nixpkgs uses this to build the seed (contains coreutils, bash, busybox, gnutar, binutils, GCC ... with disabled features) <a rel="nofollow" href="https://github.com/NixOS/nixpkgs/blob/50a11f4f4301b9b4cb1f3041fca4f2e71a73d4a5/pkgs/stdenv/linux/make-bootstrap-tools.nix">https://github.com/NixOS/nixpkgs/blob/50a11f4f4301b9b4cb1f3041fca4f2e71a73d4a5/pkgs/stdenv/linux/make-bootstrap-tools.nix</a> </span></div><div class="line" id="192250"><span class="nick" style="color:#8dd3c7"><a href="#192250" label="[19:22:50]">&lt;unmatched-paren&gt;</a></span><span class="message">muurkha: seems like most of the criticisms in bwk's article do not apply to modern Pascals</span></div><div class="line" id="192311"><span class="nick" style="color:#8dd3c7"><a href="#192311" label="[19:23:11]">&lt;unmatched-paren&gt;</a></span><span class="message">Borland provides `array of foo`</span></div><div class="line" id="192325"><span class="nick" style="color:#8dd3c7"><a href="#192325" label="[19:23:25]">&lt;unmatched-paren&gt;</a></span><span class="message">instead of `array [x..y] of foo`</span></div><div class="line" id="192443"><span class="nick" style="color:#8dd3c7"><a href="#192443" label="[19:24:43]">&lt;unmatched-paren&gt;</a></span><span class="message">funny how he gives &quot;there is no macro processor&quot; as a problem :P</span></div><div class="line" id="192452"><span class="nick" style="color:#8dd3c7"><a href="#192452" label="[19:24:52]">&lt;unmatched-paren&gt;</a></span><span class="message">though i think one does exist in Borland Pascal</span></div><div class="line" id="192602"><span class="nick" style="color:#8dd3c7"><a href="#192602" label="[19:26:02]">&lt;unmatched-paren&gt;</a></span><span class="message">{$...} comments are eaten by the preprocessor</span></div><div class="line" id="192614"><span class="nick" style="color:#8dd3c7"><a href="#192614" label="[19:26:14]">&lt;unmatched-paren&gt;</a></span><span class="message">&quot;Because the language is so impotent, it must be extended.  But each group extends Pascal in its own direction, to make it look like whatever language they really want.  Extensions for separate compilation, Fortran-like COMMON, string data types, internal static variables, initialization, octal numbers, bit operators, etc., all add to the utility of the language for one group, but destroy its portability to others.</span></div><div class="line" id="200240"><span class="nick" style="color:#80b1d3"><a href="#200240" label="[20:02:40]">&lt;muurkha&gt;</a></span><span class="message">unmatched-paren: they do not</span></div><div class="line" id="200710"><span class="nick" style="color:#389600"><a href="#200710" label="[20:07:10]">&lt;stikonas&gt;</a></span><span class="message">davidak[m]: depending on your requirements, it might be easier to you live-bootstrap for your seed for other distros</span></div><div class="line" id="200739"><span class="nick" style="color:#389600"><a href="#200739" label="[20:07:39]">&lt;stikonas&gt;</a></span><span class="message">it should be more reproducible than guix outputs</span></div><div class="line" id="200815"><span class="nick" style="color:#389600"><a href="#200815" label="[20:08:15]">&lt;stikonas&gt;</a></span><span class="message">though if you need non-x86 binaries, then guix is your best bet for now</span></div><div class="line" id="202947"><span class="nick" style="color:#2e2a4a"><a href="#202947" label="[20:29:47]">&lt;littlebobeep&gt;</a></span><span class="message">stikonas: what about cross-compiling ?</span></div><div class="line" id="203108"><span class="nick" style="color:#6b8072"><a href="#203108" label="[20:31:08]">&lt;stikonas[m]&gt;</a></span><span class="message">Yes, you can cross compile everything from x86</span></div><div class="line" id="203140"><span class="nick" style="color:#6b8072"><a href="#203140" label="[20:31:40]">&lt;stikonas[m]&gt;</a></span><span class="message">But we don't have any of that scripted</span></div><div class="line" id="203201"><span class="nick" style="color:#6b8072"><a href="#203201" label="[20:32:01]">&lt;stikonas[m]&gt;</a></span><span class="message">But yes, that would work</span></div><div class="line" id="203247"><span class="nick" style="color:#234e69"><a href="#203247" label="[20:32:47]">*</a></span><span class="message">littlebobeep doesn't know a better path for aarch64</span></div><div class="line" id="203321"><span class="nick" style="color:#6b8072"><a href="#203321" label="[20:33:21]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, nothing better until mes-&gt;tcc step is done on aarch63</span></div><div class="line" id="203711"><span class="nick" style="color:#2e2a4a"><a href="#203711" label="[20:37:11]">&lt;littlebobeep&gt;</a></span><span class="message">Mes can be compiled on aarch64 right?  Just mescc needs to support it?</span></div><div class="line" id="204442"><span class="nick" style="color:#6b8072"><a href="#204442" label="[20:44:42]">&lt;stikonas[m]&gt;</a></span><span class="message">mescc might already be working on aarch64</span></div><div class="line" id="204452"><span class="nick" style="color:#6b8072"><a href="#204452" label="[20:44:52]">&lt;stikonas[m]&gt;</a></span><span class="message">It's tcc that doesn't</span></div><div class="line" id="204536"><span class="nick" style="color:#6b8072"><a href="#204536" label="[20:45:36]">&lt;stikonas[m]&gt;</a></span><span class="message">OK, only arm32 is supported on mes</span></div><div class="line" id="204630"><span class="nick" style="color:#8dd3c7"><a href="#204630" label="[20:46:30]">&lt;unmatched-paren&gt;</a></span><span class="message">i think tcc has an aarch port somewhere? probably mistaken as usual though</span></div><div class="line" id="204724"><span class="nick" style="color:#6b8072"><a href="#204724" label="[20:47:24]">&lt;stikonas[m]&gt;</a></span><span class="message">tcc 0.9.27 has</span></div><div class="line" id="204733"><span class="nick" style="color:#6b8072"><a href="#204733" label="[20:47:33]">&lt;stikonas[m]&gt;</a></span><span class="message">mescc can't build it</span></div><div class="line" id="204749"><span class="nick" style="color:#6b8072"><a href="#204749" label="[20:47:49]">&lt;stikonas[m]&gt;</a></span><span class="message">Only ancient 0.9.26</span></div><div class="line" id="204804"><span class="nick" style="color:#8dd3c7"><a href="#204804" label="[20:48:04]">&lt;unmatched-paren&gt;</a></span><span class="message">i see</span></div><div class="line" id="204805"><span class="nick" style="color:#6b8072"><a href="#204805" label="[20:48:05]">&lt;stikonas[m]&gt;</a></span><span class="message">And even that one is patched</span></div><div class="line" id="204813"><span class="nick" style="color:#2e2a4a"><a href="#204813" label="[20:48:13]">&lt;littlebobeep&gt;</a></span><span class="message">haha one subpoint release back makes it ancient?</span></div><div class="line" id="204820"><span class="nick" style="color:#8dd3c7"><a href="#204820" label="[20:48:20]">&lt;unmatched-paren&gt;</a></span><span class="message">you could build tcc 0.9.27 with 0.9.26 couldn't you?</span></div><div class="line" id="204830"><span class="nick" style="color:#8dd3c7"><a href="#204830" label="[20:48:30]">&lt;unmatched-paren&gt;</a></span><span class="message">then use that to cross-compile to aarch</span></div><div class="line" id="204858"><span class="nick" style="color:#6b8072"><a href="#204858" label="[20:48:58]">&lt;stikonas[m]&gt;</a></span><span class="message">Then just cross-compile once you have GCC...</span></div><div class="line" id="204918"><span class="nick" style="color:#6b8072"><a href="#204918" label="[20:49:18]">&lt;stikonas[m]&gt;</a></span><span class="message">littlebobeep: tcc releases are like every 5 years</span></div><div class="line" id="204929"><span class="nick" style="color:#8dd3c7"><a href="#204929" label="[20:49:29]">&lt;unmatched-paren&gt;</a></span><span class="message">oh, you can't cross-compile at that point?</span></div><div class="line" id="204931"><span class="nick" style="color:#8dd3c7"><a href="#204931" label="[20:49:31]">&lt;unmatched-paren&gt;</a></span><span class="message">i see</span></div><div class="line" id="204955"><span class="nick" style="color:#6b8072"><a href="#204955" label="[20:49:55]">&lt;stikonas[m]&gt;</a></span><span class="message">26 is from 2013</span></div><div class="line" id="205008"><span class="nick" style="color:#234e69"><a href="#205008" label="[20:50:08]">*</a></span><span class="message">unmatched-paren also just realizes that the question is about building it all on aarch and feels stupid :P</span></div><div class="line" id="205029"><span class="nick" style="color:#6b8072"><a href="#205029" label="[20:50:29]">&lt;stikonas[m]&gt;</a></span><span class="message">You can cross-compile then but you can just as well wait...</span></div><div class="line" id="205802"><span class="nick" style="color:#6b8072"><a href="#205802" label="[20:58:02]">&lt;doras&gt;</a></span><span class="message">Does anyone mind reviewing <a rel="nofollow" href="https://github.com/fosslinux/live-bootstrap/pull/161?">https://github.com/fosslinux/live-bootstrap/pull/161?</a> </span></div><div class="line" id="205839"><span class="nick" style="color:#6b8072"><a href="#205839" label="[20:58:39]">&lt;doras&gt;</a></span><span class="message">I think it's pretty noncontroversial.</span></div><div class="line" id="210352"><span class="nick" style="color:#bc80bd"><a href="#210352" label="[21:03:52]">&lt;Hagfish&gt;</a></span><span class="message">+7 −7</span></div><div class="line" id="210359"><span class="nick" style="color:#bc80bd"><a href="#210359" label="[21:03:59]">&lt;Hagfish&gt;</a></span><span class="message">perfectly balanced, as all things should be</span></div><div class="line" id="210609"><span class="nick" style="color:#6b8072"><a href="#210609" label="[21:06:09]">&lt;doras&gt;</a></span><span class="message">;)</span></div><div class="line" id="214218"><span class="nick" style="color:#389600"><a href="#214218" label="[21:42:18]">&lt;stikonas&gt;</a></span><span class="message">doras: yes, looks good</span></div><div class="line" id="215509"><span class="nick" style="color:#389600"><a href="#215509" label="[21:55:09]">&lt;stikonas&gt;</a></span><span class="message">doras: merged</span></div><div class="line" id="215528"><span class="nick" style="color:#389600"><a href="#215528" label="[21:55:28]">&lt;stikonas&gt;</a></span><span class="message">I'll probably leave the other PR for fossy to merge</span></div><div class="line" id="221810"><span class="nick" style="color:#6b8072"><a href="#221810" label="[22:18:10]">&lt;doras&gt;</a></span><span class="message">Thanks, stikonas @stikonas:libera.chat.</span></div><div class="line" id="235124"><span class="nick" style="color:#2e2a4a"><a href="#235124" label="[23:51:24]">&lt;oriansj&gt;</a></span><span class="message">muurkha: interesting perspective. especially when it has less types than C (no unsigned nor long) but one would hope the fixed string flaw could have been skipped.</span></div><div class="line" id="235239"><span class="nick" style="color:#2e2a4a"><a href="#235239" label="[23:52:39]">&lt;oriansj&gt;</a></span><span class="message">Hagfish: yeah that is a clever hack but notice its limits.</span></div><br /></div></body></html>