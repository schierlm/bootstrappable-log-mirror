<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2021-01-25.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="002603"><span class="nick" style="color:#8dd3c7"><a href="#002603" label="[00:26:03]">&lt;stikonas&gt;</a></span><span class="message">fossy: so the remaining problem is probably caused by L prefix before strings</span></div><div class="line" id="002617"><span class="nick" style="color:#8dd3c7"><a href="#002617" label="[00:26:17]">&lt;stikonas&gt;</a></span><span class="message">when operating on chars</span></div><div class="line" id="002627"><span class="nick" style="color:#8dd3c7"><a href="#002627" label="[00:26:27]">&lt;stikonas&gt;</a></span><span class="message">on char strings</span></div><div class="line" id="002628"><span class="nick" style="color:#8dd3c7"><a href="#002628" label="[00:26:28]">&lt;stikonas&gt;</a></span><span class="message">it only keeps first character</span></div><div class="line" id="002702"><span class="nick" style="color:#8dd3c7"><a href="#002702" label="[00:27:02]">&lt;stikonas&gt;</a></span><span class="message">fossy: I can try to catch all unnecessary L prefixes in yacc and patch them out...</span></div><div class="line" id="002725"><span class="nick" style="color:#2e2a4a"><a href="#002725" label="[00:27:25]">&lt;fossy&gt;</a></span><span class="message">L prefix is borked in yacc?</span></div><div class="line" id="002909"><span class="nick" style="color:#8dd3c7"><a href="#002909" label="[00:29:09]">&lt;stikonas&gt;</a></span><span class="message">well, maybe in mes libc?</span></div><div class="line" id="002913"><span class="nick" style="color:#8dd3c7"><a href="#002913" label="[00:29:13]">&lt;stikonas&gt;</a></span><span class="message">not sure where...</span></div><div class="line" id="002922"><span class="nick" style="color:#8dd3c7"><a href="#002922" label="[00:29:22]">&lt;stikonas&gt;</a></span><span class="message">even without yacc, I can reproduce that issue</span></div><div class="line" id="003007"><span class="nick" style="color:#8dd3c7"><a href="#003007" label="[00:30:07]">&lt;stikonas&gt;</a></span><span class="message">fossy: <a rel="nofollow" href="https://paste.debian.net/1182631/">https://paste.debian.net/1182631/</a>  prints only t</span></div><div class="line" id="003331"><span class="nick" style="color:#8dd3c7"><a href="#003331" label="[00:33:31]">&lt;stikonas&gt;</a></span><span class="message">if you don't see any nicer solution, I can try to go over them one by one...</span></div><div class="line" id="014936"><span class="nick" style="color:#8dd3c7"><a href="#014936" label="[01:49:36]">&lt;stikonas&gt;</a></span><span class="message">hmm, I think fprintf just refuses to work on wchars...</span></div><div class="line" id="015013"><span class="nick" style="color:#8dd3c7"><a href="#015013" label="[01:50:13]">&lt;stikonas&gt;</a></span><span class="message">fossy: I think we'll have to rename wchar_t -&gt; char</span></div><div class="line" id="015332"><span class="nick" style="color:#8dd3c7"><a href="#015332" label="[01:53:32]">&lt;stikonas&gt;</a></span><span class="message">or maybe easier to write a function to convert wide string to string</span></div><div class="line" id="021243"><span class="nick" style="color:#6b8072"><a href="#021243" label="[02:12:43]">&lt;xentrac&gt;</a></span><span class="message">stikonas: according to <a rel="nofollow" href="https://www.gnu.org/software/libc/manual/html_node/Extended-Char-Intro.html">https://www.gnu.org/software/libc/manual/html_node/Extended-Char-Intro.html</a>  it is totally valid and standards-compliant to define wchar_t as char</span></div><div class="line" id="021358"><span class="nick" style="color:#6b8072"><a href="#021358" label="[02:13:58]">&lt;xentrac&gt;</a></span><span class="message">in other bootstrapping news I ran across <a rel="nofollow" href="https://insights.sei.cmu.edu/sei_blog/2019/10/how-to-build-a-trustworthy-freelibre-linux-capable-64-bit-risc-v-computer.html">https://insights.sei.cmu.edu/sei_blog/2019/10/how-to-build-a-trustworthy-freelibre-linux-capable-64-bit-risc-v-computer.html</a>  about bringing up Rocket Chip on an FPGA board in order to defeat Karger-Thompson attacks</span></div><div class="line" id="021428"><span class="nick" style="color:#6b8072"><a href="#021428" label="[02:14:28]">&lt;xentrac&gt;</a></span><span class="message">and also OpenTitan: <a rel="nofollow" href="https://www.lowrisc.org/">https://www.lowrisc.org/</a> </span></div><div class="line" id="021447"><span class="nick" style="color:#6b8072"><a href="#021447" label="[02:14:47]">&lt;xentrac&gt;</a></span><span class="message">the “first transparent silicon root of trust”</span></div><div class="line" id="021456"><span class="nick" style="color:#6b8072"><a href="#021456" label="[02:14:56]">&lt;xentrac&gt;</a></span><span class="message">so things are really starting to come together</span></div><div class="line" id="021512"><span class="nick" style="color:#6b8072"><a href="#021512" label="[02:15:12]">&lt;xentrac&gt;</a></span><span class="message">those are RISC-V, which is confusingly totally unrelated to Wirth's RISC5</span></div><div class="line" id="021601"><span class="nick" style="color:#8dd3c7"><a href="#021601" label="[02:16:01]">&lt;stikonas&gt;</a></span><span class="message">xentrac: well, it's totally valid, but I think mes libc chokes on something...</span></div><div class="line" id="021606"><span class="nick" style="color:#8dd3c7"><a href="#021606" label="[02:16:06]">&lt;stikonas&gt;</a></span><span class="message">and a bit hard to tell what exactly</span></div><div class="line" id="021613"><span class="nick" style="color:#80b1d3"><a href="#021613" label="[02:16:13]">&lt;pabs3&gt;</a></span><span class="message">this reminds me of Precursor <a rel="nofollow" href="https://www.bunniestudios.com/blog/?cat=71">https://www.bunniestudios.com/blog/?cat=71</a> </span></div><div class="line" id="021626"><span class="nick" style="color:#8dd3c7"><a href="#021626" label="[02:16:26]">&lt;stikonas&gt;</a></span><span class="message">somehow tokens that yacc reads and up only 1 byte in size...</span></div><div class="line" id="021632"><span class="nick" style="color:#8dd3c7"><a href="#021632" label="[02:16:32]">&lt;stikonas&gt;</a></span><span class="message">rest is truncated</span></div><div class="line" id="022103"><span class="nick" style="color:#6b8072"><a href="#022103" label="[02:21:03]">&lt;xentrac&gt;</a></span><span class="message">pabs3: yes, <a rel="nofollow" href="https://www.bunniestudios.com/blog/?p=5706">https://www.bunniestudios.com/blog/?p=5706</a>  doesn't talk about what CPU core he wants to use; does he mention it anywhere?</span></div><div class="line" id="022121"><span class="nick" style="color:#6b8072"><a href="#022121" label="[02:21:21]">&lt;xentrac&gt;</a></span><span class="message">ah yes</span></div><div class="line" id="022132"><span class="nick" style="color:#6b8072"><a href="#022132" label="[02:21:32]">&lt;xentrac&gt;</a></span><span class="message">&quot;The “Core Complex” currently consists of one RISC-V core, implemented using Charles Papon’s VexRiscV&quot;</span></div><div class="line" id="022319"><span class="nick" style="color:#6b8072"><a href="#022319" label="[02:23:19]">&lt;xentrac&gt;</a></span><span class="message">in <a rel="nofollow" href="https://www.bunniestudios.com/blog/?p=5971">https://www.bunniestudios.com/blog/?p=5971</a> </span></div><div class="line" id="022342"><span class="nick" style="color:#80b1d3"><a href="#022342" label="[02:23:42]">&lt;pabs3&gt;</a></span><span class="message">yep, there is a block diagram on that page</span></div><div class="line" id="022406"><span class="nick" style="color:#6b8072"><a href="#022406" label="[02:24:06]">&lt;xentrac&gt;</a></span><span class="message">RISC-V is astoundingly less complex than modern CPUs.  the full architecture manual is about 300 pages, about the same as a Z80</span></div><div class="line" id="022422"><span class="nick" style="color:#6b8072"><a href="#022422" label="[02:24:22]">&lt;xentrac&gt;</a></span><span class="message">I mean, than more popular modern CPUs</span></div><div class="line" id="022513"><span class="nick" style="color:#6b8072"><a href="#022513" label="[02:25:13]">&lt;xentrac&gt;</a></span><span class="message">and a significant chunk of that is floating-point stuff that they've configured out of their &quot;RV32IMAC&quot; (RISC-V 32-bit with integer, multiply, atomic, and compressed instructions)</span></div><div class="line" id="030757"><span class="nick" style="color:#6b8072"><a href="#030757" label="[03:07:57]">&lt;xentrac&gt;</a></span><span class="message">for better or worse, lowRISC's OpenTitan is derived from Google's Titan chip</span></div><div class="line" id="033930"><span class="nick" style="color:#6d2462"><a href="#033930" label="[03:39:30]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: but bootstrapping RISC-V is going to be a bitch</span></div><div class="line" id="034037"><span class="nick" style="color:#6d2462"><a href="#034037" label="[03:40:37]">&lt;OriansJ&gt;</a></span><span class="message">The instruction encoding looks like a massive grad student orgy of questionable optimizations.</span></div><div class="line" id="034130"><span class="nick" style="color:#6d2462"><a href="#034130" label="[03:41:30]">&lt;OriansJ&gt;</a></span><span class="message">because you know immediates should be compressed and broken into 5 difference pieces inside of a 32bit word.</span></div><div class="line" id="034340"><span class="nick" style="color:#6d2462"><a href="#034340" label="[03:43:40]">&lt;OriansJ&gt;</a></span><span class="message">I think, we will have to duplicate the AArch64 hack and just do load/skips with immediates. It'll triple the instruction size to 12bytes to load an 8bit number but hey atleast RISC-V has such a cool and novel optimization for supporting immediates.</span></div><div class="line" id="034446"><span class="nick" style="color:#6d2462"><a href="#034446" label="[03:44:46]">&lt;OriansJ&gt;</a></span><span class="message">Instead of just dropping a byte for encoding, supporting multiples of 16bits for instructions and having 48bit instructions to support 32bit immediates.</span></div><div class="line" id="040214"><span class="nick" style="color:#234e69"><a href="#040214" label="[04:02:14]">&lt;siraben&gt;</a></span><span class="message">I died at &quot;massive grad student orgy&quot;</span></div><div class="line" id="040703"><span class="nick" style="color:#6b8072"><a href="#040703" label="[04:07:03]">&lt;xentrac&gt;</a></span><span class="message">yeah, the immediate encoding is pretty hilarious</span></div><div class="line" id="040751"><span class="nick" style="color:#6b8072"><a href="#040751" label="[04:07:51]">&lt;xentrac&gt;</a></span><span class="message">it turns out that what's efficient to support in hardware is not always what's easy to generate code for in software (or decode in a software emulator)</span></div><div class="line" id="040829"><span class="nick" style="color:#6b8072"><a href="#040829" label="[04:08:29]">&lt;xentrac&gt;</a></span><span class="message">the instruction set manual almost apologizes for what it describes as a &quot;scrambled&quot; encoding</span></div><div class="line" id="040855"><span class="nick" style="color:#6b8072"><a href="#040855" label="[04:08:55]">&lt;xentrac&gt;</a></span><span class="message">OTOH it only has six instruction word layouts, which is more than Wirth-the-RISC or x18, but less than anything else</span></div><div class="line" id="040932"><span class="nick" style="color:#6b8072"><a href="#040932" label="[04:09:32]">&lt;xentrac&gt;</a></span><span class="message">well, almost.  8080 and 6502 do beat it on that axis :)</span></div><div class="line" id="041129"><span class="nick" style="color:#6b8072"><a href="#041129" label="[04:11:29]">&lt;xentrac&gt;</a></span><span class="message">but it's equivalent to, say, Z80, and simpler than 8086</span></div><div class="line" id="041218"><span class="nick" style="color:#234e69"><a href="#041218" label="[04:12:18]">&lt;siraben&gt;</a></span><span class="message">Z80 assembler in Scheme, anyone? <a rel="nofollow" href="https://github.com/siraben/zkeme80/blob/master/src/assembler.scm">https://github.com/siraben/zkeme80/blob/master/src/assembler.scm</a> </span></div><div class="line" id="041229"><span class="nick" style="color:#234e69"><a href="#041229" label="[04:12:29]">&lt;siraben&gt;</a></span><span class="message">Runs with Guile</span></div><div class="line" id="041301"><span class="nick" style="color:#234e69"><a href="#041301" label="[04:13:01]">&lt;siraben&gt;</a></span><span class="message">other Z80 assemblers were so limited in their macro systems I gave up and wrote my own assembler</span></div><div class="line" id="041333"><span class="nick" style="color:#6b8072"><a href="#041333" label="[04:13:33]">&lt;xentrac&gt;</a></span><span class="message">I don't think the optimizations are actually questionable; VexRiscv fits in just over 500 flip-flops and just over 500 LUTs, which I think is actually smaller than the J1A: <a rel="nofollow" href="https://github.com/jamesbowman/swapforth/tree/master/j1a">https://github.com/jamesbowman/swapforth/tree/master/j1a</a> </span></div><div class="line" id="041347"><span class="nick" style="color:#6b8072"><a href="#041347" label="[04:13:47]">&lt;xentrac&gt;</a></span><span class="message">yeah, that's a good idea, siraben</span></div><div class="line" id="041428"><span class="nick" style="color:#6b8072"><a href="#041428" label="[04:14:28]">&lt;xentrac&gt;</a></span><span class="message">that reminds me, you'd probably enjoy <a rel="nofollow" href="http://research.microsoft.com/en-us/um/people/nick/coqasm.pdf">http://research.microsoft.com/en-us/um/people/nick/coqasm.pdf</a>,  siraben</span></div><div class="line" id="041435"><span class="nick" style="color:#6b8072"><a href="#041435" label="[04:14:35]">&lt;xentrac&gt;</a></span><span class="message">if you haven't seen it previously</span></div><div class="line" id="041518"><span class="nick" style="color:#234e69"><a href="#041518" label="[04:15:18]">&lt;siraben&gt;</a></span><span class="message">Every time I try to read a Coq paper I feel so dumb hehe</span></div><div class="line" id="041536"><span class="nick" style="color:#6b8072"><a href="#041536" label="[04:15:36]">&lt;xentrac&gt;</a></span><span class="message">OriansJ: I think the &quot;grad student&quot; in question was probably David Patterson, the co-author of Hennessy and Patterson, and the optimizations were validated by a series of full-custom chips in the 02011-02014 time frame</span></div><div class="line" id="041537"><span class="nick" style="color:#234e69"><a href="#041537" label="[04:15:37]">&lt;siraben&gt;</a></span><span class="message">Oh doesn't seem too bad, nice</span></div><div class="line" id="041544"><span class="nick" style="color:#6b8072"><a href="#041544" label="[04:15:44]">&lt;xentrac&gt;</a></span><span class="message">yeah, I have the same problem in general ;)</span></div><div class="line" id="041618"><span class="nick" style="color:#234e69"><a href="#041618" label="[04:16:18]">&lt;siraben&gt;</a></span><span class="message">one day we'll get bootstrapped Coq, that'll be cool</span></div><div class="line" id="041702"><span class="nick" style="color:#6b8072"><a href="#041702" label="[04:17:02]">&lt;xentrac&gt;</a></span><span class="message">well, Metamath is moving aggressively toward such a goal: <a rel="nofollow" href="https://arxiv.org/abs/1907.01283">https://arxiv.org/abs/1907.01283</a> </span></div><div class="line" id="042121"><span class="nick" style="color:#234e69"><a href="#042121" label="[04:21:21]">&lt;siraben&gt;</a></span><span class="message">Right. What's the basis behind Metamath's logic anyway? Isn't it purely based on string-rewriting?</span></div><div class="line" id="042852"><span class="nick" style="color:#6b8072"><a href="#042852" label="[04:28:52]">&lt;xentrac&gt;</a></span><span class="message">I think it's tree-rewriting, but I don't really know</span></div><div class="line" id="042902"><span class="nick" style="color:#6b8072"><a href="#042902" label="[04:29:02]">&lt;xentrac&gt;</a></span><span class="message">I'm pretty ignorant about logic</span></div><div class="line" id="043005"><span class="nick" style="color:#234e69"><a href="#043005" label="[04:30:05]">&lt;siraben&gt;</a></span><span class="message">I'm taking logic this semester, interesting class</span></div><div class="line" id="043020"><span class="nick" style="color:#6b8072"><a href="#043020" label="[04:30:20]">&lt;xentrac&gt;</a></span><span class="message">the crucial thing, though, is that the *verifier* is extremely simple, just verifying that the steps in the (potentially voluminous) proof, produced by whatever means, are valid</span></div><div class="line" id="043031"><span class="nick" style="color:#234e69"><a href="#043031" label="[04:30:31]">&lt;siraben&gt;</a></span><span class="message">Yes</span></div><div class="line" id="043038"><span class="nick" style="color:#6d2462"><a href="#043038" label="[04:30:38]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well there is a big difference between  optimizing for benchmarks and having a clean design.</span></div><div class="line" id="043052"><span class="nick" style="color:#234e69"><a href="#043052" label="[04:30:52]">&lt;siraben&gt;</a></span><span class="message">OriansJ: RISC-V would be the former?</span></div><div class="line" id="043108"><span class="nick" style="color:#6d2462"><a href="#043108" label="[04:31:08]">&lt;OriansJ&gt;</a></span><span class="message">and Patterson clearly optimized for synthetic benchmarks</span></div><div class="line" id="043110"><span class="nick" style="color:#234e69"><a href="#043110" label="[04:31:10]">&lt;siraben&gt;</a></span><span class="message">or rather, x86 is 100% guilty of this</span></div><div class="line" id="043112"><span class="nick" style="color:#6b8072"><a href="#043112" label="[04:31:12]">&lt;xentrac&gt;</a></span><span class="message">it's a compromise</span></div><div class="line" id="043127"><span class="nick" style="color:#6b8072"><a href="#043127" label="[04:31:27]">&lt;xentrac&gt;</a></span><span class="message">why do you think the benchmarks the team optimized for were synthetic?</span></div><div class="line" id="043133"><span class="nick" style="color:#234e69"><a href="#043133" label="[04:31:33]">&lt;siraben&gt;</a></span><span class="message">What about ARM, IIRC it has a pretty uniform encoding right?</span></div><div class="line" id="043157"><span class="nick" style="color:#6b8072"><a href="#043157" label="[04:31:57]">&lt;xentrac&gt;</a></span><span class="message">ARM1 yeah</span></div><div class="line" id="043208"><span class="nick" style="color:#6b8072"><a href="#043208" label="[04:32:08]">&lt;xentrac&gt;</a></span><span class="message">although it still had things like LDM and STM IIRC</span></div><div class="line" id="043218"><span class="nick" style="color:#6d2462"><a href="#043218" label="[04:32:18]">&lt;OriansJ&gt;</a></span><span class="message">siraben: arm7l and earlier had a simple immediate encoding option (thumb and thumb2 not so much)</span></div><div class="line" id="043246"><span class="nick" style="color:#6b8072"><a href="#043246" label="[04:32:46]">&lt;xentrac&gt;</a></span><span class="message">and having condition code flags at all kind of makes ARM a lot more complicated than RISC-V</span></div><div class="line" id="043325"><span class="nick" style="color:#6d2462"><a href="#043325" label="[04:33:25]">&lt;OriansJ&gt;</a></span><span class="message">and honestly if they just did their encoding for their instructions in big endian, I would have been singing its praises when bootstrapping.</span></div><div class="line" id="043331"><span class="nick" style="color:#6b8072"><a href="#043331" label="[04:33:31]">&lt;xentrac&gt;</a></span><span class="message">(even in the versions where you don't have universal instruction predication)</span></div><div class="line" id="043410"><span class="nick" style="color:#6d2462"><a href="#043410" label="[04:34:10]">&lt;OriansJ&gt;</a></span><span class="message">the 4bit condition code Isn't a bootstrapping problem at all</span></div><div class="line" id="043426"><span class="nick" style="color:#6d2462"><a href="#043426" label="[04:34:26]">&lt;OriansJ&gt;</a></span><span class="message">where they put it is awkward</span></div><div class="line" id="043512"><span class="nick" style="color:#6d2462"><a href="#043512" label="[04:35:12]">&lt;OriansJ&gt;</a></span><span class="message">but big endian bytes mixed with little endian words is gonna be ugly</span></div><div class="line" id="043524"><span class="nick" style="color:#6d2462"><a href="#043524" label="[04:35:24]">&lt;OriansJ&gt;</a></span><span class="message">but I guess we can blame MOS 6502 for that</span></div><div class="line" id="043534"><span class="nick" style="color:#6b8072"><a href="#043534" label="[04:35:34]">&lt;xentrac&gt;</a></span><span class="message">but arm7tdmi, for example, has 16 different instruction word layouts</span></div><div class="line" id="043550"><span class="nick" style="color:#6d2462"><a href="#043550" label="[04:35:50]">&lt;OriansJ&gt;</a></span><span class="message">as ARM opted for little endian words because of it</span></div><div class="line" id="043638"><span class="nick" style="color:#6b8072"><a href="#043638" label="[04:36:38]">&lt;xentrac&gt;</a></span><span class="message">but a lot of those instruction formats were added after the initial ARM design</span></div><div class="line" id="043824"><span class="nick" style="color:#6b8072"><a href="#043824" label="[04:38:24]">&lt;xentrac&gt;</a></span><span class="message">it's true, though, that only one of those 16 chopped up its immediates into apparently random chunks scattered through the instruction word, the way RISC-V does</span></div><div class="line" id="044007"><span class="nick" style="color:#6d2462"><a href="#044007" label="[04:40:07]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: well studies done on human written assembly indiciated 12bits of immediate are sufficient for 80% of all immediates and 16bits for 95%</span></div><div class="line" id="044050"><span class="nick" style="color:#6d2462"><a href="#044050" label="[04:40:50]">&lt;OriansJ&gt;</a></span><span class="message">I could deal with a 12bit immediate in M1 just fine</span></div><div class="line" id="044053"><span class="nick" style="color:#6b8072"><a href="#044053" label="[04:40:53]">&lt;xentrac&gt;</a></span><span class="message">(this being the immediate form of the ldhr/strh/ldrsb/ldrsh instructions, which has an 8-bit offset broken into two pieces with some opcode bits between them)</span></div><div class="line" id="044122"><span class="nick" style="color:#6d2462"><a href="#044122" label="[04:41:22]">&lt;OriansJ&gt;</a></span><span class="message">4bit shift and 8bit immediate also is easy in M1</span></div><div class="line" id="044212"><span class="nick" style="color:#6b8072"><a href="#044212" label="[04:42:12]">&lt;xentrac&gt;</a></span><span class="message">yeah, I thought RISC-V's choice to separate loadhi/loadlo into a 20-bit high and 12-bit low was pretty surprising, but the RISC-V manual explained it in something like those terms</span></div><div class="line" id="044227"><span class="nick" style="color:#6d2462"><a href="#044227" label="[04:42:27]">&lt;OriansJ&gt;</a></span><span class="message">'4' !9 =&gt; boom we are happy</span></div><div class="line" id="044301"><span class="nick" style="color:#6b8072"><a href="#044301" label="[04:43:01]">&lt;xentrac&gt;</a></span><span class="message">M1 as in M1-macro?</span></div><div class="line" id="044327"><span class="nick" style="color:#6d2462"><a href="#044327" label="[04:43:27]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: yes, I am expressing bootstrapping encodings for immediates</span></div><div class="line" id="044340"><span class="nick" style="color:#6d2462"><a href="#044340" label="[04:43:40]">&lt;OriansJ&gt;</a></span><span class="message">which are reasonable</span></div><div class="line" id="044351"><span class="nick" style="color:#6b8072"><a href="#044351" label="[04:43:51]">&lt;xentrac&gt;</a></span><span class="message">yeah, definitely RISC-V's bit-swizzling is an extra pain there</span></div><div class="line" id="044415"><span class="nick" style="color:#6d2462"><a href="#044415" label="[04:44:15]">&lt;OriansJ&gt;</a></span><span class="message">coldfire actually looks like they learned better</span></div><div class="line" id="044422"><span class="nick" style="color:#6b8072"><a href="#044422" label="[04:44:22]">&lt;xentrac&gt;</a></span><span class="message">but it will pay dividends when you're wiring up discrete logic chips I suspect</span></div><div class="line" id="044505"><span class="nick" style="color:#6d2462"><a href="#044505" label="[04:45:05]">&lt;OriansJ&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/Freescale_ColdFire">https://en.wikipedia.org/wiki/Freescale_ColdFire</a> </span></div><div class="line" id="044507"><span class="nick" style="color:#6b8072"><a href="#044507" label="[04:45:07]">&lt;xentrac&gt;</a></span><span class="message">what do you mean by &quot;big-endian bytes&quot;?</span></div><div class="line" id="044714"><span class="nick" style="color:#6d2462"><a href="#044714" label="[04:47:14]">&lt;OriansJ&gt;</a></span><span class="message">01100111 =&gt; is encoded as either 67 or 76</span></div><div class="line" id="044743"><span class="nick" style="color:#6d2462"><a href="#044743" label="[04:47:43]">&lt;OriansJ&gt;</a></span><span class="message">0x67 is big endian</span></div><div class="line" id="044800"><span class="nick" style="color:#6b8072"><a href="#044800" label="[04:48:00]">&lt;xentrac&gt;</a></span><span class="message">what about 0xe6?</span></div><div class="line" id="044812"><span class="nick" style="color:#6b8072"><a href="#044812" label="[04:48:12]">&lt;xentrac&gt;</a></span><span class="message">I'd say 0x76 is nibble-swapped</span></div><div class="line" id="044825"><span class="nick" style="color:#6d2462"><a href="#044825" label="[04:48:25]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: you are correct</span></div><div class="line" id="044841"><span class="nick" style="color:#6d2462"><a href="#044841" label="[04:48:41]">&lt;OriansJ&gt;</a></span><span class="message">I didn't do the  76 right</span></div><div class="line" id="044902"><span class="nick" style="color:#6d2462"><a href="#044902" label="[04:49:02]">&lt;OriansJ&gt;</a></span><span class="message">mostly because little bit endian reads wrong to me</span></div><div class="line" id="044940"><span class="nick" style="color:#6b8072"><a href="#044940" label="[04:49:40]">&lt;xentrac&gt;</a></span><span class="message">generally speaking, though, in any computer since the 1960s, the bits in a byte are arranged along a separate dimension from bytes in memory</span></div><div class="line" id="045008"><span class="nick" style="color:#6b8072"><a href="#045008" label="[04:50:08]">&lt;xentrac&gt;</a></span><span class="message">so the only time it comes up is when you're transmitting bits one at a time, like over SPI or RS-232</span></div><div class="line" id="045049"><span class="nick" style="color:#6b8072"><a href="#045049" label="[04:50:49]">&lt;xentrac&gt;</a></span><span class="message">(bit-serial computers of the 1950s and early 1960s were invariably little-endian, because the alternative was to run an order of magnitude slower)</span></div><div class="line" id="045158"><span class="nick" style="color:#6d2462"><a href="#045158" label="[04:51:58]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: the sins we have commited in the name of performance in synthetic benchmarks</span></div><div class="line" id="045617"><span class="nick" style="color:#6d2462"><a href="#045617" label="[04:56:17]">&lt;OriansJ&gt;</a></span><span class="message">I guess they are easy to miss for those who don't have to write the assembler to support that garbage</span></div><div class="line" id="045816"><span class="nick" style="color:#6d2462"><a href="#045816" label="[04:58:16]">&lt;OriansJ&gt;</a></span><span class="message">Once you think about how to write an assembler in the very assembly language you wish to support. These sort of optimizations vanish like a fart in the wind.</span></div><div class="line" id="050021"><span class="nick" style="color:#6d2462"><a href="#050021" label="[05:00:21]">&lt;OriansJ&gt;</a></span><span class="message">Shit all pre-C code assemblers when having to write an 8bit immediate did; this is 8bits long store8 reg, [address] =&gt; done; need to write a 32bit immediate? store32 reg, [address] =&gt; done.</span></div><div class="line" id="050116"><span class="nick" style="color:#6d2462"><a href="#050116" label="[05:01:16]">&lt;OriansJ&gt;</a></span><span class="message">The only logic you might need is will this fit in 8, 16 or 32bits? and then picking the opcode that can handle that shit.</span></div><div class="line" id="050404"><span class="nick" style="color:#6b8072"><a href="#050404" label="[05:04:04]">&lt;xentrac&gt;</a></span><span class="message">hardware doesn't work that way, though</span></div><div class="line" id="050420"><span class="nick" style="color:#6d2462"><a href="#050420" label="[05:04:20]">&lt;OriansJ&gt;</a></span><span class="message">Not I'm gonna juggle these 8 balls in the air while I gargle this hardware &quot;Architect's&quot; nut sack to gain 0.0001% in a benchark showing you can load immediates into a register faster and then load another immediate without looking at it.</span></div><div class="line" id="050434"><span class="nick" style="color:#6b8072"><a href="#050434" label="[05:04:34]">&lt;xentrac&gt;</a></span><span class="message">haha</span></div><div class="line" id="050440"><span class="nick" style="color:#6b8072"><a href="#050440" label="[05:04:40]">&lt;xentrac&gt;</a></span><span class="message">yeah, that's not the deal</span></div><div class="line" id="050517"><span class="nick" style="color:#6d2462"><a href="#050517" label="[05:05:17]">&lt;OriansJ&gt;</a></span><span class="message">or did you miss the Transmeta benchmark &quot;hack&quot;</span></div><div class="line" id="050550"><span class="nick" style="color:#6d2462"><a href="#050550" label="[05:05:50]">&lt;OriansJ&gt;</a></span><span class="message">which simply optimized out the benchmark entirely and set records doing it</span></div><div class="line" id="050618"><span class="nick" style="color:#6b8072"><a href="#050618" label="[05:06:18]">&lt;xentrac&gt;</a></span><span class="message">in synchronous hardware, which is almost all digital hardware, your clock rate is determined by the longest number of propagation delays to quiescence</span></div><div class="line" id="050643"><span class="nick" style="color:#6b8072"><a href="#050643" label="[05:06:43]">&lt;xentrac&gt;</a></span><span class="message">it doesn't matter if the logic path that's two propagation delays longer is only used in 0.1% of all instructions</span></div><div class="line" id="050702"><span class="nick" style="color:#6b8072"><a href="#050702" label="[05:07:02]">&lt;xentrac&gt;</a></span><span class="message">you pay the cost on every clock cycle</span></div><div class="line" id="050715"><span class="nick" style="color:#6d2462"><a href="#050715" label="[05:07:15]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: or you break it in half</span></div><div class="line" id="050738"><span class="nick" style="color:#6d2462"><a href="#050738" label="[05:07:38]">&lt;OriansJ&gt;</a></span><span class="message">1 clock or 2 clock makes no difference to the programmer.</span></div><div class="line" id="050742"><span class="nick" style="color:#6b8072"><a href="#050742" label="[05:07:42]">&lt;xentrac&gt;</a></span><span class="message">yeah, you may be able to do that, but that means you incur the cost of an extra pipeline stage</span></div><div class="line" id="050809"><span class="nick" style="color:#6d2462"><a href="#050809" label="[05:08:09]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: we have seen 40+ stage pipelines already</span></div><div class="line" id="050816"><span class="nick" style="color:#6b8072"><a href="#050816" label="[05:08:16]">&lt;xentrac&gt;</a></span><span class="message">we're talking about RISC here, so the chip is designed to execute one instruction per clock cycle</span></div><div class="line" id="050839"><span class="nick" style="color:#6b8072"><a href="#050839" label="[05:08:39]">&lt;xentrac&gt;</a></span><span class="message">yeah, you can do 40+ stage pipelines in something like a TPU, but they're useless for general-purpose processors</span></div><div class="line" id="050919"><span class="nick" style="color:#6d2462"><a href="#050919" label="[05:09:19]">&lt;OriansJ&gt;</a></span><span class="message">did you not remember the Intel NetWorst which broke execute into 2 clocks then simply double clock that bit to make up for it?</span></div><div class="line" id="050942"><span class="nick" style="color:#6b8072"><a href="#050942" label="[05:09:42]">&lt;xentrac&gt;</a></span><span class="message">that definitely was not what the RISC-V team was hoping to emulate ;)</span></div><div class="line" id="051029"><span class="nick" style="color:#6b8072"><a href="#051029" label="[05:10:29]">&lt;xentrac&gt;</a></span><span class="message">the bizarre immediate encoding was prompted specifically by the desire to shorten the critical path for immediate-operand sign-extension logic, which apparently is a significant aspect of the critical path</span></div><div class="line" id="051042"><span class="nick" style="color:#6b8072"><a href="#051042" label="[05:10:42]">&lt;xentrac&gt;</a></span><span class="message">with CMOS, the propagation delays get longer when fanout goes up</span></div><div class="line" id="051218"><span class="nick" style="color:#6b8072"><a href="#051218" label="[05:12:18]">&lt;xentrac&gt;</a></span><span class="message">it's true that with a sufficiently complex design you can work around things like that with extra pipeline stages, complex speculation logic, and so on, but for many simple designs, that scrambled immediate encoding probably improves overall processor throughput by something like 10%</span></div><div class="line" id="051228"><span class="nick" style="color:#6d2462"><a href="#051228" label="[05:12:28]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: Implementation problems can be addressed without forcing the rest of the world put up with your crap.</span></div><div class="line" id="051250"><span class="nick" style="color:#6b8072"><a href="#051250" label="[05:12:50]">&lt;xentrac&gt;</a></span><span class="message">and I don't mean on artificial benchmarks, but on all code, because it means you can clock the design 10% faster</span></div><div class="line" id="051321"><span class="nick" style="color:#6b8072"><a href="#051321" label="[05:13:21]">&lt;xentrac&gt;</a></span><span class="message">yes, but there's a cost to addressing implementation problems like that</span></div><div class="line" id="051345"><span class="nick" style="color:#6b8072"><a href="#051345" label="[05:13:45]">&lt;xentrac&gt;</a></span><span class="message">in the majority of ways RISC-V is an eminently boring design</span></div><div class="line" id="051410"><span class="nick" style="color:#6b8072"><a href="#051410" label="[05:14:10]">&lt;xentrac&gt;</a></span><span class="message">in a good way, like C or Golang</span></div><div class="line" id="051418"><span class="nick" style="color:#6b8072"><a href="#051418" label="[05:14:18]">&lt;xentrac&gt;</a></span><span class="message">there are a few places, like the immediate encoding, where they did bizarre things</span></div><div class="line" id="051503"><span class="nick" style="color:#6d2462"><a href="#051503" label="[05:15:03]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: execution trace cache solves the immediate internal encoding vs external immediate encoding  rather quick</span></div><div class="line" id="051512"><span class="nick" style="color:#6b8072"><a href="#051512" label="[05:15:12]">&lt;xentrac&gt;</a></span><span class="message">but most of those turn out to have been carefully considered bizarre things that were worth the cost</span></div><div class="line" id="051555"><span class="nick" style="color:#6b8072"><a href="#051555" label="[05:15:55]">&lt;xentrac&gt;</a></span><span class="message">that's assuming you're doing a Pentium-style decoding into micro-ops in the front-end instruction decode in the first place, though</span></div><div class="line" id="051556"><span class="nick" style="color:#6d2462"><a href="#051556" label="[05:15:56]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: They are punting costs into the software side.</span></div><div class="line" id="051612"><span class="nick" style="color:#6b8072"><a href="#051612" label="[05:16:12]">&lt;xentrac&gt;</a></span><span class="message">and such a front end would be larger than an entire RISC-V core!</span></div><div class="line" id="051619"><span class="nick" style="color:#6d2462"><a href="#051619" label="[05:16:19]">&lt;OriansJ&gt;</a></span><span class="message">and that just makes bootstrapping even harder.</span></div><div class="line" id="051643"><span class="nick" style="color:#6b8072"><a href="#051643" label="[05:16:43]">&lt;xentrac&gt;</a></span><span class="message">well, no; it makes the software part of bootstrapping harder, but it makes the hardware side easier</span></div><div class="line" id="051721"><span class="nick" style="color:#6d2462"><a href="#051721" label="[05:17:21]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: I'll believe it when I see a RISC-V in indivial logic gates on a printed circuit board.</span></div><div class="line" id="051731"><span class="nick" style="color:#6b8072"><a href="#051731" label="[05:17:31]">&lt;xentrac&gt;</a></span><span class="message">the question is on which side it amounts to a larger amount of complexity</span></div><div class="line" id="051817"><span class="nick" style="color:#6d2462"><a href="#051817" label="[05:18:17]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: When I do Knight in Hardware, I'll experiment and let you know</span></div><div class="line" id="051841"><span class="nick" style="color:#6d2462"><a href="#051841" label="[05:18:41]">&lt;OriansJ&gt;</a></span><span class="message">but until then we just have worthless speculation</span></div><div class="line" id="051930"><span class="nick" style="color:#6d2462"><a href="#051930" label="[05:19:30]">&lt;OriansJ&gt;</a></span><span class="message">hell I've seen FORTH CPUs simpler than RISC-V without overly complicated immediate encodings.</span></div><div class="line" id="051953"><span class="nick" style="color:#6b8072"><a href="#051953" label="[05:19:53]">&lt;xentrac&gt;</a></span><span class="message">I mean on the software side we're talking about something like `(imm &amp; 0xfe) &lt;&lt; 20 | (imm &amp; 0x1f) &lt;&lt; 7`</span></div><div class="line" id="052017"><span class="nick" style="color:#6d2462"><a href="#052017" label="[05:20:17]">&lt;OriansJ&gt;</a></span><span class="message">So my feeling (and that is all it is at this point) is that it might make things faster but it sure as shit doesn't make things simpler.</span></div><div class="line" id="052019"><span class="nick" style="color:#6b8072"><a href="#052019" label="[05:20:19]">&lt;xentrac&gt;</a></span><span class="message">well, as I pointed out above, I think VexRiscv is actually fewer LUTs in an FPGA than the J1A</span></div><div class="line" id="052026"><span class="nick" style="color:#6b8072"><a href="#052026" label="[05:20:26]">&lt;xentrac&gt;</a></span><span class="message">but I could be wrong about that</span></div><div class="line" id="052058"><span class="nick" style="color:#6d2462"><a href="#052058" label="[05:20:58]">&lt;OriansJ&gt;</a></span><span class="message">xentrac: as can I but it is late and I have work early tomorrow.</span></div><div class="line" id="052111"><span class="nick" style="color:#6d2462"><a href="#052111" label="[05:21:11]">&lt;OriansJ&gt;</a></span><span class="message">good night</span></div><div class="line" id="052119"><span class="nick" style="color:#6b8072"><a href="#052119" label="[05:21:19]">&lt;xentrac&gt;</a></span><span class="message">Robert Baruch hasn't finished doing it yet: <a rel="nofollow" href="https://hackaday.com/2020/11/09/the-logic-chip-risc-v-project-reboots/">https://hackaday.com/2020/11/09/the-logic-chip-risc-v-project-reboots/</a> </span></div><div class="line" id="052124"><span class="nick" style="color:#6b8072"><a href="#052124" label="[05:21:24]">&lt;xentrac&gt;</a></span><span class="message">goodnight!</span></div><div class="line" id="052254"><span class="nick" style="color:#6b8072"><a href="#052254" label="[05:22:54]">&lt;xentrac&gt;</a></span><span class="message">but &quot;a RISC-V in individual logic gates on a printed circuit board&quot; does seem to be his objective</span></div><div class="line" id="052300"><span class="nick" style="color:#6b8072"><a href="#052300" label="[05:23:00]">&lt;xentrac&gt;</a></span><span class="message">LMARV-1 being the project name</span></div><div class="line" id="052406"><span class="nick" style="color:#6b8072"><a href="#052406" label="[05:24:06]">&lt;xentrac&gt;</a></span><span class="message">I think that as long as there's a minimal acceptable speed, making things faster in one place allows you to make them simpler somewhere else</span></div><div class="line" id="065758"><span class="nick" style="color:#2e2a4a"><a href="#065758" label="[06:57:58]">&lt;fossy&gt;</a></span><span class="message">aww, cute, tcc is segfaulting /s</span></div><div class="line" id="065806"><span class="nick" style="color:#2e2a4a"><a href="#065806" label="[06:58:06]">&lt;fossy&gt;</a></span><span class="message">chokes very very hard on .S files</span></div><div class="line" id="071302"><span class="nick">***</span><span class="message notice">janneke_ is now known as janneke</span></div><div class="line" id="204948"><span class="nick" style="color:#8dd3c7"><a href="#204948" label="[20:49:48]">&lt;stikonas&gt;</a></span><span class="message">gio: in the readme <a rel="nofollow" href="https://gitlab.com/giomasce/nbs/">https://gitlab.com/giomasce/nbs/</a>  you might want to replace boostrapping -&gt; bootstrapping</span></div><div class="line" id="211123"><span class="nick" style="color:#8dd3c7"><a href="#211123" label="[21:11:23]">&lt;stikonas&gt;</a></span><span class="message">fossy: I think my PR is now ready <a rel="nofollow" href="https://github.com/fosslinux/live-bootstrap/pull/19">https://github.com/fosslinux/live-bootstrap/pull/19</a> </span></div><div class="line" id="211136"><span class="nick" style="color:#8dd3c7"><a href="#211136" label="[21:11:36]">&lt;stikonas&gt;</a></span><span class="message">yacc is now fixed and working</span></div><div class="line" id="211143"><span class="nick" style="color:#8dd3c7"><a href="#211143" label="[21:11:43]">&lt;stikonas&gt;</a></span><span class="message">and shouldn't need any more changes</span></div><div class="line" id="211223"><span class="nick" style="color:#8dd3c7"><a href="#211223" label="[21:12:23]">&lt;stikonas&gt;</a></span><span class="message">lex might possibly need some changes to build flex but we can patch it later. At the moment lex itself builds fine</span></div><div class="line" id="214952"><span class="nick" style="color:#6c3d55"><a href="#214952" label="[21:49:52]">&lt;bauen1&gt;</a></span><span class="message">&lt;another brain dump&gt;</span></div><div class="line" id="215149"><span class="nick" style="color:#6c3d55"><a href="#215149" label="[21:51:49]">&lt;bauen1&gt;</a></span><span class="message">so to make reviewing easier (or rather to make review &quot;unecessary&quot;), there should probably be an utility to hash data early in the bootstrap, this way you can remember the hash of some &lt;data&gt; and when you bootstrap again (e.g. after developing some changes) you check / run stage0 by hand, until you have your hash utility, then you use that to verify that the source still matches what you've used</span></div><div class="line" id="215155"><span class="nick" style="color:#6c3d55"><a href="#215155" label="[21:51:55]">&lt;bauen1&gt;</a></span><span class="message">last time</span></div><div class="line" id="215243"><span class="nick" style="color:#8dd3c7"><a href="#215243" label="[21:52:43]">&lt;stikonas&gt;</a></span><span class="message">well, as an additional check I guess it's alright but it in no way guarantees that backdoor is not there</span></div><div class="line" id="215309"><span class="nick" style="color:#6c3d55"><a href="#215309" label="[21:53:09]">&lt;bauen1&gt;</a></span><span class="message">stikonas: how so ?</span></div><div class="line" id="215318"><span class="nick" style="color:#8dd3c7"><a href="#215318" label="[21:53:18]">&lt;stikonas&gt;</a></span><span class="message">if hash is compromised?</span></div><div class="line" id="215430"><span class="nick" style="color:#6c3d55"><a href="#215430" label="[21:54:30]">&lt;bauen1&gt;</a></span><span class="message">stikonas: you still verify stage0 (i.e. hex monitor) up to your hash utility, you need to do this every time and it's therefor important to keep this short ; so unless you've misremebered your hash or messed up already i don't see a way to insert a backdoor</span></div><div class="line" id="215438"><span class="nick" style="color:#8dd3c7"><a href="#215438" label="[21:54:38]">&lt;stikonas&gt;</a></span><span class="message">oh in that case yes</span></div><div class="line" id="215445"><span class="nick" style="color:#8dd3c7"><a href="#215445" label="[21:54:45]">&lt;stikonas&gt;</a></span><span class="message">if you can verify up to hash</span></div><div class="line" id="215539"><span class="nick" style="color:#6c3d55"><a href="#215539" label="[21:55:39]">&lt;bauen1&gt;</a></span><span class="message">after this is done you can continue the bootstrap _without review_, up to the point where you need to apply your patches, which you review, at the end you can again build a merkle hash tree of your updated bootstrap and remember that</span></div><div class="line" id="215821"><span class="nick" style="color:#6c3d55"><a href="#215821" label="[21:58:21]">&lt;bauen1&gt;</a></span><span class="message">now there's still a problem, if you later figure out that you've included a bug or backdoor that makes it necessary to &quot;revert&quot; to an earlier version of the bootstrap, this could be solved by including the previous hash when cacluating the merkle tree, effectively forming a sort of blockchain</span></div><div class="line" id="215958"><span class="nick" style="color:#6c3d55"><a href="#215958" label="[21:59:58]">&lt;bauen1&gt;</a></span><span class="message">if you then have a copy of the merkle tree (which is comparably small, and can be verified by remembering the root) you can rebuild any version of the bootstrap without review</span></div><div class="line" id="220041"><span class="nick" style="color:#6c3d55"><a href="#220041" label="[22:00:41]">&lt;bauen1&gt;</a></span><span class="message">if someone inserts a backdoor and destroys your copy of the merkle tree you're kind of out of luck and i wish you fun with reviewing</span></div><div class="line" id="220057"><span class="nick" style="color:#6c3d55"><a href="#220057" label="[22:00:57]">&lt;bauen1&gt;</a></span><span class="message">this is kind of like reinventing how git works, but simpler</span></div><div class="line" id="220151"><span class="nick" style="color:#6c3d55"><a href="#220151" label="[22:01:51]">&lt;bauen1&gt;</a></span><span class="message">arguably you could also &quot;prune&quot; the merkle tree if it should ever become too big, at the cost of loosing cheap access to some earlier versions</span></div><div class="line" id="220352"><span class="nick" style="color:#8dd3c7"><a href="#220352" label="[22:03:52]">&lt;stikonas&gt;</a></span><span class="message">yeah, I guess that might help with reviewing later...</span></div><div class="line" id="220424"><span class="nick" style="color:#6c3d55"><a href="#220424" label="[22:04:24]">&lt;bauen1&gt;</a></span><span class="message">it's still a problem that the entire source code you need to review before you have something you can &quot;properly&quot; develop with is absolutely massive</span></div><div class="line" id="220534"><span class="nick" style="color:#8dd3c7"><a href="#220534" label="[22:05:34]">&lt;stikonas&gt;</a></span><span class="message">and you need to print everything for reviewing :D</span></div><div class="line" id="220538"><span class="nick" style="color:#8dd3c7"><a href="#220538" label="[22:05:38]">&lt;stikonas&gt;</a></span><span class="message">you can't review on the screen</span></div><div class="line" id="220554"><span class="nick" style="color:#6c3d55"><a href="#220554" label="[22:05:54]">&lt;bauen1&gt;</a></span><span class="message">stikonas: yes you can, even for the first bootstrap</span></div><div class="line" id="220634"><span class="nick" style="color:#6c3d55"><a href="#220634" label="[22:06:34]">&lt;bauen1&gt;</a></span><span class="message">stikonas: verify stage0 by hand (i.e. paper + dip switches), all until you can use the screen to display code and continue your way, always computing the hash of components, so you have it easier later</span></div><div class="line" id="220711"><span class="nick" style="color:#6c3d55"><a href="#220711" label="[22:07:11]">&lt;bauen1&gt;</a></span><span class="message">stikonas: however you can't just use a linux desktop to review the kernel code, make a hash of it and then use that for bootstrap, the hash could be backdoored</span></div><div class="line" id="220910"><span class="nick" style="color:#6c3d55"><a href="#220910" label="[22:09:10]">&lt;bauen1&gt;</a></span><span class="message">actually let me dig up this discussion i had about printing information on paper and how much tons that results in</span></div><div class="line" id="221019"><span class="nick" style="color:#8dd3c7"><a href="#221019" label="[22:10:19]">&lt;stikonas&gt;</a></span><span class="message">well, I guess you can always use some other screen if you enter code manually until you get screen...</span></div><div class="line" id="221430"><span class="nick" style="color:#6c3d55"><a href="#221430" label="[22:14:30]">&lt;bauen1&gt;</a></span><span class="message">ah yes, some shady math resulted in 1tb of binary data -&gt; ~ 25 000 tons of paper</span></div><div class="line" id="224642"><span class="nick">***</span><span class="message notice">ChanServ sets mode: +o rekado_</span></div><div class="line" id="224644"><span class="nick">***</span><span class="message notice">rekado_ is now known as rekado</span></div><div class="line" id="233249"><span class="nick" style="color:#d9d9d9"><a href="#233249" label="[23:32:49]">&lt;ullbeking&gt;</a></span><span class="message">good evening all</span></div><div class="line" id="233258"><span class="nick" style="color:#d9d9d9"><a href="#233258" label="[23:32:58]">&lt;ullbeking&gt;</a></span><span class="message">just wanted to check in, say hi</span></div><div class="line" id="233307"><span class="nick" style="color:#d9d9d9"><a href="#233307" label="[23:33:07]">&lt;ullbeking&gt;</a></span><span class="message">haven't forgotten about this!</span></div><div class="line" id="233316"><span class="nick" style="color:#d9d9d9"><a href="#233316" label="[23:33:16]">&lt;ullbeking&gt;</a></span><span class="message">i hage a job interview on friday!</span></div><div class="line" id="234428"><span class="nick" style="color:#8dd3c7"><a href="#234428" label="[23:44:28]">&lt;stikonas&gt;</a></span><span class="message">ullbeking: good luck!</span></div><div class="line" id="235544"><span class="nick" style="color:#d9d9d9"><a href="#235544" label="[23:55:44]">&lt;ullbeking&gt;</a></span><span class="message">thank you stikonas !</span></div><br /></div></body></html>