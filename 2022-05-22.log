<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-05-22.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000018"><span class="nick" style="color:#389600"><a href="#000018" label="[00:00:18]">&lt;stikonas&gt;</a></span><span class="message">I usually just execute individual build steps after chrooting</span></div><div class="line" id="000029"><span class="nick" style="color:#8dd3c7"><a href="#000029" label="[00:00:29]">&lt;doras&gt;</a></span><span class="message">But it's really up to you, I'm fine with it either way.</span></div><div class="line" id="000122"><span class="nick" style="color:#8dd3c7"><a href="#000122" label="[00:01:22]">&lt;doras&gt;</a></span><span class="message">I like resuming the bootstrap, so if I actually fixed the issue it would continue to the end.</span></div><div class="line" id="000142"><span class="nick" style="color:#8dd3c7"><a href="#000142" label="[00:01:42]">&lt;doras&gt;</a></span><span class="message">It involves commenting out build steps that succeeded.</span></div><div class="line" id="000525"><span class="nick" style="color:#8dd3c7"><a href="#000525" label="[00:05:25]">&lt;doras&gt;</a></span><span class="message">stikonas: regarding the tmpfs thing, I mostly need to come up a nice way for the Python code not to assume that mounting and unmounting needs to happen.</span></div><div class="line" id="000945"><span class="nick" style="color:#8dd3c7"><a href="#000945" label="[00:09:45]">&lt;doras&gt;</a></span><span class="message">It probably involves moving this logic out of the sysx constructors.</span></div><div class="line" id="003217"><span class="nick" style="color:#389600"><a href="#003217" label="[00:32:17]">&lt;stikonas&gt;</a></span><span class="message">can we not just hide it in the if block?</span></div><div class="line" id="011603"><span class="nick" style="color:#6b8072"><a href="#011603" label="[01:16:03]">&lt;Hagfish&gt;</a></span><span class="message">&quot;commenting out build steps that succeeded&quot; =&gt; i'm wondering if there could be a runner which keeps track of which steps have succeeded to allow resuming from the last known good step</span></div><div class="line" id="011636"><span class="nick" style="color:#6b8072"><a href="#011636" label="[01:16:36]">&lt;Hagfish&gt;</a></span><span class="message">i guess adding that extra layer of abstraction wouldn't be helpful once all the steps are working though</span></div><div class="line" id="013443"><span class="nick" style="color:#389600"><a href="#013443" label="[01:34:43]">&lt;stikonas&gt;</a></span><span class="message">Hagfish: I was thinking of just checking build results before build</span></div><div class="line" id="013447"><span class="nick" style="color:#389600"><a href="#013447" label="[01:34:47]">&lt;stikonas&gt;</a></span><span class="message">if they exists, skip the build</span></div><div class="line" id="013455"><span class="nick" style="color:#389600"><a href="#013455" label="[01:34:55]">&lt;stikonas&gt;</a></span><span class="message">it's fairly easy</span></div><div class="line" id="013736"><span class="nick" style="color:#389600"><a href="#013736" label="[01:37:36]">&lt;stikonas&gt;</a></span><span class="message">I was thinking of that already but there were other things that neede doing</span></div><div class="line" id="013952"><span class="nick" style="color:#80b1d3"><a href="#013952" label="[01:39:52]">&lt;oriansj&gt;</a></span><span class="message">catm</span></div><div class="line" id="014031"><span class="nick" style="color:#80b1d3"><a href="#014031" label="[01:40:31]">&lt;oriansj&gt;</a></span><span class="message">catm kaem.run step_07.success standard_init.run</span></div><div class="line" id="014050"><span class="nick" style="color:#80b1d3"><a href="#014050" label="[01:40:50]">&lt;oriansj&gt;</a></span><span class="message">catm kaem.run step_08.success standard_init.run</span></div><div class="line" id="014117"><span class="nick" style="color:#80b1d3"><a href="#014117" label="[01:41:17]">&lt;oriansj&gt;</a></span><span class="message">then just use match and if blocks to skip steps</span></div><div class="line" id="014152"><span class="nick" style="color:#80b1d3"><a href="#014152" label="[01:41:52]">&lt;oriansj&gt;</a></span><span class="message">but I would tweak match to give you a more efficient solution</span></div><div class="line" id="014245"><span class="nick" style="color:#80b1d3"><a href="#014245" label="[01:42:45]">&lt;oriansj&gt;</a></span><span class="message">say match --greater ${last_stage} 4</span></div><div class="line" id="014453"><span class="nick" style="color:#389600"><a href="#014453" label="[01:44:53]">&lt;stikonas&gt;</a></span><span class="message">well, for now I'll just do it in bash</span></div><div class="line" id="014529"><span class="nick" style="color:#389600"><a href="#014529" label="[01:45:29]">&lt;stikonas&gt;</a></span><span class="message">just run src_checksum at the beginning of the build process, if it succeeds, return, else continue with the build</span></div><div class="line" id="014629"><span class="nick" style="color:#80b1d3"><a href="#014629" label="[01:46:29]">&lt;oriansj&gt;</a></span><span class="message">that'll even work in kaem</span></div><div class="line" id="020052"><span class="nick" style="color:#80b1d3"><a href="#020052" label="[02:00:52]">&lt;oriansj&gt;</a></span><span class="message">so much better idea, good job stikonas</span></div><div class="line" id="020258"><span class="nick" style="color:#389600"><a href="#020258" label="[02:02:58]">&lt;stikonas&gt;</a></span><span class="message">well, in kaem we don't have those helper function...</span></div><div class="line" id="020322"><span class="nick" style="color:#389600"><a href="#020322" label="[02:03:22]">&lt;stikonas&gt;</a></span><span class="message">anyway, in kaem the only steps worth skipping are mes and initial build of tcc</span></div><div class="line" id="020335"><span class="nick" style="color:#389600"><a href="#020335" label="[02:03:35]">&lt;stikonas&gt;</a></span><span class="message">everything else is very quick</span></div><div class="line" id="020547"><span class="nick" style="color:#80b1d3"><a href="#020547" label="[02:05:47]">&lt;oriansj&gt;</a></span><span class="message">to be honest, part of me misses when M2-Planet could compile 1+Mloc/second</span></div><div class="line" id="020603"><span class="nick" style="color:#80b1d3"><a href="#020603" label="[02:06:03]">&lt;oriansj&gt;</a></span><span class="message">but it is now *MUCH* more robust</span></div><div class="line" id="020759"><span class="nick" style="color:#80b1d3"><a href="#020759" label="[02:07:59]">&lt;oriansj&gt;</a></span><span class="message">but I guess 300+Kloc/second is still respectable</span></div><div class="line" id="020836"><span class="nick" style="color:#6d2462"><a href="#020836" label="[02:08:36]">&lt;muurkha&gt;</a></span><span class="message">robustness is super important.  we don't want it to have an exploitable compiler bug!</span></div><div class="line" id="020909"><span class="nick" style="color:#80b1d3"><a href="#020909" label="[02:09:09]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well we do have an exploitable bug in untar</span></div><div class="line" id="020931"><span class="nick" style="color:#6d2462"><a href="#020931" label="[02:09:31]">&lt;muurkha&gt;</a></span><span class="message">hopefully our source tarfiles aren't yet exploiting it to introduce backdoors</span></div><div class="line" id="021002"><span class="nick" style="color:#80b1d3"><a href="#021002" label="[02:10:02]">&lt;oriansj&gt;</a></span><span class="message">well we can sha256sum those files prior to untaring them</span></div><div class="line" id="021054"><span class="nick" style="color:#80b1d3"><a href="#021054" label="[02:10:54]">&lt;oriansj&gt;</a></span><span class="message">So we can limit that attack surface to a degree but it is a bug that just requires input validation checks to be added to untar</span></div><div class="line" id="021119"><span class="nick" style="color:#80b1d3"><a href="#021119" label="[02:11:19]">&lt;oriansj&gt;</a></span><span class="message">same could be said about ungz</span></div><div class="line" id="021302"><span class="nick" style="color:#80b1d3"><a href="#021302" label="[02:13:02]">&lt;oriansj&gt;</a></span><span class="message">although one could argue adding --fuzz-test to mes.c would probably be the best way to make our bootstrap robust</span></div><div class="line" id="021430"><span class="nick" style="color:#389600"><a href="#021430" label="[02:14:30]">&lt;stikonas&gt;</a></span><span class="message">M2-Planet now has more features too, so it has to make more processing</span></div><div class="line" id="021449"><span class="nick" style="color:#389600"><a href="#021449" label="[02:14:49]">&lt;stikonas&gt;</a></span><span class="message">preprocessor basically makes it two-pass run</span></div><div class="line" id="025527"><span class="nick" style="color:#80b1d3"><a href="#025527" label="[02:55:27]">&lt;oriansj&gt;</a></span><span class="message">stikonas: yeah the preprocessor was the majority of the speed loss.</span></div><div class="line" id="030227"><span class="nick" style="color:#80b1d3"><a href="#030227" label="[03:02:27]">&lt;oriansj&gt;</a></span><span class="message">stikonas, fossy: would it be an issue if I changed ungz and untar to allow safer fuzzing but it would change the invocation commands slightly?</span></div><div class="line" id="030244"><span class="nick" style="color:#389600"><a href="#030244" label="[03:02:44]">&lt;stikonas&gt;</a></span><span class="message">should be fine</span></div><div class="line" id="030257"><span class="nick" style="color:#389600"><a href="#030257" label="[03:02:57]">&lt;stikonas&gt;</a></span><span class="message">we can adjust commnads in live-bootstrap when we pull in newer stage0-posix</span></div><div class="line" id="030348"><span class="nick" style="color:#80b1d3"><a href="#030348" label="[03:03:48]">&lt;oriansj&gt;</a></span><span class="message">thank you</span></div><div class="line" id="032251"><span class="nick" style="color:#80b1d3"><a href="#032251" label="[03:22:51]">&lt;oriansj&gt;</a></span><span class="message">and you'll now be able to specify the output file name for ungz</span></div><div class="line" id="043045"><span class="nick" style="color:#80b1d3"><a href="#043045" label="[04:30:45]">&lt;oriansj&gt;</a></span><span class="message">and untar and ungz now have the new flags, I'll begin fuzzing and adding input validation</span></div><div class="line" id="044039"><span class="nick" style="color:#80b1d3"><a href="#044039" label="[04:40:39]">&lt;oriansj&gt;</a></span><span class="message">took only 10 seconds of fuzzing to find the first ungz segfault</span></div><div class="line" id="073015"><span class="nick" style="color:#234e69"><a href="#073015" label="[07:30:15]">&lt;midgardian[m]&gt;</a></span><span class="message">&lt;oriansj&gt; &quot;but I guess 300+Kloc/second is...&quot; &lt;- Can you explain why M2-Planet compile performance decreased?  Also how do you benchmark how many LOC/s it compiles?</span></div><div class="line" id="073314"><span class="nick" style="color:#234e69"><a href="#073314" label="[07:33:14]">&lt;midgardian[m]&gt;</a></span><span class="message">&lt;oriansj&gt; &quot;muurkha: well we do have an...&quot; &lt;- [oriansj](<a rel="nofollow" href="https://matrix.to/#/%40oriansj%3Alibera.chat">https://matrix.to/#/%40oriansj%3Alibera.chat</a>)  What bug in untar is this?  is it in this file: sysa/stage0-posix/src/mescc-tools-extra/untar.c  ??</span></div><div class="line" id="073354"><span class="nick" style="color:#234e69"><a href="#073354" label="[07:33:54]">&lt;midgardian[m]&gt;</a></span><span class="message">&lt;oriansj&gt; &quot;stikonas: yeah the preprocessor...&quot; &lt;- Oh sorry I read this, the M2-Planet performance decreased due to preprocessing?</span></div><div class="line" id="115039"><span class="nick" style="color:#6c3d55"><a href="#115039" label="[11:50:39]">&lt;stikonas[m]&gt;</a></span><span class="message">midgardian: M2-Planet is also doing a bit more features and safety checks. That is a further drop in performance...</span></div><div class="line" id="123918"><span class="nick" style="color:#80b1d3"><a href="#123918" label="[12:39:18]">&lt;oriansj&gt;</a></span><span class="message">midgardian[m]: this one is the one I was speaking of: <a rel="nofollow" href="https://www.openwall.com/lists/oss-security/2021/10/03/1">https://www.openwall.com/lists/oss-security/2021/10/03/1</a> </span></div><div class="line" id="124437"><span class="nick" style="color:#80b1d3"><a href="#124437" label="[12:44:37]">&lt;oriansj&gt;</a></span><span class="message">and yes it is the untar in mescc-tools-extra</span></div><div class="line" id="125636"><span class="nick" style="color:#80b1d3"><a href="#125636" label="[12:56:36]">&lt;oriansj&gt;</a></span><span class="message">the method for testing compile speed was done using a 100Mloc test file and timing how long it took to compile.</span></div><div class="line" id="130100"><span class="nick" style="color:#80b1d3"><a href="#130100" label="[13:01:00]">&lt;oriansj&gt;</a></span><span class="message">things that reduce performance: looking at data more than once, manipulating data more than once, inefficient algorithm choices, inefficient syscalls (this was previously the major performance problem with M2-Planet) and busy code</span></div><div class="line" id="130418"><span class="nick" style="color:#80b1d3"><a href="#130418" label="[13:04:18]">&lt;oriansj&gt;</a></span><span class="message">doing a separate preprocessing stage required us to look at the data more than once and manipulate the data more than once, which did cut performance in half. adding all those require statements to catch garbage input (which provide useful error messages rather than just segfaults) requires us to look at the data more than once and caused the remaining performance drop.</span></div><div class="line" id="130931"><span class="nick" style="color:#80b1d3"><a href="#130931" label="[13:09:31]">&lt;oriansj&gt;</a></span><span class="message">The algorithm currently used is not optimal in terms of absolute performance (I selected simplicity of mental model and minimal build requirements) but as it is just a simple state machine walking a list so there is only a possible 4x performance improvement if I went to the extreme. (Which would be a major rewrite effort taking possibly years [aka not worth it])</span></div><div class="line" id="131136"><span class="nick" style="color:#80b1d3"><a href="#131136" label="[13:11:36]">&lt;oriansj&gt;</a></span><span class="message">the previous inefficient syscalls in M2-Planet relates to how fgetc and fputc used to work (and how cc_* still works); in particular one only reads a single byte or writes a single byte per syscall.</span></div><div class="line" id="131401"><span class="nick" style="color:#80b1d3"><a href="#131401" label="[13:14:01]">&lt;oriansj&gt;</a></span><span class="message">but fortunately the M2libc work showed that major performance improvements could be obtained by buffering input/output. So now M2-Planet only does a single read from an input file and minimizes the number of writes. Which resulted in a 10x performance improvement in M2-Planet</span></div><div class="line" id="131502"><span class="nick" style="color:#80b1d3"><a href="#131502" label="[13:15:02]">&lt;oriansj&gt;</a></span><span class="message">and there are no busy wait loops or deadlocks or other busy code blocks in M2-Planet so isn't an issue</span></div><div class="line" id="133210"><span class="nick" style="color:#80b1d3"><a href="#133210" label="[13:32:10]">&lt;oriansj&gt;</a></span><span class="message">in an unrelated note; The freedom to study the source code and make changes. What could we do to improve the situation at the hex0 level?</span></div><div class="line" id="133252"><span class="nick" style="color:#80b1d3"><a href="#133252" label="[13:32:52]">&lt;oriansj&gt;</a></span><span class="message">because right now it is just doing art with individual grains of colored sand sort of labor of love.</span></div><div class="line" id="135844"><span class="nick" style="color:#6d2462"><a href="#135844" label="[13:58:44]">&lt;muurkha&gt;</a></span><span class="message">I feel like a formal proof that the code does one thing and not another, using a formal model of the semantics of the CPU instructions it uses, would be a useful step</span></div><div class="line" id="135912"><span class="nick" style="color:#6d2462"><a href="#135912" label="[13:59:12]">&lt;muurkha&gt;</a></span><span class="message">it maybe wouldn't help people make changes but it could help them study it</span></div><div class="line" id="135932"><span class="nick" style="color:#6d2462"><a href="#135932" label="[13:59:32]">&lt;muurkha&gt;</a></span><span class="message">or maybe it would help them make changes because it would tell them what they broke</span></div><div class="line" id="135945"><span class="nick" style="color:#6d2462"><a href="#135945" label="[13:59:45]">&lt;muurkha&gt;</a></span><span class="message">unfortunately I don't know how to do formal proofs of programs beyond the most basic Hoare logic level</span></div><div class="line" id="150826"><span class="nick" style="color:#80b1d3"><a href="#150826" label="[15:08:26]">&lt;oriansj&gt;</a></span><span class="message">hmmm but would that make writing unreadable code easier so I am not sure how much that will gain us.</span></div><div class="line" id="151745"><span class="nick" style="color:#6d2462"><a href="#151745" label="[15:17:45]">&lt;muurkha&gt;</a></span><span class="message">I don't think it would, but I hardly have more experience with the thing than you do</span></div><div class="line" id="152356"><span class="nick" style="color:#80b1d3"><a href="#152356" label="[15:23:56]">&lt;oriansj&gt;</a></span><span class="message">imagine a code golfer with a tool which can say yes or no if a program would do the thing specified. Then apply some brute force search and boom, a program that complies with the spec but no one knows how it works.</span></div><div class="line" id="152550"><span class="nick" style="color:#80b1d3"><a href="#152550" label="[15:25:50]">&lt;oriansj&gt;</a></span><span class="message">for a real world example: <a rel="nofollow" href="https://www.damninteresting.com/on-the-origin-of-circuits/">https://www.damninteresting.com/on-the-origin-of-circuits/</a> </span></div><div class="line" id="152955"><span class="nick" style="color:#6d2462"><a href="#152955" label="[15:29:55]">&lt;muurkha&gt;</a></span><span class="message">I don't think you can actually write code that way even with a proof assistant</span></div><div class="line" id="153123"><span class="nick" style="color:#6d2462"><a href="#153123" label="[15:31:23]">&lt;muurkha&gt;</a></span><span class="message">your article is not a real world example of someone using formal proofs; it's rather the opposite extreme</span></div><div class="line" id="153442"><span class="nick" style="color:#6d2462"><a href="#153442" label="[15:34:42]">&lt;muurkha&gt;</a></span><span class="message">I mean, yes, superoptimizers can generate code sequences successfully</span></div><div class="line" id="153514"><span class="nick" style="color:#6d2462"><a href="#153514" label="[15:35:14]">&lt;muurkha&gt;</a></span><span class="message">but they top out around ten instructions, and generally it's not that hard to figure out how they work</span></div><div class="line" id="153520"><span class="nick" style="color:#80b1d3"><a href="#153520" label="[15:35:20]">&lt;oriansj&gt;</a></span><span class="message">perhaps I am just thinking of it in terms of a program that would take the hex0 and the specification and generate a formal proof of correctness. And what one could build on top of it.</span></div><div class="line" id="153600"><span class="nick" style="color:#6d2462"><a href="#153600" label="[15:36:00]">&lt;muurkha&gt;</a></span><span class="message">yeah, I don't think that is a thing that anybody knows how to do</span></div><div class="line" id="153727"><span class="nick" style="color:#80b1d3"><a href="#153727" label="[15:37:27]">&lt;oriansj&gt;</a></span><span class="message">because a one off proof doesn't really help one change code</span></div><div class="line" id="153800"><span class="nick" style="color:#6d2462"><a href="#153800" label="[15:38:00]">&lt;muurkha&gt;</a></span><span class="message">hmm, I don't think that's true from my experience with programming in statically typed languages</span></div><div class="line" id="153830"><span class="nick" style="color:#80b1d3"><a href="#153830" label="[15:38:30]">&lt;oriansj&gt;</a></span><span class="message">hex0 is a typeless programming language</span></div><div class="line" id="153837"><span class="nick" style="color:#6d2462"><a href="#153837" label="[15:38:37]">&lt;muurkha&gt;</a></span><span class="message">irrelevant</span></div><div class="line" id="153915"><span class="nick" style="color:#6d2462"><a href="#153915" label="[15:39:15]">&lt;muurkha&gt;</a></span><span class="message">I find that static types (which are simple theorems checked by the compiler) are helpful for changing code because they help me rule out large classes of interactions</span></div><div class="line" id="153935"><span class="nick" style="color:#80b1d3"><a href="#153935" label="[15:39:35]">&lt;oriansj&gt;</a></span><span class="message">perhaps we are thinking of two different things when talking about a proof for hex0</span></div><div class="line" id="153955"><span class="nick" style="color:#6d2462"><a href="#153955" label="[15:39:55]">&lt;muurkha&gt;</a></span><span class="message">also, though, because the process of structuring the code such that it's *possible* for the types to check requires me to write the code in a clearer way</span></div><div class="line" id="154008"><span class="nick" style="color:#6d2462"><a href="#154008" label="[15:40:08]">&lt;muurkha&gt;</a></span><span class="message">which makes it easier to change</span></div><div class="line" id="154257"><span class="nick" style="color:#80b1d3"><a href="#154257" label="[15:42:57]">&lt;oriansj&gt;</a></span><span class="message">granted that editors with proper syntax and type checking make code easier to maintain but I don't think of that is a proof of correctness.</span></div><div class="line" id="154318"><span class="nick" style="color:#6d2462"><a href="#154318" label="[15:43:18]">&lt;muurkha&gt;</a></span><span class="message">it's a proof of a particular property of the code</span></div><div class="line" id="154400"><span class="nick" style="color:#6d2462"><a href="#154400" label="[15:44:00]">&lt;muurkha&gt;</a></span><span class="message">generally a non-dependent type system isn't sufficiently expressive to express all the correctness properties we'd like to express, just some of them</span></div><div class="line" id="154410"><span class="nick" style="color:#6d2462"><a href="#154410" label="[15:44:10]">&lt;muurkha&gt;</a></span><span class="message">but I've never used more expressive proof systems like PVS, ACL2, or Coq, so maybe my experience doesn't generalize</span></div><div class="line" id="154411"><span class="nick" style="color:#80b1d3"><a href="#154411" label="[15:44:11]">&lt;oriansj&gt;</a></span><span class="message">indeed it is but that property in no way indicates that the code comforms to the specification.</span></div><div class="line" id="154458"><span class="nick" style="color:#6d2462"><a href="#154458" label="[15:44:58]">&lt;muurkha&gt;</a></span><span class="message">I wouldn't say &quot;in no way&quot; — it shows that the code conforms to the type specification.  such and such a function returns a list of integers, or whatever</span></div><div class="line" id="154609"><span class="nick" style="color:#6d2462"><a href="#154609" label="[15:46:09]">&lt;muurkha&gt;</a></span><span class="message">dependent type systems like Idris allow you to specify tighter types, such as a list of integers that is a permutation of the first argument such that for every i x[i] ≤ x[i+1]</span></div><div class="line" id="154622"><span class="nick" style="color:#6d2462"><a href="#154622" label="[15:46:22]">&lt;muurkha&gt;</a></span><span class="message">at which point you've proven your sort function correct</span></div><div class="line" id="154641"><span class="nick" style="color:#80b1d3"><a href="#154641" label="[15:46:41]">&lt;oriansj&gt;</a></span><span class="message">specification says: return &quot;true&quot; if prime else return &quot;false&quot;; code does return 42;</span></div><div class="line" id="154715"><span class="nick" style="color:#6d2462"><a href="#154715" label="[15:47:15]">&lt;muurkha&gt;</a></span><span class="message">yeah, see, even C's type system can demonstrate that code is incorrect</span></div><div class="line" id="154804"><span class="nick" style="color:#80b1d3"><a href="#154804" label="[15:48:04]">&lt;oriansj&gt;</a></span><span class="message">return &quot;42&quot;; fixed</span></div><div class="line" id="154832"><span class="nick" style="color:#6d2462"><a href="#154832" label="[15:48:32]">&lt;muurkha&gt;</a></span><span class="message">right, in that case C's type system isn't sufficiently expressive to find the bug but, say, TypeScript's is</span></div><div class="line" id="154919"><span class="nick" style="color:#d9d9d9"><a href="#154919" label="[15:49:19]">&lt;unmatched-paren&gt;</a></span><span class="message">well, if the only possible returns are &quot;true&quot; and &quot;false&quot;, then you could just use &lt;stdbool.h&gt;'s `bool`</span></div><div class="line" id="154922"><span class="nick" style="color:#d9d9d9"><a href="#154922" label="[15:49:22]">&lt;unmatched-paren&gt;</a></span><span class="message">not sure why you'd use a string in that case?</span></div><div class="line" id="154953"><span class="nick" style="color:#d9d9d9"><a href="#154953" label="[15:49:53]">&lt;unmatched-paren&gt;</a></span><span class="message">and i'm pretty sure if you used an enum then most compilers would check that it's a valid member of the enum...</span></div><div class="line" id="154959"><span class="nick" style="color:#bc80bd"><a href="#154959" label="[15:49:59]">*</a></span><span class="message">unmatched-paren checks with gcc</span></div><div class="line" id="155003"><span class="nick" style="color:#6d2462"><a href="#155003" label="[15:50:03]">&lt;muurkha&gt;</a></span><span class="message">C isn't very good at enum checks</span></div><div class="line" id="155028"><span class="nick" style="color:#80b1d3"><a href="#155028" label="[15:50:28]">&lt;oriansj&gt;</a></span><span class="message">TypeScript would be checking that it is a string type, so it wouldn't catch that &quot;42&quot; is not the string &quot;true&quot; or the string &quot;false&quot;</span></div><div class="line" id="155030"><span class="nick" style="color:#6d2462"><a href="#155030" label="[15:50:30]">&lt;muurkha&gt;</a></span><span class="message">but Java, Kotlin, Scala, OCaml, F#, or Pascal is fine</span></div><div class="line" id="155059"><span class="nick" style="color:#6d2462"><a href="#155059" label="[15:50:59]">&lt;muurkha&gt;</a></span><span class="message">in TypeScript &quot;true&quot; | &quot;false&quot; is a valid type, and the compiler can see that &quot;42&quot; does not conform to it</span></div><div class="line" id="155120"><span class="nick" style="color:#d9d9d9"><a href="#155120" label="[15:51:20]">&lt;unmatched-paren&gt;</a></span><span class="message">oh, that's kind of neat that it uses strings as enums...</span></div><div class="line" id="155145"><span class="nick" style="color:#6d2462"><a href="#155145" label="[15:51:45]">&lt;muurkha&gt;</a></span><span class="message">yeah, TS is designed to be able to check the kind of goofy stuff we routinely do in JS</span></div><div class="line" id="155151"><span class="nick" style="color:#d9d9d9"><a href="#155151" label="[15:51:51]">&lt;unmatched-paren&gt;</a></span><span class="message">in a cursed JavaScripty meaning of neat i guess :P</span></div><div class="line" id="155158"><span class="nick" style="color:#80b1d3"><a href="#155158" label="[15:51:58]">&lt;oriansj&gt;</a></span><span class="message">unmatched-paren: the reason for the string type is to demonstrate the point that types by themselves don't solve the problem but we can create structures that do</span></div><div class="line" id="155230"><span class="nick" style="color:#6d2462"><a href="#155230" label="[15:52:30]">&lt;muurkha&gt;</a></span><span class="message">yes, and the reason for TypeScript's more complex type system is to demonstrate that types by themselves do solve *that* problem</span></div><div class="line" id="155255"><span class="nick" style="color:#6d2462"><a href="#155255" label="[15:52:55]">&lt;muurkha&gt;</a></span><span class="message">expressing prime() in your type system requires a substantially more elaborate type system though</span></div><div class="line" id="155307"><span class="nick" style="color:#80b1d3"><a href="#155307" label="[15:53:07]">&lt;oriansj&gt;</a></span><span class="message">muurkha: custom created types that are written by people to help themselves, not out of the box types</span></div><div class="line" id="155310"><span class="nick" style="color:#6d2462"><a href="#155310" label="[15:53:10]">&lt;muurkha&gt;</a></span><span class="message">Coq or Idris or Agda can do it, TS can't</span></div><div class="line" id="155322"><span class="nick" style="color:#6d2462"><a href="#155322" label="[15:53:22]">&lt;muurkha&gt;</a></span><span class="message">yes, of course</span></div><div class="line" id="155339"><span class="nick" style="color:#6d2462"><a href="#155339" label="[15:53:39]">&lt;muurkha&gt;</a></span><span class="message">you can't get very far with primitive types in any language</span></div><div class="line" id="155412"><span class="nick" style="color:#d9d9d9"><a href="#155412" label="[15:54:12]">&lt;unmatched-paren&gt;</a></span><span class="message">what... GCC does not, apparently, check that an `enum foo` value is a valid member of that enum... i'd expect better from it.</span></div><div class="line" id="155420"><span class="nick" style="color:#80b1d3"><a href="#155420" label="[15:54:20]">&lt;oriansj&gt;</a></span><span class="message">it isn't a native property of type checking but humans leveraging type checking in clever ways</span></div><div class="line" id="155427"><span class="nick" style="color:#d9d9d9"><a href="#155427" label="[15:54:27]">&lt;unmatched-paren&gt;</a></span><span class="message">pretty sure the C standard allows you to do that check</span></div><div class="line" id="155458"><span class="nick" style="color:#80b1d3"><a href="#155458" label="[15:54:58]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I managed to get pretty far with just char* and int</span></div><div class="line" id="155459"><span class="nick" style="color:#d9d9d9"><a href="#155459" label="[15:54:59]">&lt;unmatched-paren&gt;</a></span><span class="message">it was mentioned in ANSI K&amp;R that compilers were allowed to do that... maybe it's changed since then</span></div><div class="line" id="155551"><span class="nick" style="color:#6d2462"><a href="#155551" label="[15:55:51]">&lt;muurkha&gt;</a></span><span class="message">oriansj: you can get pretty far writing code without any types at all, as in assembly!  but you can't get very far expressing correctness properties of your program</span></div><div class="line" id="155613"><span class="nick" style="color:#6d2462"><a href="#155613" label="[15:56:13]">&lt;muurkha&gt;</a></span><span class="message">unmatched-paren: did you try -Wall -pedantic -Wextra?</span></div><div class="line" id="155627"><span class="nick" style="color:#d9d9d9"><a href="#155627" label="[15:56:27]">&lt;unmatched-paren&gt;</a></span><span class="message">muurkha: yes</span></div><div class="line" id="155641"><span class="nick" style="color:#6d2462"><a href="#155641" label="[15:56:41]">&lt;muurkha&gt;</a></span><span class="message">I'm surprised it didn't even warn</span></div><div class="line" id="155905"><span class="nick" style="color:#6d2462"><a href="#155905" label="[15:59:05]">&lt;muurkha&gt;</a></span><span class="message">oriansj: <a rel="nofollow" href="https://thatgeoguy.ca/blog/2021/03/07/review-the-little-typer/">https://thatgeoguy.ca/blog/2021/03/07/review-the-little-typer/</a>  showed up on the orange website today</span></div><div class="line" id="155949"><span class="nick" style="color:#80b1d3"><a href="#155949" label="[15:59:49]">&lt;oriansj&gt;</a></span><span class="message">hex0 could support annotation</span></div><div class="line" id="160038"><span class="nick" style="color:#80b1d3"><a href="#160038" label="[16:00:38]">&lt;oriansj&gt;</a></span><span class="message">which a tool could perform checks on</span></div><div class="line" id="160101"><span class="nick" style="color:#80b1d3"><a href="#160101" label="[16:01:01]">&lt;oriansj&gt;</a></span><span class="message">is this bag of bytes a valid instruction and does it correspond to the # assembly ; block</span></div><div class="line" id="160135"><span class="nick" style="color:#6d2462"><a href="#160135" label="[16:01:35]">&lt;muurkha&gt;</a></span><span class="message">yes, and there's no limit to how far you can take the expressiveness of that sort of annotation</span></div><div class="line" id="160148"><span class="nick" style="color:#6d2462"><a href="#160148" label="[16:01:48]">&lt;muurkha&gt;</a></span><span class="message">which, ideally, would be in a separate file from the hex bytes themselves</span></div><div class="line" id="160225"><span class="nick" style="color:#80b1d3"><a href="#160225" label="[16:02:25]">&lt;oriansj&gt;</a></span><span class="message">well hence my question about how we can make hex0 into a better programming language</span></div><div class="line" id="160303"><span class="nick" style="color:#80b1d3"><a href="#160303" label="[16:03:03]">&lt;oriansj&gt;</a></span><span class="message">for example #:label ; [0xaddress] could be checked if it would actually be that address</span></div><div class="line" id="160410"><span class="nick" style="color:#80b1d3"><a href="#160410" label="[16:04:10]">&lt;oriansj&gt;</a></span><span class="message">(just thinking in terms of developer tooling)</span></div><div class="line" id="160554"><span class="nick" style="color:#80b1d3"><a href="#160554" label="[16:05:54]">&lt;oriansj&gt;</a></span><span class="message">hex # jump label ; comment could be checked to see if it is a jump instruction and would it jump to the address at that label</span></div><div class="line" id="160759"><span class="nick" style="color:#80b1d3"><a href="#160759" label="[16:07:59]">&lt;oriansj&gt;</a></span><span class="message">if one does mov ax, [memory] and doesn't do a movzx or movsx to fill up the register that could be a bug and an annotation could be put there to ignore that warning or the programmer could just fix the code sort of details</span></div><div class="line" id="161201"><span class="nick" style="color:#389600"><a href="#161201" label="[16:12:01]">&lt;stikonas&gt;</a></span><span class="message">But label checking tool is basically &quot;hex2&quot;</span></div><div class="line" id="161218"><span class="nick" style="color:#389600"><a href="#161218" label="[16:12:18]">&lt;stikonas&gt;</a></span><span class="message">one can just build it with hex0 and hex2 and compare output</span></div><div class="line" id="161724"><span class="nick" style="color:#6d2462"><a href="#161724" label="[16:17:24]">&lt;muurkha&gt;</a></span><span class="message">podcast on dependent types and proving programs correct: <a rel="nofollow" href="https://corecursive.com/023-little-typer-and-pie-language/">https://corecursive.com/023-little-typer-and-pie-language/</a> </span></div><div class="line" id="164247"><span class="nick" style="color:#6d2462"><a href="#164247" label="[16:42:47]">&lt;muurkha&gt;</a></span><span class="message"> <a rel="nofollow" href="https://stackoverflow.com/questions/8597426/enum-type-check-in-c-gcc">https://stackoverflow.com/questions/8597426/enum-type-check-in-c-gcc</a>  says the enum constants are of type int</span></div><div class="line" id="164306"><span class="nick" style="color:#6d2462"><a href="#164306" label="[16:43:06]">&lt;muurkha&gt;</a></span><span class="message">&quot;Yes, that means that the constant apple, even though it was declared as part of the definition of enum fruit, isn't actually of type enum fruit. The reasons for this are historical. And yes, it would probably have made more sense for the enumerators to be constants of the type.&quot;</span></div><div class="line" id="164351"><span class="nick" style="color:#6d2462"><a href="#164351" label="[16:43:51]">&lt;muurkha&gt;</a></span><span class="message">it says clang has -Wenum-conversion</span></div><div class="line" id="164434"><span class="nick" style="color:#6d2462"><a href="#164434" label="[16:44:34]">&lt;muurkha&gt;</a></span><span class="message">which was added to GCC last year</span></div><div class="line" id="164450"><span class="nick" style="color:#6d2462"><a href="#164450" label="[16:44:50]">&lt;muurkha&gt;</a></span><span class="message">in GCC 10</span></div><div class="line" id="170556"><span class="nick" style="color:#389600"><a href="#170556" label="[17:05:56]">&lt;stikonas&gt;</a></span><span class="message">in C++ there was already strongly typed enum for some time</span></div><div class="line" id="170704"><span class="nick" style="color:#6d2462"><a href="#170704" label="[17:07:04]">&lt;muurkha&gt;</a></span><span class="message">yeah, C++ enum is different</span></div><div class="line" id="172306"><span class="nick">***</span><span class="message notice">mid-kid1 is now known as mid-kid</span></div><div class="line" id="180256"><span class="nick" style="color:#389600"><a href="#180256" label="[18:02:56]">&lt;stikonas&gt;</a></span><span class="message">oriansj: would you mind if I also add --verbose option to untar?</span></div><div class="line" id="180343"><span class="nick" style="color:#389600"><a href="#180343" label="[18:03:43]">&lt;stikonas&gt;</a></span><span class="message">(to print list of extracted files, else untar will not print the list of files but will still print &quot;The extraction of $name.tar was successful&quot;</span></div><div class="line" id="180502"><span class="nick" style="color:#389600"><a href="#180502" label="[18:05:02]">&lt;stikonas&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/oriansj/mescc-tools-extra/pull/10">https://github.com/oriansj/mescc-tools-extra/pull/10</a> </span></div><div class="line" id="232309"><span class="nick" style="color:#80b1d3"><a href="#232309" label="[23:23:09]">&lt;oriansj&gt;</a></span><span class="message">stikonas: looks great</span></div><div class="line" id="232425"><span class="nick" style="color:#389600"><a href="#232425" label="[23:24:25]">&lt;stikonas&gt;</a></span><span class="message">ok, I'll push it then</span></div><div class="line" id="232626"><span class="nick" style="color:#80b1d3"><a href="#232626" label="[23:26:26]">&lt;oriansj&gt;</a></span><span class="message">thanks stikonas</span></div><div class="line" id="232804"><span class="nick" style="color:#3c5b35"><a href="#232804" label="[23:28:04]">&lt;siraben&gt;</a></span><span class="message"> <a rel="nofollow" href="https://justine.lol/lambda/">https://justine.lol/lambda/</a> </span></div><div class="line" id="233404"><span class="nick" style="color:#80b1d3"><a href="#233404" label="[23:34:04]">&lt;oriansj&gt;</a></span><span class="message">siraben: the 255 character limitation seems pretty harsh</span></div><div class="line" id="233502"><span class="nick" style="color:#3c5b35"><a href="#233502" label="[23:35:02]">&lt;siraben&gt;</a></span><span class="message">the binary nature makes it even harder to audit</span></div><div class="line" id="233512"><span class="nick" style="color:#3c5b35"><a href="#233512" label="[23:35:12]">&lt;siraben&gt;</a></span><span class="message">I'm a bigger fan of Ben Lynn's readable (with enough effort) implementation</span></div><div class="line" id="233542"><span class="nick" style="color:#80b1d3"><a href="#233542" label="[23:35:42]">&lt;oriansj&gt;</a></span><span class="message">and the &quot;Output consists of 0 and 1 bytes&quot; presents a serious practical concern</span></div><div class="line" id="233913"><span class="nick" style="color:#389600"><a href="#233913" label="[23:39:13]">&lt;stikonas&gt;</a></span><span class="message">yeah, 255 characters is not enough to even self-host it</span></div><div class="line" id="234315"><span class="nick" style="color:#80b1d3"><a href="#234315" label="[23:43:15]">&lt;oriansj&gt;</a></span><span class="message">does however appear to be enough to do a brainf#ck</span></div><br /></div></body></html>