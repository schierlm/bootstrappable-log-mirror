<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2021-09-11.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000017"><span class="nick" style="color:#389600"><a href="#000017" label="[00:00:17]">&lt;stikonas&gt;</a></span><span class="message">well, definitely not USB keyboard :D</span></div><div class="line" id="000055"><span class="nick" style="color:#389600"><a href="#000055" label="[00:00:55]">&lt;stikonas&gt;</a></span><span class="message">that one needs quite a bit of code to get working, initial negotiation and then periodic polling, decoding signal</span></div><div class="line" id="000209"><span class="nick" style="color:#8dd3c7"><a href="#000209" label="[00:02:09]">&lt;xentrac&gt;</a></span><span class="message">depends on your hardware</span></div><div class="line" id="000225"><span class="nick" style="color:#8dd3c7"><a href="#000225" label="[00:02:25]">&lt;xentrac&gt;</a></span><span class="message">but usually not!</span></div><div class="line" id="001300"><span class="nick" style="color:#8dd3c7"><a href="#001300" label="[00:13:00]">&lt;xentrac&gt;</a></span><span class="message">if you had to bitbang a serial interface to your paper-tape reader, the first-stage bootloader might be quite a bit more complicated too</span></div><div class="line" id="001937"><span class="nick" style="color:#2e2a4a"><a href="#001937" label="[00:19:37]">&lt;Hagfish&gt;</a></span><span class="message">it's kind of cool to think about what could be implemented in 4-16 instructions, that's intriguing</span></div><div class="line" id="002311"><span class="nick" style="color:#8dd3c7"><a href="#002311" label="[00:23:11]">&lt;xentrac&gt;</a></span><span class="message">like OUT $f00, $1; LOOP: IN $f01; JZ LOOP; ST (I0+); CMP $-1; JNE LOOP; JMP $0</span></div><div class="line" id="002333"><span class="nick" style="color:#8dd3c7"><a href="#002333" label="[00:23:33]">&lt;xentrac&gt;</a></span><span class="message">if you have a blocking IN instruction it could be</span></div><div class="line" id="002345"><span class="nick" style="color:#8dd3c7"><a href="#002345" label="[00:23:45]">&lt;xentrac&gt;</a></span><span class="message">like OUT $f00, $1; LOOP: IN $f01; ST (I0+); CMP $-1; JNE LOOP; JMP $0</span></div><div class="line" id="002358"><span class="nick" style="color:#8dd3c7"><a href="#002358" label="[00:23:58]">&lt;xentrac&gt;</a></span><span class="message">which is 6 instructions</span></div><div class="line" id="004554"><span class="nick" style="color:#2e2a4a"><a href="#004554" label="[00:45:54]">&lt;Hagfish&gt;</a></span><span class="message">wow, thank you</span></div><div class="line" id="004727"><span class="nick" style="color:#8dd3c7"><a href="#004727" label="[00:47:27]">&lt;xentrac&gt;</a></span><span class="message">I mean that's a nonexistent assembly syntax for an imaginary machine I just invented in my head</span></div><div class="line" id="004810"><span class="nick" style="color:#8dd3c7"><a href="#004810" label="[00:48:10]">&lt;xentrac&gt;</a></span><span class="message">with a single accumulator and a postincrementing index register addressing mode</span></div><div class="line" id="032612"><span class="nick" style="color:#80b1d3"><a href="#032612" label="[03:26:12]">&lt;oriansj&gt;</a></span><span class="message">xentrac: I find it quite odd people never consider the rather simple option of just building dedicated hardware when bootstrapping.</span></div><div class="line" id="032703"><span class="nick" style="color:#80b1d3"><a href="#032703" label="[03:27:03]">&lt;oriansj&gt;</a></span><span class="message">what is to stop one from simply implementing a tape reader/writer that follows the knight interface standard?</span></div><div class="line" id="032737"><span class="nick" style="color:#80b1d3"><a href="#032737" label="[03:27:37]">&lt;oriansj&gt;</a></span><span class="message">or atleast one close enough to be trivial changes in the early stages to go from POSIX to bare metal.</span></div><div class="line" id="032841"><span class="nick" style="color:#80b1d3"><a href="#032841" label="[03:28:41]">&lt;oriansj&gt;</a></span><span class="message">wire that shit directly to the RAM if one wants.</span></div><div class="line" id="032943"><span class="nick" style="color:#80b1d3"><a href="#032943" label="[03:29:43]">&lt;oriansj&gt;</a></span><span class="message">write this value to this memory address and wait until this memory address becomes zero; your value is now at this memory address.</span></div><div class="line" id="033101"><span class="nick" style="color:#80b1d3"><a href="#033101" label="[03:31:01]">&lt;oriansj&gt;</a></span><span class="message">spend a little more time and you get the 3 tape drives (ROM loader tape0, Input tape1 and Output tape2)</span></div><div class="line" id="033327"><span class="nick" style="color:#80b1d3"><a href="#033327" label="[03:33:27]">&lt;oriansj&gt;</a></span><span class="message">then you can write your kernel in the C subset that M2-Planet supports (or expand M2-Planet to the level required to support your kernel)</span></div><div class="line" id="033346"><span class="nick" style="color:#80b1d3"><a href="#033346" label="[03:33:46]">&lt;oriansj&gt;</a></span><span class="message">as all of those steps can be reduced down to single input and single output</span></div><div class="line" id="033421"><span class="nick" style="color:#80b1d3"><a href="#033421" label="[03:34:21]">&lt;oriansj&gt;</a></span><span class="message">stikonas: bootstrap-seeds merged.</span></div><div class="line" id="033512"><span class="nick" style="color:#8dd3c7"><a href="#033512" label="[03:35:12]">&lt;xentrac&gt;</a></span><span class="message">yeah, that's what I outlined above in fake assembly</span></div><div class="line" id="033613"><span class="nick" style="color:#8dd3c7"><a href="#033613" label="[03:36:13]">&lt;xentrac&gt;</a></span><span class="message">stikonas[m]: â†‘</span></div><div class="line" id="034132"><span class="nick" style="color:#80b1d3"><a href="#034132" label="[03:41:32]">&lt;oriansj&gt;</a></span><span class="message">and stage0-posix updated bootstrap-seeds and merged.</span></div><div class="line" id="034146"><span class="nick" style="color:#8dd3c7"><a href="#034146" label="[03:41:46]">&lt;xentrac&gt;</a></span><span class="message">wonderful!</span></div><div class="line" id="063225"><span class="nick" style="color:#6d2462"><a href="#063225" label="[06:32:25]">&lt;theruran&gt;</a></span><span class="message">xentrac: this is what I was thinking of: &quot;A pure vau-caluclus is also described (even more lightly) in Appendix C of the Kernel Report (&quot;De-trivializing the theory of fexprs&quot;).&quot;</span></div><div class="line" id="063254"><span class="nick" style="color:#8dd3c7"><a href="#063254" label="[06:32:54]">&lt;xentrac&gt;</a></span><span class="message">hmm</span></div><div class="line" id="063318"><span class="nick" style="color:#8dd3c7"><a href="#063318" label="[06:33:18]">&lt;xentrac&gt;</a></span><span class="message">wasn't Appendix C the appendix that describes the history of the letter vau?</span></div><div class="line" id="063456"><span class="nick" style="color:#6d2462"><a href="#063456" label="[06:34:56]">&lt;theruran&gt;</a></span><span class="message">no?</span></div><div class="line" id="063918"><span class="nick" style="color:#8dd3c7"><a href="#063918" label="[06:39:18]">&lt;xentrac&gt;</a></span><span class="message">&quot;Appendix C: The letter vau&quot;, pp. 375-379?</span></div><div class="line" id="063944"><span class="nick" style="color:#8dd3c7"><a href="#063944" label="[06:39:44]">&lt;xentrac&gt;</a></span><span class="message">maybe I'm looking at a different version of the dissertation?</span></div><div class="line" id="064006"><span class="nick" style="color:#8dd3c7"><a href="#064006" label="[06:40:06]">&lt;xentrac&gt;</a></span><span class="message">btw I wrote up a simple term-rewriting system today</span></div><div class="line" id="064801"><span class="nick" style="color:#6d2462"><a href="#064801" label="[06:48:01]">&lt;theruran&gt;</a></span><span class="message">in the Kernel Language Revised Report</span></div><div class="line" id="064829"><span class="nick" style="color:#8dd3c7"><a href="#064829" label="[06:48:29]">&lt;xentrac&gt;</a></span><span class="message">oh hmm</span></div><div class="line" id="065034"><span class="nick" style="color:#6d2462"><a href="#065034" label="[06:50:34]">&lt;theruran&gt;</a></span><span class="message"> <a rel="nofollow" href="https://www.irccloud.com/pastebin/SAE2ND1L/">https://www.irccloud.com/pastebin/SAE2ND1L/</a> </span></div><div class="line" id="080926"><span class="nick" style="color:#8dd3c7"><a href="#080926" label="[08:09:26]">&lt;xentrac&gt;</a></span><span class="message">theruran: hmm, could be interesting</span></div><div class="line" id="082009"><span class="nick" style="color:#8dd3c7"><a href="#082009" label="[08:20:09]">&lt;xentrac&gt;</a></span><span class="message">I just sketched out a term-rewriting interpreter that I think could maybe reach usability in a kilobyte or so of machine code.  I don't think it can beat hex0 though :)</span></div><div class="line" id="082034"><span class="nick" style="color:#8dd3c7"><a href="#082034" label="[08:20:34]">&lt;xentrac&gt;</a></span><span class="message">in <a rel="nofollow" href="http://canonical.org/~kragen/dernocua.git">http://canonical.org/~kragen/dernocua.git</a>  in file text/term-rewriting-micro-interpreter.md</span></div><div class="line" id="093752"><span class="nick" style="color:#8dd3c7"><a href="#093752" label="[09:37:52]">&lt;xentrac&gt;</a></span><span class="message">theruran: you might be interested</span></div><div class="line" id="170100"><span class="nick" style="color:#80b1d3"><a href="#170100" label="[17:01:00]">&lt;oriansj&gt;</a></span><span class="message">the question is when (not if) someone is going to try to find the absolute minimal number of bytes required to implement hex0.</span></div><div class="line" id="172555"><span class="nick" style="color:#80b1d3"><a href="#172555" label="[17:25:55]">&lt;oriansj&gt;</a></span><span class="message">as there is considerable space remaining in potential size optimization (if not clarity)</span></div><div class="line" id="173317"><span class="nick" style="color:#389600"><a href="#173317" label="[17:33:17]">&lt;stikonas&gt;</a></span><span class="message">well, not all ISAs are good for minimal hex0</span></div><div class="line" id="173343"><span class="nick" style="color:#389600"><a href="#173343" label="[17:33:43]">&lt;stikonas&gt;</a></span><span class="message">probably want some low bit, definitely not 64-bit one...</span></div><div class="line" id="173748"><span class="nick" style="color:#389600"><a href="#173748" label="[17:37:48]">&lt;stikonas&gt;</a></span><span class="message">hmm, unless we do extra work cc_* will be the last program to run on RV32I subset of Risc-V</span></div><div class="line" id="173759"><span class="nick" style="color:#389600"><a href="#173759" label="[17:37:59]">&lt;stikonas&gt;</a></span><span class="message">M2-Planet uses multiplication, etc in a few places</span></div><div class="line" id="173811"><span class="nick" style="color:#389600"><a href="#173811" label="[17:38:11]">&lt;stikonas&gt;</a></span><span class="message">that's probably fine though</span></div><div class="line" id="173853"><span class="nick" style="color:#389600"><a href="#173853" label="[17:38:53]">&lt;stikonas&gt;</a></span><span class="message">if somebody really has RV32I only hardware, they can implement software multiplication in M2-Planet instead...</span></div><div class="line" id="182137"><span class="nick" style="color:#8dd3c7"><a href="#182137" label="[18:21:37]">&lt;xentrac&gt;</a></span><span class="message">absolute minimal number of bytes is probably not ideal for auditability</span></div><div class="line" id="182331"><span class="nick" style="color:#8dd3c7"><a href="#182331" label="[18:23:31]">&lt;xentrac&gt;</a></span><span class="message">probably if someone does want auditable hardware they wouldn't include a multiplier.  that's a lot of transistors to save a pretty small amount of code</span></div><div class="line" id="182423"><span class="nick" style="color:#389600"><a href="#182423" label="[18:24:23]">&lt;stikonas&gt;</a></span><span class="message">yes, I think most of those small risc-v cpus don't have multiplication</span></div><div class="line" id="182457"><span class="nick" style="color:#389600"><a href="#182457" label="[18:24:57]">&lt;stikonas&gt;</a></span><span class="message">but what I mean, if somebody needs to work with such hardware, at that time they can juts patch M2-Planet and write that multiplication function in simple C...</span></div><div class="line" id="183001"><span class="nick" style="color:#389600"><a href="#183001" label="[18:30:01]">&lt;stikonas&gt;</a></span><span class="message">hmm, actually cc_* also have a few divisions/multiplications</span></div><div class="line" id="184200"><span class="nick" style="color:#8dd3c7"><a href="#184200" label="[18:42:00]">&lt;xentrac&gt;</a></span><span class="message">in Ur-Scheme I didn't implement multiplication or division</span></div><div class="line" id="184500"><span class="nick" style="color:#8dd3c7"><a href="#184500" label="[18:45:00]">&lt;xentrac&gt;</a></span><span class="message">just (define (2* x) (+ x x)) and similarly 4*</span></div><div class="line" id="190230"><span class="nick" style="color:#234e69"><a href="#190230" label="[19:02:30]">&lt;stikonas[m]&gt;</a></span><span class="message">Well, multiplication by any constant integer is easy to do with bit shifts</span></div><div class="line" id="190309"><span class="nick" style="color:#234e69"><a href="#190309" label="[19:03:09]">&lt;stikonas[m]&gt;</a></span><span class="message">But two arbitrary variables need more code</span></div><div class="line" id="190314"><span class="nick" style="color:#8dd3c7"><a href="#190314" label="[19:03:14]">&lt;xentrac&gt;</a></span><span class="message">Yeah, but I avoided having to do that, or implement bit shifts; I got away with just 2* and 4*</span></div><div class="line" id="190445"><span class="nick" style="color:#8dd3c7"><a href="#190445" label="[19:04:45]">&lt;xentrac&gt;</a></span><span class="message">oh I'm wrong, I also implemented 10* and 8*</span></div><div class="line" id="190622"><span class="nick" style="color:#8dd3c7"><a href="#190622" label="[19:06:22]">&lt;xentrac&gt;</a></span><span class="message">OTOH I didn't have to implement even the i386 ModR/M byte for Ur-Scheme, much less the noticeably uglier RISC-V instruction formats, because I sort of fobbed that off on the assembler</span></div><div class="line" id="190647"><span class="nick" style="color:#8dd3c7"><a href="#190647" label="[19:06:47]">&lt;xentrac&gt;</a></span><span class="message">and I *did* implement quotient and remainder</span></div><div class="line" id="190802"><span class="nick" style="color:#8dd3c7"><a href="#190802" label="[19:08:02]">&lt;xentrac&gt;</a></span><span class="message">and I used right shifts too, though only in assembly</span></div><div class="line" id="191304"><span class="nick" style="color:#80b1d3"><a href="#191304" label="[19:13:04]">&lt;oriansj&gt;</a></span><span class="message">stikonas: if you notice, ARMv7l doesn't have division or modulo; so in M2-Planet we just created a software routine and simply called it with with the arguments in R0 and R1 with the result returned in R0</span></div><div class="line" id="191326"><span class="nick" style="color:#8dd3c7"><a href="#191326" label="[19:13:26]">&lt;xentrac&gt;</a></span><span class="message">I think reducing hex0 much further would probably involve refactoring its responsibilities so it doesn't have to open files and chmod things.  your idea about just using memory buffers and invoking hex0 as a subroutine seems clearly correct for bootstrapping before a kernel</span></div><div class="line" id="191327"><span class="nick" style="color:#389600"><a href="#191327" label="[19:13:27]">&lt;stikonas&gt;</a></span><span class="message">oh, so it's already done in M2-Planet...</span></div><div class="line" id="191331"><span class="nick" style="color:#80b1d3"><a href="#191331" label="[19:13:31]">&lt;oriansj&gt;</a></span><span class="message">So RISC-V can very trivially do the same thing for multiplication, division and modulo</span></div><div class="line" id="191341"><span class="nick" style="color:#389600"><a href="#191341" label="[19:13:41]">&lt;stikonas&gt;</a></span><span class="message">well, maybe at some point I'll do it for cc_* too</span></div><div class="line" id="191357"><span class="nick" style="color:#389600"><a href="#191357" label="[19:13:57]">&lt;stikonas&gt;</a></span><span class="message">although first I think I'll just write with hw division</span></div><div class="line" id="191407"><span class="nick" style="color:#389600"><a href="#191407" label="[19:14:07]">&lt;stikonas&gt;</a></span><span class="message">and then it can be added on top</span></div><div class="line" id="191502"><span class="nick" style="color:#80b1d3"><a href="#191502" label="[19:15:02]">&lt;oriansj&gt;</a></span><span class="message">stikonas: actually I suggest doing: <a rel="nofollow" href="https://github.com/oriansj/stage0/tree/master/stage2/High_level_prototypes/cc_amd64">https://github.com/oriansj/stage0/tree/master/stage2/High_level_prototypes/cc_amd64</a>  for RISC-V before you start doing it in assembly (to work out the basics first)</span></div><div class="line" id="191524"><span class="nick" style="color:#389600"><a href="#191524" label="[19:15:24]">&lt;stikonas&gt;</a></span><span class="message">hmm, I was thinking of doing cc_amd64 in riscv first</span></div><div class="line" id="191556"><span class="nick" style="color:#389600"><a href="#191556" label="[19:15:56]">&lt;stikonas&gt;</a></span><span class="message">and then maybe do C prototype when I port cc_amd64-&gt;cc_riscv64</span></div><div class="line" id="191610"><span class="nick" style="color:#389600"><a href="#191610" label="[19:16:10]">&lt;stikonas&gt;</a></span><span class="message">btw, those prototypes need extra linker flags to build with recent gcc</span></div><div class="line" id="191630"><span class="nick" style="color:#389600"><a href="#191630" label="[19:16:30]">&lt;stikonas&gt;</a></span><span class="message">need to add  -Wl,--allow-multiple-definition to CFLAGS</span></div><div class="line" id="191642"><span class="nick" style="color:#389600"><a href="#191642" label="[19:16:42]">&lt;stikonas&gt;</a></span><span class="message">well, it's actually LDFLAG but anyway...</span></div><div class="line" id="191659"><span class="nick" style="color:#8dd3c7"><a href="#191659" label="[19:16:59]">&lt;xentrac&gt;</a></span><span class="message">if it can be postponed until after you have a C compiler, you could have one division subroutine for all platforms instead of one per platform.  though as jessica clarke pointed out, ultimately the instruction set that matters for trusting trust is the one you have auditable hardware for, and I think her idea of doing an unjumbled version of RISC-V to make the binary code more auditable is</span></div><div class="line" id="191705"><span class="nick" style="color:#8dd3c7"><a href="#191705" label="[19:17:05]">&lt;xentrac&gt;</a></span><span class="message">probably worthwhile</span></div><div class="line" id="191729"><span class="nick" style="color:#8dd3c7"><a href="#191729" label="[19:17:29]">&lt;xentrac&gt;</a></span><span class="message">even if it does require a few more transistors and slow down the clock</span></div><div class="line" id="191735"><span class="nick" style="color:#389600"><a href="#191735" label="[19:17:35]">&lt;stikonas&gt;</a></span><span class="message">jumbling doesn't make binary code that much more complicated</span></div><div class="line" id="191737"><span class="nick" style="color:#80b1d3"><a href="#191737" label="[19:17:37]">&lt;oriansj&gt;</a></span><span class="message">stikonas: it is cc_* in C for the architecture in question to work out the details ahead of time: as you can see here: <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/stage2/High_level_prototypes/cc_armv7l/cc_core.c#L486">https://github.com/oriansj/stage0/blob/master/stage2/High_level_prototypes/cc_armv7l/cc_core.c#L486</a> </span></div><div class="line" id="191737"><span class="nick" style="color:#80b1d3"><a href="#191737" label="[19:17:37]">&lt;oriansj&gt;</a></span><span class="message">where the details of division are sorted out and the order details specific to the assembly</span></div><div class="line" id="191741"><span class="nick" style="color:#80b1d3"><a href="#191741" label="[19:17:41]">&lt;oriansj&gt;</a></span><span class="message">for example in ARMv7l it was label then instruction rather than instruction then label in the output for x86</span></div><div class="line" id="191807"><span class="nick" style="color:#8dd3c7"><a href="#191807" label="[19:18:07]">&lt;xentrac&gt;</a></span><span class="message">it makes binary code much harder to read, but only somewhat harder to generate from a compiler</span></div><div class="line" id="191944"><span class="nick" style="color:#80b1d3"><a href="#191944" label="[19:19:44]">&lt;oriansj&gt;</a></span><span class="message">xentrac: I think stikonas demonstrated that although the jumbling is a pain, it isn't actually an issue in bootstrapping once we figured out the .hex .hex word solution.</span></div><div class="line" id="192005"><span class="nick" style="color:#389600"><a href="#192005" label="[19:20:05]">&lt;stikonas&gt;</a></span><span class="message">and once you have hex1, it's only immediates that are a bit jumbled</span></div><div class="line" id="192024"><span class="nick" style="color:#389600"><a href="#192024" label="[19:20:24]">&lt;stikonas&gt;</a></span><span class="message">and most common onces (I-type used in ADDI and LD) are not jumbled</span></div><div class="line" id="192039"><span class="nick" style="color:#80b1d3"><a href="#192039" label="[19:20:39]">&lt;oriansj&gt;</a></span><span class="message">and once you implement that in M0 and M1 it doesn't actually matter up the chain.</span></div><div class="line" id="192059"><span class="nick" style="color:#389600"><a href="#192059" label="[19:20:59]">&lt;stikonas&gt;</a></span><span class="message">yeah, I can finally write final code directly now after M0</span></div><div class="line" id="192109"><span class="nick" style="color:#389600"><a href="#192109" label="[19:21:09]">&lt;stikonas&gt;</a></span><span class="message">(will probably just skip GAS version)</span></div><div class="line" id="192228"><span class="nick" style="color:#8dd3c7"><a href="#192228" label="[19:22:28]">&lt;xentrac&gt;</a></span><span class="message">oriansj: the .hex .hex word solution helps with generating the binary code, but not with auditing the binary seed.  but I guess using B-type and J-type instructions sparingly helps with that</span></div><div class="line" id="192259"><span class="nick" style="color:#389600"><a href="#192259" label="[19:22:59]">&lt;stikonas&gt;</a></span><span class="message">xentrac: well, it kind of helps with auditing too</span></div><div class="line" id="192301"><span class="nick" style="color:#80b1d3"><a href="#192301" label="[19:23:01]">&lt;oriansj&gt;</a></span><span class="message">the only thing that needs to be accounted for the immediate encoding is the need for two instructions rather than 1 in certain cases, in which case we can do this: <a rel="nofollow" href="https://github.com/oriansj/M2-Planet/blob/master/cc_core.c#L535">https://github.com/oriansj/M2-Planet/blob/master/cc_core.c#L535</a> </span></div><div class="line" id="192303"><span class="nick" style="color:#389600"><a href="#192303" label="[19:23:03]">&lt;stikonas&gt;</a></span><span class="message">because we have prototypes</span></div><div class="line" id="192314"><span class="nick" style="color:#389600"><a href="#192314" label="[19:23:14]">&lt;stikonas&gt;</a></span><span class="message">so you can take a look what word decomposes into</span></div><div class="line" id="192322"><span class="nick" style="color:#389600"><a href="#192322" label="[19:23:22]">&lt;stikonas&gt;</a></span><span class="message">and check if it adds up to what you expect</span></div><div class="line" id="192353"><span class="nick" style="color:#80b1d3"><a href="#192353" label="[19:23:53]">&lt;oriansj&gt;</a></span><span class="message">xentrac: we can also do it with --binary instead of hex if it makes it easier to audit</span></div><div class="line" id="192356"><span class="nick" style="color:#8dd3c7"><a href="#192356" label="[19:23:56]">&lt;xentrac&gt;</a></span><span class="message">that's true!</span></div><div class="line" id="192502"><span class="nick" style="color:#389600"><a href="#192502" label="[19:25:02]">&lt;stikonas&gt;</a></span><span class="message">in any case auditing early binaries shouldn't take longer than writing them</span></div><div class="line" id="192517"><span class="nick" style="color:#8dd3c7"><a href="#192517" label="[19:25:17]">&lt;xentrac&gt;</a></span><span class="message">the new hex0 has 5 J-type and 11 B-type instructions if I'm counting correctly</span></div><div class="line" id="192535"><span class="nick" style="color:#389600"><a href="#192535" label="[19:25:35]">&lt;stikonas&gt;</a></span><span class="message">something like that</span></div><div class="line" id="192542"><span class="nick" style="color:#8dd3c7"><a href="#192542" label="[19:25:42]">&lt;xentrac&gt;</a></span><span class="message">stikonas: yeah, but you may have to audit them more than once</span></div><div class="line" id="192619"><span class="nick" style="color:#389600"><a href="#192619" label="[19:26:19]">&lt;stikonas&gt;</a></span><span class="message">I counted 13 branches and 6 jumps</span></div><div class="line" id="192630"><span class="nick" style="color:#389600"><a href="#192630" label="[19:26:30]">&lt;stikonas&gt;</a></span><span class="message">in riscv version</span></div><div class="line" id="192635"><span class="nick" style="color:#389600"><a href="#192635" label="[19:26:35]">&lt;stikonas&gt;</a></span><span class="message">but some of them are duplicate</span></div><div class="line" id="192643"><span class="nick" style="color:#8dd3c7"><a href="#192643" label="[19:26:43]">&lt;xentrac&gt;</a></span><span class="message">I probably missed some</span></div><div class="line" id="192711"><span class="nick" style="color:#389600"><a href="#192711" label="[19:27:11]">&lt;stikonas&gt;</a></span><span class="message">some of them identical e.g. both are jump 2 instructions forward</span></div><div class="line" id="192758"><span class="nick" style="color:#389600"><a href="#192758" label="[19:27:58]">&lt;stikonas&gt;</a></span><span class="message">well, you can get rid of some of them if you want at the expense of more complicated code</span></div><div class="line" id="192835"><span class="nick" style="color:#389600"><a href="#192835" label="[19:28:35]">&lt;stikonas&gt;</a></span><span class="message">e.g. hexifying part of the hex0 can be done with branchless programming</span></div><div class="line" id="192903"><span class="nick" style="color:#8dd3c7"><a href="#192903" label="[19:29:03]">&lt;xentrac&gt;</a></span><span class="message">not sure whether that would make it more complicated or not</span></div><div class="line" id="192909"><span class="nick" style="color:#389600"><a href="#192909" label="[19:29:09]">&lt;stikonas&gt;</a></span><span class="message">exactly...</span></div><div class="line" id="192915"><span class="nick" style="color:#8dd3c7"><a href="#192915" label="[19:29:15]">&lt;xentrac&gt;</a></span><span class="message">maybe not</span></div><div class="line" id="192915"><span class="nick" style="color:#389600"><a href="#192915" label="[19:29:15]">&lt;stikonas&gt;</a></span><span class="message">it's more complicated alrgorithm</span></div><div class="line" id="192926"><span class="nick" style="color:#389600"><a href="#192926" label="[19:29:26]">&lt;stikonas&gt;</a></span><span class="message">but you avoid risc-v jumbling</span></div><div class="line" id="192931"><span class="nick" style="color:#8dd3c7"><a href="#192931" label="[19:29:31]">&lt;xentrac&gt;</a></span><span class="message">right</span></div><div class="line" id="192935"><span class="nick" style="color:#8dd3c7"><a href="#192935" label="[19:29:35]">&lt;xentrac&gt;</a></span><span class="message">if you dehexify something, are you exorcising it?  sanctifying it?</span></div><div class="line" id="193034"><span class="nick" style="color:#389600"><a href="#193034" label="[19:30:34]">&lt;stikonas&gt;</a></span><span class="message">uncursing?</span></div><div class="line" id="193039"><span class="nick" style="color:#8dd3c7"><a href="#193039" label="[19:30:39]">&lt;xentrac&gt;</a></span><span class="message">uncursing :)</span></div><div class="line" id="193226"><span class="nick" style="color:#8dd3c7"><a href="#193226" label="[19:32:26]">&lt;xentrac&gt;</a></span><span class="message">btw, I mentioned your work on this as an inspiration in text/term-rewriting-micro-interpreter.md in <a rel="nofollow" href="http://canonical.org/~kragen/dernocua.git">http://canonical.org/~kragen/dernocua.git</a> </span></div><div class="line" id="193240"><span class="nick" style="color:#8dd3c7"><a href="#193240" label="[19:32:40]">&lt;xentrac&gt;</a></span><span class="message">which is still kind of a sketch</span></div><div class="line" id="193537"><span class="nick" style="color:#389600"><a href="#193537" label="[19:35:37]">&lt;stikonas&gt;</a></span><span class="message">well, you can't have something 100-bytes on POSIX...</span></div><div class="line" id="193627"><span class="nick" style="color:#8dd3c7"><a href="#193627" label="[19:36:27]">&lt;xentrac&gt;</a></span><span class="message"> <a rel="nofollow" href="https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html">https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html</a>  is 45 bytes</span></div><div class="line" id="193644"><span class="nick" style="color:#389600"><a href="#193644" label="[19:36:44]">&lt;stikonas&gt;</a></span><span class="message">elf header is 120 bytes</span></div><div class="line" id="193649"><span class="nick" style="color:#8dd3c7"><a href="#193649" label="[19:36:49]">&lt;xentrac&gt;</a></span><span class="message">you'd think</span></div><div class="line" id="193702"><span class="nick" style="color:#389600"><a href="#193702" label="[19:37:02]">&lt;stikonas&gt;</a></span><span class="message">and you need at least 2 instructions 2 exit, so I would think 128 bytes</span></div><div class="line" id="193709"><span class="nick" style="color:#8dd3c7"><a href="#193709" label="[19:37:09]">&lt;xentrac&gt;</a></span><span class="message">I don't think POSIX is so much the obstacle as ELF, but even ELF turns out to be more flexible than that</span></div><div class="line" id="193727"><span class="nick" style="color:#389600"><a href="#193727" label="[19:37:27]">&lt;stikonas&gt;</a></span><span class="message">hmm, that's probably some older non-elf format?</span></div><div class="line" id="193730"><span class="nick" style="color:#389600"><a href="#193730" label="[19:37:30]">&lt;stikonas&gt;</a></span><span class="message">a.out I guess</span></div><div class="line" id="193730"><span class="nick" style="color:#8dd3c7"><a href="#193730" label="[19:37:30]">&lt;xentrac&gt;</a></span><span class="message">nope</span></div><div class="line" id="193740"><span class="nick" style="color:#8dd3c7"><a href="#193740" label="[19:37:40]">&lt;xentrac&gt;</a></span><span class="message">it's ELF</span></div><div class="line" id="193756"><span class="nick" style="color:#80b1d3"><a href="#193756" label="[19:37:56]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well there are probably headerless executable formats for POSIX that we can use as nothing in the lower stages demands ELF</span></div><div class="line" id="193758"><span class="nick" style="color:#8dd3c7"><a href="#193758" label="[19:37:58]">&lt;xentrac&gt;</a></span><span class="message">last time I talked to Brian Raiter about it, it even ran on current Linux</span></div><div class="line" id="193825"><span class="nick" style="color:#8dd3c7"><a href="#193825" label="[19:38:25]">&lt;xentrac&gt;</a></span><span class="message">POSIX doesn't really define ABIs in general; that wouldn't be PO</span></div><div class="line" id="193843"><span class="nick" style="color:#80b1d3"><a href="#193843" label="[19:38:43]">&lt;oriansj&gt;</a></span><span class="message">perhaps a .COM format of sorts that is supported by BSDs and Linux</span></div><div class="line" id="193953"><span class="nick" style="color:#389600"><a href="#193953" label="[19:39:53]">&lt;stikonas&gt;</a></span><span class="message">anyway, elf header is closer to metadata than code</span></div><div class="line" id="193957"><span class="nick" style="color:#8dd3c7"><a href="#193957" label="[19:39:57]">&lt;xentrac&gt;</a></span><span class="message">I don't think there is such a thing.  well, except for .COM itself, which is supported by various DOS and Windows emulation stuff</span></div><div class="line" id="194102"><span class="nick" style="color:#389600"><a href="#194102" label="[19:41:02]">&lt;stikonas&gt;</a></span><span class="message">well, that 45 byte &quot;program&quot; kind of uses part of elf header as &quot;code&quot;</span></div><div class="line" id="194127"><span class="nick" style="color:#80b1d3"><a href="#194127" label="[19:41:27]">&lt;oriansj&gt;</a></span><span class="message">xentrac: what sort of effort required would it take to add a new executable format to the BSDs and Linux?</span></div><div class="line" id="194127"><span class="nick" style="color:#8dd3c7"><a href="#194127" label="[19:41:27]">&lt;xentrac&gt;</a></span><span class="message">yes, it packs the code into an unused part of the ELF header</span></div><div class="line" id="194221"><span class="nick" style="color:#80b1d3"><a href="#194221" label="[19:42:21]">&lt;oriansj&gt;</a></span><span class="message">like 4bytes Magic header: dump rest into memory at a fixed address, RX permissions only</span></div><div class="line" id="194224"><span class="nick" style="color:#389600"><a href="#194224" label="[19:42:24]">&lt;stikonas&gt;</a></span><span class="message">I doubt it makes sense to introduce new executable format...</span></div><div class="line" id="194245"><span class="nick" style="color:#80b1d3"><a href="#194245" label="[19:42:45]">&lt;oriansj&gt;</a></span><span class="message">stikonas: generally agree here but I am curious</span></div><div class="line" id="194246"><span class="nick" style="color:#389600"><a href="#194246" label="[19:42:46]">&lt;stikonas&gt;</a></span><span class="message">elf header is much easier to inspect than rest of the code</span></div><div class="line" id="194253"><span class="nick" style="color:#8dd3c7"><a href="#194253" label="[19:42:53]">&lt;xentrac&gt;</a></span><span class="message">oriansj: if you can put an interpreter in the root directory, you can get by witha 5-byte magic header: #!/x</span></div><div class="line" id="194258"><span class="nick" style="color:#389600"><a href="#194258" label="[19:42:58]">&lt;stikonas&gt;</a></span><span class="message">most of early programs use almost identical headers</span></div><div class="line" id="194259"><span class="nick" style="color:#8dd3c7"><a href="#194259" label="[19:42:59]">&lt;xentrac&gt;</a></span><span class="message">well #!/x\n</span></div><div class="line" id="194340"><span class="nick" style="color:#8dd3c7"><a href="#194340" label="[19:43:40]">&lt;xentrac&gt;</a></span><span class="message">(and if you can't put things in the root directory, loading a kernel module is going to be a much more significant difficulty)</span></div><div class="line" id="194347"><span class="nick" style="color:#80b1d3"><a href="#194347" label="[19:43:47]">&lt;oriansj&gt;</a></span><span class="message">xentrac: no other binaries besides kaem-optional and hex0</span></div><div class="line" id="194359"><span class="nick" style="color:#8dd3c7"><a href="#194359" label="[19:43:59]">&lt;xentrac&gt;</a></span><span class="message">not even the kernel?</span></div><div class="line" id="194410"><span class="nick" style="color:#389600"><a href="#194410" label="[19:44:10]">&lt;stikonas&gt;</a></span><span class="message">you have kernel</span></div><div class="line" id="194415"><span class="nick" style="color:#389600"><a href="#194415" label="[19:44:15]">&lt;stikonas&gt;</a></span><span class="message">otherwise it makes no sense to talk about headers</span></div><div class="line" id="194424"><span class="nick" style="color:#8dd3c7"><a href="#194424" label="[19:44:24]">&lt;xentrac&gt;</a></span><span class="message">yeah, that's what I was thinking</span></div><div class="line" id="194436"><span class="nick" style="color:#8dd3c7"><a href="#194436" label="[19:44:36]">&lt;xentrac&gt;</a></span><span class="message">but the kernel is... noticeably larger than kaem-optional</span></div><div class="line" id="194437"><span class="nick" style="color:#389600"><a href="#194437" label="[19:44:37]">&lt;stikonas&gt;</a></span><span class="message">you just have code at CPU entry address without kernel</span></div><div class="line" id="194558"><span class="nick" style="color:#80b1d3"><a href="#194558" label="[19:45:58]">&lt;oriansj&gt;</a></span><span class="message">well stage0-posix is the smallest set of userspace bootstrap pieces, stage0 is the bare metal stuff and it is the exact same steps with much more complex hardware requirements.</span></div><div class="line" id="194701"><span class="nick" style="color:#80b1d3"><a href="#194701" label="[19:47:01]">&lt;oriansj&gt;</a></span><span class="message">hence why I am figuring out the minimal bootstrap filesystem that could be used to bootstrap a proper POSIX kernel and go the rest of the way to Linux+GCC+Guile (needed for Guix to do the rest)</span></div><div class="line" id="194723"><span class="nick" style="color:#8dd3c7"><a href="#194723" label="[19:47:23]">&lt;xentrac&gt;</a></span><span class="message">if you're willing to depend on kernel modules, you could just load a Scheme interpreter into the kernel</span></div><div class="line" id="194739"><span class="nick" style="color:#389600"><a href="#194739" label="[19:47:39]">&lt;stikonas&gt;</a></span><span class="message">even fossy's linux kernel is compiled without kernel modules...</span></div><div class="line" id="194749"><span class="nick" style="color:#80b1d3"><a href="#194749" label="[19:47:49]">&lt;oriansj&gt;</a></span><span class="message">xentrac: and then just directly run MesCC+slow-utils and be done</span></div><div class="line" id="194755"><span class="nick" style="color:#8dd3c7"><a href="#194755" label="[19:47:55]">&lt;xentrac&gt;</a></span><span class="message">exactly</span></div><div class="line" id="194808"><span class="nick" style="color:#8dd3c7"><a href="#194808" label="[19:48:08]">&lt;xentrac&gt;</a></span><span class="message">(or other arbitrary kernel code; you can compile a Scheme interpreter in statically just as easily)</span></div><div class="line" id="194824"><span class="nick" style="color:#389600"><a href="#194824" label="[19:48:24]">&lt;stikonas&gt;</a></span><span class="message">well, putting interpreters, etc into kernels is a bit of cheating</span></div><div class="line" id="194840"><span class="nick" style="color:#80b1d3"><a href="#194840" label="[19:48:40]">&lt;oriansj&gt;</a></span><span class="message">stikonas: not a bit, entirely cheating.</span></div><div class="line" id="194907"><span class="nick" style="color:#389600"><a href="#194907" label="[19:49:07]">&lt;stikonas&gt;</a></span><span class="message">kernel functionality that is used should just be bits that abstract out hardware, i.e. reading from files rather than some tape, etc...</span></div><div class="line" id="194920"><span class="nick" style="color:#80b1d3"><a href="#194920" label="[19:49:20]">&lt;oriansj&gt;</a></span><span class="message">it is kinda like saying the smallest hello world is a precompiled binary named a</span></div><div class="line" id="194953"><span class="nick" style="color:#8dd3c7"><a href="#194953" label="[19:49:53]">&lt;xentrac&gt;</a></span><span class="message">echo '#!/bin/echo' &gt; hello; chmod 755 hello</span></div><div class="line" id="195123"><span class="nick" style="color:#8dd3c7"><a href="#195123" label="[19:51:23]">&lt;xentrac&gt;</a></span><span class="message">anyway, stikonas, in non-cheating land, I think your idea of invoking hex0 as a subroutine to transcode bytes from one memory buffer to another is an excellent one</span></div><div class="line" id="195227"><span class="nick" style="color:#389600"><a href="#195227" label="[19:52:27]">&lt;stikonas&gt;</a></span><span class="message">it's not really my idea...</span></div><div class="line" id="195240"><span class="nick" style="color:#389600"><a href="#195240" label="[19:52:40]">&lt;stikonas&gt;</a></span><span class="message">that's just how bare metal programs run...</span></div><div class="line" id="195242"><span class="nick" style="color:#80b1d3"><a href="#195242" label="[19:52:42]">&lt;oriansj&gt;</a></span><span class="message">there are a great meany details in bare-metal bootstrapping still needing to be worked out.</span></div><div class="line" id="195244"><span class="nick" style="color:#389600"><a href="#195244" label="[19:52:44]">&lt;stikonas&gt;</a></span><span class="message">there are no processes there</span></div><div class="line" id="195308"><span class="nick" style="color:#8dd3c7"><a href="#195308" label="[19:53:08]">&lt;xentrac&gt;</a></span><span class="message">some bare metal programs interact with I/O devices</span></div><div class="line" id="195320"><span class="nick" style="color:#80b1d3"><a href="#195320" label="[19:53:20]">&lt;oriansj&gt;</a></span><span class="message">with a couple tape drives everything from hex0 to M2-Planet have been sorted out but after that we need a filesystem and a kernel</span></div><div class="line" id="195337"><span class="nick" style="color:#8dd3c7"><a href="#195337" label="[19:53:37]">&lt;xentrac&gt;</a></span><span class="message">we don't really need a kernel</span></div><div class="line" id="195358"><span class="nick" style="color:#8dd3c7"><a href="#195358" label="[19:53:58]">&lt;xentrac&gt;</a></span><span class="message">just a sort of monitor thing that lets us load one program after another</span></div><div class="line" id="195403"><span class="nick" style="color:#80b1d3"><a href="#195403" label="[19:54:03]">&lt;oriansj&gt;</a></span><span class="message">xentrac: the step after M2-Planet is MesCC and yes it absolutely needs a POSIX kernel</span></div><div class="line" id="195450"><span class="nick" style="color:#389600"><a href="#195450" label="[19:54:50]">&lt;stikonas&gt;</a></span><span class="message">well, there are some intermediate tools before mescc but yes, if we count just C compilers...</span></div><div class="line" id="195528"><span class="nick" style="color:#8dd3c7"><a href="#195528" label="[19:55:28]">&lt;xentrac&gt;</a></span><span class="message">you said it only needs exit, execve, fork, waitpid, brk, open, close, read, write, lseek, chmod, fchmod, access, chdir, fchdir, mkdir, mknod, getcwd, umask, uname, unlink, ioctl, stat and fsync</span></div><div class="line" id="195533"><span class="nick" style="color:#8dd3c7"><a href="#195533" label="[19:55:33]">&lt;xentrac&gt;</a></span><span class="message">IIRC</span></div><div class="line" id="195534"><span class="nick" style="color:#80b1d3"><a href="#195534" label="[19:55:34]">&lt;oriansj&gt;</a></span><span class="message">mescc-tools and mescc-tools-extras</span></div><div class="line" id="195558"><span class="nick" style="color:#80b1d3"><a href="#195558" label="[19:55:58]">&lt;oriansj&gt;</a></span><span class="message">then after MesCC, we have TCC and its requirements</span></div><div class="line" id="195612"><span class="nick" style="color:#80b1d3"><a href="#195612" label="[19:56:12]">&lt;oriansj&gt;</a></span><span class="message">but then we can build a Linux or BSD possibly</span></div><div class="line" id="195620"><span class="nick" style="color:#8dd3c7"><a href="#195620" label="[19:56:20]">&lt;xentrac&gt;</a></span><span class="message">and IIRC it uses fork+exit+waitpid in a stereotyped way that doesn't actually require multiple concurrent processes</span></div><div class="line" id="195652"><span class="nick" style="color:#80b1d3"><a href="#195652" label="[19:56:52]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well we did try to make it into a solvable problem ^_^</span></div><div class="line" id="195701"><span class="nick" style="color:#8dd3c7"><a href="#195701" label="[19:57:01]">&lt;xentrac&gt;</a></span><span class="message">and ioctl is just isatty</span></div><div class="line" id="195720"><span class="nick" style="color:#80b1d3"><a href="#195720" label="[19:57:20]">&lt;oriansj&gt;</a></span><span class="message">but it needs to be something that M2-Planet can compile</span></div><div class="line" id="195729"><span class="nick" style="color:#389600"><a href="#195729" label="[19:57:29]">&lt;stikonas&gt;</a></span><span class="message">yeah, ioctl can be easily patched out</span></div><div class="line" id="195738"><span class="nick" style="color:#8dd3c7"><a href="#195738" label="[19:57:38]">&lt;xentrac&gt;</a></span><span class="message">not sure what tcc requires.  not much I'm guessing</span></div><div class="line" id="195813"><span class="nick" style="color:#80b1d3"><a href="#195813" label="[19:58:13]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well expect the list of requirements to grow as we discover what assumptions of ours were wrong.</span></div><div class="line" id="195818"><span class="nick" style="color:#8dd3c7"><a href="#195818" label="[19:58:18]">&lt;xentrac&gt;</a></span><span class="message">also I think probably chmod, umask, and access there are not actually providing functionality; they're just leaping hurdles POSIX puts in your way</span></div><div class="line" id="195824"><span class="nick" style="color:#389600"><a href="#195824" label="[19:58:24]">&lt;stikonas&gt;</a></span><span class="message">well, tcc probably is not too bad</span></div><div class="line" id="195831"><span class="nick" style="color:#389600"><a href="#195831" label="[19:58:31]">&lt;stikonas&gt;</a></span><span class="message">after all somebody had tccboot project</span></div><div class="line" id="195844"><span class="nick" style="color:#8dd3c7"><a href="#195844" label="[19:58:44]">&lt;xentrac&gt;</a></span><span class="message">heh, good point</span></div><div class="line" id="195857"><span class="nick" style="color:#80b1d3"><a href="#195857" label="[19:58:57]">&lt;oriansj&gt;</a></span><span class="message">compilers need less than interpreters</span></div><div class="line" id="195859"><span class="nick" style="color:#8dd3c7"><a href="#195859" label="[19:58:59]">&lt;xentrac&gt;</a></span><span class="message">tcc evidently doesn't require a kernel to generate runnable code successfully</span></div><div class="line" id="195917"><span class="nick" style="color:#389600"><a href="#195917" label="[19:59:17]">&lt;stikonas&gt;</a></span><span class="message">yeah, most of those syscalls are either POSIX hurdles or dealing with file system/processes which is irrelevant for baremetal</span></div><div class="line" id="195918"><span class="nick" style="color:#80b1d3"><a href="#195918" label="[19:59:18]">&lt;oriansj&gt;</a></span><span class="message">So MesCC and Bash are the two with the most of the requirements</span></div><div class="line" id="195941"><span class="nick" style="color:#8dd3c7"><a href="#195941" label="[19:59:41]">&lt;xentrac&gt;</a></span><span class="message">hmm, does djgpp still exist?  does it include bash?</span></div><div class="line" id="195942"><span class="nick" style="color:#389600"><a href="#195942" label="[19:59:42]">&lt;stikonas&gt;</a></span><span class="message">yeah, bash definitely needs kernel</span></div><div class="line" id="195949"><span class="nick" style="color:#8dd3c7"><a href="#195949" label="[19:59:49]">&lt;xentrac&gt;</a></span><span class="message">because djgpp runs without a kernel</span></div><div class="line" id="200035"><span class="nick" style="color:#8dd3c7"><a href="#200035" label="[20:00:35]">&lt;xentrac&gt;</a></span><span class="message">anyway so I don't think you need a kernel, just a filesystem and some way of returning control to a monitor</span></div><div class="line" id="200112"><span class="nick" style="color:#389600"><a href="#200112" label="[20:01:12]">&lt;stikonas&gt;</a></span><span class="message">well, returning control is simple</span></div><div class="line" id="200123"><span class="nick" style="color:#389600"><a href="#200123" label="[20:01:23]">&lt;stikonas&gt;</a></span><span class="message">that's exactly the same as you return from functions inside your program</span></div><div class="line" id="200139"><span class="nick" style="color:#389600"><a href="#200139" label="[20:01:39]">&lt;stikonas&gt;</a></span><span class="message">e.g. store return address in some register</span></div><div class="line" id="200211"><span class="nick" style="color:#80b1d3"><a href="#200211" label="[20:02:11]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well kaem-optional is the monitor and a kernel that just provides a handful of syscalls like a runtime library in a separate memory space</span></div><div class="line" id="200212"><span class="nick" style="color:#389600"><a href="#200212" label="[20:02:12]">&lt;stikonas&gt;</a></span><span class="message">or in some predetermined memory lcoation</span></div><div class="line" id="200218"><span class="nick" style="color:#8dd3c7"><a href="#200218" label="[20:02:18]">&lt;xentrac&gt;</a></span><span class="message"> <a rel="nofollow" href="https://en.wikipedia.org/wiki/DJGPP">https://en.wikipedia.org/wiki/DJGPP</a>  makes it sound like it's not actually dead; it includes GCC 9.3.0</span></div><div class="line" id="200228"><span class="nick" style="color:#389600"><a href="#200228" label="[20:02:28]">&lt;stikonas&gt;</a></span><span class="message">yeah, without kernel need to be more careful with memory partitioning</span></div><div class="line" id="200245"><span class="nick" style="color:#389600"><a href="#200245" label="[20:02:45]">&lt;stikonas&gt;</a></span><span class="message">and manage registers better (kernel zeroes them before program is started)</span></div><div class="line" id="200413"><span class="nick" style="color:#80b1d3"><a href="#200413" label="[20:04:13]">&lt;oriansj&gt;</a></span><span class="message">kernels seem like a better option when one isn't short on RAM and have a working MMU in hardware</span></div><div class="line" id="200503"><span class="nick" style="color:#80b1d3"><a href="#200503" label="[20:05:03]">&lt;oriansj&gt;</a></span><span class="message">if not Amiga EXEC <a rel="nofollow" href="https://en.wikipedia.org/wiki/Exec_">https://en.wikipedia.org/wiki/Exec_</a>(Amiga)  shared functionality library at fixed memory address is a better idea</span></div><div class="line" id="200601"><span class="nick" style="color:#389600"><a href="#200601" label="[20:06:01]">&lt;stikonas&gt;</a></span><span class="message">we don't even need multitasking...</span></div><div class="line" id="200638"><span class="nick" style="color:#8dd3c7"><a href="#200638" label="[20:06:38]">&lt;xentrac&gt;</a></span><span class="message">multitasking is easier than memory protection</span></div><div class="line" id="200714"><span class="nick" style="color:#80b1d3"><a href="#200714" label="[20:07:14]">&lt;oriansj&gt;</a></span><span class="message">stikonas: true but the idea is a kernel just being a library at a fixed memory address that one uses</span></div><div class="line" id="200726"><span class="nick" style="color:#8dd3c7"><a href="#200726" label="[20:07:26]">&lt;xentrac&gt;</a></span><span class="message">but even memory protection is not rocket science on RISC-V</span></div><div class="line" id="201001"><span class="nick" style="color:#80b1d3"><a href="#201001" label="[20:10:01]">&lt;oriansj&gt;</a></span><span class="message">well MMUs are not free in terms of transistors but they are probably worth it</span></div><div class="line" id="201100"><span class="nick" style="color:#8dd3c7"><a href="#201100" label="[20:11:00]">&lt;xentrac&gt;</a></span><span class="message">they definitely make debugging a lot less painful :)</span></div><div class="line" id="201154"><span class="nick" style="color:#8dd3c7"><a href="#201154" label="[20:11:54]">&lt;xentrac&gt;</a></span><span class="message">I've been noodling for a few years about master-slave processors as an alternative to MMUs</span></div><div class="line" id="201327"><span class="nick" style="color:#8dd3c7"><a href="#201327" label="[20:13:27]">&lt;xentrac&gt;</a></span><span class="message">run your &quot;kernel&quot; on a master processor and your user processes on a slave processor; the master has private RAM and also a link to the slave's RAM, so it can read and write it as it wishes, and can also pause the slave or reset it</span></div><div class="line" id="201608"><span class="nick" style="color:#8dd3c7"><a href="#201608" label="[20:16:08]">&lt;xentrac&gt;</a></span><span class="message">this is a simpler design than the traditional MMU approach, because the master and slave processors are identical; the only difference is that the slave's reset and pause pins are connected to I/O pins on the master, and the slave doesn't have a link to the master's RAM. and it provides stronger isolation with no risk of things like rowhammer or spectre.  the downside is that you need twice as</span></div><div class="line" id="201614"><span class="nick" style="color:#8dd3c7"><a href="#201614" label="[20:16:14]">&lt;xentrac&gt;</a></span><span class="message">many CPUs, and context switches involve rebooting the slave with new code</span></div><div class="line" id="201706"><span class="nick" style="color:#8dd3c7"><a href="#201706" label="[20:17:06]">&lt;xentrac&gt;</a></span><span class="message">in terms of verifiability, verifying that the slave CPU is identical to the master might be a lot easier than auditing an MMU</span></div><div class="line" id="202002"><span class="nick" style="color:#8dd3c7"><a href="#202002" label="[20:20:02]">&lt;xentrac&gt;</a></span><span class="message">other potential advantages to such a system include potentially higher performance with multiple slaves, since each slave has full-speed access to its own memory, and better scalability of power usage, since a slave that doesn't have a task to run can be turned off, but these are probably irrelevant to bootstrapping builds</span></div><div class="line" id="202146"><span class="nick" style="color:#8dd3c7"><a href="#202146" label="[20:21:46]">&lt;xentrac&gt;</a></span><span class="message">(SMP systems with N processors can potentially also have N times the memory bandwidth, but this usually involves some kind of crossbar switch in between the CPUs and RAM, so larger &quot;SMP&quot; systems resort to NUMA)</span></div><div class="line" id="203219"><span class="nick" style="color:#80b1d3"><a href="#203219" label="[20:32:19]">&lt;oriansj&gt;</a></span><span class="message">well if one requires a PID register (say only use the bottom 8bits when bootstrapping), then one needs only 256 pointers worth of Memory and a finite state machine to implement a proper MMU. Which is probably much cheaper in terms of implementation parts than multiple CPU cores</span></div><div class="line" id="203311"><span class="nick" style="color:#80b1d3"><a href="#203311" label="[20:33:11]">&lt;oriansj&gt;</a></span><span class="message">I don't disagree that SMP has many potential advantages but I don't think they add much in terms of bootstrapping.</span></div><div class="line" id="203518"><span class="nick" style="color:#80b1d3"><a href="#203518" label="[20:35:18]">&lt;oriansj&gt;</a></span><span class="message">which is why in the original transistor constrained history that it was the winning solution that everyone adopted.</span></div><div class="line" id="203625"><span class="nick" style="color:#8dd3c7"><a href="#203625" label="[20:36:25]">&lt;xentrac&gt;</a></span><span class="message">yeah, an MMU is definitely less transistors than a second CPU!  but they're harder to verify</span></div><div class="line" id="203702"><span class="nick" style="color:#80b1d3"><a href="#203702" label="[20:37:02]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well you would have to verify BOTH CPUs even if they are identical in design.</span></div><div class="line" id="203731"><span class="nick" style="color:#8dd3c7"><a href="#203731" label="[20:37:31]">&lt;xentrac&gt;</a></span><span class="message">To do change detection of two CPU die photos you can print one in red and one in transparency in blue, then lay it on top of the red one</span></div><div class="line" id="203746"><span class="nick" style="color:#8dd3c7"><a href="#203746" label="[20:37:46]">&lt;xentrac&gt;</a></span><span class="message">well, cyan, not blue</span></div><div class="line" id="203813"><span class="nick" style="color:#8dd3c7"><a href="#203813" label="[20:38:13]">&lt;xentrac&gt;</a></span><span class="message">then spotting differences between them becomes trivial and obvious</span></div><div class="line" id="203844"><span class="nick" style="color:#8dd3c7"><a href="#203844" label="[20:38:44]">&lt;xentrac&gt;</a></span><span class="message">also, if youhave a third-party supplier, the supplier doesn't know which one you're going to use as master and which one as slave</span></div><div class="line" id="203858"><span class="nick" style="color:#80b1d3"><a href="#203858" label="[20:38:58]">&lt;oriansj&gt;</a></span><span class="message">xentrac: assuming the CPUs are single dies yes but not so much if they are wire wrapped CPUs</span></div><div class="line" id="203911"><span class="nick" style="color:#8dd3c7"><a href="#203911" label="[20:39:11]">&lt;xentrac&gt;</a></span><span class="message">agreed, wirewrap is not auditable</span></div><div class="line" id="203923"><span class="nick" style="color:#8dd3c7"><a href="#203923" label="[20:39:23]">&lt;xentrac&gt;</a></span><span class="message">by any means, not just with die photos</span></div><div class="line" id="204033"><span class="nick" style="color:#80b1d3"><a href="#204033" label="[20:40:33]">&lt;oriansj&gt;</a></span><span class="message">xentrac: well a good plan needs also to make sense if someone in their garage were to have to make the hardware themselves</span></div><div class="line" id="204058"><span class="nick" style="color:#8dd3c7"><a href="#204058" label="[20:40:58]">&lt;xentrac&gt;</a></span><span class="message">did you see Sam Zeloof's recent update on making chips in his garage?</span></div><div class="line" id="204107"><span class="nick" style="color:#80b1d3"><a href="#204107" label="[20:41:07]">&lt;oriansj&gt;</a></span><span class="message">yep</span></div><div class="line" id="204124"><span class="nick" style="color:#80b1d3"><a href="#204124" label="[20:41:24]">&lt;oriansj&gt;</a></span><span class="message">clever little trick to up the transistor count</span></div><div class="line" id="204229"><span class="nick" style="color:#80b1d3"><a href="#204229" label="[20:42:29]">&lt;oriansj&gt;</a></span><span class="message">but I doubt a proper 32bit CPU can be done in that current transistor limit</span></div><div class="line" id="204318"><span class="nick" style="color:#8dd3c7"><a href="#204318" label="[20:43:18]">&lt;xentrac&gt;</a></span><span class="message">agreed, though I think he's nudging up against the 3500 transistors of a 6502</span></div><div class="line" id="204319"><span class="nick" style="color:#80b1d3"><a href="#204319" label="[20:43:19]">&lt;oriansj&gt;</a></span><span class="message">So PDP-1 style CPU building is probably a solid idea</span></div><div class="line" id="204450"><span class="nick" style="color:#80b1d3"><a href="#204450" label="[20:44:50]">&lt;oriansj&gt;</a></span><span class="message">but yeah in the future assuming progress, a simple 32bit CPU will certainly be possible</span></div><div class="line" id="204506"><span class="nick" style="color:#80b1d3"><a href="#204506" label="[20:45:06]">&lt;oriansj&gt;</a></span><span class="message">and will probably benefit from your master/slave suggestion.</span></div><div class="line" id="204521"><span class="nick" style="color:#8dd3c7"><a href="#204521" label="[20:45:21]">&lt;xentrac&gt;</a></span><span class="message">and the MuP21 was a 21-bit processor in 7000 transistors, though a lot of those were in the NTSC generation hardware</span></div><div class="line" id="204630"><span class="nick" style="color:#8dd3c7"><a href="#204630" label="[20:46:30]">&lt;xentrac&gt;</a></span><span class="message">heh, if you think the RISC-V instruction encoding is bad, you should check out the MuP21's!</span></div><div class="line" id="204658"><span class="nick" style="color:#80b1d3"><a href="#204658" label="[20:46:58]">&lt;oriansj&gt;</a></span><span class="message">well Berkeley's RISC II was 39K transistors with a good chunk of them allocated to Registers, which could probably be shaved off</span></div><div class="line" id="204735"><span class="nick" style="color:#80b1d3"><a href="#204735" label="[20:47:35]">&lt;oriansj&gt;</a></span><span class="message">say go from 138 registers down to just 16</span></div><div class="line" id="204842"><span class="nick" style="color:#8dd3c7"><a href="#204842" label="[20:48:42]">&lt;xentrac&gt;</a></span><span class="message">yeah :)</span></div><div class="line" id="204857"><span class="nick" style="color:#8dd3c7"><a href="#204857" label="[20:48:57]">&lt;xentrac&gt;</a></span><span class="message">that was already a reduction from RISC-I</span></div><div class="line" id="204953"><span class="nick" style="color:#8dd3c7"><a href="#204953" label="[20:49:53]">&lt;xentrac&gt;</a></span><span class="message">it wouldn't be surprising if a minimal RISC-V was smaller than RISC-II, too; a lot of the architectural decisions in RISC-V had to do with simplifying minimal implementations</span></div><div class="line" id="205002"><span class="nick" style="color:#80b1d3"><a href="#205002" label="[20:50:02]">&lt;oriansj&gt;</a></span><span class="message">so assuming 6transister per bit in the register, it would be a 18304 transistor reduction</span></div><div class="line" id="205030"><span class="nick" style="color:#8dd3c7"><a href="#205030" label="[20:50:30]">&lt;xentrac&gt;</a></span><span class="message">nice</span></div><div class="line" id="205125"><span class="nick" style="color:#8dd3c7"><a href="#205125" label="[20:51:25]">&lt;xentrac&gt;</a></span><span class="message">I think the reason for the large register files of RISC-I and RISC-II was the sliding-window mechanism we know from SPARC</span></div><div class="line" id="205139"><span class="nick" style="color:#8dd3c7"><a href="#205139" label="[20:51:39]">&lt;xentrac&gt;</a></span><span class="message">which in a sense is a substitute for a data cache</span></div><div class="line" id="205218"><span class="nick" style="color:#8dd3c7"><a href="#205218" label="[20:52:18]">&lt;xentrac&gt;</a></span><span class="message">but a thing to keep in mind is that, with semiconductor memories, your RAM accounts for a lot more transistors than a simple CPU like this</span></div><div class="line" id="205403"><span class="nick" style="color:#8dd3c7"><a href="#205403" label="[20:54:03]">&lt;xentrac&gt;</a></span><span class="message">I mean that's why weird memory technology like magnetic drums, acoustic delay lines, Williams tubes, and magnetic cores were crucial to computers from 01945 to 01975</span></div><div class="line" id="205428"><span class="nick" style="color:#8dd3c7"><a href="#205428" label="[20:54:28]">&lt;xentrac&gt;</a></span><span class="message">because it was totally impractical to build RAM out of vacuum-tube flip-flops</span></div><div class="line" id="205704"><span class="nick" style="color:#8dd3c7"><a href="#205704" label="[20:57:04]">&lt;xentrac&gt;</a></span><span class="message">to run something like a BASIC interpreter from RAM, you need about 4 KiB.  you might be able to do it in 2 KiB with a stack-machine instruction set, but 4 KiB is the usual minimum.  if that's DRAM it's 32768 transistors and 32768 capacitors</span></div><div class="line" id="205914"><span class="nick" style="color:#8dd3c7"><a href="#205914" label="[20:59:14]">&lt;xentrac&gt;</a></span><span class="message">(plus the column and row drivers, but that's probably only another 1000-4000 transistors, and the proportion goes down as you go to larger arrays)</span></div><div class="line" id="210827"><span class="nick" style="color:#80b1d3"><a href="#210827" label="[21:08:27]">&lt;oriansj&gt;</a></span><span class="message">yeah, fortunately duplication works well when makes DRAM/SRAM chips</span></div><div class="line" id="210844"><span class="nick" style="color:#80b1d3"><a href="#210844" label="[21:08:44]">&lt;oriansj&gt;</a></span><span class="message">^makes^making^</span></div><div class="line" id="210911"><span class="nick" style="color:#80b1d3"><a href="#210911" label="[21:09:11]">&lt;oriansj&gt;</a></span><span class="message">as I don't want to deal with hand making core memory</span></div><div class="line" id="210939"><span class="nick" style="color:#80b1d3"><a href="#210939" label="[21:09:39]">&lt;oriansj&gt;</a></span><span class="message">but core memory modules can be bought on Ebay at cost</span></div><div class="line" id="210944"><span class="nick" style="color:#8dd3c7"><a href="#210944" label="[21:09:44]">&lt;xentrac&gt;</a></span><span class="message">right.  so my thought is to take the same approach to making CPUs, though not to the same extent as the GA144</span></div><div class="line" id="211010"><span class="nick" style="color:#8dd3c7"><a href="#211010" label="[21:10:10]">&lt;xentrac&gt;</a></span><span class="message">oh, that's interesting!  I didn't know that!</span></div><div class="line" id="211020"><span class="nick" style="color:#8dd3c7"><a href="#211020" label="[21:10:20]">&lt;xentrac&gt;</a></span><span class="message">I assumed they were sort of rare artifacts by now</span></div><div class="line" id="211057"><span class="nick" style="color:#80b1d3"><a href="#211057" label="[21:10:57]">&lt;oriansj&gt;</a></span><span class="message">at about $50 per KB; so about $50K for 1MB</span></div><div class="line" id="211057"><span class="nick" style="color:#8dd3c7"><a href="#211057" label="[21:10:57]">&lt;xentrac&gt;</a></span><span class="message">(since the total number of computers that ever used core is probably somewhere in the neighborhood of half a million, and most of them have been scrapped by now)</span></div><div class="line" id="211111"><span class="nick" style="color:#8dd3c7"><a href="#211111" label="[21:11:11]">&lt;xentrac&gt;</a></span><span class="message">so for US$200 you could have 4 KiB</span></div><div class="line" id="211201"><span class="nick" style="color:#80b1d3"><a href="#211201" label="[21:12:01]">&lt;oriansj&gt;</a></span><span class="message">plus new core memory is being made for legacy systems</span></div><div class="line" id="211203"><span class="nick" style="color:#8dd3c7"><a href="#211203" label="[21:12:03]">&lt;xentrac&gt;</a></span><span class="message">about the same price as JLCPCB would charge you for assembling a DRAM out of discrete transistors and capacitors with a pick-and-place machine</span></div><div class="line" id="211220"><span class="nick" style="color:#8dd3c7"><a href="#211220" label="[21:12:20]">&lt;xentrac&gt;</a></span><span class="message">seriously?  who's making new core memory?</span></div><div class="line" id="211235"><span class="nick" style="color:#80b1d3"><a href="#211235" label="[21:12:35]">&lt;oriansj&gt;</a></span><span class="message">mostly military contracts if I remember correctly</span></div><div class="line" id="211353"><span class="nick" style="color:#80b1d3"><a href="#211353" label="[21:13:53]">&lt;oriansj&gt;</a></span><span class="message">core memory survives nuclear blasts far better than CMOS DRAM/SRAM cells</span></div><div class="line" id="211637"><span class="nick" style="color:#80b1d3"><a href="#211637" label="[21:16:37]">&lt;oriansj&gt;</a></span><span class="message">ironically it was uranium run off contamination in the manufactor of IC packaging that resulted in the discovery of radiation causing bit flips in ICs for Intel</span></div><div class="line" id="211742"><span class="nick" style="color:#8dd3c7"><a href="#211742" label="[21:17:42]">&lt;xentrac&gt;</a></span><span class="message">interesting!</span></div><div class="line" id="211823"><span class="nick" style="color:#80b1d3"><a href="#211823" label="[21:18:23]">&lt;oriansj&gt;</a></span><span class="message">1978 paper &quot;A new physical Mechanism for Soft Errors in Dynamic Memories&quot;</span></div><div class="line" id="211924"><span class="nick" style="color:#8dd3c7"><a href="#211924" label="[21:19:24]">&lt;xentrac&gt;</a></span><span class="message">still, I imagine SRAM has much higher immuninty to that kind of thing, even if it's CMOS rather than TTL or ECL</span></div><div class="line" id="211935"><span class="nick" style="color:#8dd3c7"><a href="#211935" label="[21:19:35]">&lt;xentrac&gt;</a></span><span class="message">actually maybe *especially* if it's CMOS</span></div><div class="line" id="212031"><span class="nick" style="color:#80b1d3"><a href="#212031" label="[21:20:31]">&lt;oriansj&gt;</a></span><span class="message">there are many tricks for RAD hardening of systems and the military has the money to buy the best available</span></div><div class="line" id="212058"><span class="nick" style="color:#80b1d3"><a href="#212058" label="[21:20:58]">&lt;oriansj&gt;</a></span><span class="message">NASA gets discounts on Radiation hardened chips as a minor side benefit</span></div><div class="line" id="212149"><span class="nick" style="color:#8dd3c7"><a href="#212149" label="[21:21:49]">&lt;xentrac&gt;</a></span><span class="message">*immunity</span></div><div class="line" id="212400"><span class="nick" style="color:#80b1d3"><a href="#212400" label="[21:24:00]">&lt;oriansj&gt;</a></span><span class="message">anyway. Back to the previous topic of garage build Systems as the final step of a trusted bootstrap. It'll be a good while before the transistor count gets high enough for CPU on Chip and thus not betting on it at this stage is a reasonable plan until such time that evidence suggests changes.</span></div><div class="line" id="212433"><span class="nick" style="color:#80b1d3"><a href="#212433" label="[21:24:33]">&lt;oriansj&gt;</a></span><span class="message">As people seem more than happy with usespace bootstrapping being ported to more architectures, rather than people wanting to dip into bare metal bootstrapping work.</span></div><div class="line" id="212448"><span class="nick" style="color:#8dd3c7"><a href="#212448" label="[21:24:48]">&lt;xentrac&gt;</a></span><span class="message">sounds reasonable.  I don't think it'll be the final step, though</span></div><div class="line" id="212529"><span class="nick" style="color:#8dd3c7"><a href="#212529" label="[21:25:29]">&lt;xentrac&gt;</a></span><span class="message">there are probably fewer hardware engineers than software engineers, and because hardware can't be freely copied, hardware engineers don't have the free-software traditions</span></div><div class="line" id="212643"><span class="nick" style="color:#80b1d3"><a href="#212643" label="[21:26:43]">&lt;oriansj&gt;</a></span><span class="message">xentrac: I hope we can bring a libre hardware design tradition to the hardware engineers with things like print your own CPU at home sort of fun</span></div><div class="line" id="212701"><span class="nick" style="color:#80b1d3"><a href="#212701" label="[21:27:01]">&lt;oriansj&gt;</a></span><span class="message">along with libresilicon providing better standards for the industry</span></div><div class="line" id="212734"><span class="nick" style="color:#80b1d3"><a href="#212734" label="[21:27:34]">&lt;oriansj&gt;</a></span><span class="message">so that foundries can provide a universal standard product to compete on price alone</span></div><div class="line" id="212750"><span class="nick" style="color:#8dd3c7"><a href="#212750" label="[21:27:50]">&lt;xentrac&gt;</a></span><span class="message">libre hardware design requires matter compilers or matter replicators</span></div><div class="line" id="212811"><span class="nick" style="color:#6c3d55"><a href="#212811" label="[21:28:11]">&lt;Gooberpatrol66&gt;</a></span><span class="message">can't you make FPGA soft processors?</span></div><div class="line" id="212816"><span class="nick" style="color:#8dd3c7"><a href="#212816" label="[21:28:16]">&lt;xentrac&gt;</a></span><span class="message">yes</span></div><div class="line" id="212859"><span class="nick" style="color:#8dd3c7"><a href="#212859" label="[21:28:59]">&lt;xentrac&gt;</a></span><span class="message">Bunnie has written about the difficulties that approach would pose to would-be attackers who seek to compromise the hardware</span></div><div class="line" id="212911"><span class="nick" style="color:#8dd3c7"><a href="#212911" label="[21:29:11]">&lt;xentrac&gt;</a></span><span class="message">(FPGA soft processors)</span></div><div class="line" id="212952"><span class="nick" style="color:#389600"><a href="#212952" label="[21:29:52]">&lt;stikonas&gt;</a></span><span class="message">Gooberpatrol66: there are alreaydy some FPGA soft processors, but not sure about open/libre silicon FPGA processors</span></div><div class="line" id="213035"><span class="nick" style="color:#8dd3c7"><a href="#213035" label="[21:30:35]">&lt;xentrac&gt;</a></span><span class="message">stikonas: there are lots of freely licensed soft cores, but I don't think there are any freely licensed FPGAs</span></div><div class="line" id="213059"><span class="nick" style="color:#389600"><a href="#213059" label="[21:30:59]">&lt;stikonas&gt;</a></span><span class="message">probably...</span></div><div class="line" id="213105"><span class="nick" style="color:#80b1d3"><a href="#213105" label="[21:31:05]">&lt;oriansj&gt;</a></span><span class="message">I don't believe anyone has made a libre FPGA hardware (let alone for sale) the closest I have seen has been the iCE FPGA which we only reverse engineered the bitstream format</span></div><div class="line" id="213107"><span class="nick" style="color:#389600"><a href="#213107" label="[21:31:07]">&lt;stikonas&gt;</a></span><span class="message">also FPGA toolchains...</span></div><div class="line" id="213123"><span class="nick" style="color:#80b1d3"><a href="#213123" label="[21:31:23]">&lt;oriansj&gt;</a></span><span class="message">stikonas: icestorm</span></div><div class="line" id="213124"><span class="nick" style="color:#8dd3c7"><a href="#213124" label="[21:31:24]">&lt;xentrac&gt;</a></span><span class="message">there are CPLDs for which the mask work rights have expired</span></div><div class="line" id="213216"><span class="nick" style="color:#80b1d3"><a href="#213216" label="[21:32:16]">&lt;oriansj&gt;</a></span><span class="message">So we can do free hardware designs for FPGAs but that doesn't prevent attacks that compromise the bitstream generation process.</span></div><div class="line" id="213232"><span class="nick" style="color:#8dd3c7"><a href="#213232" label="[21:32:32]">&lt;xentrac&gt;</a></span><span class="message">but a CPU softcore would probably require a lot of CPLDs</span></div><div class="line" id="213309"><span class="nick" style="color:#6c3d55"><a href="#213309" label="[21:33:09]">&lt;Gooberpatrol66&gt;</a></span><span class="message">i've heard of this <a rel="nofollow" href="https://symbiflow.github.io/">https://symbiflow.github.io/</a> </span></div><div class="line" id="213332"><span class="nick" style="color:#80b1d3"><a href="#213332" label="[21:33:32]">&lt;oriansj&gt;</a></span><span class="message">as one needs trusted CPUs to run a trusted bootstrap to build a trusted bitstream for a softcore CPU</span></div><div class="line" id="213406"><span class="nick" style="color:#8dd3c7"><a href="#213406" label="[21:34:06]">&lt;xentrac&gt;</a></span><span class="message">not necessarily.  I mean you can verify a CPLD bitstream by hand</span></div><div class="line" id="213430"><span class="nick" style="color:#80b1d3"><a href="#213430" label="[21:34:30]">&lt;oriansj&gt;</a></span><span class="message">assuming we want to address Nexus Intruder style attacks (hardware compromising softwware to compromise hardware cycles)</span></div><div class="line" id="213438"><span class="nick" style="color:#389600"><a href="#213438" label="[21:34:38]">&lt;stikonas&gt;</a></span><span class="message">aren't bistreams quite big?</span></div><div class="line" id="213453"><span class="nick" style="color:#80b1d3"><a href="#213453" label="[21:34:53]">&lt;oriansj&gt;</a></span><span class="message">depends entirely on want is being built</span></div><div class="line" id="213502"><span class="nick" style="color:#8dd3c7"><a href="#213502" label="[21:35:02]">&lt;xentrac&gt;</a></span><span class="message">also depends on the device</span></div><div class="line" id="213517"><span class="nick" style="color:#80b1d3"><a href="#213517" label="[21:35:17]">&lt;oriansj&gt;</a></span><span class="message">a single bit processor could be small enough to hand audit with time/money to do so</span></div><div class="line" id="213520"><span class="nick" style="color:#389600"><a href="#213520" label="[21:35:20]">&lt;stikonas&gt;</a></span><span class="message">but I mean verifying bitreap by hand is probably harder than verifying gcc binary</span></div><div class="line" id="213626"><span class="nick" style="color:#8dd3c7"><a href="#213626" label="[21:36:26]">&lt;xentrac&gt;</a></span><span class="message">Altera introduced the Max5000 in 01988, and in the US, mask works are only protected for 10 years</span></div><div class="line" id="213658"><span class="nick" style="color:#8dd3c7"><a href="#213658" label="[21:36:58]">&lt;xentrac&gt;</a></span><span class="message">and the maximum duration contemplated for mask-work protection in TRIPS is 15 years</span></div><div class="line" id="213719"><span class="nick" style="color:#8dd3c7"><a href="#213719" label="[21:37:19]">&lt;xentrac&gt;</a></span><span class="message">so any CPLD or FPGA produced before 02006 is fair game to copy</span></div><div class="line" id="213843"><span class="nick" style="color:#8dd3c7"><a href="#213843" label="[21:38:43]">&lt;xentrac&gt;</a></span><span class="message">stikonas: a CPLD bitstream would be a lot easier to verify than a transistor design or even a netlist of gates, much less a physical PCB full of chips.  but of course you also have to verify the CPLD itself</span></div><div class="line" id="213902"><span class="nick" style="color:#80b1d3"><a href="#213902" label="[21:39:02]">&lt;oriansj&gt;</a></span><span class="message">so we have options to potentially explore but nothing solid until someone is willing to put in a good bit of work.</span></div><div class="line" id="214019"><span class="nick" style="color:#8dd3c7"><a href="#214019" label="[21:40:19]">&lt;xentrac&gt;</a></span><span class="message">the sum-of-products expression of a PAL, PLA, PLD, or CPLD is a lot easier to understand than an arbitrary expression of NAND gates or whatever</span></div><div class="line" id="214027"><span class="nick" style="color:#8dd3c7"><a href="#214027" label="[21:40:27]">&lt;xentrac&gt;</a></span><span class="message">/GAL</span></div><div class="line" id="214039"><span class="nick" style="color:#80b1d3"><a href="#214039" label="[21:40:39]">&lt;oriansj&gt;</a></span><span class="message">FPGAs probably will be like the user space bootstrapping work. It hides a big potential risk (like the kernel) but is easy enough to get into that more people would be willing to work in it than working in individual gates</span></div><div class="line" id="214047"><span class="nick" style="color:#389600"><a href="#214047" label="[21:40:47]">&lt;stikonas&gt;</a></span><span class="message">oh ok, CPLD are simpler than FPGAs...</span></div><div class="line" id="214207"><span class="nick" style="color:#8dd3c7"><a href="#214207" label="[21:42:07]">&lt;xentrac&gt;</a></span><span class="message">CPLDs are definitely less capable than FPGAs</span></div><div class="line" id="214233"><span class="nick" style="color:#389600"><a href="#214233" label="[21:42:33]">&lt;stikonas&gt;</a></span><span class="message">never heard of them before...</span></div><div class="line" id="214244"><span class="nick" style="color:#8dd3c7"><a href="#214244" label="[21:42:44]">&lt;xentrac&gt;</a></span><span class="message">I think bitstreams for them are also easier to analyze.  CPLDs also have the enormous advantage that their designs are public</span></div><div class="line" id="214254"><span class="nick" style="color:#389600"><a href="#214254" label="[21:42:54]">&lt;stikonas&gt;</a></span><span class="message">I've only used FPGAs before</span></div><div class="line" id="214714"><span class="nick" style="color:#8dd3c7"><a href="#214714" label="[21:47:14]">&lt;xentrac&gt;</a></span><span class="message">FPGAs are actually a little older than CPLDs; the XC500 is from 01985.  but PLDs in general (including FPGAs, PALs/GALs (01978), PLA, and CPLDs) are from 01971</span></div><div class="line" id="214729"><span class="nick" style="color:#8dd3c7"><a href="#214729" label="[21:47:29]">&lt;xentrac&gt;</a></span><span class="message">I had thought FPGAs came after CPLDs</span></div><div class="line" id="214837"><span class="nick" style="color:#389600"><a href="#214837" label="[21:48:37]">&lt;stikonas&gt;</a></span><span class="message">well, I just never encountered CPLDs before but we use some FPGAs at work</span></div><div class="line" id="214936"><span class="nick" style="color:#8dd3c7"><a href="#214936" label="[21:49:36]">&lt;xentrac&gt;</a></span><span class="message">I think Lattice has mostly squeezed CPLDs out of the market with their cheap FPGAs</span></div><div class="line" id="215223"><span class="nick" style="color:#8dd3c7"><a href="#215223" label="[21:52:23]">&lt;xentrac&gt;</a></span><span class="message">Digi-Key has 151 CPLD models in stock <a rel="nofollow" href="https://www.digikey.com/en/products/filter/embedded-cplds-complex-programmable-logic-devices/695?s=N4IgjCBcoLQJxVAYygFwE4FcCmAaEA9lANrggC6AvvjAEyIgqQY75GSkCsFl1IAbAwCWAEyggYYAAz18AB1TiQ%2BAI6oAnuIj4Nc7OJEBnFLyA">https://www.digikey.com/en/products/filter/embedded-cplds-complex-programmable-logic-devices/695?s=N4IgjCBcoLQJxVAYygFwE4FcCmAaEA9lANrggC6AvvjAEyIgqQY75GSkCsFl1IAbAwCWAEyggYYAAz18AB1TiQ%2BAI6oAnuIj4Nc7OJEBnFLyA</a> </span></div><div class="line" id="215243"><span class="nick" style="color:#8dd3c7"><a href="#215243" label="[21:52:43]">&lt;xentrac&gt;</a></span><span class="message">but 508 FPGAs <a rel="nofollow" href="https://www.digikey.com/en/products/filter/embedded-fpgas-field-programmable-gate-array/696?s=N4IgjCBcoLQJxVAYygFwE4FcCmAaEA9lANrggC6AvvjAEyIgqQY75GSkCsFl1IAbAwCWAEyggYYAAz18AB1TiQ%2BAI6oAnuIj4Nc7OJEBnFLyA">https://www.digikey.com/en/products/filter/embedded-fpgas-field-programmable-gate-array/696?s=N4IgjCBcoLQJxVAYygFwE4FcCmAaEA9lANrggC6AvvjAEyIgqQY75GSkCsFl1IAbAwCWAEyggYYAAz18AB1TiQ%2BAI6oAnuIj4Nc7OJEBnFLyA</a> </span></div><div class="line" id="215722"><span class="nick" style="color:#8dd3c7"><a href="#215722" label="[21:57:22]">&lt;xentrac&gt;</a></span><span class="message">but you can see that the cheapest FPGAs are like US$1.90 while the cheapest CPLDs are like US$1.50</span></div><div class="line" id="220759"><span class="nick" style="color:#80b1d3"><a href="#220759" label="[22:07:59]">&lt;oriansj&gt;</a></span><span class="message">add to notes for when we actually start doing that work (unless someone else beats us to it)</span></div><div class="line" id="225013"><span class="nick" style="color:#80b1d3"><a href="#225013" label="[22:50:13]">&lt;oriansj&gt;</a></span><span class="message">a full breakdown of time spent in qemu for every step in the x86 stage0-posix bootstrap on a raspberryPI <a rel="nofollow" href="https://paste.debian.net/1211381/">https://paste.debian.net/1211381/</a> </span></div><div class="line" id="225059"><span class="nick" style="color:#80b1d3"><a href="#225059" label="[22:50:59]">&lt;oriansj&gt;</a></span><span class="message">hex2 (written in hex1) is absolutely the biggest reason for the slow run time</span></div><div class="line" id="225142"><span class="nick" style="color:#8dd3c7"><a href="#225142" label="[22:51:42]">&lt;xentrac&gt;</a></span><span class="message">makes sense</span></div><div class="line" id="225412"><span class="nick" style="color:#80b1d3"><a href="#225412" label="[22:54:12]">&lt;oriansj&gt;</a></span><span class="message">in fact it is the only bit that takes more than 30 seconds</span></div><div class="line" id="225440"><span class="nick" style="color:#80b1d3"><a href="#225440" label="[22:54:40]">&lt;oriansj&gt;</a></span><span class="message">the second slowest is cc_x86 building M2-Planet in 0:16.99</span></div><div class="line" id="225501"><span class="nick" style="color:#80b1d3"><a href="#225501" label="[22:55:01]">&lt;oriansj&gt;</a></span><span class="message">and then third is M2-Planet self-hosting in 0:12.10</span></div><div class="line" id="225605"><span class="nick" style="color:#80b1d3"><a href="#225605" label="[22:56:05]">&lt;oriansj&gt;</a></span><span class="message">and ./hex2-0 hold M2 in 6:31.76 and ./hex2-0 hold hex2-1 in 4:05.36 are 5/9ths off the entire time</span></div><div class="line" id="225642"><span class="nick" style="color:#8dd3c7"><a href="#225642" label="[22:56:42]">&lt;xentrac&gt;</a></span><span class="message">how much RAM does it need?</span></div><div class="line" id="225713"><span class="nick" style="color:#80b1d3"><a href="#225713" label="[22:57:13]">&lt;oriansj&gt;</a></span><span class="message">need or currently uses?</span></div><div class="line" id="225752"><span class="nick" style="color:#80b1d3"><a href="#225752" label="[22:57:52]">&lt;oriansj&gt;</a></span><span class="message">need is about 16KB but uses is 8MB</span></div><div class="line" id="225923"><span class="nick" style="color:#80b1d3"><a href="#225923" label="[22:59:23]">&lt;oriansj&gt;</a></span><span class="message">as M2-Planet shoves the entire input source code and the entire output into memory before doing one big dump</span></div><div class="line" id="225958"><span class="nick" style="color:#80b1d3"><a href="#225958" label="[22:59:58]">&lt;oriansj&gt;</a></span><span class="message">blood-elf is even more wasteful right now</span></div><div class="line" id="230034"><span class="nick" style="color:#8dd3c7"><a href="#230034" label="[23:00:34]">&lt;xentrac&gt;</a></span><span class="message">makes things easier</span></div><div class="line" id="230100"><span class="nick" style="color:#80b1d3"><a href="#230100" label="[23:01:00]">&lt;oriansj&gt;</a></span><span class="message">M1 deduplicates the tokens, so that it has an O(1) for the application of defines</span></div><div class="line" id="230133"><span class="nick" style="color:#80b1d3"><a href="#230133" label="[23:01:33]">&lt;oriansj&gt;</a></span><span class="message">So M1 only has O(n) unique tokens stored in memory (including immediates)</span></div><div class="line" id="230158"><span class="nick" style="color:#80b1d3"><a href="#230158" label="[23:01:58]">&lt;oriansj&gt;</a></span><span class="message">as %1 %1 %1, would only appear once in M1</span></div><div class="line" id="230212"><span class="nick" style="color:#8dd3c7"><a href="#230212" label="[23:02:12]">&lt;xentrac&gt;</a></span><span class="message">right</span></div><div class="line" id="230645"><span class="nick" style="color:#80b1d3"><a href="#230645" label="[23:06:45]">&lt;oriansj&gt;</a></span><span class="message">I could probably break out the 3 functions that would need update into a separate file and produce a minimal memory version without much trouble; which should fit in 256KB</span></div><div class="line" id="230756"><span class="nick" style="color:#80b1d3"><a href="#230756" label="[23:07:56]">&lt;oriansj&gt;</a></span><span class="message">would have to add more optimizations into M2-Planet (or a seperate optimizer) to shrink things down smaller than that</span></div><div class="line" id="230908"><span class="nick" style="color:#80b1d3"><a href="#230908" label="[23:09:08]">&lt;oriansj&gt;</a></span><span class="message">as the current M2-Planet+M2libc binary is 204024bytes in size (and you need 3 4KB input token buffers to build mes-m2)</span></div><div class="line" id="231143"><span class="nick" style="color:#389600"><a href="#231143" label="[23:11:43]">&lt;stikonas&gt;</a></span><span class="message">oriansj: well, hex2  is probably stuck in mprotect syscalls</span></div><div class="line" id="231156"><span class="nick" style="color:#389600"><a href="#231156" label="[23:11:56]">&lt;stikonas&gt;</a></span><span class="message">you can backport my fix from risc-v</span></div><div class="line" id="231225"><span class="nick" style="color:#80b1d3"><a href="#231225" label="[23:12:25]">&lt;oriansj&gt;</a></span><span class="message">stikonas: actually I was confirming that because M0 has that same work as your RISC-V</span></div><div class="line" id="231255"><span class="nick" style="color:#389600"><a href="#231255" label="[23:12:55]">&lt;stikonas&gt;</a></span><span class="message">actually that's how I noticed the problem</span></div><div class="line" id="231301"><span class="nick" style="color:#389600"><a href="#231301" label="[23:13:01]">&lt;stikonas&gt;</a></span><span class="message">I noticed that M0 was fast</span></div><div class="line" id="231305"><span class="nick" style="color:#389600"><a href="#231305" label="[23:13:05]">&lt;stikonas&gt;</a></span><span class="message">while hex2 was slow</span></div><div class="line" id="231322"><span class="nick" style="color:#389600"><a href="#231322" label="[23:13:22]">&lt;stikonas&gt;</a></span><span class="message">but I think everything with section table would be fast</span></div><div class="line" id="231346"><span class="nick" style="color:#389600"><a href="#231346" label="[23:13:46]">&lt;stikonas&gt;</a></span><span class="message">so I think writing to heap before blood-elf will be slow on qemu</span></div><div class="line" id="231514"><span class="nick" style="color:#389600"><a href="#231514" label="[23:15:14]">&lt;stikonas&gt;</a></span><span class="message">by switching to stack I was seeing speedup from 8s to 0.5s or so</span></div><div class="line" id="231539"><span class="nick" style="color:#389600"><a href="#231539" label="[23:15:39]">&lt;stikonas&gt;</a></span><span class="message">and I didn't even fix everything, only fputc/fgetc, I still left scratch in heap</span></div><div class="line" id="232329"><span class="nick" style="color:#8dd3c7"><a href="#232329" label="[23:23:29]">&lt;xentrac&gt;</a></span><span class="message">I just pushed an update to <a rel="nofollow" href="http://canonical.org/~kragen/dernocua.git">http://canonical.org/~kragen/dernocua.git</a>  with the notes about term rewriting in text/term-rewriting-micro-interpreter.md</span></div><div class="line" id="235333"><span class="nick" style="color:#80b1d3"><a href="#235333" label="[23:53:33]">&lt;oriansj&gt;</a></span><span class="message">odd, looks like GDB's behavior has changed in regards to disassembling memory</span></div><div class="line" id="235445"><span class="nick" style="color:#80b1d3"><a href="#235445" label="[23:54:45]">&lt;oriansj&gt;</a></span><span class="message">symbol table is valid according to readelf and objdump -d has no problem with the file</span></div><div class="line" id="235515"><span class="nick" style="color:#80b1d3"><a href="#235515" label="[23:55:15]">&lt;oriansj&gt;</a></span><span class="message">so why does GDB complain that there is no symbol table and refuse to show the assembly instructions???</span></div><div class="line" id="235922"><span class="nick" style="color:#80b1d3"><a href="#235922" label="[23:59:22]">&lt;oriansj&gt;</a></span><span class="message">oh, I now need to also do layout asm along with layout regs</span></div><div class="line" id="235927"><span class="nick" style="color:#80b1d3"><a href="#235927" label="[23:59:27]">&lt;oriansj&gt;</a></span><span class="message">I'm dumb</span></div><br /></div></body></html>