<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-04-03.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="000603"><span class="nick" style="color:#389600"><a href="#000603" label="[00:06:03]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I don't think it solves the exact same problem but perhaps a related one</span></div><div class="line" id="000851"><span class="nick" style="color:#8dd3c7"><a href="#000851" label="[00:08:51]">&lt;muurkha&gt;</a></span><span class="message">well, to solving the Karger–Thompson attack, which is one objective of stage0 etc.</span></div><div class="line" id="002742"><span class="nick" style="color:#389600"><a href="#002742" label="[00:27:42]">&lt;oriansj&gt;</a></span><span class="message">true</span></div><div class="line" id="010134"><span class="nick" style="color:#6b8072"><a href="#010134" label="[01:01:34]">&lt;nimaje&gt;</a></span><span class="message">well, you want proofs for (most of) your bootstrap, that doesn't mean that you need to verify them via some tiny seed, you could run the verification on a bootstrapped system</span></div><div class="line" id="010519"><span class="nick" style="color:#80b1d3"><a href="#010519" label="[01:05:19]">&lt;vagrantc&gt;</a></span><span class="message">verifying the bootstrap using the tools the bootstrap generated?</span></div><div class="line" id="010845"><span class="nick" style="color:#389600"><a href="#010845" label="[01:08:45]">&lt;oriansj&gt;</a></span><span class="message">well the problem of creating a trusted system for doing the verifying; is kinda why it is related but not exactly the same thing</span></div><div class="line" id="011307"><span class="nick" style="color:#389600"><a href="#011307" label="[01:13:07]">&lt;oriansj&gt;</a></span><span class="message">which honestly is why the assumption: user has a trusted way to get the root binaries into RAM to run our builds is unavoidable</span></div><div class="line" id="011409"><span class="nick" style="color:#8dd3c7"><a href="#011409" label="[01:14:09]">&lt;muurkha&gt;</a></span><span class="message">nimaje: if the proofs of your bootstrap are unsound, perhaps the unsoundness is that your bootstrap contains a backdoor that looks for your proof verifier and tweaks its answer to be &quot;accept&quot; in some case</span></div><div class="line" id="011424"><span class="nick" style="color:#389600"><a href="#011424" label="[01:14:24]">&lt;oriansj&gt;</a></span><span class="message">punting it to hand toggling memory and/or specialized hardware is a much easier thing to do</span></div><div class="line" id="011441"><span class="nick" style="color:#8dd3c7"><a href="#011441" label="[01:14:41]">&lt;muurkha&gt;</a></span><span class="message">so it would be worthwhile to run the proof verifier on a system that isn't vulnerable to the thing you're trying to verify</span></div><div class="line" id="011459"><span class="nick" style="color:#8dd3c7"><a href="#011459" label="[01:14:59]">&lt;muurkha&gt;</a></span><span class="message">and there are Metamath Zero verifiers that are quite small in machine code</span></div><div class="line" id="011653"><span class="nick" style="color:#6d2462"><a href="#011653" label="[01:16:53]">&lt;littlebobeep&gt;</a></span><span class="message">oriansj: Why does bootstrap seed for x86-32 need to be under 510 bytes?</span></div><div class="line" id="011803"><span class="nick" style="color:#389600"><a href="#011803" label="[01:18:03]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: the Master Boot Record is only 512 bytes in size and the last 2 bytes are reserved for a signature that is mandatory</span></div><div class="line" id="011819"><span class="nick" style="color:#6d2462"><a href="#011819" label="[01:18:19]">&lt;littlebobeep&gt;</a></span><span class="message">Oh it needs to fit in MBR?</span></div><div class="line" id="011842"><span class="nick" style="color:#8dd3c7"><a href="#011842" label="[01:18:42]">&lt;muurkha&gt;</a></span><span class="message">heh, &quot;x86-32&quot;</span></div><div class="line" id="011914"><span class="nick" style="color:#389600"><a href="#011914" label="[01:19:14]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: you can fit a whole operating system in that space: <a rel="nofollow" href="https://github.com/nanochess/bootOS">https://github.com/nanochess/bootOS</a> </span></div><div class="line" id="012325"><span class="nick" style="color:#389600"><a href="#012325" label="[01:23:25]">&lt;oriansj&gt;</a></span><span class="message">or a lisp: <a rel="nofollow" href="https://github.com/jart/sectorlisp">https://github.com/jart/sectorlisp</a> </span></div><div class="line" id="012342"><span class="nick" style="color:#389600"><a href="#012342" label="[01:23:42]">&lt;oriansj&gt;</a></span><span class="message">or a FORTH: <a rel="nofollow" href="https://github.com/cesarblum/sectorforth">https://github.com/cesarblum/sectorforth</a> </span></div><div class="line" id="012417"><span class="nick" style="color:#389600"><a href="#012417" label="[01:24:17]">&lt;oriansj&gt;</a></span><span class="message">so why if you wanted a minimal and trivial to audit root binary would you go larger?</span></div><div class="line" id="012446"><span class="nick" style="color:#80b1d3"><a href="#012446" label="[01:24:46]">&lt;vagrantc&gt;</a></span><span class="message">easter eggs</span></div><div class="line" id="012551"><span class="nick" style="color:#389600"><a href="#012551" label="[01:25:51]">&lt;oriansj&gt;</a></span><span class="message">well a trusting trust attack would certainly be one hell of an easter egg</span></div><div class="line" id="012608"><span class="nick" style="color:#389600"><a href="#012608" label="[01:26:08]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://gitlab.com/bauen1/stage0-backdoor.git">https://gitlab.com/bauen1/stage0-backdoor.git</a> </span></div><div class="line" id="013010"><span class="nick" style="color:#8dd3c7"><a href="#013010" label="[01:30:10]">&lt;muurkha&gt;</a></span><span class="message">not sure if bootOS is actually an OS, but it's about as much of an OS as MS-DOS</span></div><div class="line" id="013104"><span class="nick" style="color:#8dd3c7"><a href="#013104" label="[01:31:04]">&lt;muurkha&gt;</a></span><span class="message">it can load and run programs, and you can write programs in it</span></div><div class="line" id="014149"><span class="nick" style="color:#6d2462"><a href="#014149" label="[01:41:49]">&lt;littlebobeep&gt;</a></span><span class="message">muurkha: Yeah just specifying bit depth</span></div><div class="line" id="014206"><span class="nick" style="color:#6d2462"><a href="#014206" label="[01:42:06]">&lt;littlebobeep&gt;</a></span><span class="message">speaking of bit depth why does TCC not work on x86_64?</span></div><div class="line" id="014359"><span class="nick" style="color:#389600"><a href="#014359" label="[01:43:59]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: TCC does work on x86_64</span></div><div class="line" id="014846"><span class="nick" style="color:#389600"><a href="#014846" label="[01:48:46]">&lt;oriansj&gt;</a></span><span class="message">it is Gnu Mes that only supports x86-linux and armhf-linux</span></div><div class="line" id="015028"><span class="nick" style="color:#8dd3c7"><a href="#015028" label="[01:50:28]">&lt;muurkha&gt;</a></span><span class="message">littlebobeep: it's not wrong!</span></div><div class="line" id="021003"><span class="nick" style="color:#6d2462"><a href="#021003" label="[02:10:03]">&lt;littlebobeep&gt;</a></span><span class="message">oriansj: Oh wut okay someone told me in #guix that it was TCC's limitations that cause all Guix bootstrap binaries to be x86-32</span></div><div class="line" id="021046"><span class="nick" style="color:#6d2462"><a href="#021046" label="[02:10:46]">&lt;littlebobeep&gt;</a></span><span class="message">oriansj: Do you know what it is about GNU Mes that only supports those two 32-bit ISAs?  Why not x86-64 or aarch64 or riscv64?</span></div><div class="line" id="021710"><span class="nick" style="color:#389600"><a href="#021710" label="[02:17:10]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: short answer is because no one has taken the time to do the porting work yet nor funded janneke to work on it yet</span></div><div class="line" id="021831"><span class="nick" style="color:#389600"><a href="#021831" label="[02:18:31]">&lt;oriansj&gt;</a></span><span class="message">So it can be done and stage0-posix+TCC both support AMD64 so it would enable live-bootstrap to have a start on that port too. (not sure where the next blocker will be yet though)</span></div><div class="line" id="021836"><span class="nick" style="color:#6d2462"><a href="#021836" label="[02:18:36]">&lt;littlebobeep&gt;</a></span><span class="message">Hmmmm okay well isn't it written in C so should be portable...?</span></div><div class="line" id="021906"><span class="nick" style="color:#6d2462"><a href="#021906" label="[02:19:06]">&lt;littlebobeep&gt;</a></span><span class="message">Ahh I thought stage0 was 32-bit only</span></div><div class="line" id="022200"><span class="nick" style="color:#389600"><a href="#022200" label="[02:22:00]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: I wonder how seeing AArch64, AMD64 and riscv64 <a rel="nofollow" href="https://github.com/oriansj/stage0-posix">https://github.com/oriansj/stage0-posix</a>  would indicate it was 32bit only?</span></div><div class="line" id="022300"><span class="nick" style="color:#389600"><a href="#022300" label="[02:23:00]">&lt;oriansj&gt;</a></span><span class="message">also C can be extremely portable if done with care and interpreted languages like scheme and even common lisp can become non-portable if one with careless</span></div><div class="line" id="022350"><span class="nick" style="color:#389600"><a href="#022350" label="[02:23:50]">&lt;oriansj&gt;</a></span><span class="message">So the language isn't the deciding factor on how portable something is, so much as the consideration done by the developer(s)</span></div><div class="line" id="022459"><span class="nick" style="color:#389600"><a href="#022459" label="[02:24:59]">&lt;oriansj&gt;</a></span><span class="message">(even macro assembly can be portable to different hardware architectures and operating systems)</span></div><div class="line" id="022529"><span class="nick" style="color:#8dd3c7"><a href="#022529" label="[02:25:29]">&lt;muurkha&gt;</a></span><span class="message">C can be portable or nonportable</span></div><div class="line" id="022611"><span class="nick" style="color:#389600"><a href="#022611" label="[02:26:11]">&lt;oriansj&gt;</a></span><span class="message">(things below macro assembly however tend not to be portable simply due to the high bar required to make them portable)</span></div><div class="line" id="022822"><span class="nick" style="color:#389600"><a href="#022822" label="[02:28:22]">&lt;oriansj&gt;</a></span><span class="message">(portable hex0 is possible if one is willing to do custom hex0 ELF headers)</span></div><div class="line" id="023337"><span class="nick" style="color:#389600"><a href="#023337" label="[02:33:37]">&lt;oriansj&gt;</a></span><span class="message">also MesCC is portable to Mes.c and guile; not sure how many other schemes it runs well on though</span></div><div class="line" id="023637"><span class="nick" style="color:#389600"><a href="#023637" label="[02:36:37]">&lt;oriansj&gt;</a></span><span class="message">and Guile does run on 6x86-pae, AMD64, AArch64, armel, armhf, mips, mips64el, mipsel, ppc64el, s390x (but not on mips64, ppc64, ppc32el, ppc32, s390, riscv32, riscv64 or a bunch of other architectures that having working C compilers)</span></div><div class="line" id="024513"><span class="nick" style="color:#8dd3c7"><a href="#024513" label="[02:45:13]">&lt;muurkha&gt;</a></span><span class="message">interesting, I didn't know that about Guile!</span></div><div class="line" id="024954"><span class="nick" style="color:#389600"><a href="#024954" label="[02:49:54]">&lt;oriansj&gt;</a></span><span class="message">and because M2-Planet supports Knight and there are C compilers for both FORTH machines and Lisp machines. One could argue C is the most portable language; it just has a bunch of undefined behaviors that people tend to abuse.</span></div><div class="line" id="025432"><span class="nick" style="color:#8dd3c7"><a href="#025432" label="[02:54:32]">&lt;muurkha&gt;</a></span><span class="message">I think C has a lot of implementation-specific behavior too</span></div><div class="line" id="025512"><span class="nick" style="color:#8dd3c7"><a href="#025512" label="[02:55:12]">&lt;muurkha&gt;</a></span><span class="message">like, 65535u + 1u isn't undefined, but whether it ends up being 65536u or 0u depends on the machine's word size</span></div><div class="line" id="025629"><span class="nick" style="color:#389600"><a href="#025629" label="[02:56:29]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I mean one can't even assume -1+1 = 0 in C (it can be -0)</span></div><div class="line" id="025640"><span class="nick" style="color:#8dd3c7"><a href="#025640" label="[02:56:40]">&lt;muurkha&gt;</a></span><span class="message">I think -0 == 0 though</span></div><div class="line" id="025939"><span class="nick" style="color:#389600"><a href="#025939" label="[02:59:39]">&lt;oriansj&gt;</a></span><span class="message">not in terms of behavior: <a rel="nofollow" href="https://en.wikipedia.org/wiki/Ones">https://en.wikipedia.org/wiki/Ones</a>'_complement#Negative_zero </span></div><div class="line" id="030037"><span class="nick" style="color:#8dd3c7"><a href="#030037" label="[03:00:37]">&lt;muurkha&gt;</a></span><span class="message">I don't know, I've never programmed on a one's-complement machine</span></div><div class="line" id="030050"><span class="nick" style="color:#8dd3c7"><a href="#030050" label="[03:00:50]">&lt;muurkha&gt;</a></span><span class="message">but I thought C guaranteed that they tested equal</span></div><div class="line" id="030259"><span class="nick" style="color:#389600"><a href="#030259" label="[03:02:59]">&lt;oriansj&gt;</a></span><span class="message">well I am not certain of the current standard in that regard but I have seen C code which made a serious point about ((0 == a) || (-0 == a))</span></div><div class="line" id="030321"><span class="nick" style="color:#8dd3c7"><a href="#030321" label="[03:03:21]">&lt;muurkha&gt;</a></span><span class="message">I see</span></div><div class="line" id="030337"><span class="nick" style="color:#8dd3c7"><a href="#030337" label="[03:03:37]">&lt;muurkha&gt;</a></span><span class="message">I don't think -1+1 is undefined behavior either though</span></div><div class="line" id="030402"><span class="nick" style="color:#8dd3c7"><a href="#030402" label="[03:04:02]">&lt;muurkha&gt;</a></span><span class="message">(independent of whether C guarantees that -1+1 == 0 I think it does guarantee it won't make demons fly out of your nose)</span></div><div class="line" id="030504"><span class="nick" style="color:#389600"><a href="#030504" label="[03:05:04]">&lt;oriansj&gt;</a></span><span class="message">one also has to remember not all C compilers behave according to the spec</span></div><div class="line" id="030532"><span class="nick" style="color:#389600"><a href="#030532" label="[03:05:32]">&lt;oriansj&gt;</a></span><span class="message">and valid C code for one compiler might not be valid for another C compiler</span></div><div class="line" id="030554"><span class="nick" style="color:#8dd3c7"><a href="#030554" label="[03:05:54]">&lt;muurkha&gt;</a></span><span class="message">aye</span></div><div class="line" id="030812"><span class="nick" style="color:#389600"><a href="#030812" label="[03:08:12]">&lt;oriansj&gt;</a></span><span class="message">but then again, I don't know of any real programming language that it couldn't also be said about.</span></div><div class="line" id="030903"><span class="nick" style="color:#8dd3c7"><a href="#030903" label="[03:09:03]">&lt;muurkha&gt;</a></span><span class="message">sure, once you have multiple implementations they have differences</span></div><div class="line" id="030944"><span class="nick" style="color:#8dd3c7"><a href="#030944" label="[03:09:44]">&lt;muurkha&gt;</a></span><span class="message">C tries to expose the machine more than high-level languages do, though ANSI has rolled that back pretty far in recent decades</span></div><div class="line" id="031043"><span class="nick" style="color:#389600"><a href="#031043" label="[03:10:43]">&lt;oriansj&gt;</a></span><span class="message">the best one can hope is the Turing core and import functionality is universal or eventually one implementation will &quot;win&quot; and then bleh</span></div><div class="line" id="031328"><span class="nick" style="color:#8dd3c7"><a href="#031328" label="[03:13:28]">&lt;muurkha&gt;</a></span><span class="message">burn it down, burn it all down</span></div><div class="line" id="031335"><span class="nick" style="color:#8dd3c7"><a href="#031335" label="[03:13:35]">&lt;muurkha&gt;</a></span><span class="message">we don't need no water</span></div><div class="line" id="031416"><span class="nick" style="color:#389600"><a href="#031416" label="[03:14:16]">&lt;oriansj&gt;</a></span><span class="message">muurkha: wouldn't work, we have a C compiler and scheme bootstrapped</span></div><div class="line" id="031449"><span class="nick" style="color:#389600"><a href="#031449" label="[03:14:49]">&lt;oriansj&gt;</a></span><span class="message">and neither of those languages pass on the universal import functionality front</span></div><div class="line" id="031519"><span class="nick" style="color:#389600"><a href="#031519" label="[03:15:19]">&lt;oriansj&gt;</a></span><span class="message">so there is always going to be a &quot;winner&quot; for those languages and no way to avoid it</span></div><div class="line" id="031917"><span class="nick" style="color:#389600"><a href="#031917" label="[03:19:17]">&lt;oriansj&gt;</a></span><span class="message">not that it would be hard to make a &quot;P&quot; language which would be 99% compatible with C and without that sort of detail but I doubt we could convince anyone to bother to adopt it</span></div><div class="line" id="032125"><span class="nick">***</span><span class="message notice">alMalsamo is now known as littlebobeep</span></div><div class="line" id="032323"><span class="nick" style="color:#389600"><a href="#032323" label="[03:23:23]">&lt;oriansj&gt;</a></span><span class="message">heck just replace int, char, MES and long in M2-Planet with int32_t, int8_t, uint64_t and int64_t; pull out the macro functionality and stict with the CONSTANT keyword and you'll have it</span></div><div class="line" id="032352"><span class="nick" style="color:#389600"><a href="#032352" label="[03:23:52]">&lt;oriansj&gt;</a></span><span class="message">^stict^stick^</span></div><div class="line" id="032528"><span class="nick" style="color:#389600"><a href="#032528" label="[03:25:28]">&lt;oriansj&gt;</a></span><span class="message">p $LIBRARY_PATH/libp.p hello-world.p -o hello-world</span></div><div class="line" id="032737"><span class="nick" style="color:#389600"><a href="#032737" label="[03:27:37]">&lt;oriansj&gt;</a></span><span class="message">might make for some ugly compile commands but it'll be impossible for one not to know where the source they are building from and it'll be impossible for any particular implementation of that language to &quot;win&quot; as any competitor could just support that turing core and compile behavior and build every program written in that language</span></div><div class="line" id="032827"><span class="nick" style="color:#8dd3c7"><a href="#032827" label="[03:28:27]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="033306"><span class="nick" style="color:#389600"><a href="#033306" label="[03:33:06]">&lt;oriansj&gt;</a></span><span class="message">possibly toss in a rule in the language specification banning the use of ASM() outside of a single standard library which provides access to low level functionality (syscalls sort of fun)</span></div><div class="line" id="041542"><span class="nick" style="color:#389600"><a href="#041542" label="[04:15:42]">&lt;oriansj&gt;</a></span><span class="message">then autotools doing things like: checking size of int8_t and checking size int64_t wouldn't happen</span></div><div class="line" id="054658"><span class="nick" style="color:#6d2462"><a href="#054658" label="[05:46:58]">&lt;littlebobeep&gt;</a></span><span class="message">oriansj: You mentioned coding a kernel in ASM so we wouldn't depend on Linux binary to bootstrap, but ASM for what ISA?  This would not be portable to other ISAs...</span></div><div class="line" id="065936"><span class="nick" style="color:#389600"><a href="#065936" label="[06:59:36]">&lt;oriansj&gt;</a></span><span class="message">littlebobeep: it is something I will have to do several times honestly; just like I wrote C compilers in assembly multiple times (knight, x86, amd64) and with luck other people might want to help (like I got for AArch64, riscv32 and riscv64) and they just leverage my work to speed up their own</span></div><div class="line" id="070318"><span class="nick" style="color:#389600"><a href="#070318" label="[07:03:18]">&lt;oriansj&gt;</a></span><span class="message">So ideally I would have a minimal one written in C that is good enough for live-bootstrap to build TCC. Snapshot that code and just hand compile to assembly; then continue the development on the C version until it is powerful enough to run all the steps needed to bootstrap Linux (or Guix) and then we do ports to as many architectures as possible and then I get to move on to another fun road-block</span></div><div class="line" id="070935"><span class="nick" style="color:#8dd3c7"><a href="#070935" label="[07:09:35]">&lt;muurkha&gt;</a></span><span class="message">you only need to bootstrap once to defeat the Karger–Thompson attack</span></div><div class="line" id="071012"><span class="nick" style="color:#8dd3c7"><a href="#071012" label="[07:10:12]">&lt;muurkha&gt;</a></span><span class="message">if you do it on ppc64el you can then use it to cross-compile kernels and compilers for other architectures</span></div><div class="line" id="072155"><span class="nick" style="color:#6d2462"><a href="#072155" label="[07:21:55]">&lt;littlebobeep&gt;</a></span><span class="message">muurkha: Is Karger-Thompson attack the same as Trusting Trust backdoored compiler attack?</span></div><div class="line" id="072330"><span class="nick" style="color:#8dd3c7"><a href="#072330" label="[07:23:30]">&lt;muurkha&gt;</a></span><span class="message">yeah, Thompson's Turing Award lecture on it was called &quot;Reflections on Trusting Trust&quot;</span></div><div class="line" id="073729"><span class="nick" style="color:#6d2462"><a href="#073729" label="[07:37:29]">&lt;littlebobeep&gt;</a></span><span class="message">muurkha: OKay yes I never had a system that is not vulernable to this :/</span></div><div class="line" id="073735"><span class="nick" style="color:#6d2462"><a href="#073735" label="[07:37:35]">&lt;littlebobeep&gt;</a></span><span class="message">muurkha: I never heard of Karger tho</span></div><div class="line" id="080004"><span class="nick" style="color:#8dd3c7"><a href="#080004" label="[08:00:04]">&lt;muurkha&gt;</a></span><span class="message">Paul Karger and Roger Schell published the attack in Multics Security Evaluation: Vulnerability Analysis in 01974</span></div><div class="line" id="080025"><span class="nick" style="color:#8dd3c7"><a href="#080025" label="[08:00:25]">&lt;muurkha&gt;</a></span><span class="message">cf. <a rel="nofollow" href="https://en.wikipedia.org/wiki/Backdoor_%28computing%29#Compiler_backdoors">https://en.wikipedia.org/wiki/Backdoor_%28computing%29#Compiler_backdoors</a> </span></div><div class="line" id="080138"><span class="nick" style="color:#8dd3c7"><a href="#080138" label="[08:01:38]">&lt;muurkha&gt;</a></span><span class="message">oh, I bet mode +c removed my underlining of the paper title</span></div><div class="line" id="080147"><span class="nick" style="color:#8dd3c7"><a href="#080147" label="[08:01:47]">&lt;muurkha&gt;</a></span><span class="message">but you can probably figure out what it is</span></div><div class="line" id="080433"><span class="nick" style="color:#389600"><a href="#080433" label="[08:04:33]">&lt;oriansj&gt;</a></span><span class="message">muurkha: true but I'm going after the Nexus Intruder Attack; Sorting out the Trusting Trust attack is just a step on that journey</span></div><div class="line" id="080544"><span class="nick" style="color:#389600"><a href="#080544" label="[08:05:44]">&lt;oriansj&gt;</a></span><span class="message">you know, solve the software problems first before getting into the more expensive work</span></div><div class="line" id="081033"><span class="nick" style="color:#8dd3c7"><a href="#081033" label="[08:10:33]">&lt;muurkha&gt;</a></span><span class="message">you explained what the Nexus Intruder attack was before, but I forget</span></div><div class="line" id="083727"><span class="nick" style="color:#6d2462"><a href="#083727" label="[08:37:27]">&lt;littlebobeep&gt;</a></span><span class="message">Ohhh okay I read about the Multics attack</span></div><div class="line" id="083820"><span class="nick" style="color:#6b8072"><a href="#083820" label="[08:38:20]">&lt;nimaje&gt;</a></span><span class="message">does autotools even work on platforms where CHAR_BIT != 8? well, you wouldn't have int8_t on those and int64_t only if CHAR_BIT is in (16, 32, 64) (int{8,16,32,64}_t 'signed integer type with width of exactly 8, 16, 32 and 64 bits respectively with no padding bits and using 2's complement for negative values (provided if and only if the implementation directly supports the type)')</span></div><div class="line" id="083832"><span class="nick" style="color:#6d2462"><a href="#083832" label="[08:38:32]">&lt;littlebobeep&gt;</a></span><span class="message">oriansj: wut is Nexus Intruder attack, I just grepped the logs for this channel and nothing shows up</span></div><div class="line" id="134230"><span class="nick" style="color:#389600"><a href="#134230" label="[13:42:30]">&lt;oriansj&gt;</a></span><span class="message">muurkha, littlebobeep: short version hardware compromises operating systems, which compromise compilers and VLSI tools; which ensure future hardware is malicious and will ensure the cycle continues. It was a proposal to subvert the Soviet computing infrastructure *forever*</span></div><div class="line" id="152118"><span class="nick" style="color:#389600"><a href="#152118" label="[15:21:18]">&lt;oriansj&gt;</a></span><span class="message">that being said, there is no evidence that it was done nor that it is even possible.</span></div><div class="line" id="152156"><span class="nick" style="color:#389600"><a href="#152156" label="[15:21:56]">&lt;oriansj&gt;</a></span><span class="message">But it makes for a fun little puzzle for me to solve, even if it has no real world applications.</span></div><div class="line" id="183957"><span class="nick" style="color:#8dd3c7"><a href="#183957" label="[18:39:57]">&lt;muurkha&gt;</a></span><span class="message">oh, right!  yeah, you can definitely do that but you probably don't need to involve the compilers</span></div><div class="line" id="194354"><span class="nick" style="color:#389600"><a href="#194354" label="[19:43:54]">&lt;oriansj&gt;</a></span><span class="message">I guess I never defined what the size field means in GFK filesystem in dnodes for folders</span></div><div class="line" id="194838"><span class="nick" style="color:#389600"><a href="#194838" label="[19:48:38]">&lt;oriansj&gt;</a></span><span class="message"> <a rel="nofollow" href="https://github.com/oriansj/GFK/blob/main/GFK%20standard.org">https://github.com/oriansj/GFK/blob/main/GFK%20standard.org</a> </span></div><div class="line" id="195924"><span class="nick" style="color:#389600"><a href="#195924" label="[19:59:24]">&lt;oriansj&gt;</a></span><span class="message">hmmm how does this sound: for files be the size of the file in bytes but for folders be: the sum of all the contents of that directory or zero to simplify bootstrapping implementations done in assembly</span></div><div class="line" id="200007"><span class="nick" style="color:#8dd3c7"><a href="#200007" label="[20:00:07]">&lt;muurkha&gt;</a></span><span class="message">maybe you should implement it first and see what you need it for</span></div><div class="line" id="200136"><span class="nick" style="color:#389600"><a href="#200136" label="[20:01:36]">&lt;oriansj&gt;</a></span><span class="message">I don't need it but I did define a standard dnode</span></div><div class="line" id="200154"><span class="nick" style="color:#8dd3c7"><a href="#200154" label="[20:01:54]">&lt;muurkha&gt;</a></span><span class="message">original Unix didn't have a readdir() or getdents() system call, you just read() the directory</span></div><div class="line" id="200212"><span class="nick" style="color:#8dd3c7"><a href="#200212" label="[20:02:12]">&lt;muurkha&gt;</a></span><span class="message">then there was a library function to parse the directory contents into filenames and inode numbers</span></div><div class="line" id="200252"><span class="nick" style="color:#8dd3c7"><a href="#200252" label="[20:02:52]">&lt;muurkha&gt;</a></span><span class="message">so naturally the file size was the number of bytes you would read in that fashion</span></div><div class="line" id="200421"><span class="nick" style="color:#389600"><a href="#200421" label="[20:04:21]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I am also trying to figure out what would be easy to manually create in hex0</span></div><div class="line" id="200454"><span class="nick" style="color:#8dd3c7"><a href="#200454" label="[20:04:54]">&lt;muurkha&gt;</a></span><span class="message">yeah</span></div><div class="line" id="200836"><span class="nick" style="color:#389600"><a href="#200836" label="[20:08:36]">&lt;oriansj&gt;</a></span><span class="message">well fat12 did: For other entries than files then file size field should be set to 0.</span></div><div class="line" id="203231"><span class="nick" style="color:#389600"><a href="#203231" label="[20:32:31]">&lt;oriansj&gt;</a></span><span class="message">and I guess just doing that probably is good enough</span></div><div class="line" id="203431"><span class="nick" style="color:#389600"><a href="#203431" label="[20:34:31]">&lt;oriansj&gt;</a></span><span class="message">ok so: if pointing to a file/Indirect File: the size of that file in bytes and if anything else: ZERO to simplify bootstrapping implementations.</span></div><div class="line" id="215657"><span class="nick">***</span><span class="message notice">alMalsamo is now known as littlebobeep</span></div><br /></div></body></html>