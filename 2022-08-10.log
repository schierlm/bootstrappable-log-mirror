<!DOCTYPE html><html><head><title>IRC channel logs</title><style>html {
  background: #fdfdfd;
}

h1 {
  font-weight: 300;
}

h2 {
  font-weight: 200;
}

h3 {
  padding: .5em 0;
  border-top: 3px dotted #ddd;
  margin-bottom: 0;
}

form {
  width: 400px;
  display: flex;
}

input {
  width: 100%;
  display: flex;
  border-radius: .25em 0 0 .25em;
  border: 1px solid #aaa;
  border-right: 0;
  padding: 0.5em;
}

button {
  display: flex;
  border-radius: 0 .25em .25em 0;
  background-color: #007bff;
  border: 1px solid #007bff;
  padding: .5em;
  cursor: pointer;
  color: white;
}

button:hover {
  background-color: #0069d9;
  border-color: #0062cc;
}

a {
  color: #007bff;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

h4 {
  margin-bottom: .5em;
}

table td {
  padding: 0.75em;
}

table tr:hover {
  background: #eee;
}

.year {
  display: table;
}

.month {
  display: table-cell;
  padding-right: 1em;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nick {
  padding-right: 0.6rem;
  font-weight: bold;
  text-align: right;
  width: 13rem;
  display: table-cell;
}

.nick a {
  color: inherit;
  text-decoration: none;
}

.message {
  display: table-cell;
  padding-left: 0.6rem;
  border-left: 2px solid #333;
}

.notice {
  color: #859900;
  font-style: italic;
}

.line {
  line-height: 1.8rem;
  display: table;
}

#logs {
  margin-top: 1.5rem;
  padding: 1.5rem;
}
</style></head><body><h1>IRC channel logs</h1><h2>2022-08-10.log</h2><p><a href="/bootstrappable">back to list of logs</a></p><div id="logs"><div class="line" id="012126"><span class="nick" style="color:#8dd3c7"><a href="#012126" label="[01:21:26]">&lt;oriansj&gt;</a></span><span class="message">stikonas: well you could always switch from sysa to stage4-&gt;stageN</span></div><div class="line" id="012240"><span class="nick" style="color:#8dd3c7"><a href="#012240" label="[01:22:40]">&lt;oriansj&gt;</a></span><span class="message">samplet: could you either point to more information about that tar extension or perhaps a mescc-tools-extra patch to help support that? that way we can remove that bug entirely.</span></div><div class="line" id="012630"><span class="nick" style="color:#8dd3c7"><a href="#012630" label="[01:26:30]">&lt;oriansj&gt;</a></span><span class="message">rickmasters: well hex2 and M1 can be leveraged to find errors in hex0/hex1/M0 programs but unfortunately debugging your implementations of hex0/hex1/hex2/M0/cc_* is something even debug logic wouldn't help too much... although gdb support for your kernel might be a bit much to expect. (Hence why I was originally thinking of doing the kernel in C first to figure out basics before doing the extra painful assembly work)</span></div><div class="line" id="013116"><span class="nick" style="color:#8dd3c7"><a href="#013116" label="[01:31:16]">&lt;oriansj&gt;</a></span><span class="message">but you really beat me to that punch and seem much better at kernel work than I am so I am really excited to see your progress (it is quite awesome)</span></div><div class="line" id="013641"><span class="nick" style="color:#2e2a4a"><a href="#013641" label="[01:36:41]">&lt;stikonas&gt;</a></span><span class="message">I didn't bother with gdb for stage0-uefi work either</span></div><div class="line" id="013718"><span class="nick" style="color:#6b8072"><a href="#013718" label="[01:37:18]">&lt;rickmasters&gt;</a></span><span class="message">honestly i wouldn't know how to implement gdb support for a kernel whether written in C or otherwise</span></div><div class="line" id="013734"><span class="nick" style="color:#8dd3c7"><a href="#013734" label="[01:37:34]">&lt;oriansj&gt;</a></span><span class="message">fair, it seems to involve a good bit of complexity</span></div><div class="line" id="013759"><span class="nick" style="color:#6b8072"><a href="#013759" label="[01:37:59]">&lt;rickmasters&gt;</a></span><span class="message">it traditionally required gdb running on another computer using a serial port to talk to a special gdb handler in the kernel</span></div><div class="line" id="013911"><span class="nick" style="color:#8dd3c7"><a href="#013911" label="[01:39:11]">&lt;oriansj&gt;</a></span><span class="message">true</span></div><div class="line" id="013911"><span class="nick" style="color:#80b1d3"><a href="#013911" label="[01:39:11]">&lt;samplet&gt;</a></span><span class="message">oriansj: Yeah.  Here’s a commit implementing it for Gash-Utils: <a rel="nofollow" href="https://git.savannah.nongnu.org/cgit/gash/gash-utils.git/commit/?id=319b1836fd1f519c43955ee29f00aa0a90049754">https://git.savannah.nongnu.org/cgit/gash/gash-utils.git/commit/?id=319b1836fd1f519c43955ee29f00aa0a90049754</a> </span></div><div class="line" id="013925"><span class="nick" style="color:#80b1d3"><a href="#013925" label="[01:39:25]">&lt;samplet&gt;</a></span><span class="message">I think the GNU manual explains it a bit: <a rel="nofollow" href="https://www.gnu.org/software/tar/manual/html_node/Standard.html#Standard">https://www.gnu.org/software/tar/manual/html_node/Standard.html#Standard</a> </span></div><div class="line" id="013942"><span class="nick" style="color:#6b8072"><a href="#013942" label="[01:39:42]">&lt;rickmasters&gt;</a></span><span class="message">i did debug a couple issues by breaking into the qemu monitor and using its debug facilities</span></div><div class="line" id="013949"><span class="nick" style="color:#8dd3c7"><a href="#013949" label="[01:39:49]">&lt;oriansj&gt;</a></span><span class="message">thank you samplet</span></div><div class="line" id="013952"><span class="nick" style="color:#80b1d3"><a href="#013952" label="[01:39:52]">&lt;samplet&gt;</a></span><span class="message">Is mescc-tools-extra implemented in M2?</span></div><div class="line" id="014008"><span class="nick" style="color:#2e2a4a"><a href="#014008" label="[01:40:08]">&lt;stikonas&gt;</a></span><span class="message">samplet: yes</span></div><div class="line" id="014021"><span class="nick" style="color:#2e2a4a"><a href="#014021" label="[01:40:21]">&lt;stikonas&gt;</a></span><span class="message">in fact we build it with M2-Mesoplanet</span></div><div class="line" id="014038"><span class="nick" style="color:#2e2a4a"><a href="#014038" label="[01:40:38]">&lt;stikonas&gt;</a></span><span class="message">so we have a few extra goodies like better preprocessor and #includes</span></div><div class="line" id="014159"><span class="nick" style="color:#80b1d3"><a href="#014159" label="[01:41:59]">&lt;samplet&gt;</a></span><span class="message">Cool.  I learned a fair bit about M2 while hacking on Mes.  It’s developed quite a bit since the version Mes is using AIUI.</span></div><div class="line" id="014418"><span class="nick" style="color:#8dd3c7"><a href="#014418" label="[01:44:18]">&lt;oriansj&gt;</a></span><span class="message">and the C behavior is generally pretty standard for the bits we do implement</span></div><div class="line" id="014524"><span class="nick" style="color:#2e2a4a"><a href="#014524" label="[01:45:24]">&lt;stikonas&gt;</a></span><span class="message">well, except for pointer arithmetic</span></div><div class="line" id="014607"><span class="nick" style="color:#2e2a4a"><a href="#014607" label="[01:46:07]">&lt;stikonas&gt;</a></span><span class="message">but yes, M2 has grown quite a lot in features</span></div><div class="line" id="014626"><span class="nick" style="color:#2e2a4a"><a href="#014626" label="[01:46:26]">&lt;stikonas&gt;</a></span><span class="message">though adding more features to M2-Planet is increasingly hard</span></div><div class="line" id="014940"><span class="nick" style="color:#8dd3c7"><a href="#014940" label="[01:49:40]">&lt;oriansj&gt;</a></span><span class="message">and multiple architectures</span></div><div class="line" id="015027"><span class="nick" style="color:#8dd3c7"><a href="#015027" label="[01:50:27]">&lt;oriansj&gt;</a></span><span class="message">but it was never intended to be a single step from cc_* to tcc or GCC but only the subset of features needed by mes.c</span></div><div class="line" id="015108"><span class="nick" style="color:#8dd3c7"><a href="#015108" label="[01:51:08]">&lt;oriansj&gt;</a></span><span class="message">So some badly planned short-cuts were used.</span></div><div class="line" id="015210"><span class="nick" style="color:#8dd3c7"><a href="#015210" label="[01:52:10]">&lt;oriansj&gt;</a></span><span class="message">redoing it with an IR and separate architecture specializers would have produced more efficient code and a much easier path to adding functionality.</span></div><div class="line" id="015310"><span class="nick" style="color:#80b1d3"><a href="#015310" label="[01:53:10]">&lt;samplet&gt;</a></span><span class="message">In brief, the GNU extension works by having a “fake” file with typeflag 'L' or 'K' (for long name and long link respectively).  Then, the name of the next file is the contents of the “fake” file.</span></div><div class="line" id="015327"><span class="nick" style="color:#80b1d3"><a href="#015327" label="[01:53:27]">&lt;samplet&gt;</a></span><span class="message">I read my own code so no one else has to.  :)</span></div><div class="line" id="015336"><span class="nick" style="color:#8dd3c7"><a href="#015336" label="[01:53:36]">&lt;oriansj&gt;</a></span><span class="message">but at this point doing that work would basically cause us to skip mescc entirely and eat about a year of dedicated effort.</span></div><div class="line" id="020118"><span class="nick" style="color:#8dd3c7"><a href="#020118" label="[02:01:18]">&lt;oriansj&gt;</a></span><span class="message">so not something that would push the bootstrap forward into a new area so much as make future work on the transistion to tcc simpler</span></div><div class="line" id="020511"><span class="nick" style="color:#8dd3c7"><a href="#020511" label="[02:05:11]">&lt;oriansj&gt;</a></span><span class="message">and it looks like a new person finally posted some questions about stage0</span></div><div class="line" id="022019"><span class="nick" style="color:#8dd3c7"><a href="#022019" label="[02:20:19]">&lt;oriansj&gt;</a></span><span class="message">that reminds me, I probably should do a hex0 monitor for UEFI as one can't assume a text editor in a UEFI implementation can they?</span></div><div class="line" id="022259"><span class="nick" style="color:#6d2462"><a href="#022259" label="[02:22:59]">&lt;stikonas[m]&gt;</a></span><span class="message">No, we can't...</span></div><div class="line" id="022559"><span class="nick" style="color:#8dd3c7"><a href="#022559" label="[02:25:59]">&lt;oriansj&gt;</a></span><span class="message">just requires a tweak to the read/write behavior and using keyboard input to populate 2 files (all keypresses and the built binary)</span></div><div class="line" id="022751"><span class="nick" style="color:#8dd3c7"><a href="#022751" label="[02:27:51]">&lt;oriansj&gt;</a></span><span class="message">it is absolutely terrible with no editing functionality nor backspace functionality but it'll only cost a small handful of bytes</span></div><div class="line" id="023014"><span class="nick" style="color:#6d2462"><a href="#023014" label="[02:30:14]">&lt;stikonas[m]&gt;</a></span><span class="message">Are those stage0 questions you got public?</span></div><div class="line" id="023328"><span class="nick" style="color:#8dd3c7"><a href="#023328" label="[02:33:28]">&lt;oriansj&gt;</a></span><span class="message">yep: <a rel="nofollow" href="https://github.com/oriansj/stage0/issues/26">https://github.com/oriansj/stage0/issues/26</a> </span></div><div class="line" id="023346"><span class="nick" style="color:#8dd3c7"><a href="#023346" label="[02:33:46]">&lt;oriansj&gt;</a></span><span class="message">writing up the answers now</span></div><div class="line" id="042102"><span class="nick" style="color:#8dd3c7"><a href="#042102" label="[04:21:02]">&lt;oriansj&gt;</a></span><span class="message">hopefully I made everything clear: <a rel="nofollow" href="https://github.com/oriansj/stage0/blob/master/questions_asked_by_new_people.org">https://github.com/oriansj/stage0/blob/master/questions_asked_by_new_people.org</a> </span></div><div class="line" id="042326"><span class="nick" style="color:#234e69"><a href="#042326" label="[04:23:26]">&lt;theruran&gt;</a></span><span class="message">I have a question... how can I boot into stage2 LISP in QEMU? :)</span></div><div class="line" id="042923"><span class="nick" style="color:#8dd3c7"><a href="#042923" label="[04:29:23]">&lt;oriansj&gt;</a></span><span class="message">theruran: well stage2 lisp is currently only written in knight assembly, So only if you are running a knight instruction set architecture emulator inside of qemu as qemu doesn't not yet support emulation of knight yet.</span></div><div class="line" id="043050"><span class="nick" style="color:#8dd3c7"><a href="#043050" label="[04:30:50]">&lt;oriansj&gt;</a></span><span class="message">ultimately for non-bare metal bootstrapping, building of mes.c provides for a much better lisp experience</span></div><div class="line" id="043102"><span class="nick" style="color:#234e69"><a href="#043102" label="[04:31:02]">&lt;theruran&gt;</a></span><span class="message">ohhh is that why it is slow to boot up using the given VM?</span></div><div class="line" id="043126"><span class="nick" style="color:#234e69"><a href="#043126" label="[04:31:26]">&lt;theruran&gt;</a></span><span class="message">I am looking for a path that does not touch C</span></div><div class="line" id="043211"><span class="nick" style="color:#8dd3c7"><a href="#043211" label="[04:32:11]">&lt;oriansj&gt;</a></span><span class="message">theruran: noble goal to have</span></div><div class="line" id="043300"><span class="nick" style="color:#8dd3c7"><a href="#043300" label="[04:33:00]">&lt;oriansj&gt;</a></span><span class="message">I would strongly suggest you taking a look at Ur-Scheme</span></div><div class="line" id="043324"><span class="nick" style="color:#234e69"><a href="#043324" label="[04:33:24]">&lt;theruran&gt;</a></span><span class="message">oriansj: so there is a Knight assembler written in hex2 or ???</span></div><div class="line" id="043328"><span class="nick" style="color:#234e69"><a href="#043328" label="[04:33:28]">&lt;theruran&gt;</a></span><span class="message">what about x86_64</span></div><div class="line" id="043356"><span class="nick" style="color:#8dd3c7"><a href="#043356" label="[04:33:56]">&lt;oriansj&gt;</a></span><span class="message">it is great and its author is here too.</span></div><div class="line" id="043435"><span class="nick" style="color:#234e69"><a href="#043435" label="[04:34:35]">&lt;theruran&gt;</a></span><span class="message">hmm but Ur-Scheme is written in Scheme</span></div><div class="line" id="043435"><span class="nick" style="color:#8dd3c7"><a href="#043435" label="[04:34:35]">&lt;oriansj&gt;</a></span><span class="message">well the knight assembler is written in C, M1 and hex2</span></div><div class="line" id="043509"><span class="nick" style="color:#234e69"><a href="#043509" label="[04:35:09]">&lt;theruran&gt;</a></span><span class="message">bronze-age-lisp is written in x86 (32-bit) and I am wondering how much work it is to convert it to 64-bit and what needs to be done</span></div><div class="line" id="043533"><span class="nick" style="color:#8dd3c7"><a href="#043533" label="[04:35:33]">&lt;oriansj&gt;</a></span><span class="message">theruran: let me take a quick look</span></div><div class="line" id="043551"><span class="nick" style="color:#234e69"><a href="#043551" label="[04:35:51]">&lt;theruran&gt;</a></span><span class="message">oriansj: I mirrored it here: <a rel="nofollow" href="https://git.hackers.town/theruran/bronze-age-lisp">https://git.hackers.town/theruran/bronze-age-lisp</a> </span></div><div class="line" id="043617"><span class="nick" style="color:#8dd3c7"><a href="#043617" label="[04:36:17]">&lt;oriansj&gt;</a></span><span class="message">thank you for the link</span></div><div class="line" id="043759"><span class="nick" style="color:#234e69"><a href="#043759" label="[04:37:59]">&lt;theruran&gt;</a></span><span class="message">it is pretty clever. I doubt I could make an improvement</span></div><div class="line" id="044016"><span class="nick" style="color:#8dd3c7"><a href="#044016" label="[04:40:16]">&lt;oriansj&gt;</a></span><span class="message">looking at it, it appears to do structs the manual way (multiple %define lines) but that is fine, one doesn't need to leverage gas's support for structs.</span></div><div class="line" id="044119"><span class="nick">***</span><span class="message notice">muurkha_ is now known as muurkha</span></div><div class="line" id="044232"><span class="nick" style="color:#8dd3c7"><a href="#044232" label="[04:42:32]">&lt;oriansj&gt;</a></span><span class="message">So to convert to AMD64, you'll need to tweak the syscalls as the calling convention and syscall numbers will be different. And adjust the struct sizes to reflect the bigger int size and possibly a few max_int/min_int corner cases in the code</span></div><div class="line" id="044252"><span class="nick" style="color:#8dd3c7"><a href="#044252" label="[04:42:52]">&lt;oriansj&gt;</a></span><span class="message">oh and the univeral replacement of E* with R*</span></div><div class="line" id="044328"><span class="nick" style="color:#234e69"><a href="#044328" label="[04:43:28]">&lt;theruran&gt;</a></span><span class="message">I see. doesn't sound too awful!</span></div><div class="line" id="044409"><span class="nick" style="color:#8dd3c7"><a href="#044409" label="[04:44:09]">&lt;oriansj&gt;</a></span><span class="message">well going from x86 to AMD64 was engineered to be a smooth transisition.</span></div><div class="line" id="044450"><span class="nick" style="color:#8dd3c7"><a href="#044450" label="[04:44:50]">&lt;oriansj&gt;</a></span><span class="message">you literally could run x86 binaries in AMD64 and only make changes if you want 64bit integers and 64bit pointers.</span></div><div class="line" id="044628"><span class="nick" style="color:#234e69"><a href="#044628" label="[04:46:28]">&lt;theruran&gt;</a></span><span class="message">when I try to build it, I get a linking error saying its for i386. and I stopped there</span></div><div class="line" id="044845"><span class="nick" style="color:#8dd3c7"><a href="#044845" label="[04:48:45]">&lt;oriansj&gt;</a></span><span class="message">well there might be an assembly directive you could just change to fix that</span></div><div class="line" id="045156"><span class="nick" style="color:#8dd3c7"><a href="#045156" label="[04:51:56]">&lt;oriansj&gt;</a></span><span class="message">as usually when you build a 32bit binary on a 64bit architecture, it should error with a message like: (Error: operand type mismatch for `pop') and require you to do something like: as --32 $Source.S -o $Binary.o &amp;&amp; ld -m elf_i386 $Binary.o -o $Final_Name to work around that if there wasn't a directive</span></div><div class="line" id="045340"><span class="nick" style="color:#234e69"><a href="#045340" label="[04:53:40]">&lt;theruran&gt;</a></span><span class="message">looks like nasm uses -gelfx32</span></div><div class="line" id="045357"><span class="nick" style="color:#234e69"><a href="#045357" label="[04:53:57]">&lt;theruran&gt;</a></span><span class="message">I accidentally ran build.sh instead of quickbuild.sh so it will be awhile</span></div><div class="line" id="045410"><span class="nick" style="color:#8dd3c7"><a href="#045410" label="[04:54:10]">&lt;oriansj&gt;</a></span><span class="message">yeah, that would do it</span></div><div class="line" id="045457"><span class="nick" style="color:#8dd3c7"><a href="#045457" label="[04:54:57]">&lt;oriansj&gt;</a></span><span class="message">on nasm the building of a 64bit binary is usually: nasm -f elf64 -o $Final_Name $Source.S</span></div><div class="line" id="045535"><span class="nick" style="color:#6c3d55"><a href="#045535" label="[04:55:35]">&lt;muurkha&gt;</a></span><span class="message">oriansj: I'm glad you enjoyed Ur-Scheme</span></div><div class="line" id="045706"><span class="nick" style="color:#6c3d55"><a href="#045706" label="[04:57:06]">&lt;muurkha&gt;</a></span><span class="message">x32 is not the same thing as i386</span></div><div class="line" id="045714"><span class="nick" style="color:#6c3d55"><a href="#045714" label="[04:57:14]">&lt;muurkha&gt;</a></span><span class="message">I don't think?</span></div><div class="line" id="045723"><span class="nick" style="color:#8dd3c7"><a href="#045723" label="[04:57:23]">&lt;oriansj&gt;</a></span><span class="message">muurkha: well it helped me improve my mes-m2 rewrite a great deal and it gave me the dream of just compiling mescc and having something fast build tcc</span></div><div class="line" id="045726"><span class="nick" style="color:#6c3d55"><a href="#045726" label="[04:57:26]">&lt;muurkha&gt;</a></span><span class="message">I mean Debian Sid treats it as a separate architecture</span></div><div class="line" id="045747"><span class="nick" style="color:#234e69"><a href="#045747" label="[04:57:47]">&lt;theruran&gt;</a></span><span class="message">nasm --help says: elfx32:    dwarf     ELFx32 (x86-64) dwarf (newer) [default]</span></div><div class="line" id="045808"><span class="nick" style="color:#6c3d55"><a href="#045808" label="[04:58:08]">&lt;muurkha&gt;</a></span><span class="message">oriansj: great!  my life has thus had some benefits</span></div><div class="line" id="045816"><span class="nick" style="color:#234e69"><a href="#045816" label="[04:58:16]">&lt;theruran&gt;</a></span><span class="message">I thought that meant running 32-bit ELF on 64-bit system</span></div><div class="line" id="045817"><span class="nick" style="color:#8dd3c7"><a href="#045817" label="[04:58:17]">&lt;oriansj&gt;</a></span><span class="message">muurkha: x32 is AMD64 with 32bit pointers and a few more special things that I don't remember off the top of my head</span></div><div class="line" id="045819"><span class="nick" style="color:#6c3d55"><a href="#045819" label="[04:58:19]">&lt;muurkha&gt;</a></span><span class="message">and it might have more!  since I'm not dead yet</span></div><div class="line" id="045837"><span class="nick" style="color:#6c3d55"><a href="#045837" label="[04:58:37]">&lt;muurkha&gt;</a></span><span class="message">oriansj: yeah, and I'm guessing that's what -gelfx32 does on nasm</span></div><div class="line" id="045854"><span class="nick" style="color:#6c3d55"><a href="#045854" label="[04:58:54]">&lt;muurkha&gt;</a></span><span class="message">I mean it's possible that -gelfx32 builds a 32-bit binary but it would surprise me</span></div><div class="line" id="045921"><span class="nick" style="color:#234e69"><a href="#045921" label="[04:59:21]">&lt;theruran&gt;</a></span><span class="message">OK I will try a few things once it's done building. very slow for some reason...</span></div><div class="line" id="045943"><span class="nick" style="color:#8dd3c7"><a href="#045943" label="[04:59:43]">&lt;oriansj&gt;</a></span><span class="message">muurkha: you are awesome and I love your work it teaches me things I haven't seen yet or perhaps a new fun perspective on it.</span></div><div class="line" id="050128"><span class="nick" style="color:#8dd3c7"><a href="#050128" label="[05:01:28]">&lt;oriansj&gt;</a></span><span class="message">theruran: well 18,269 lines of macro heavy assembly isn't an easy task, especially if one tries to be too clever by half</span></div><div class="line" id="050221"><span class="nick" style="color:#234e69"><a href="#050221" label="[05:02:21]">&lt;theruran&gt;</a></span><span class="message">it's generating the assembly from Kernel LISP code running on Klisp</span></div><div class="line" id="050338"><span class="nick" style="color:#234e69"><a href="#050338" label="[05:03:38]">&lt;theruran&gt;</a></span><span class="message">about 700 bytes every 2 seconds :D</span></div><div class="line" id="050347"><span class="nick" style="color:#234e69"><a href="#050347" label="[05:03:47]">&lt;theruran&gt;</a></span><span class="message">watch'ing it go~</span></div><div class="line" id="050423"><span class="nick" style="color:#8dd3c7"><a href="#050423" label="[05:04:23]">&lt;oriansj&gt;</a></span><span class="message">hmm: klisp mold.k &quot;$@&quot; &gt; build/out.asm where does that root klisp binary get built?</span></div><div class="line" id="050504"><span class="nick" style="color:#234e69"><a href="#050504" label="[05:05:04]">&lt;theruran&gt;</a></span><span class="message">oriansj: it is another Kernel implementation based on the Lua source (C)</span></div><div class="line" id="050732"><span class="nick" style="color:#8dd3c7"><a href="#050732" label="[05:07:32]">&lt;oriansj&gt;</a></span><span class="message">so generated assembly because they never wanted to put in the effort required to write it actually in assembly???</span></div><div class="line" id="051103"><span class="nick" style="color:#8dd3c7"><a href="#051103" label="[05:11:03]">&lt;oriansj&gt;</a></span><span class="message">stikonas: you are now assigned push/commit access to stage0-posix-amd64 and the invite has been sent</span></div><div class="line" id="051242"><span class="nick" style="color:#6c3d55"><a href="#051242" label="[05:12:42]">&lt;muurkha&gt;</a></span><span class="message">oriansj: :)</span></div><div class="line" id="051403"><span class="nick" style="color:#6c3d55"><a href="#051403" label="[05:14:03]">&lt;muurkha&gt;</a></span><span class="message">the intuition behind Qfitzah is that it ought to be easier to write compilers in a term-rewriting language, and a term-rewriting bootstrap interpreter ought to be pretty easy to write if it doesn't have to be fast</span></div><div class="line" id="051442"><span class="nick" style="color:#6c3d55"><a href="#051442" label="[05:14:42]">&lt;muurkha&gt;</a></span><span class="message">so far it's about 500 lines of assembly: <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/qfitzah.s">http://canonical.org/~kragen/sw/dev3/qfitzah.s</a> </span></div><div class="line" id="051504"><span class="nick" style="color:#234e69"><a href="#051504" label="[05:15:04]">&lt;theruran&gt;</a></span><span class="message">honestly, the author doesn't seem to explain why. <a rel="nofollow" href="https://groups.google.com/g/klisp/c/hX-xevvrYWk">https://groups.google.com/g/klisp/c/hX-xevvrYWk</a> </span></div><div class="line" id="051517"><span class="nick" style="color:#6c3d55"><a href="#051517" label="[05:15:17]">&lt;muurkha&gt;</a></span><span class="message">but so far qfitzah only runs really simple programs</span></div><div class="line" id="051527"><span class="nick" style="color:#234e69"><a href="#051527" label="[05:15:27]">&lt;theruran&gt;</a></span><span class="message">I assume it's because LISP programmers don't like writing anything that's not S-expressions ;)</span></div><div class="line" id="051553"><span class="nick" style="color:#234e69"><a href="#051553" label="[05:15:53]">&lt;theruran&gt;</a></span><span class="message">I did find a note in TROUBLESHOOTING doc though: LD='ld -m elf_i386' ./build.sh</span></div><div class="line" id="051556"><span class="nick" style="color:#234e69"><a href="#051556" label="[05:15:56]">&lt;theruran&gt;</a></span><span class="message">ha!</span></div><div class="line" id="051607"><span class="nick" style="color:#6c3d55"><a href="#051607" label="[05:16:07]">&lt;muurkha&gt;</a></span><span class="message">huh, does -m32 work?</span></div><div class="line" id="051622"><span class="nick" style="color:#6c3d55"><a href="#051622" label="[05:16:22]">&lt;muurkha&gt;</a></span><span class="message">I didn't know elf_i386 was even a valid -m</span></div><div class="line" id="051624"><span class="nick" style="color:#8dd3c7"><a href="#051624" label="[05:16:24]">&lt;oriansj&gt;</a></span><span class="message">muurkha: nope</span></div><div class="line" id="051639"><span class="nick" style="color:#234e69"><a href="#051639" label="[05:16:39]">&lt;theruran&gt;</a></span><span class="message">muurkha: not on my system. unrecognized</span></div><div class="line" id="051646"><span class="nick" style="color:#6c3d55"><a href="#051646" label="[05:16:46]">&lt;muurkha&gt;</a></span><span class="message">interesting!</span></div><div class="line" id="051717"><span class="nick" style="color:#6c3d55"><a href="#051717" label="[05:17:17]">&lt;muurkha&gt;</a></span><span class="message">the benefit of S-expressions is that it saves you from having to write a complex parser</span></div><div class="line" id="051745"><span class="nick" style="color:#234e69"><a href="#051745" label="[05:17:45]">&lt;theruran&gt;</a></span><span class="message">OK it linked, but running it immediately gets an &quot;ERROR: Internal error.&quot; along with some hex addresses</span></div><div class="line" id="051747"><span class="nick" style="color:#6c3d55"><a href="#051747" label="[05:17:47]">&lt;muurkha&gt;</a></span><span class="message">like, even with a parser generator, it's easy for the parser for a programming language to run to several pages of code</span></div><div class="line" id="051808"><span class="nick" style="color:#6c3d55"><a href="#051808" label="[05:18:08]">&lt;muurkha&gt;</a></span><span class="message">and if you're writing the parser in assembly, it can be dozens of pages of code</span></div><div class="line" id="051822"><span class="nick" style="color:#234e69"><a href="#051822" label="[05:18:22]">&lt;theruran&gt;</a></span><span class="message">whew!</span></div><div class="line" id="051835"><span class="nick" style="color:#6c3d55"><a href="#051835" label="[05:18:35]">&lt;muurkha&gt;</a></span><span class="message">yay!  hopefully you can figure out what the addresses are</span></div><div class="line" id="051914"><span class="nick" style="color:#6c3d55"><a href="#051914" label="[05:19:14]">&lt;muurkha&gt;</a></span><span class="message">the S-expression BNF is, like, sexp ::= &quot;(&quot; sexp* &quot;)&quot; | atom</span></div><div class="line" id="051922"><span class="nick" style="color:#234e69"><a href="#051922" label="[05:19:22]">&lt;theruran&gt;</a></span><span class="message">unlikely. no time to debug this thing</span></div><div class="line" id="051927"><span class="nick" style="color:#8dd3c7"><a href="#051927" label="[05:19:27]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I'd have to disagree on the saving you from having to write a complex parser bit as mes.c has a *WAY* more complex parser than M2-Planet does</span></div><div class="line" id="051931"><span class="nick" style="color:#6c3d55"><a href="#051931" label="[05:19:31]">&lt;muurkha&gt;</a></span><span class="message">that's adequate (if annoying) to express any tree structure</span></div><div class="line" id="051946"><span class="nick" style="color:#6c3d55"><a href="#051946" label="[05:19:46]">&lt;muurkha&gt;</a></span><span class="message">oriansj: why is that?</span></div><div class="line" id="051955"><span class="nick" style="color:#8dd3c7"><a href="#051955" label="[05:19:55]">&lt;oriansj&gt;</a></span><span class="message">macros</span></div><div class="line" id="052005"><span class="nick" style="color:#6c3d55"><a href="#052005" label="[05:20:05]">&lt;muurkha&gt;</a></span><span class="message">macros?</span></div><div class="line" id="052029"><span class="nick" style="color:#8dd3c7"><a href="#052029" label="[05:20:29]">&lt;oriansj&gt;</a></span><span class="message">more precisely reader macro support</span></div><div class="line" id="052100"><span class="nick" style="color:#8dd3c7"><a href="#052100" label="[05:21:00]">&lt;oriansj&gt;</a></span><span class="message">so the parser can be changed how it reads bytes and how it parses them</span></div><div class="line" id="052116"><span class="nick" style="color:#8dd3c7"><a href="#052116" label="[05:21:16]">&lt;oriansj&gt;</a></span><span class="message">with just a few s-expressions</span></div><div class="line" id="052159"><span class="nick" style="color:#8dd3c7"><a href="#052159" label="[05:21:59]">&lt;oriansj&gt;</a></span><span class="message">without reader macro support you are absolutely right, pure S-expression only is only about 77 lines of assembly</span></div><div class="line" id="052531"><span class="nick" style="color:#6c3d55"><a href="#052531" label="[05:25:31]">&lt;muurkha&gt;</a></span><span class="message">the S-expression reader in Qfitzah is a little longer than that but not much</span></div><div class="line" id="052622"><span class="nick" style="color:#6c3d55"><a href="#052622" label="[05:26:22]">&lt;muurkha&gt;</a></span><span class="message">it's a little hard to tell because it's mixed in with support for strings and integers that isn't actually being used yet</span></div><div class="line" id="052940"><span class="nick" style="color:#6c3d55"><a href="#052940" label="[05:29:40]">&lt;muurkha&gt;</a></span><span class="message">in <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/readprint.fs">http://canonical.org/~kragen/sw/dev3/readprint.fs</a>  it took me 15 lines of Forth to do pure S-expression parsing</span></div><div class="line" id="053037"><span class="nick" style="color:#6c3d55"><a href="#053037" label="[05:30:37]">&lt;muurkha&gt;</a></span><span class="message">oriansj: did I already show you Meta5ix?  it makes me wonder if it might be worthwhile to do a parser generator very early on</span></div><div class="line" id="053117"><span class="nick" style="color:#8dd3c7"><a href="#053117" label="[05:31:17]">&lt;oriansj&gt;</a></span><span class="message">pure S-expressions are so simple and honestly I wished more languages used them, the problem is the temptation for reader macros support is too strong</span></div><div class="line" id="053203"><span class="nick" style="color:#8dd3c7"><a href="#053203" label="[05:32:03]">&lt;oriansj&gt;</a></span><span class="message">muurkha: I don't believe so as I usually make copies of everything you share</span></div><div class="line" id="053205"><span class="nick" style="color:#6c3d55"><a href="#053205" label="[05:32:05]">&lt;muurkha&gt;</a></span><span class="message">because in 18 lines of Meta5ix you already have a Meta5ix parser, but to get that to bootstrap you need some kind of bootstrap interpreter</span></div><div class="line" id="053230"><span class="nick" style="color:#6c3d55"><a href="#053230" label="[05:32:30]">&lt;muurkha&gt;</a></span><span class="message">meta5ix is a few files scattered around <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/meta5ixrun.py">http://canonical.org/~kragen/sw/dev3/meta5ixrun.py</a> </span></div><div class="line" id="053419"><span class="nick" style="color:#6c3d55"><a href="#053419" label="[05:34:19]">&lt;muurkha&gt;</a></span><span class="message">the version in <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/meta5ix2c.m5">http://canonical.org/~kragen/sw/dev3/meta5ix2c.m5</a>  compiles to C instead of the virtual machine instruction set implemented by the Python program</span></div><div class="line" id="053554"><span class="nick" style="color:#8dd3c7"><a href="#053554" label="[05:35:54]">&lt;oriansj&gt;</a></span><span class="message">neat</span></div><div class="line" id="053709"><span class="nick" style="color:#6c3d55"><a href="#053709" label="[05:37:09]">&lt;muurkha&gt;</a></span><span class="message">a friend of mine also got his own reimplementation of META-II to be able to generate Python code, but extremely far from idiomatic Python code</span></div><div class="line" id="053800"><span class="nick" style="color:#6c3d55"><a href="#053800" label="[05:38:00]">&lt;muurkha&gt;</a></span><span class="message">META-II out of the box is a little awkward about indentation; it's designed for 01960s assembly language syntax</span></div><div class="line" id="053827"><span class="nick" style="color:#6c3d55"><a href="#053827" label="[05:38:27]">&lt;muurkha&gt;</a></span><span class="message">but it turns out Python is a lot more forgiving of indentation if you put your entire program into a single gigantic list comprehension &gt;:-)</span></div><div class="line" id="053855"><span class="nick" style="color:#8dd3c7"><a href="#053855" label="[05:38:55]">&lt;oriansj&gt;</a></span><span class="message">take that whitespace sensitivity</span></div><div class="line" id="053916"><span class="nick" style="color:#6c3d55"><a href="#053916" label="[05:39:16]">&lt;muurkha&gt;</a></span><span class="message">in the output in <a rel="nofollow" href="http://canonical.org/~kragen/sw/dev3/meta5ix2c.c">http://canonical.org/~kragen/sw/dev3/meta5ix2c.c</a>  you can see the C parser Meta5ix generated</span></div><div class="line" id="054050"><span class="nick" style="color:#8dd3c7"><a href="#054050" label="[05:40:50]">&lt;oriansj&gt;</a></span><span class="message">looks almost like C code generated by M1</span></div><div class="line" id="054108"><span class="nick" style="color:#6c3d55"><a href="#054108" label="[05:41:08]">&lt;muurkha&gt;</a></span><span class="message">about Forth, the parser in those 15 lines of Forth took me almost an hour because it took me a long time to debug</span></div><div class="line" id="054148"><span class="nick" style="color:#6c3d55"><a href="#054148" label="[05:41:48]">&lt;muurkha&gt;</a></span><span class="message">I thought it would be a lot faster but I'm not that great at Forth</span></div><div class="line" id="054232"><span class="nick" style="color:#8dd3c7"><a href="#054232" label="[05:42:32]">&lt;oriansj&gt;</a></span><span class="message">if it makes you feel any better, it took me weeks to do FORTH.s and even after that we were still finding bugs in my work for about a month after.</span></div><div class="line" id="054250"><span class="nick" style="color:#6c3d55"><a href="#054250" label="[05:42:50]">&lt;muurkha&gt;</a></span><span class="message">yeah, I don't remember how long it took me to write StoneKnifeForth</span></div><div class="line" id="054308"><span class="nick" style="color:#6c3d55"><a href="#054308" label="[05:43:08]">&lt;muurkha&gt;</a></span><span class="message">and it wouldn't be surprising at all if SKF had bugs in it, though it might be hard to tell</span></div><div class="line" id="054351"><span class="nick" style="color:#6c3d55"><a href="#054351" label="[05:43:51]">&lt;muurkha&gt;</a></span><span class="message">bug report: compiler considers foo and far equivalent.  state: closed, working as designed</span></div><div class="line" id="054445"><span class="nick" style="color:#6c3d55"><a href="#054445" label="[05:44:45]">&lt;muurkha&gt;</a></span><span class="message">I think the right way to think about Forth is not as a small programming *language*, because it's easy to do a better language</span></div><div class="line" id="054522"><span class="nick" style="color:#6c3d55"><a href="#054522" label="[05:45:22]">&lt;muurkha&gt;</a></span><span class="message">but rather as the simplest way to get interactive debugging, memory dumping, I/O port probing, etc., up and running</span></div><div class="line" id="054617"><span class="nick" style="color:#8dd3c7"><a href="#054617" label="[05:46:17]">&lt;oriansj&gt;</a></span><span class="message">more reasonable than what I saw today: User locked out due to password expiration while they were on vacation attached is properly filled out form with management approve to get the password reset. Response: User account has been succefully been deleted; if you require access please follow the proper process for account creation.</span></div><div class="line" id="054643"><span class="nick" style="color:#6c3d55"><a href="#054643" label="[05:46:43]">&lt;muurkha&gt;</a></span><span class="message">hahaha oh dear that's terrible</span></div><div class="line" id="054703"><span class="nick" style="color:#6c3d55"><a href="#054703" label="[05:47:03]">&lt;muurkha&gt;</a></span><span class="message">was it a misunderstanding?</span></div><div class="line" id="054717"><span class="nick" style="color:#8dd3c7"><a href="#054717" label="[05:47:17]">&lt;oriansj&gt;</a></span><span class="message">nope</span></div><div class="line" id="054754"><span class="nick" style="color:#6c3d55"><a href="#054754" label="[05:47:54]">&lt;muurkha&gt;</a></span><span class="message">with Forth, instead of a programming language you get an interactive shell, a sort of debugger, and a sort of IDE all for the price of a small programming language.  unfortunately, considered as a language alone, the language is extra special bugprone</span></div><div class="line" id="054812"><span class="nick" style="color:#6c3d55"><a href="#054812" label="[05:48:12]">&lt;muurkha&gt;</a></span><span class="message">so you spend more time debugging, which I am not a fan of</span></div><div class="line" id="054835"><span class="nick" style="color:#6c3d55"><a href="#054835" label="[05:48:35]">&lt;muurkha&gt;</a></span><span class="message">also it has terrible traps for new programmers</span></div><div class="line" id="055036"><span class="nick" style="color:#8dd3c7"><a href="#055036" label="[05:50:36]">&lt;oriansj&gt;</a></span><span class="message">well FORTH has a niche where it is great, the biggest problem is those who love FORTH seem to mistakenly believe it belongs outside of that niche and well sadly they are wrong.</span></div><div class="line" id="055132"><span class="nick" style="color:#6c3d55"><a href="#055132" label="[05:51:32]">&lt;muurkha&gt;</a></span><span class="message">well, you can do anything with it, same as assembly</span></div><div class="line" id="055216"><span class="nick" style="color:#8dd3c7"><a href="#055216" label="[05:52:16]">&lt;oriansj&gt;</a></span><span class="message">I can even imagine loving to use FORTH but I know how easy it is to write a C compiler in Assembly and C is just better than FORTH for making useful things</span></div><div class="line" id="055349"><span class="nick" style="color:#6c3d55"><a href="#055349" label="[05:53:49]">&lt;muurkha&gt;</a></span><span class="message">I can't disagree with that from my experience, but I wonder if my experience is colored by having written hundreds of thousands of lines of C and only hundreds of lines of Forth</span></div><div class="line" id="055418"><span class="nick" style="color:#6c3d55"><a href="#055418" label="[05:54:18]">&lt;muurkha&gt;</a></span><span class="message">maybe someone who has written hundreds of thousands of lines of Forth can make useful things with Forth more easily than I can with C</span></div><div class="line" id="055430"><span class="nick" style="color:#8dd3c7"><a href="#055430" label="[05:54:30]">&lt;oriansj&gt;</a></span><span class="message">well yes, the more familiar you are with a language the more you like it.</span></div><div class="line" id="055604"><span class="nick" style="color:#8dd3c7"><a href="#055604" label="[05:56:04]">&lt;oriansj&gt;</a></span><span class="message">especially when you learn how to do something neat in one language and you try to replicate it in another language and you just can't and it seems so stupid</span></div><div class="line" id="055606"><span class="nick" style="color:#6c3d55"><a href="#055606" label="[05:56:06]">&lt;muurkha&gt;</a></span><span class="message">I mean, C is pretty awkward for a lot of things</span></div><div class="line" id="055639"><span class="nick" style="color:#6c3d55"><a href="#055639" label="[05:56:39]">&lt;muurkha&gt;</a></span><span class="message">yeah, that would happen a lot trying to move from Forth to C, because Forth has general compile-time metaprogramming and C doesn't</span></div><div class="line" id="055701"><span class="nick" style="color:#8dd3c7"><a href="#055701" label="[05:57:01]">&lt;oriansj&gt;</a></span><span class="message">like how in assembly you can do micro-stubs but it is impossible to do in all higher languages.</span></div><div class="line" id="055722"><span class="nick" style="color:#6c3d55"><a href="#055722" label="[05:57:22]">&lt;muurkha&gt;</a></span><span class="message">even gas macros are a lot more powerful than the C preprocessor</span></div><div class="line" id="055751"><span class="nick" style="color:#8dd3c7"><a href="#055751" label="[05:57:51]">&lt;oriansj&gt;</a></span><span class="message">well gas when abused is more flexible than FORTH</span></div><div class="line" id="060016"><span class="nick" style="color:#6c3d55"><a href="#060016" label="[06:00:16]">&lt;muurkha&gt;</a></span><span class="message">unfortunately for Forth, nothing is more flexible than Forth ;)</span></div><div class="line" id="060238"><span class="nick" style="color:#8dd3c7"><a href="#060238" label="[06:02:38]">&lt;oriansj&gt;</a></span><span class="message">: probably ;</span></div><div class="line" id="060852"><span class="nick" style="color:#8dd3c7"><a href="#060852" label="[06:08:52]">&lt;oriansj&gt;</a></span><span class="message">but the more freedom one has to change the language to fit their own tastes, the more worthless the language is for cooperation.</span></div><div class="line" id="061040"><span class="nick" style="color:#8dd3c7"><a href="#061040" label="[06:10:40]">&lt;oriansj&gt;</a></span><span class="message">the rewriting of what the language is while you use it can very quickly exceed the ability for anyone to know what the heck the line noise is and even what language it was written in.</span></div><div class="line" id="061052"><span class="nick" style="color:#6c3d55"><a href="#061052" label="[06:10:52]">&lt;muurkha&gt;</a></span><span class="message">maybe, I don't know how to cooperate with people</span></div><div class="line" id="061123"><span class="nick" style="color:#6c3d55"><a href="#061123" label="[06:11:23]">&lt;muurkha&gt;</a></span><span class="message">but that sounds like a problem that could be managed</span></div><div class="line" id="061147"><span class="nick" style="color:#6c3d55"><a href="#061147" label="[06:11:47]">&lt;muurkha&gt;</a></span><span class="message">I mean Emacs Lisp is pretty flexible and everyone is contributing to this single humongous program</span></div><div class="line" id="061155"><span class="nick" style="color:#8dd3c7"><a href="#061155" label="[06:11:55]">&lt;oriansj&gt;</a></span><span class="message">muurkha: you start with talking usually and then a couple lines of code being different but providing some value to your life and then it grows from there</span></div><div class="line" id="061157"><span class="nick" style="color:#6c3d55"><a href="#061157" label="[06:11:57]">&lt;muurkha&gt;</a></span><span class="message">for almost 40 years now</span></div><div class="line" id="061233"><span class="nick" style="color:#8dd3c7"><a href="#061233" label="[06:12:33]">&lt;oriansj&gt;</a></span><span class="message">emacs isn't 1 program, it is literally tens of thousands</span></div><div class="line" id="061235"><span class="nick" style="color:#6c3d55"><a href="#061235" label="[06:12:35]">&lt;muurkha&gt;</a></span><span class="message">it doesn't have readmacros though, just regular procedural macros</span></div><div class="line" id="061314"><span class="nick" style="color:#6c3d55"><a href="#061314" label="[06:13:14]">&lt;muurkha&gt;</a></span><span class="message">it feels like tens of thousands of programs, but they're all running in the same interpreter at the same time and calling each other</span></div><div class="line" id="061358"><span class="nick" style="color:#8dd3c7"><a href="#061358" label="[06:13:58]">&lt;oriansj&gt;</a></span><span class="message">well elisp makes a program literally 1 line of code in some cases</span></div><div class="line" id="061422"><span class="nick" style="color:#8dd3c7"><a href="#061422" label="[06:14:22]">&lt;oriansj&gt;</a></span><span class="message">dozens more often, hundreds rarely and thousands only when there are multiple developers</span></div><div class="line" id="061511"><span class="nick" style="color:#8dd3c7"><a href="#061511" label="[06:15:11]">&lt;oriansj&gt;</a></span><span class="message">and debugging when it goes bad is impossible</span></div><div class="line" id="061514"><span class="nick" style="color:#6c3d55"><a href="#061514" label="[06:15:14]">&lt;muurkha&gt;</a></span><span class="message">I mean they all have read/write access to each other's global variables</span></div><div class="line" id="061524"><span class="nick" style="color:#6c3d55"><a href="#061524" label="[06:15:24]">&lt;muurkha&gt;</a></span><span class="message">usually debugging elisp gone bad is pretty easy</span></div><div class="line" id="061530"><span class="nick" style="color:#6c3d55"><a href="#061530" label="[06:15:30]">&lt;muurkha&gt;</a></span><span class="message">although there's some seriously hairy stuff in c-mode</span></div><div class="line" id="061531"><span class="nick" style="color:#8dd3c7"><a href="#061531" label="[06:15:31]">&lt;oriansj&gt;</a></span><span class="message">and can hook into each other's internals</span></div><div class="line" id="061541"><span class="nick" style="color:#6c3d55"><a href="#061541" label="[06:15:41]">&lt;muurkha&gt;</a></span><span class="message">oh yeah, advice</span></div><div class="line" id="061601"><span class="nick" style="color:#8dd3c7"><a href="#061601" label="[06:16:01]">&lt;oriansj&gt;</a></span><span class="message">which can be advice'd to insanity</span></div><div class="line" id="061606"><span class="nick" style="color:#6c3d55"><a href="#061606" label="[06:16:06]">&lt;muurkha&gt;</a></span><span class="message">hard to say two elisp packages are separate programs when one is defining advice for the other</span></div><div class="line" id="061620"><span class="nick" style="color:#6c3d55"><a href="#061620" label="[06:16:20]">&lt;muurkha&gt;</a></span><span class="message">fortunately advice is more often used for end-user customization\</span></div><div class="line" id="061708"><span class="nick" style="color:#8dd3c7"><a href="#061708" label="[06:17:08]">&lt;oriansj&gt;</a></span><span class="message">emacs bankruptcy is the only thing that really saved emacs from going off the rails</span></div><div class="line" id="061731"><span class="nick" style="color:#6c3d55"><a href="#061731" label="[06:17:31]">&lt;muurkha&gt;</a></span><span class="message">anyway so elisp makes me skeptical of the Python thesis that cooperating with people benefits from the language being inflexible</span></div><div class="line" id="061745"><span class="nick" style="color:#6c3d55"><a href="#061745" label="[06:17:45]">&lt;muurkha&gt;</a></span><span class="message">even though I don't know what cooperating with people actually does require</span></div><div class="line" id="061754"><span class="nick" style="color:#8dd3c7"><a href="#061754" label="[06:17:54]">&lt;oriansj&gt;</a></span><span class="message">people who stick close to the core generally are good without much trouble but the second you go towards the deep end, giving up and starting from scratch is sometimes the only option.</span></div><div class="line" id="061937"><span class="nick" style="color:#6c3d55"><a href="#061937" label="[06:19:37]">&lt;muurkha&gt;</a></span><span class="message">but the last time someone gave up and started from scratch was in 01984</span></div><div class="line" id="061945"><span class="nick" style="color:#6c3d55"><a href="#061945" label="[06:19:45]">&lt;muurkha&gt;</a></span><span class="message">everyone's been using Richard's GNU Emacs since then</span></div><div class="line" id="062016"><span class="nick" style="color:#8dd3c7"><a href="#062016" label="[06:20:16]">&lt;oriansj&gt;</a></span><span class="message">if I can create a construct in the language where you need to spend a week figuring out what the f&amp;%k (*&amp;*#&amp;$&amp;^#$*&amp;^*!***&amp;^&amp;*: means; then you just can't work with another person.</span></div><div class="line" id="062028"><span class="nick" style="color:#6c3d55"><a href="#062028" label="[06:20:28]">&lt;muurkha&gt;</a></span><span class="message">well, maybe you can if they don't do that ;)</span></div><div class="line" id="062039"><span class="nick" style="color:#8dd3c7"><a href="#062039" label="[06:20:39]">&lt;oriansj&gt;</a></span><span class="message">as guix proves out</span></div><div class="line" id="062059"><span class="nick" style="color:#8dd3c7"><a href="#062059" label="[06:20:59]">&lt;oriansj&gt;</a></span><span class="message">but that requires a strict culture in guix limiting what one can do in guile</span></div><div class="line" id="062143"><span class="nick" style="color:#6c3d55"><a href="#062143" label="[06:21:43]">&lt;muurkha&gt;</a></span><span class="message">well, that's one way to look at it</span></div><div class="line" id="062143"><span class="nick" style="color:#8dd3c7"><a href="#062143" label="[06:21:43]">&lt;oriansj&gt;</a></span><span class="message">and why few projects in guile grow past one developer which doesn't have that culture</span></div><div class="line" id="062224"><span class="nick" style="color:#6c3d55"><a href="#062224" label="[06:22:24]">&lt;muurkha&gt;</a></span><span class="message">more static types would probably help with reading other people's code</span></div><div class="line" id="062251"><span class="nick" style="color:#8dd3c7"><a href="#062251" label="[06:22:51]">&lt;oriansj&gt;</a></span><span class="message">it is either the language enforces a common standard to reading comprehension or the community has to make hard rules that enforce a common standard for reading comprehension.</span></div><div class="line" id="062322"><span class="nick" style="color:#8dd3c7"><a href="#062322" label="[06:23:22]">&lt;oriansj&gt;</a></span><span class="message">muurkha: the haskell donut might disagree with that</span></div><div class="line" id="062328"><span class="nick" style="color:#6c3d55"><a href="#062328" label="[06:23:28]">&lt;muurkha&gt;</a></span><span class="message">when the community makes those rules, it can make exceptions to them</span></div><div class="line" id="062358"><span class="nick" style="color:#6c3d55"><a href="#062358" label="[06:23:58]">&lt;muurkha&gt;</a></span><span class="message">which is a thing you have to do at the semantic level too</span></div><div class="line" id="062408"><span class="nick" style="color:#8dd3c7"><a href="#062408" label="[06:24:08]">&lt;oriansj&gt;</a></span><span class="message">very true and the more the community resists that temptation to do exceptions the better</span></div><div class="line" id="062436"><span class="nick" style="color:#8dd3c7"><a href="#062436" label="[06:24:36]">&lt;oriansj&gt;</a></span><span class="message">much like having a standard astyle for C code</span></div><div class="line" id="062441"><span class="nick" style="color:#6c3d55"><a href="#062441" label="[06:24:41]">&lt;muurkha&gt;</a></span><span class="message">on one project I'm working on we are discussing whether we should use longjmp() to handle stack overflows, for example</span></div><div class="line" id="062448"><span class="nick" style="color:#6c3d55"><a href="#062448" label="[06:24:48]">&lt;muurkha&gt;</a></span><span class="message">longjmp() is not the sort of thing you want to use lightly</span></div><div class="line" id="062524"><span class="nick" style="color:#6c3d55"><a href="#062524" label="[06:25:24]">&lt;muurkha&gt;</a></span><span class="message">not in a program where you care a lot whether it works or not</span></div><div class="line" id="062543"><span class="nick" style="color:#8dd3c7"><a href="#062543" label="[06:25:43]">&lt;oriansj&gt;</a></span><span class="message">indeed, in fact it isn't even used once in all of stage0 or even mes.c</span></div><div class="line" id="062755"><span class="nick" style="color:#8dd3c7"><a href="#062755" label="[06:27:55]">&lt;oriansj&gt;</a></span><span class="message">I need to get some sleep. Talk more tomorrow ^_^</span></div><div class="line" id="063202"><span class="nick" style="color:#6c3d55"><a href="#063202" label="[06:32:02]">&lt;muurkha&gt;</a></span><span class="message">likewise! :)</span></div><div class="line" id="110328"><span class="nick" style="color:#d9d9d9"><a href="#110328" label="[11:03:28]">&lt;pabs3&gt;</a></span><span class="message">Apple Swift is starting to build parts of itself with Swift, seems like they are going to keep it bootstrappable from C++ though: <a rel="nofollow" href="https://forums.swift.org/t/implementing-parts-of-the-swift-compiler-in-swift/59524">https://forums.swift.org/t/implementing-parts-of-the-swift-compiler-in-swift/59524</a>  <a rel="nofollow" href="https://news.ycombinator.com/item?id=32399663">https://news.ycombinator.com/item?id=32399663</a> </span></div><div class="line" id="133316"><span class="nick" style="color:#8dd3c7"><a href="#133316" label="[13:33:16]">&lt;oriansj&gt;</a></span><span class="message">I love that bootstrapping is even there for once, gives me hope that people might put just a little more thought into these sorts of things.</span></div><div class="line" id="133713"><span class="nick" style="color:#bc80bd"><a href="#133713" label="[13:37:13]">&lt;siraben&gt;</a></span><span class="message">Given that Apple is also undergoing a very large change in their instruction sets to ARM it makes sense they care about bootstrapping.</span></div><div class="line" id="133938"><span class="nick" style="color:#3c5b35"><a href="#133938" label="[13:39:38]">&lt;unmatched-paren&gt;</a></span><span class="message">pabs3: Huh? &quot;This proposal specifically plans to not have a &quot;pure C++&quot; Swift compiler any more.</span></div><div class="line" id="134502"><span class="nick" style="color:#d9d9d9"><a href="#134502" label="[13:45:02]">&lt;pabs3&gt;</a></span><span class="message">unmatched-paren: see the &quot;Concrete Build Process&quot; section, it starts out with a C++ compiler</span></div><div class="line" id="134539"><span class="nick" style="color:#3c5b35"><a href="#134539" label="[13:45:39]">&lt;unmatched-paren&gt;</a></span><span class="message">...for the C++ bits.</span></div><div class="line" id="134548"><span class="nick" style="color:#3c5b35"><a href="#134548" label="[13:45:48]">&lt;unmatched-paren&gt;</a></span><span class="message">But the proposal is to add *mandatory* Swift bits.</span></div><div class="line" id="134557"><span class="nick" style="color:#3c5b35"><a href="#134557" label="[13:45:57]">&lt;unmatched-paren&gt;</a></span><span class="message">There's already optional Swift bits.</span></div><div class="line" id="134601"><span class="nick" style="color:#3c5b35"><a href="#134601" label="[13:46:01]">&lt;unmatched-paren&gt;</a></span><span class="message">Build C++ bits with the host C++ compiler</span></div><div class="line" id="134604"><span class="nick" style="color:#3c5b35"><a href="#134604" label="[13:46:04]">&lt;unmatched-paren&gt;</a></span><span class="message">Build mandatory Swift bits with the host Swift compiler</span></div><div class="line" id="134604"><span class="nick" style="color:#d9d9d9"><a href="#134604" label="[13:46:04]">&lt;pabs3&gt;</a></span><span class="message">hmm, perhaps I misread it :/</span></div><div class="line" id="134635"><span class="nick" style="color:#3c5b35"><a href="#134635" label="[13:46:35]">&lt;unmatched-paren&gt;</a></span><span class="message">3. Link a “minimal stage 1&quot; Swift compiler</span></div><div class="line" id="134640"><span class="nick" style="color:#3c5b35"><a href="#134640" label="[13:46:40]">&lt;unmatched-paren&gt;</a></span><span class="message">4. Build optional Swift bits with the minimal stage 1 compiler. Note that these bits may not be fully optimized because the stage 1 compiler may lack some optimizer passes.</span></div><div class="line" id="134645"><span class="nick" style="color:#3c5b35"><a href="#134645" label="[13:46:45]">&lt;unmatched-paren&gt;</a></span><span class="message">etc</span></div><div class="line" id="140614"><span class="nick">***</span><span class="message notice">attila_lendvai_ is now known as attila_lendvai</span></div><div class="line" id="170941"><span class="nick">***</span><span class="message notice">zv_ is now known as zv</span></div><div class="line" id="191423"><span class="nick" style="color:#234e69"><a href="#191423" label="[19:14:23]">&lt;theruran&gt;</a></span><span class="message">@oriansj&gt; well the knight assembler is written in C, M1 and hex2</span></div><div class="line" id="191451"><span class="nick" style="color:#234e69"><a href="#191451" label="[19:14:51]">&lt;theruran&gt;</a></span><span class="message">I don't understand. looking at stage0 and looks like lisp.s only needs M0-compact</span></div><div class="line" id="191503"><span class="nick" style="color:#234e69"><a href="#191503" label="[19:15:03]">&lt;theruran&gt;</a></span><span class="message">(and the pieces up to that point)</span></div><div class="line" id="210313"><span class="nick" style="color:#2e2a4a"><a href="#210313" label="[21:03:13]">&lt;stikonas&gt;</a></span><span class="message">theruran: yes, lisp.c is written in M0</span></div><div class="line" id="210336"><span class="nick" style="color:#2e2a4a"><a href="#210336" label="[21:03:36]">&lt;stikonas&gt;</a></span><span class="message">but it's not used later, so you can basically forget it</span></div><div class="line" id="210347"><span class="nick" style="color:#2e2a4a"><a href="#210347" label="[21:03:47]">&lt;stikonas&gt;</a></span><span class="message">only cc_* ended up promising</span></div><div class="line" id="211141"><span class="nick" style="color:#234e69"><a href="#211141" label="[21:11:41]">&lt;theruran&gt;</a></span><span class="message">hi stikonas - but isn't this lisp.s theoretically capable of doing something useful? such as implementing M1 or another assembler for x86_64?</span></div><div class="line" id="211250"><span class="nick" style="color:#2e2a4a"><a href="#211250" label="[21:12:50]">&lt;stikonas&gt;</a></span><span class="message">theruran: yes, theoretically it is capable</span></div><div class="line" id="211326"><span class="nick" style="color:#2e2a4a"><a href="#211326" label="[21:13:26]">&lt;stikonas&gt;</a></span><span class="message">but in practice nobody worked on it</span></div><div class="line" id="211408"><span class="nick" style="color:#2e2a4a"><a href="#211408" label="[21:14:08]">&lt;stikonas&gt;</a></span><span class="message">theruran: but cc_x86 is not that hard to write</span></div><div class="line" id="211437"><span class="nick" style="color:#2e2a4a"><a href="#211437" label="[21:14:37]">&lt;stikonas&gt;</a></span><span class="message">yes, it is about 16 KiB binary rather than 2 KiB for M0</span></div><div class="line" id="211531"><span class="nick" style="color:#2e2a4a"><a href="#211531" label="[21:15:31]">&lt;stikonas&gt;</a></span><span class="message">but it's still fairly easy</span></div><div class="line" id="213350"><span class="nick" style="color:#234e69"><a href="#213350" label="[21:33:50]">&lt;theruran&gt;</a></span><span class="message">well, I might work on it. or at least I am trying to understand the paths available.</span></div><div class="line" id="213401"><span class="nick" style="color:#234e69"><a href="#213401" label="[21:34:01]">&lt;theruran&gt;</a></span><span class="message">I want to obviate C in the bootstrap path for Scheme/Kernel</span></div><div class="line" id="213538"><span class="nick" style="color:#af8d2f"><a href="#213538" label="[21:35:38]">&lt;Irvise_&gt;</a></span><span class="message">theruran: in the end you will need C. So were it comes, either early or later, should not matter too much imho.</span></div><div class="line" id="213650"><span class="nick" style="color:#234e69"><a href="#213650" label="[21:36:50]">&lt;theruran&gt;</a></span><span class="message">why???</span></div><div class="line" id="213738"><span class="nick" style="color:#234e69"><a href="#213738" label="[21:37:38]">&lt;theruran&gt;</a></span><span class="message">i gotta go</span></div><div class="line" id="214212"><span class="nick" style="color:#af8d2f"><a href="#214212" label="[21:42:12]">&lt;Irvise_&gt;</a></span><span class="message">theruran: the kernel will need it... Yes, it is not bootstrapped early. But in the end, you will need C. And luckily we have TCC, which is fairly competitive.</span></div><div class="line" id="214555"><span class="nick" style="color:#2e2a4a"><a href="#214555" label="[21:45:55]">&lt;stikonas&gt;</a></span><span class="message">well, you can have non-C kernel...</span></div><div class="line" id="214606"><span class="nick" style="color:#2e2a4a"><a href="#214606" label="[21:46:06]">&lt;stikonas&gt;</a></span><span class="message">though it still have to be something compiled</span></div><div class="line" id="215416"><span class="nick">***</span><span class="message notice">pgreco_ is now known as pegreco</span></div><div class="line" id="215426"><span class="nick">***</span><span class="message notice">pegreco is now known as pgreco</span></div><div class="line" id="215453"><span class="nick" style="color:#6c3d55"><a href="#215453" label="[21:54:53]">&lt;muurkha&gt;</a></span><span class="message">we might be able to do better than C for a kernel bringup language with the additional 40 years of experience we have now</span></div><div class="line" id="220349"><span class="nick" style="color:#389600"><a href="#220349" label="[22:03:49]">*</a></span><span class="message">vagrantc notes the use of &quot;might&quot;</span></div><div class="line" id="220411"><span class="nick" style="color:#6c3d55"><a href="#220411" label="[22:04:11]">&lt;muurkha&gt;</a></span><span class="message">;)</span></div><div class="line" id="220503"><span class="nick" style="color:#6c3d55"><a href="#220503" label="[22:05:03]">&lt;muurkha&gt;</a></span><span class="message">C has a lot of advantages; most of the worst mistakes were fixed in the early 01980s, it's not that hard to compile, and lots of people have experience reading it</span></div><div class="line" id="220529"><span class="nick" style="color:#6c3d55"><a href="#220529" label="[22:05:29]">&lt;muurkha&gt;</a></span><span class="message">in a vacuum obviously the relative precedence of the bitwise operators and the equality operators is wrong, for example</span></div><div class="line" id="220559"><span class="nick" style="color:#6c3d55"><a href="#220559" label="[22:05:59]">&lt;muurkha&gt;</a></span><span class="message">but you can't change them now.  the best you could do is give a compile error if someone tries to compile code that depends on that precedence order</span></div><div class="line" id="220815"><span class="nick" style="color:#6c3d55"><a href="#220815" label="[22:08:15]">&lt;muurkha&gt;</a></span><span class="message">but it has a lot of drawbacks too</span></div><div class="line" id="220835"><span class="nick" style="color:#6c3d55"><a href="#220835" label="[22:08:35]">&lt;muurkha&gt;</a></span><span class="message">even for systems programming</span></div><div class="line" id="220836"><span class="nick" style="color:#2e2a4a"><a href="#220836" label="[22:08:36]">&lt;stikonas&gt;</a></span><span class="message">yes, C' easy readability is big advantage</span></div><div class="line" id="220920"><span class="nick" style="color:#6c3d55"><a href="#220920" label="[22:09:20]">&lt;muurkha&gt;</a></span><span class="message">it sucks at higher-order programming, it has no pattern-matching, Golang interfaces are usually better than raw function pointers, stronger type checking would help catch a lot of errors, and C's arithmetic coercions are totally a mistake</span></div><div class="line" id="221011"><span class="nick" style="color:#6c3d55"><a href="#221011" label="[22:10:11]">&lt;muurkha&gt;</a></span><span class="message">by &quot;higher-order programming&quot; I mean things like qsort(), map(), and filter()</span></div><div class="line" id="221011"><span class="nick" style="color:#2e2a4a"><a href="#221011" label="[22:10:11]">&lt;stikonas&gt;</a></span><span class="message">yes, but golang has to be written in someting</span></div><div class="line" id="221027"><span class="nick" style="color:#2e2a4a"><a href="#221027" label="[22:10:27]">&lt;stikonas&gt;</a></span><span class="message">for bootstrap language you don't want pattern-patching or all extra features</span></div><div class="line" id="221029"><span class="nick" style="color:#6c3d55"><a href="#221029" label="[22:10:29]">&lt;muurkha&gt;</a></span><span class="message">yeah, I didn't mean Golang is an alternative</span></div><div class="line" id="221043"><span class="nick" style="color:#2e2a4a"><a href="#221043" label="[22:10:43]">&lt;stikonas&gt;</a></span><span class="message">it has to be as small as possible, so  that it is easy to implement in assembly</span></div><div class="line" id="221046"><span class="nick" style="color:#6c3d55"><a href="#221046" label="[22:10:46]">&lt;muurkha&gt;</a></span><span class="message">for Qfitzah I'm trying having *only* pattern-matching, it seems to be working okay</span></div><div class="line" id="221101"><span class="nick" style="color:#2e2a4a"><a href="#221101" label="[22:11:01]">&lt;stikonas&gt;</a></span><span class="message">for 2nd compiler, pattern-matching might be useful</span></div><div class="line" id="221112"><span class="nick" style="color:#6c3d55"><a href="#221112" label="[22:11:12]">&lt;muurkha&gt;</a></span><span class="message">yeah, clearly you don't want pattern-matching in hex0</span></div><div class="line" id="221121"><span class="nick" style="color:#6c3d55"><a href="#221121" label="[22:11:21]">&lt;muurkha&gt;</a></span><span class="message">but pattern-matching is a pretty useful feature for compilers</span></div><div class="line" id="221321"><span class="nick" style="color:#2e2a4a"><a href="#221321" label="[22:13:21]">&lt;stikonas&gt;</a></span><span class="message">anyway, I'm slightly sceptical about replacing C stuff with scheme. Not opposed to it if it works</span></div><div class="line" id="221332"><span class="nick" style="color:#2e2a4a"><a href="#221332" label="[22:13:32]">&lt;stikonas&gt;</a></span><span class="message">but it's harder for most people to maintain than C</span></div><div class="line" id="221341"><span class="nick" style="color:#2e2a4a"><a href="#221341" label="[22:13:41]">&lt;stikonas&gt;</a></span><span class="message">and probably runs very slowly too</span></div><div class="line" id="231838"><span class="nick" style="color:#8dd3c7"><a href="#231838" label="[23:18:38]">&lt;oriansj&gt;</a></span><span class="message">theruran: well you could do a kernel in Assembly like L3 and do everything above that in scheme without trouble but if you wanted to do a kernel in Lisp, Common Lisp is a much better plan than scheme.</span></div><div class="line" id="232034"><span class="nick" style="color:#8dd3c7"><a href="#232034" label="[23:20:34]">&lt;oriansj&gt;</a></span><span class="message">honestly the biggest strength of C for bootstrapping is struct and local variables and there are assembly languages that support those and are certainly good enough for the things one would want assembly for if you didn't care about portability.</span></div><div class="line" id="232222"><span class="nick" style="color:#8dd3c7"><a href="#232222" label="[23:22:22]">&lt;oriansj&gt;</a></span><span class="message">if you looked at <a rel="nofollow" href="https://github.com/oriansj/slow_lisp">https://github.com/oriansj/slow_lisp</a>  you'll see all of the functionality of lisp.s and if it was worth your trouble.</span></div><div class="line" id="232600"><span class="nick" style="color:#8dd3c7"><a href="#232600" label="[23:26:00]">&lt;oriansj&gt;</a></span><span class="message">it is literally all of the functionality that most people say lisp brings (things like map, reduce, fold, etc) but very quickly you discover very little lisp code out there actually could run on this lambda core. Reader macros and tail call support somehow seem to be the things people actually want about lisp, not the s-expressions and first class functions.</span></div><div class="line" id="232910"><span class="nick" style="color:#8dd3c7"><a href="#232910" label="[23:29:10]">&lt;ekaitz&gt;</a></span><span class="message">oriansj: tail calls depends on the lisp you use, also continuations... but yeah</span></div><div class="line" id="233000"><span class="nick" style="color:#2e2a4a"><a href="#233000" label="[23:30:00]">&lt;stikonas&gt;</a></span><span class="message">but C has an advantage that almost everybody (who might care about bootstrapping) knows it</span></div><div class="line" id="233009"><span class="nick" style="color:#2e2a4a"><a href="#233009" label="[23:30:09]">&lt;stikonas&gt;</a></span><span class="message">you'll find plenty of people who have not seen scheme</span></div><div class="line" id="233028"><span class="nick" style="color:#8dd3c7"><a href="#233028" label="[23:30:28]">&lt;oriansj&gt;</a></span><span class="message">and the last work on that is here: <a rel="nofollow" href="https://github.com/markjenkins/mes-m2-rewrite">https://github.com/markjenkins/mes-m2-rewrite</a>  it isn't a bad lisp for bootstrapping work but it is a very rigid lisp by most standards</span></div><div class="line" id="233211"><span class="nick" style="color:#8dd3c7"><a href="#233211" label="[23:32:11]">&lt;oriansj&gt;</a></span><span class="message">ekaitz: completely fair, although doing a common lisp in assembly while bootstrapping seems impossible of a task for a single individual even if they were willing to dedicate a few years of hard work doing it.</span></div><div class="line" id="233227"><span class="nick" style="color:#2e2a4a"><a href="#233227" label="[23:32:27]">&lt;stikonas&gt;</a></span><span class="message">hmm, I wonder whether I should implement full hex2 for UEFI</span></div><div class="line" id="233241"><span class="nick" style="color:#2e2a4a"><a href="#233241" label="[23:32:41]">&lt;stikonas&gt;</a></span><span class="message">we are unlikely to use &amp; functionality</span></div><div class="line" id="233306"><span class="nick" style="color:#2e2a4a"><a href="#233306" label="[23:33:06]">&lt;stikonas&gt;</a></span><span class="message">though perhaps it is simpler if for code is in sync with posix version...</span></div><div class="line" id="233315"><span class="nick" style="color:#2e2a4a"><a href="#233315" label="[23:33:15]">&lt;stikonas&gt;</a></span><span class="message">s/for/more/</span></div><div class="line" id="233326"><span class="nick" style="color:#8dd3c7"><a href="#233326" label="[23:33:26]">&lt;ekaitz&gt;</a></span><span class="message">oriansj: yeah, for sure</span></div><div class="line" id="233442"><span class="nick" style="color:#8dd3c7"><a href="#233442" label="[23:34:42]">&lt;oriansj&gt;</a></span><span class="message">stikonas: that is a very good question as absolute addresses are something to avoid right now in UEFI</span></div><div class="line" id="233530"><span class="nick" style="color:#8dd3c7"><a href="#233530" label="[23:35:30]">&lt;oriansj&gt;</a></span><span class="message">and cc_* can be done without them. But we will need to do some tweaks for M2-Planet</span></div><div class="line" id="233627"><span class="nick" style="color:#2e2a4a"><a href="#233627" label="[23:36:27]">&lt;stikonas&gt;</a></span><span class="message">well, I'll see, it might be just simpler not to remove it</span></div><div class="line" id="233641"><span class="nick" style="color:#2e2a4a"><a href="#233641" label="[23:36:41]">&lt;stikonas&gt;</a></span><span class="message">since I'm mostly basing UEFI version on POSIX version</span></div><div class="line" id="233647"><span class="nick" style="color:#2e2a4a"><a href="#233647" label="[23:36:47]">&lt;stikonas&gt;</a></span><span class="message">rather than writing the whole thing from scratch</span></div><div class="line" id="234508"><span class="nick" style="color:#2e2a4a"><a href="#234508" label="[23:45:08]">&lt;stikonas&gt;</a></span><span class="message">oriansj:  can you merge <a rel="nofollow" href="https://github.com/oriansj/bootstrap-seeds/pull/28">https://github.com/oriansj/bootstrap-seeds/pull/28</a>  ?</span></div><div class="line" id="234521"><span class="nick" style="color:#2e2a4a"><a href="#234521" label="[23:45:21]">&lt;stikonas&gt;</a></span><span class="message">no binary changes, but I fixed some comments in hex0 files</span></div><div class="line" id="234541"><span class="nick" style="color:#2e2a4a"><a href="#234541" label="[23:45:41]">&lt;stikonas&gt;</a></span><span class="message">best to keep it in sync with stage0 repo</span></div><div class="line" id="234704"><span class="nick" style="color:#8dd3c7"><a href="#234704" label="[23:47:04]">&lt;oriansj&gt;</a></span><span class="message">merged</span></div><div class="line" id="234745"><span class="nick" style="color:#2e2a4a"><a href="#234745" label="[23:47:45]">&lt;stikonas&gt;</a></span><span class="message">thanks</span></div><div class="line" id="234920"><span class="nick" style="color:#8dd3c7"><a href="#234920" label="[23:49:20]">&lt;oriansj&gt;</a></span><span class="message">thank you for being awesome stikonas, really impressive UEFI progress</span></div><div class="line" id="235020"><span class="nick" style="color:#2e2a4a"><a href="#235020" label="[23:50:20]">&lt;stikonas&gt;</a></span><span class="message">well, now it's simple</span></div><div class="line" id="235051"><span class="nick" style="color:#2e2a4a"><a href="#235051" label="[23:50:51]">&lt;stikonas&gt;</a></span><span class="message">once we got hex0, it's PE32 header and kaem-minimal working it's much simpler</span></div><div class="line" id="235100"><span class="nick" style="color:#2e2a4a"><a href="#235100" label="[23:51:00]">&lt;stikonas&gt;</a></span><span class="message">now just somebody needs to do some work</span></div><div class="line" id="235253"><span class="nick" style="color:#8dd3c7"><a href="#235253" label="[23:52:53]">&lt;oriansj&gt;</a></span><span class="message">doesn't make it any less impressive</span></div><div class="line" id="235350"><span class="nick" style="color:#8dd3c7"><a href="#235350" label="[23:53:50]">&lt;oriansj&gt;</a></span><span class="message">especially when you realize that your work is making it possible for me to figure out how to make M2libc treat UEFI no differently than a POSIX system</span></div><div class="line" id="235409"><span class="nick" style="color:#8dd3c7"><a href="#235409" label="[23:54:09]">&lt;oriansj&gt;</a></span><span class="message">and thus no code changes would be needed after M2-Planet</span></div><br /></div></body></html>